/**
 * Process: Insights & Easter Eggs Store
 * Purpose: Store and retrieve original, Flicklet-generated "Insights & Easter Eggs" per title
 * Data Source: Firestore (generated by Netlify function from metadata), with localStorage cache
 * Update Path: Admin triggers generation via Netlify function, writes to Firestore
 * Dependencies: Firestore, localStorage (cache), Netlify function for generation
 *
 * NOTE: This feature generates original content from Flicklet's own metadata + templates.
 * No external copyrighted blooper/goof text is used.
 */

export interface GoofItem {
  id: string;
  type: "continuity" | "prop" | "crew" | "logic" | "style" | "world" | "other"; // Extended categories
  kind?: "insight" | "easterEgg" | "pattern"; // New: distinguishes insight types
  text: string; // Original, template-generated text (not scraped from external sources)
  subtlety?: "blink" | "obvious";
}

// Alias for clarity (keeping GoofItem name for backward compatibility)
export type InsightItem = GoofItem;

export interface GoofSet {
  tmdbId: number | string; // Match existing TMDB id type
  source: "auto" | "admin" | "mixed" | "manual" | "user" | "internal"; // Extended sources
  lastUpdated: string; // ISO date
  items: GoofItem[];
}

// Alias for clarity (keeping GoofSet name for backward compatibility)
export type InsightsSet = GoofSet;

type UnsubscribeFn = () => void;

// Storage key for goofs data
const STORAGE_KEY = "flicklet.goofs.v1";

// In-memory cache
let goofsCache: Record<string, GoofSet> = {};
const listeners: Map<string, Set<(goofs: GoofSet | null) => void>> = new Map();

/**
 * Load goofs from localStorage
 */
function loadFromStorage(): Record<string, GoofSet> {
  try {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (raw) {
      return JSON.parse(raw);
    }
  } catch (error) {
    console.error("Failed to load goofs from storage:", error);
  }
  return {};
}

/**
 * Save goofs to localStorage
 */
function saveToStorage(data: Record<string, GoofSet>): void {
  try {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
  } catch (error) {
    console.error("Failed to save goofs to storage:", error);
  }
}

/**
 * Get storage key for a TMDB ID
 */
function getStorageKey(tmdbId: number | string): string {
  return String(tmdbId);
}

/**
 * Initialize cache from storage
 */
function initializeCache(): void {
  goofsCache = loadFromStorage();

  // Always merge seed data (seed data takes precedence if localStorage is empty)
  const seedData = getSeedGoofs();
  let cacheUpdated = false;

  Object.entries(seedData).forEach(([key, goofSet]) => {
    // Only add seed data if it doesn't exist in cache
    // This allows manual overrides in localStorage to persist
    if (!goofsCache[key]) {
      goofsCache[key] = goofSet;
      cacheUpdated = true;
    }
  });

  // Save merged data back if we added any seed data
  if (cacheUpdated) {
    saveToStorage(goofsCache);
  }
}

/**
 * Get goofs for a specific title by TMDB ID
 */
export async function getGoofsForTitle(
  tmdbId: number | string
): Promise<GoofSet | null> {
  const key = getStorageKey(tmdbId);

  // Always ensure cache is initialized
  if (Object.keys(goofsCache).length === 0) {
    initializeCache();
  }

  if (import.meta.env.DEV) {
    console.log(
      `ðŸ” getGoofsForTitle: Looking for TMDB ID ${tmdbId} (key: ${key})`
    );
    console.log(
      `ðŸ“¦ Cache has ${Object.keys(goofsCache).length} entries:`,
      Object.keys(goofsCache)
    );
  }

  // Check cache first
  if (goofsCache[key]) {
    if (import.meta.env.DEV) {
      console.log(
        `âœ… Found goofs in cache for ${key}:`,
        goofsCache[key].items.length,
        "items"
      );
    }
    return goofsCache[key];
  }

  // If not in cache, check seed data as fallback
  const seedData = getSeedGoofs();
  if (seedData[key]) {
    if (import.meta.env.DEV) {
      console.log(
        `âœ… Found goofs in seed data for ${key}:`,
        seedData[key].items.length,
        "items"
      );
    }
    // Add to cache for future lookups
    goofsCache[key] = seedData[key];
    saveToStorage(goofsCache);
    return seedData[key];
  }

  // If not in cache or seed data, try fetching from Firestore
  try {
    if (import.meta.env.DEV) {
      console.log(`ðŸŒ Fetching insights from Firestore for TMDB ID ${tmdbId}`);
    }

    const firestoreResult = await fetchInsightsFromFirestore(tmdbId);
    if (
      firestoreResult &&
      firestoreResult.items &&
      firestoreResult.items.length > 0
    ) {
      if (import.meta.env.DEV) {
        console.log(
          `âœ… Fetched ${firestoreResult.items.length} insights from Firestore for ${key}`
        );
      }
      // Cache the Firestore result
      goofsCache[key] = firestoreResult;
      saveToStorage(goofsCache);
      // Notify listeners
      notifyListeners(key, firestoreResult);
      return firestoreResult;
    }
  } catch (error) {
    if (import.meta.env.DEV) {
      console.error(`âŒ Failed to fetch insights from Firestore:`, error);
    }
    // Don't throw - just return null if Firestore read fails
  }

  if (import.meta.env.DEV) {
    console.log(`â„¹ï¸ No insights found for TMDB ID ${tmdbId}`);
  }

  return null;
}

/**
 * Subscribe to goofs updates for a specific title
 * Returns an unsubscribe function
 */
export function subscribeToGoofs(
  tmdbId: number | string,
  callback: (goofs: GoofSet | null) => void
): UnsubscribeFn {
  const key = getStorageKey(tmdbId);

  // Initialize cache if needed
  if (Object.keys(goofsCache).length === 0) {
    initializeCache();
  }

  // Add listener
  if (!listeners.has(key)) {
    listeners.set(key, new Set());
  }
  listeners.get(key)!.add(callback);

  // Get current value (check cache first, then seed data)
  let currentValue = goofsCache[key] || null;
  if (!currentValue) {
    const seedData = getSeedGoofs();
    if (seedData[key]) {
      // Add to cache for future lookups
      goofsCache[key] = seedData[key];
      saveToStorage(goofsCache);
      currentValue = seedData[key];
    } else {
      // Try fetching from Firestore in background
      fetchInsightsFromFirestore(tmdbId)
        .then((firestoreResult) => {
          if (
            firestoreResult &&
            firestoreResult.items &&
            firestoreResult.items.length > 0
          ) {
            goofsCache[key] = firestoreResult;
            saveToStorage(goofsCache);
            // Notify this callback and any other listeners
            notifyListeners(key, firestoreResult);
          }
        })
        .catch((error) => {
          if (import.meta.env.DEV) {
            console.error("Background Firestore fetch failed:", error);
          }
        });
    }
  }

  // Immediately call with current value (or null if not found)
  callback(currentValue);

  // Return unsubscribe function
  return () => {
    const keyListeners = listeners.get(key);
    if (keyListeners) {
      keyListeners.delete(callback);
      if (keyListeners.size === 0) {
        listeners.delete(key);
      }
    }
  };
}

/**
 * Fetch insights from Firestore
 * User path: reads only from Firestore (with localStorage cache)
 * No external API calls for user-facing features
 */
async function fetchInsightsFromFirestore(
  tmdbId: number | string
): Promise<GoofSet | null> {
  try {
    // Import Firestore dynamically to avoid issues if Firebase isn't initialized
    const { db } = await import("../firebaseBootstrap");
    const { doc, getDoc } = await import("firebase/firestore");

    if (!db) {
      if (import.meta.env.DEV) {
        console.warn("Firestore not available, skipping Firestore read");
      }
      return null;
    }
    const tmdbIdStr = String(tmdbId);
    const insightsRef = doc(db, "insights", tmdbIdStr);
    const snapshot = await getDoc(insightsRef);

    if (snapshot.exists()) {
      const data = snapshot.data();
      if (data && Array.isArray(data.items)) {
        const insightsSet: GoofSet = {
          tmdbId: data.tmdbId || tmdbId,
          source: data.source || "auto",
          lastUpdated: data.lastUpdated || new Date().toISOString(),
          items: data.items,
        };

        // Cache in localStorage
        const key = getStorageKey(tmdbId);
        goofsCache[key] = insightsSet;
        saveToStorage(goofsCache);

        if (import.meta.env.DEV) {
          console.log(
            `âœ… Fetched ${insightsSet.items.length} insights from Firestore for ${key}`
          );
        }
        return insightsSet;
      }
    }

    return null;
  } catch (error) {
    if (import.meta.env.DEV) {
      console.error("Error fetching insights from Firestore:", error);
    }
    return null;
  }
}

/**
 * Notify all listeners for a specific key
 */
function notifyListeners(key: string, goofSet: GoofSet | null): void {
  const keyListeners = listeners.get(key);
  if (keyListeners) {
    keyListeners.forEach((callback) => {
      try {
        callback(goofSet);
      } catch (error) {
        console.error("Error in goofs listener callback:", error);
      }
    });
  }
}

/**
 * Seed data for development/testing
 * NOTE: In production, insights are generated via Netlify function and stored in Firestore.
 * This seed data is only used as a fallback for development/testing.
 */
function getSeedGoofs(): Record<string, GoofSet> {
  // Example goofs for popular shows/movies
  // These are manually seeded for testing purposes only
  return {
    // The Office (US) - TMDB ID 2316
    "2316": {
      tmdbId: 2316,
      source: "manual",
      lastUpdated: new Date().toISOString(),
      items: [
        {
          id: "goof-1",
          type: "continuity",
          text: 'In "The Injury" episode, Michael\'s George Foreman grill injury switches sides between shots.',
          subtlety: "obvious",
        },
        {
          id: "goof-2",
          type: "crew",
          text: "Camera crew visible in multiple episodes, especially in warehouse scenes.",
          subtlety: "blink",
        },
        {
          id: "goof-3",
          type: "prop",
          text: "The \"World's Best Boss\" mug appears and disappears from Michael's desk inconsistently.",
          subtlety: "obvious",
        },
      ],
    },
    // Breaking Bad - TMDB ID 1396
    "1396": {
      tmdbId: 1396,
      source: "manual",
      lastUpdated: new Date().toISOString(),
      items: [
        {
          id: "goof-4",
          type: "continuity",
          text: 'In "Pilot", Walt\'s license plate changes between shots.',
          subtlety: "blink",
        },
        {
          id: "goof-5",
          type: "logic",
          text: "The timeline for Jesse's RV location doesn't always match established geography.",
          subtlety: "obvious",
        },
      ],
    },
  };
}

// Initialize on module load
if (typeof window !== "undefined") {
  initializeCache();
}

/**
 * IMPLEMENTATION NOTES:
 *
 * Firestore Integration:
 * - Collection: `insights/{tmdbId}` - stores InsightsSet per title
 * - User path: reads from Firestore (with localStorage cache)
 * - Admin path: triggers generation via Netlify function `/api/goofs-fetch`
 *
 * Content Generation:
 * - All content is original, generated from Flicklet's own metadata + templates
 * - No external copyrighted blooper/goof text is used
 * - Generation happens server-side via Netlify function
 * - Admin tools trigger generation and write results to Firestore
 *
 * Real-time Updates:
 * - Currently uses polling via subscribeToGoofs
 * - Future: could add Firestore onSnapshot listeners for real-time updates
 */
