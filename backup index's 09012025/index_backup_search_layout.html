<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Flicklet - TV & Movie Tracker</title>
    <meta
      name="description"
      content="Search, track, and rate shows & films fast."
    />
    
    <!-- Icons for different platforms -->
    <link rel="icon" href="icons/icon-512.png" />
    <link rel="apple-touch-icon" href="icons/icon-192.png" />
    <link rel="manifest" href="manifest.json" />

    <!-- CSS Files -->
    <link rel="stylesheet" href="styles/main.css" />
    <link rel="stylesheet" href="styles/mobile.css" />
    <link rel="stylesheet" href="styles/components.css" />
    
    <!-- Quick fix for genre filter -->
    <style>
      .genre-filter {
        padding: 6px 8px !important;
        min-height: auto !important;
        width: 60px !important;
        max-width: 60px !important;
        min-width: 60px !important;
      }
      
      /* Force the search row to not expand the genre filter */
      .search-row {
        grid-template-columns: 1fr 60px auto auto auto !important;
      }
      
      /* Make search input extend to fill space */
      .search-input {
        max-width: none !important;
          width: 100% !important;
      }
      
      /* Make all buttons the same size */
      .search-btn, .clear-search-btn, .advanced-search-btn {
        min-width: 80px !important;
        width: 80px !important;
        padding: 8px 12px !important;
}
</style>

</head>

  <body>
    <!-- Centralized Flicklet App Object -->
    <script>
      window.FlickletApp = {
        // Centralized state
        currentUser: null,
        currentTab: 'home',
        appData: {
          settings: {
            displayName: '',
            lang: 'en',
            theme: 'light',
            pro: false,
            notif: {}
          },
          lists: {
            watching: [],
            watched: [],
            wishlist: []
          },
          searchCache: [],
          activeTagFilters: new Set()
        },

        // Core methods
        init() {
          console.log('🚀 Initializing Flicklet App...');
          
          // Wait for DOM to be fully ready
          setTimeout(() => {
            console.log('⏰ DOM ready timeout completed, setting up app...');
            this.loadData();
            this.applyTheme();
            this.applyLanguage();
            this.applyMardiGras(); // Apply Mardi Gras state
            this.initFirebase();
            console.log('🔧 About to call setupEventListeners...');
            this.setupEventListeners();
            this.updateUI();
            
            // Call existing initialization functions for compatibility
            if (typeof loadAppData === 'function') {
              console.log('🔄 Calling existing loadAppData');
              loadAppData();
            }
            if (typeof updateUI === 'function') {
              console.log('🔄 Calling existing updateUI');
              updateUI();
            }
            if (typeof switchToTab === 'function') {
              console.log('🔄 Calling existing switchToTab');
              switchToTab('home');
            }
            
            // Ensure tab visibility is properly set after initialization
            setTimeout(() => {
              this.updateTabVisibility();
            }, 100);
            
            // Call start function to initialize ensureBlocks
            if (typeof start === 'function') {
              console.log('🔄 Calling existing start function');
              start();
            }
            
            // Run global initialization after centralized system is ready
            setTimeout(() => {
              console.log('🌍 Running global initialization after centralized system...');
              this.runGlobalInitialization();
            }, 500);
            
            console.log('✅ App initialized successfully');
            
                    // Initialize the left-side username display if username exists
        if (this.appData?.settings?.displayName) {
          console.log('🆕 Initializing left-side username display');
          this.updateLeftSideUsername();
        }

        // Initialize FlickWord integration
        this.initializeFlickWord();
        
        // Show welcome message for new users
        this.showWelcomeMessage();
            
            // Check if user should be prompted to login AFTER all functions are loaded
            setTimeout(() => {
              this.checkAndPromptLogin();
            }, 200);
          }, 100);
        },

        checkAndPromptLogin() {
          // Check if this is a new user or if they haven't signed in before
          const hasBeenPrompted = localStorage.getItem('flicklet-login-prompted');
          const hasData = localStorage.getItem('flicklet-data') || localStorage.getItem('tvMovieTrackerData');
          const isAuthenticated = this.currentUser !== null;
          
          console.log('🔍 Checking login prompt conditions:');
          console.log('  - hasBeenPrompted:', hasBeenPrompted);
          console.log('  - hasData:', hasData);
          console.log('  - isAuthenticated:', isAuthenticated);
          console.log('  - currentUser:', this.currentUser);
          console.log('  - showSignInModal available:', typeof showSignInModal === 'function');
          
          // Don't show login prompt if user is already authenticated
          if (isAuthenticated) {
            console.log('✅ User is already authenticated, no login prompt needed');
            return;
          }
          
          // If no login prompt has been shown before and no user data exists, show login modal
          if (!hasBeenPrompted && !hasData) {
            console.log('🆕 New user detected, showing login prompt');
            // Mark that we've prompted them
            localStorage.setItem('flicklet-login-prompted', 'true');
            
            // Wait a moment for the UI to settle, then show the login modal
            setTimeout(() => {
              console.log('⏰ Timeout completed, attempting to show login modal');
              if (typeof showSignInModal === 'function') {
                console.log('✅ showSignInModal function available, calling it');
                showSignInModal();
              } else {
                console.error('❌ showSignInModal function not available');
              }
            }, 1000); // Increased timeout to ensure functions are loaded
          } else if (hasBeenPrompted && !hasData) {
            console.log('👤 User has been prompted before but no data exists');
          } else {
            console.log('✅ User has existing data or has been prompted');
          }
        },

        loadData() {
          try {
            // Try to load from centralized storage first
            const saved = localStorage.getItem('flicklet-data');
            if (saved) {
              this.appData = { ...this.appData, ...JSON.parse(saved) };
              console.log('💾 Data loaded from centralized localStorage');
            } else {
              // Fallback to existing storage format
              const oldSaved = localStorage.getItem('tvMovieTrackerData');
              if (oldSaved) {
                const oldData = JSON.parse(oldSaved);
                // Convert old format to new format
                this.appData.settings.displayName = (oldData.settings && oldData.settings.displayName) || '';
                this.appData.settings.lang = (oldData.settings && oldData.settings.lang) || 'en';
                this.appData.settings.theme = (oldData.settings && oldData.settings.theme) || 'light';
                this.appData.settings.pro = (oldData.settings && oldData.settings.pro) || false;
                console.log('💾 Data loaded from legacy localStorage');
              }
            }
          } catch (error) {
            console.error('❌ Failed to load data:', error);
          }
        },

        saveData() {
          try {
            // Save to centralized storage
            localStorage.setItem('flicklet-data', JSON.stringify(this.appData));
            
            // Also save to legacy format for compatibility
            const legacyData = {
              settings: {
                displayName: this.appData.settings.displayName,
                lang: this.appData.settings.lang,
                theme: this.appData.settings.theme,
                pro: this.appData.settings.pro,
                notif: this.appData.settings.notif
              },
              tv: { watching: [], wishlist: [], watched: [] },
              movies: { watching: [], wishlist: [], watched: [] }
            };
            localStorage.setItem('tvMovieTrackerData', JSON.stringify(legacyData));
            
            console.log('💾 Data saved to both storage formats');
          } catch (error) {
            console.error('❌ Failed to save data:', error);
            this.showNotification('Failed to save data', 'error');
          }
        },

        runGlobalInitialization() {
          console.log('🌍 Running global initialization...');
          
          // Run the global initialization code that was in the fallback sequence
          if (typeof loadAppData === 'function') {
            console.log('🔄 Calling loadAppData');
            loadAppData();
            
            // Update header with username after data is loaded
            setTimeout(() => {
              if (this.updateHeaderWithUsername) {
                this.updateHeaderWithUsername();
              }
            }, 100);
          }
          
          if (typeof tryImportFromShareLink === 'function') {
            console.log('🔄 Calling tryImportFromShareLink');
            tryImportFromShareLink();
          }
          
          if (typeof loadGenres === 'function') {
            console.log('🔄 Calling loadGenres');
            loadGenres();
          }
          
          // Set up search controls
          console.log('🔍 Setting up search controls...');
          const searchBtn = document.getElementById("searchBtn");
          if (searchBtn) {
            console.log('✅ Search button found, binding performSearch');
            searchBtn.onclick = performSearch;
          } else {
            console.log('❌ Search button not found');
          }
          
          const clearSearchBtn = document.getElementById("clearSearchBtn");
          if (clearSearchBtn) {
            console.log('✅ Clear search button found, binding clearSearch');
            clearSearchBtn.onclick = clearSearch;
          } else {
            console.log('❌ Clear search button not found');
          }
          
          const searchInput = document.getElementById("searchInput");
          if (searchInput) {
            console.log('✅ Search input found, adding keydown listener');
            searchInput.addEventListener("keydown", (e) => {
              if (e.key === "Enter") {
                console.log('⌨️ Enter key pressed, calling performSearch');
                performSearch?.();
              }
            });
          } else {
            console.log('❌ Search input not found');
          }
          
          // Set up event delegation for move buttons and other card actions
          console.log('🎯 Setting up event delegation for card actions...');
          document.addEventListener("click", (e) => {
            const btn = e.target.closest("[data-action]");
            if (!btn) {
              return;
            }
            
            const action = btn.getAttribute("data-action");
            const id = Number(btn.getAttribute("data-id"));
            const list = btn.getAttribute("data-list");
            const mediaType = btn.getAttribute("data-media-type");
            
            console.log(`🎯 Action detected: action=${action}, id=${id}, list=${list}, mediaType=${mediaType}`);
            
            if (action === "addFromCache") {
              console.log('➕ Calling addToListFromCache');
              addToListFromCache(id, list);
            } else if (action === "notInterested") {
              console.log('🚫 Calling markAsNotInterested');
              e.preventDefault(); // Prevent any default form submission
              e.stopPropagation(); // Stop event bubbling
              markAsNotInterested(id, mediaType);
            } else if (action === "move") {
              console.log('🔄 Calling moveItem');
              moveItem(id, list);
            } else if (action === "notes") {
              console.log('📝 Calling openNotesTagsModal');
              openNotesTagsModal(id);
            } else if (action === "remove") {
              console.log('🗑️ Calling removeItemFromCurrentList');
              removeItemFromCurrentList(id);
            } else if (action === "rate") {
              console.log('⭐ Calling setRating');
              const rating = Number(btn.getAttribute("data-rating"));
              setRating(id, rating);
            } else if (action === "like") {
              console.log('👍 Calling setLikeStatus');
              setLikeStatus(id, "like");
            } else if (action === "dislike") {
              console.log('👎 Calling setLikeStatus');
              setLikeStatus(id, "dislike");
            } else if (action === "open") {
              console.log('🔗 Calling openTMDBLink');
              openTMDBLink(id, mediaType);
            }
          });
          
          console.log('✅ Global initialization complete');
        
        // Set up share button bindings
        console.log('🔗 Setting up share button bindings...');
        
        // Check if functions exist before binding
        console.log('🔍 Checking function availability:');
        console.log('  - openShareSelectionModal:', typeof openShareSelectionModal);
        console.log('  - generateShareLinkFromSelected:', typeof generateShareLinkFromSelected);
        console.log('  - closeShareSelectionModal:', typeof closeShareSelectionModal);
        
        try {
          bind("shareListBtn", openShareSelectionModal);
          bind("generateShareLinkBtn", generateShareLinkFromSelected);
          bind("closeShareModalBtn", closeShareSelectionModal);
          console.log('✅ Share button bindings set up');
          
          // Also add direct event listeners as backup
          const generateBtn = document.getElementById('generateShareLinkBtn');
          if (generateBtn) {
            // Remove any existing listeners first
            generateBtn.removeEventListener('click', generateShareLinkFromSelected);
            generateBtn.addEventListener('click', generateShareLinkFromSelected);
            console.log('✅ Direct event listener added to generate button');
          }
        } catch (error) {
          console.error('❌ Error setting up share button bindings:', error);
        }
        
        // Also add direct event listeners as fallback
        try {
          const shareBtn = document.getElementById('shareListBtn');
          if (shareBtn) {
            console.log('🔗 Adding direct event listener to share button');
            shareBtn.addEventListener('click', openShareSelectionModal);
            console.log('✅ Direct event listener added to share button');
          } else {
            console.error('❌ Share button not found for direct binding');
          }
          
          // Debug: Check all elements with 'share' in the ID
          const allElements = document.querySelectorAll('[id*="share"]');
          console.log('🔍 Found elements with "share" in ID:', allElements);
        } catch (error) {
          console.error('❌ Error setting up direct event listeners:', error);
        }
        },

        applyTheme() {
          if (this.appData.settings.theme === 'dark') {
            document.body.classList.add('dark-mode');
            // Update button to show sun icon for dark mode
            const themeIcon = document.getElementById('themeIcon');
            if (themeIcon) themeIcon.textContent = '☀️';
          } else {
            document.body.classList.remove('dark-mode');
            // Update button to show moon icon for light mode
            const themeIcon = document.getElementById('themeIcon');
            if (themeIcon) themeIcon.textContent = '🌙';
          }
        },

        applyLanguage() {
          const langSel = document.getElementById('langToggle');
          if (langSel) {
            langSel.value = this.appData.settings.lang || 'en';
          }
          
          // Call the existing applyTranslations function if available
          if (typeof applyTranslations === 'function') {
            applyTranslations();
          } else {
            // Don't call this.applyTranslations() yet - wait for the function to be available
            console.log('🌐 Language set to:', this.appData.settings.lang);
          }
        },

        changeLanguage(newLang) {
          console.log(`🌍 Centralized changeLanguage called with: ${newLang}`);
          
          // Update the centralized app data
          if (this.appData?.settings) {
            this.appData.settings.lang = newLang;
          }
          
          // Apply translations
          this.applyLanguage();
          
          // Handle the complex language change logic directly here
          // Set a flag to prevent dropdown resets during language change
          window.isChangingLanguage = true;
          
          // Update global app data if available
          if (window.appData?.settings) {
            window.appData.settings.lang = newLang;
          }
          if (appData?.settings) {
            appData.settings.lang = newLang;
          }
          
          // Ensure language dropdown options are preserved
          const langToggle = document.getElementById("langToggle");
          if (langToggle && langToggle.children.length < 2) {
            langToggle.innerHTML = `
              <option value="en">EN</option>
              <option value="es">ES</option>
            `;
          }
          
          // Apply translations FIRST (before rehydration)
          if (typeof applyTranslations === 'function') {
            applyTranslations();
          }
          
          // Show loading state for lists
          const currentTab = document.querySelector(".tab.active")?.id?.replace("Tab", "");
          if (currentTab && ["watching", "wishlist", "watched"].includes(currentTab)) {
            const listContainer = document.getElementById(currentTab + "List");
            if (listContainer) {
              listContainer.innerHTML = `<div style="text-align: center; padding: 20px;">${t("loading")}...</div>`;
            }
          }
          
          // Try to rehydrate lists with localized TMDB data
          if (typeof rehydrateListsForLocale === 'function') {
            rehydrateListsForLocale(newLang).then(() => {
              // Save and update UI after rehydration
              if (typeof saveAppData === 'function') saveAppData();
              if (typeof updateUI === 'function') updateUI();
            }).catch(error => {
              console.warn("Failed to rehydrate lists for locale:", error);
              // Still save and update UI even if rehydration fails
              if (typeof saveAppData === 'function') saveAppData();
              if (typeof updateUI === 'function') updateUI();
            });
          } else {
            // Fallback: just save and update UI
            if (typeof saveAppData === 'function') saveAppData();
            if (typeof updateUI === 'function') updateUI();
          }
          
          // Force refresh of genre dropdown
          setTimeout(() => {
            if (typeof loadGenres === "function") {
              loadGenres();
            }
          }, 200);
          
          // Show notification
          const langName = newLang === "es" ? "Spanish" : "English";
          this.showNotification(`Language changed to ${langName}`, "success");
          
          // Clear the flag after operations complete
          setTimeout(() => {
            window.isChangingLanguage = false;
          }, 3000);
          
          // Final refresh of horoscope and quote
          setTimeout(() => {
            const hEl = document.getElementById("fakeFortune");
            const qEl = document.getElementById("randomQuote");
            if (hEl && typeof pickDailyHoroscope === 'function') {
              hEl.textContent = pickDailyHoroscope();
            }
            if (qEl && typeof drawQuote === 'function') {
              qEl.textContent = drawQuote();
            }
            
            const fileInput = document.getElementById("importFile");
            if (fileInput && typeof updateFileLabel === 'function') {
              updateFileLabel(fileInput);
            }
            
            // Clear search cache to force fresh results in new language
            if (typeof window.searchItemCache !== 'undefined' && window.searchItemCache.clear) {
              console.log('🗑️ Clearing search cache for language change');
              console.log('📊 Cache size before clearing:', window.searchItemCache.size);
              window.searchItemCache.clear();
              console.log('📊 Cache size after clearing:', window.searchItemCache.size);
            } else {
              console.log('⚠️ searchItemCache not available globally');
            }
            
            // Refresh search results if they're visible
            if (typeof refreshSearchResults === 'function') {
              console.log('🔄 Refreshing search results for language change');
              refreshSearchResults();
            }
          }, 600);
        },

        applyMardiGras() {
          // Check if Mardi Gras mode should be enabled from localStorage
          const mardiGrasEnabled = localStorage.getItem('flicklet-mardi-gras') === 'true';
          const root = document.getElementById("appRoot");
          if (root && mardiGrasEnabled) {
            root.classList.add("mardi");
            console.log('🎭 Mardi Gras mode restored from localStorage');
          }
        },





        showNotification(message, type = 'info') {
          console.log(`🔔 Centralized showNotification called: "${message}" (${type})`);
          const notification = document.createElement('div');
          notification.className = `notification ${type}`;
          notification.textContent = message;
          
          // Create a centered notification box with proper styling
          notification.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10000;
            padding: 16px 24px;
            border-radius: 12px;
            color: white;
            font-weight: 600;
            font-size: 14px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            max-width: 400px;
            min-width: 200px;
            word-wrap: break-word;
            text-align: center;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            animation: notificationSlideIn 0.3s ease-out;
          `;

          // Set background color based on type with proper fallbacks
          switch (type) {
            case 'success':
              notification.style.background = 'linear-gradient(135deg, #10b981, #059669)';
              break;
            case 'error':
              notification.style.background = 'linear-gradient(135deg, #ef4444, #dc2626)';
              break;
            case 'warning':
              notification.style.background = 'linear-gradient(135deg, #f59e0b, #d97706)';
              notification.style.color = '#fff';
              break;
            case 'info':
            default:
              notification.style.background = 'linear-gradient(135deg, #3b82f6, #2563eb)';
              break;
          }

          document.body.appendChild(notification);
          
          // Auto-remove after 3 seconds
          setTimeout(() => {
            if (notification.parentNode) {
              notification.style.animation = 'notificationSlideOut 0.3s ease-in forwards';
              setTimeout(() => {
                if (notification.parentNode) {
                  notification.parentNode.removeChild(notification);
                }
              }, 300);
            }
          }, 3000);
        },
        
        setupKeyboardShortcuts() {
          console.log('⌨️ Setting up keyboard shortcuts...');
          
          document.addEventListener('keydown', (e) => {
            // Don't trigger shortcuts when typing in input fields
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') {
              return;
            }
            
            // Ctrl/Cmd + K: Focus search input
            if ((e.ctrlKey || e.metaKey) && e.key === 'k') {
              e.preventDefault();
              const searchInput = document.getElementById('searchInput');
              if (searchInput) {
                searchInput.focus();
                searchInput.select();
                this.showNotification('🔍 Search focused - Type to search for shows and movies', 'info');
              }
            }
            
            // Ctrl/Cmd + T: Toggle theme
            if ((e.ctrlKey || e.metaKey) && e.key === 't') {
              e.preventDefault();
              this.toggleTheme();
            }
            
            // Ctrl/Cmd + M: Toggle Mardi Gras mode
            if ((e.ctrlKey || e.metaKey) && e.key === 'm') {
              e.preventDefault();
              this.toggleMardiGras();
            }
            
            // Number keys 1-5: Switch tabs
            if (e.key >= '1' && e.key <= '5' && !e.ctrlKey && !e.metaKey) {
              e.preventDefault();
              const tabMap = {
                '1': 'home',
                '2': 'watching',
                '3': 'wishlist',
                '4': 'watched',
                '5': 'discover'
              };
              const tabName = tabMap[e.key];
              if (tabName) {
                this.switchTab(tabName);
                this.showNotification(`📱 Switched to ${tabName} tab`, 'info');
              }
            }
            
            // Escape: Clear search and close modals
            if (e.key === 'Escape') {
              const searchInput = document.getElementById('searchInput');
              if (searchInput && searchInput.value.trim()) {
                searchInput.value = '';
                this.clearSearch();
                this.showNotification('🔍 Search cleared', 'info');
              }
            }
          });
          
          console.log('✅ Keyboard shortcuts set up');
        },
        
        clearSearch() {
          console.log('🧹 Clearing search...');
          const searchInput = document.getElementById('searchInput');
          const searchResults = document.getElementById('searchResults');
          
          if (searchInput) {
            searchInput.value = '';
          }
          
          if (searchResults) {
            searchResults.style.display = 'none';
          }
          
          // Clear any active search filters
          const genreFilter = document.getElementById('genreFilter');
          if (genreFilter) {
            genreFilter.value = '';
          }
          
          // Clear advanced filters
          this.clearAdvancedFilters();
          
          // Clear stored filters
          window.currentSearchFilters = null;
          
          console.log('✅ Search cleared');
        },
        
        clearAdvancedFilters() {
          console.log('🧹 Clearing advanced filters...');
          
          // Clear all advanced filter inputs
          const searchType = document.getElementById('searchType');
          const yearFrom = document.getElementById('yearFrom');
          const yearTo = document.getElementById('yearTo');
          const ratingFilter = document.getElementById('ratingFilter');
          const mediaTypeFilter = document.getElementById('mediaTypeFilter');
          const languageFilter = document.getElementById('languageFilter');
          const sortByFilter = document.getElementById('sortByFilter');
          
          if (searchType) searchType.value = 'title';
          if (yearFrom) yearFrom.value = '';
          if (yearTo) yearTo.value = '';
          if (ratingFilter) ratingFilter.value = '';
          if (mediaTypeFilter) mediaTypeFilter.value = '';
          if (languageFilter) languageFilter.value = '';
          if (sortByFilter) sortByFilter.value = 'relevance';
          
          // Hide active filters display
          this.updateActiveFiltersDisplay();
          
          console.log('✅ Advanced filters cleared');
        },
        
        updateActiveFiltersDisplay() {
          console.log('🔍 Updating active filters display...');
          
          const activeFiltersDisplay = document.getElementById('activeFiltersDisplay');
          const activeFiltersList = document.getElementById('activeFiltersList');
          
          if (!activeFiltersDisplay || !activeFiltersList) return;
          
          const filters = window.currentSearchFilters;
          
          if (!filters || Object.values(filters).every(v => !v || v === 'relevance')) {
            // No active filters
            activeFiltersDisplay.style.display = 'none';
            return;
          }
          
          // Show active filters
          activeFiltersDisplay.style.display = 'block';
          
          // Clear existing filter tags
          activeFiltersList.innerHTML = '';
          
          // Add filter tags for active filters
          if (filters.searchType && filters.searchType !== 'title') {
            const searchTypeLabels = {
              'actor': 'Actor/Actress',
              'director': 'Director',
              'genre': 'Genre',
              'keyword': 'Keywords'
            };
            this.addFilterTag(activeFiltersList, `Search: ${searchTypeLabels[filters.searchType]}`, 'searchType');
          }
          
          if (filters.yearFrom || filters.yearTo) {
            const yearText = filters.yearFrom && filters.yearTo ? 
              `${filters.yearFrom} - ${filters.yearTo}` : 
              filters.yearFrom || filters.yearTo;
            this.addFilterTag(activeFiltersList, `Year: ${yearText}`, 'year');
          }
          
          if (filters.rating) {
            this.addFilterTag(activeFiltersList, `Rating: ${filters.rating}+`, 'rating');
          }
          
          if (filters.mediaType) {
            const typeText = filters.mediaType === 'movie' ? 'Movies Only' : 'TV Shows Only';
            this.addFilterTag(activeFiltersList, typeText, 'mediaType');
          }
          
          if (filters.language) {
            this.addFilterTag(activeFiltersList, `Language: ${filters.language.toUpperCase()}`, 'language');
          }
          
          if (filters.sortBy && filters.sortBy !== 'relevance') {
            this.addFilterTag(activeFiltersList, `Sort: ${filters.sortBy}`, 'sortBy');
          }
          
          console.log('✅ Active filters display updated');
        },
        
        addFilterTag(container, text, filterType) {
          const filterTag = document.createElement('div');
          filterTag.className = 'filter-tag';
          filterTag.innerHTML = `
            ${text}
            <button class="remove-filter" onclick="removeFilter('${filterType}')" title="Remove filter">×</button>
          `;
          container.appendChild(filterTag);
        },
        
        showLoadingState(containerId, skeletonId) {
          console.log(`🔄 Showing loading state for ${containerId}`);
          const container = document.getElementById(containerId);
          const skeleton = document.getElementById(skeletonId);
          
          if (container && skeleton) {
            container.style.display = 'none';
            skeleton.style.display = 'block';
          }
        },
        
        hideLoadingState(containerId, skeletonId) {
          console.log(`✅ Hiding loading state for ${containerId}`);
          const container = document.getElementById(containerId);
          const skeleton = document.getElementById(skeletonId);
          
          if (container && skeleton) {
            skeleton.style.display = 'none';
            container.style.display = 'block';
          }
        },
        
        showGlobalLoading() {
          console.log('🔄 Showing global loading state');
          document.body.classList.add('loading');
        },
        
        hideGlobalLoading() {
          console.log('✅ Hiding global loading state');
          document.body.classList.remove('loading');
        },
        
        showError(message, details = '', retryFunction = null) {
          console.log(`❌ Showing error: ${message}`, details);
          
          // Create error notification
          const errorDiv = document.createElement('div');
          errorDiv.className = 'error-notification';
          errorDiv.innerHTML = `
            <div class="error-header">
              <span class="error-icon">⚠️</span>
              <span class="error-title">Error</span>
              <button class="error-close" onclick="this.parentElement.parentElement.remove()">✖️</button>
            </div>
            <div class="error-message">${message}</div>
            ${details ? `<div class="error-details">${details}</div>` : ''}
            ${retryFunction ? `<button class="btn secondary retry-btn" onclick="this.parentElement.parentElement.remove(); ${retryFunction}()">🔄 Retry</button>` : ''}
          `;
          
          // Add to page
          document.body.appendChild(errorDiv);
          
          // Auto-remove after 10 seconds
          setTimeout(() => {
            if (errorDiv.parentNode) {
              errorDiv.remove();
            }
          }, 10000);
        },
        
        showSuccess(message, details = '') {
          console.log(`✅ Showing success: ${message}`, details);
          
          // Create success notification
          const successDiv = document.createElement('div');
          successDiv.className = 'success-notification';
          successDiv.innerHTML = `
            <div class="success-header">
              <span class="success-icon">✅</span>
              <span class="success-title">Success</span>
              <button class="success-close" onclick="this.parentElement.parentElement.remove()">✖️</button>
            </div>
            <div class="success-message">${message}</div>
            ${details ? `<div class="success-details">${details}</div>` : ''}
          `;
          
          // Add to page
          document.body.appendChild(successDiv);
          
          // Auto-remove after 5 seconds
          setTimeout(() => {
            if (successDiv.parentNode) {
              successDiv.remove();
            }
          }, 5000);
        },
        
        setupNetworkMonitoring() {
          console.log('🌐 Setting up network monitoring...');
          
          const networkStatus = document.getElementById('networkStatus');
          const networkIcon = document.getElementById('networkIcon');
          
          if (!networkStatus || !networkIcon) return;
          
          // Update network status
          const updateNetworkStatus = () => {
            if (navigator.onLine) {
              // Check connection speed if available
              if ('connection' in navigator) {
                const connection = navigator.connection;
                if (connection.effectiveType === 'slow-2g' || connection.effectiveType === '2g') {
                  networkStatus.className = 'network-status slow';
                  networkIcon.textContent = '🐌';
                  networkStatus.title = 'Slow connection detected';
                } else {
                  networkStatus.className = 'network-status';
                  networkIcon.textContent = '🌐';
                  networkStatus.title = 'Online - Good connection';
                }
              } else {
                networkStatus.className = 'network-status';
                networkIcon.textContent = '🌐';
                networkStatus.title = 'Online';
              }
            } else {
              networkStatus.className = 'network-status offline';
              networkIcon.textContent = '📡';
              networkStatus.title = 'Offline - Check your connection';
              
              // Show offline notification
              this.showError(
                'You are currently offline',
                'Some features may not work properly. Please check your internet connection.',
                'window.location.reload'
              );
            }
          };
          
          // Initial status
          updateNetworkStatus();
          
          // Listen for online/offline events
          window.addEventListener('online', () => {
            console.log('🌐 Network connection restored');
            updateNetworkStatus();
            this.showSuccess('Connection restored', 'You are back online!');
          });
          
          window.addEventListener('offline', () => {
            console.log('📡 Network connection lost');
            updateNetworkStatus();
          });
          
          // Monitor connection changes if available
          if ('connection' in navigator) {
            navigator.connection.addEventListener('change', updateNetworkStatus);
          }
          
          console.log('✅ Network monitoring set up');
        },
        
        exportAppData() {
          console.log('📤 Exporting app data...');
          
          try {
            // Get current app data
            const exportData = {
              version: '1.0',
              timestamp: new Date().toISOString(),
              appData: this.appData || {},
              metadata: {
                exportedFrom: window.location.hostname,
                userAgent: navigator.userAgent,
                totalShows: (this.appData?.tv?.watching?.length || 0) + 
                           (this.appData?.tv?.wishlist?.length || 0) + 
                           (this.appData?.tv?.watched?.length || 0),
                totalMovies: (this.appData?.movies?.watching?.length || 0) + 
                            (this.appData?.movies?.wishlist?.length || 0) + 
                            (this.appData?.movies?.watched?.length || 0)
              }
            };
            
            // Create and download file
            const dataStr = JSON.stringify(exportData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            
            const link = document.createElement('a');
            link.href = url;
            link.download = `flicklet-backup-${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
            
            this.showSuccess(
              'Data exported successfully!',
              `Backup created with ${exportData.metadata.totalShows + exportData.metadata.totalMovies} items`
            );
            
            console.log('✅ App data exported successfully');
          } catch (error) {
            console.error('❌ Export failed:', error);
            this.showError(
              'Export failed',
              'There was an error creating your backup. Please try again.',
              'this.exportAppData'
            );
          }
        },
        
        importAppData() {
          console.log('📥 Importing app data...');
          
          // Create file input
          const fileInput = document.createElement('input');
          fileInput.type = 'file';
          fileInput.accept = '.json';
          fileInput.style.display = 'none';
          
          fileInput.onchange = async (event) => {
            const file = event.target.files[0];
            if (!file) return;
            
            try {
              // Read file
              const text = await file.text();
              const importData = JSON.parse(text);
              
              // Validate import data
              if (!importData.appData || !importData.version) {
                throw new Error('Invalid backup file format');
              }
              
              // Show confirmation dialog
              const confirmed = confirm(
                `Import backup from ${importData.timestamp}?\n\n` +
                `This will replace your current data with:\n` +
                `• ${importData.metadata?.totalShows || 0} TV shows\n` +
                `• ${importData.metadata?.totalMovies || 0} movies\n\n` +
                `Are you sure you want to continue?`
              );
              
              if (confirmed) {
                // Import the data
                this.appData = importData.appData;
                
                // Save to storage
                this.saveData();
                
                // Update UI
                this.updateUI();
                
                this.showSuccess(
                  'Data imported successfully!',
                  `Restored ${importData.metadata?.totalShows + importData.metadata?.totalMovies} items`
                );
                
                console.log('✅ App data imported successfully');
              }
            } catch (error) {
              console.error('❌ Import failed:', error);
              this.showError(
                'Import failed',
                'The backup file could not be read or is invalid. Please check the file and try again.',
                'this.importAppData'
              );
            }
            
            // Clean up
            document.body.removeChild(fileInput);
          };
          
          // Trigger file selection
          document.body.appendChild(fileInput);
          fileInput.click();
        },
        
        validateAndCleanData() {
          console.log('🧹 Validating and cleaning app data...');
          
          try {
            let cleaned = false;
            
            // Ensure basic structure exists
            if (!this.appData) {
              this.appData = { tv: {}, movies: {}, settings: {} };
              cleaned = true;
            }
            
            if (!this.appData.tv) {
              this.appData.tv = { watching: [], wishlist: [], watched: [] };
              cleaned = true;
            }
            
            if (!this.appData.movies) {
              this.appData.movies = { watching: [], wishlist: [], watched: [] };
              cleaned = true;
            }
            
            if (!this.appData.settings) {
              this.appData.settings = { theme: 'light', lang: 'en' };
              cleaned = true;
            }
            
            // Clean up any invalid entries
            ['watching', 'wishlist', 'watched'].forEach(listType => {
              ['tv', 'movies'].forEach(mediaType => {
                if (this.appData[mediaType][listType]) {
                  this.appData[mediaType][listType] = this.appData[mediaType][listType].filter(item => 
                    item && item.id && typeof item.id === 'number'
                  );
                }
              });
            });
            
            if (cleaned) {
              this.saveData();
              console.log('✅ Data cleaned and saved');
            }
            
            return true;
          } catch (error) {
            console.error('❌ Data validation failed:', error);
            return false;
          }
        },
        
        updateDataStatistics() {
          console.log('📊 Updating data statistics...');
          
          try {
            const totalShows = document.getElementById('totalShows');
            const totalMovies = document.getElementById('totalMovies');
            const totalItems = document.getElementById('totalItems');
            
            if (!totalShows || !totalMovies || !totalItems) return;
            
            // Calculate totals
            const tvCount = (this.appData?.tv?.watching?.length || 0) + 
                           (this.appData?.tv?.wishlist?.length || 0) + 
                           (this.appData?.tv?.watched?.length || 0);
            
            const movieCount = (this.appData?.movies?.watching?.length || 0) + 
                              (this.appData?.movies?.wishlist?.length || 0) + 
                              (this.appData?.movies?.watched?.length || 0);
            
            const totalCount = tvCount + movieCount;
            
            // Update display
            totalShows.textContent = tvCount;
            totalMovies.textContent = movieCount;
            totalItems.textContent = totalCount;
            
            console.log(`✅ Data statistics updated: ${tvCount} shows, ${movieCount} movies, ${totalCount} total`);
          } catch (error) {
            console.error('❌ Failed to update data statistics:', error);
          }
        },

        switchTab(tabName) {
          this.currentTab = tabName;
          
          console.log(`🔄 Switching to tab: ${tabName}`);
          
          // Use the existing switchToTab function to ensure proper content rendering
          if (typeof window.switchToTab === 'function') {
            console.log('✅ Using existing switchToTab function');
            window.switchToTab(tabName);
            
            // Update tab visibility after switching
            setTimeout(() => {
              this.updateTabVisibility();
            }, 50);
          } else {
            console.log('⚠️ Using fallback tab switching logic');
            // Fallback tab switching logic to avoid infinite recursion
            document.querySelectorAll('.tab').forEach(tab => {
              tab.classList.remove('active');
            });
            
            document.querySelectorAll('.tab-section').forEach(section => {
              section.style.display = 'none';
            });
            
            // Activate the correct tab and show its section
            if (tabName === 'home') {
              const homeTab = document.getElementById('homeTab');
              const homeSection = document.getElementById('homeSection');
              if (homeTab) homeTab.classList.add('active');
              if (homeSection) homeSection.style.display = 'block';
            } else if (tabName === 'watching') {
              const watchingTab = document.getElementById('watchingTab');
              const watchingSection = document.getElementById('watchingSection');
              if (watchingTab) watchingTab.classList.add('active');
              if (watchingSection) watchingSection.style.display = 'block';
            } else if (tabName === 'wishlist') {
              const wishlistTab = document.getElementById('wishlistTab');
              const wishlistSection = document.getElementById('wishlistSection');
              if (wishlistTab) wishlistTab.classList.add('active');
              if (wishlistSection) wishlistSection.style.display = 'block';
            } else if (tabName === 'watched') {
              const watchedTab = document.getElementById('watchedTab');
              const watchedSection = document.getElementById('watchedSection');
              if (watchedTab) watchedTab.classList.add('active');
              if (watchedSection) watchedSection.style.display = 'block';
            } else if (tabName === 'discover') {
              const discoverTab = document.getElementById('discoverTab');
              const discoverSection = document.getElementById('discoverSection');
              if (discoverTab) discoverTab.classList.add('active');
              if (discoverSection) discoverSection.style.display = 'block';
            } else if (tabName === 'settings') {
              const settingsTab = document.getElementById('settingsTab');
              const settingsSection = document.getElementById('settingsSection');
              if (settingsTab) settingsTab.classList.add('active');
              if (settingsSection) settingsSection.style.display = 'block';
              
              // Update data statistics when settings tab is shown
              setTimeout(() => {
                this.updateDataStatistics();
              }, 100);
            }
            
            // Update tab visibility after switching
            this.updateTabVisibility();
          }
        },

        updateUI() {
          // Use fallback UI update logic to avoid infinite recursion
          document.querySelectorAll('.tab').forEach(tab => {
            tab.classList.remove('active');
          });
          
          // Activate the correct tab
          if (this.currentTab === 'home') {
            const homeTab = document.getElementById('homeTab');
            if (homeTab) homeTab.classList.add('active');
          } else if (this.currentTab === 'watching') {
            const watchingTab = document.getElementById('watchingTab');
            if (watchingTab) watchingTab.classList.add('active');
          } else if (this.currentTab === 'wishlist') {
            const wishlistTab = document.getElementById('wishlistTab');
            if (wishlistTab) wishlistTab.classList.add('active');
          } else if (this.currentTab === 'watched') {
            const watchedTab = document.getElementById('watchedTab');
            if (watchedTab) watchedTab.classList.add('active');
          } else if (this.currentTab === 'discover') {
            const discoverTab = document.getElementById('discoverTab');
            if (discoverTab) discoverTab.classList.add('active');
          } else if (this.currentTab === 'settings') {
            const settingsTab = document.getElementById('settingsTab');
            if (settingsTab) settingsTab.classList.add('active');
          }
          
          // Update tab visibility based on current tab
          this.updateTabVisibility();
          
          // Update header with username and snarky saying
          this.updateHeaderWithUsername();
        },

        updateTabVisibility() {
          console.log('🎯 updateTabVisibility called, currentTab:', this.currentTab);
          
          // Hide all tabs first
          const allTabs = ['homeTab', 'watchingTab', 'wishlistTab', 'watchedTab', 'discoverTab'];
          allTabs.forEach(tabId => {
            const tab = document.getElementById(tabId);
            if (tab) {
              tab.style.display = 'block';
              tab.style.visibility = 'visible';
              tab.style.opacity = '1';
              tab.style.position = 'static';
              tab.style.left = 'auto';
              tab.classList.remove('hidden');
              console.log(`✅ Showing tab: ${tabId}`);
            } else {
              console.log(`❌ Tab not found: ${tabId}`);
            }
          });
          
          // Hide the current tab
          let currentTabId = '';
          switch (this.currentTab) {
            case 'home':
              currentTabId = 'homeTab';
              break;
            case 'watching':
              currentTabId = 'watchingTab';
              break;
            case 'wishlist':
              currentTabId = 'wishlistTab';
              break;
            case 'watched':
              currentTabId = 'watchedTab';
              break;
            case 'discover':
              currentTabId = 'discoverTab';
              break;
            case 'settings':
              // Settings tab is handled separately, don't hide any main tabs
              console.log('⚙️ Settings tab active - no main tabs to hide');
              return;
            default:
              console.log('⚠️ Unknown currentTab:', this.currentTab);
              return;
          }
          
          if (currentTabId) {
            const currentTab = document.getElementById(currentTabId);
            if (currentTab) {
              // Use multiple hiding methods to ensure it's hidden
              currentTab.style.display = 'none';
              currentTab.style.visibility = 'hidden';
              currentTab.style.opacity = '0';
              currentTab.style.position = 'absolute';
              currentTab.style.left = '-9999px';
              currentTab.classList.add('hidden');
              console.log(`🎯 Hidden current tab: ${currentTabId} with multiple methods`);
            } else {
              console.log(`❌ Current tab not found: ${currentTabId}`);
            }
          }
          
          console.log(`🎯 Tab visibility update complete - hiding ${currentTabId}, showing other tabs`);
        },

        updateHeaderWithUsername() {
          // DISABLED - Old header update system conflicts with new layout
          console.log('🚫 updateHeaderWithUsername disabled - using new independent system');
          return;
        },

        _performHeaderUpdate() {
          // DISABLED - Old header update system conflicts with new layout
          console.log('🚫 _performHeaderUpdate disabled - using new independent system');
          return;
          
          console.log('🔤 _performHeaderUpdate called');
          console.log('🔍 FlickletApp appData:', this.appData);
          console.log('🔍 FlickletApp appData.settings:', this.appData?.settings);
          console.log('🔍 FlickletApp appData.settings.displayName:', this.appData?.settings?.displayName);
          
          // GUARD CLAUSE: Don't run if appData isn't ready yet
          if (!this.appData || !this.appData.settings) {
            console.log('🚫 App data not ready yet, skipping header update');
            return;
          }
          
          const welcomeText = document.getElementById('welcomeText');
          const snarkySubtitle = document.getElementById('snarkySubtitle');
          
          console.log('🔍 Found elements:', { welcomeText: !!welcomeText, snarkySubtitle: !!snarkySubtitle });
          
          if (!welcomeText || !snarkySubtitle) {
            console.log('❌ Missing header elements, returning early');
            return;
          }
          
          // Log what the header currently shows BEFORE updating
          console.log('📝 Header BEFORE update:', {
            title: welcomeText.textContent,
            subtitle: snarkySubtitle.textContent
          });
          
          const displayName = this.appData?.settings?.displayName;
          console.log('👤 Display name found:', displayName);
          
          if (displayName && displayName.trim()) {
            // User has a username - show it with a snarky saying
            console.log('✅ Updating header with username:', displayName);
            
            welcomeText.textContent = displayName;
            
            // Array of snarky sayings
            const snarkySayings = [
              "because apparently you need help keeping track of your life",
              "watching you waste time, one episode at a time",
              "judging your taste in entertainment since forever",
              "keeping track of your questionable life choices",
              "because your memory is shorter than a goldfish's",
              "helping you remember what you're supposed to be watching",
              "because binge-watching is totally a personality trait",
              "keeping you organized, one show at a time",
              "because someone has to remember what you're watching",
              "your personal TV memory bank (you're welcome)"
            ];
            
            // Pick a random snarky saying
            const randomSnark = snarkySayings[Math.floor(Math.random() * snarkySayings.length)];
            
            snarkySubtitle.textContent = randomSnark;
            console.log('💬 Updated subtitle with snark:', randomSnark);
            
            // Log what the header shows AFTER updating
            console.log('📝 Header AFTER update:', {
              title: welcomeText.textContent,
              subtitle: snarkySubtitle.textContent
            });

          } else {
            // No username - show default Flicklet title
            console.log('🔄 No username, showing default Flicklet title');
            welcomeText.textContent = 'Flicklet';
            snarkySubtitle.textContent = 'TV & Movie Tracker';
            
            // Log what the header shows AFTER updating
            console.log('📝 Header AFTER update:', {
              title: welcomeText.textContent,
              subtitle: snarkySubtitle.textContent
            });

          }
        },

        // NEW INDEPENDENT USERNAME SYSTEM - Updates left-side container only
        updateLeftSideUsername() {
          console.log('🆕 updateLeftSideUsername called - updating left container only');
          
          // Find the left-side container elements
          const dynamicUsername = document.getElementById('dynamicUsername');
          const dynamicSnark = document.getElementById('dynamicSnark');
          
          console.log('🔍 Left container elements found:', { 
            dynamicUsername: !!dynamicUsername, 
            dynamicSnark: !!dynamicSnark 
          });
          
          if (!dynamicUsername || !dynamicSnark) {
            console.log('❌ Left container elements not found, returning early');
            return;
          }
          
          // Get username from appData or extract from email
          let displayName = this.appData?.settings?.displayName;
          console.log('👤 Display name from appData:', displayName);
          
          if (!displayName || !displayName.trim()) {
            // No custom display name - try to extract from email
            const email = this.currentUser?.email;
            if (email) {
              // Extract the part before @ and capitalize first letter
              const emailName = email.split('@')[0];
              // Take only the part before the first dot for cleaner display
              const cleanName = emailName.split('.')[0];
              displayName = cleanName.charAt(0).toUpperCase() + cleanName.slice(1);
              console.log('📧 Extracted name from email:', displayName);
            }
          }
          
          if (displayName && displayName.trim()) {
            // User has a username - show it with a snarky saying
            console.log('✅ Updating left container with username:', displayName);
            
            dynamicUsername.textContent = displayName;
            
            // Array of snarky sayings
            const snarkySayings = [
              "because apparently you need help keeping track of your life",
              "watching you waste time, one episode at a time",
              "judging your taste in entertainment since forever",
              "keeping track of your questionable life choices",
              "because your memory is shorter than a goldfish's",
              "helping you remember what you're supposed to be watching",
              "because binge-watching is totally a personality trait",
              "keeping you organized, one show at a time",
              "because someone has to remember what you're watching",
              "your personal TV memory bank (you're welcome)"
            ];
            
            // Pick a random snarky saying
            const randomSnark = snarkySayings[Math.floor(Math.random() * snarkySayings.length)];
            
            dynamicSnark.textContent = randomSnark;
            console.log('💬 Updated left container with snark:', randomSnark);
            
          } else {
            // No username or email - show default welcome message
            console.log('🔄 No username or email, showing default welcome message');
            dynamicUsername.textContent = 'Welcome!';
            dynamicSnark.textContent = 'Ready to track your shows';
          }
        },

        // FlickWord Integration Methods
        initializeFlickWord() {
          console.log('🎯 Initializing FlickWord integration');
          
          // Feature flag - set to false to disable FlickWord
          const enableFlickWord = true;
          
          if (!enableFlickWord) {
            console.log('🚫 FlickWord disabled by feature flag');
            return;
          }

          // Show the FlickWord card
          const flickwordCard = document.getElementById('flickwordCard');
          if (flickwordCard) {
            flickwordCard.style.display = 'block';
          }

          // Set up event listeners
          this.setupFlickWordEventListeners();
          
          // Start countdown and update stats
          this.startDailyCountdown();
          this.updateFlickWordStats();
          this.updateWordHint();
        },
        
        // Show welcome message for new users
        showWelcomeMessage() {
          const welcomeMessage = document.getElementById('welcomeMessage');
          if (welcomeMessage) {
            // Check if user has any data (indicating they're not new)
            const hasData = this.appData?.lists?.watching?.length > 0 || 
                           this.appData?.lists?.wishlist?.length > 0 || 
                           this.appData?.lists?.watched?.length > 0;
            
            if (!hasData) {
              welcomeMessage.style.display = 'block';
              // Hide after 10 seconds
              setTimeout(() => {
                welcomeMessage.style.opacity = '0';
                setTimeout(() => {
                  welcomeMessage.style.display = 'none';
                }, 600);
              }, 10000);
            }
          }
        },

        setupFlickWordEventListeners() {
          const playBtn = document.getElementById('playFlickwordBtn');
          if (playBtn) {
            playBtn.addEventListener('click', () => this.openFlickWord());
          }

          // Listen for FlickWord results
          window.addEventListener('message', (e) => {
            const msg = e.data || {};
            if (msg.type === 'flickword:result') {
              this.handleFlickWordResult(msg);
            } else if (msg.type === 'flickword:close') {
              // Handle iframe close if needed
              console.log('🎯 FlickWord closed');
            }
          });
        },

        openFlickWord() {
          console.log('🎯 Opening FlickWord');
          
          // Build URL with today's date for consistency
          const now = new Date();
          const yyyy = now.getUTCFullYear();
          const mm = String(now.getUTCMonth() + 1).padStart(2, '0');
          const dd = String(now.getUTCDate()).padStart(2, '0');
          const iso = `${yyyy}-${mm}-${dd}`;
          
          const flickwordUrl = `/features/flickword.html?date=${iso}`;
          
          // Open in new tab
          window.open(flickwordUrl, '_blank');
        },

        startDailyCountdown() {
          const countdownEl = document.getElementById('dailyCountdown');
          if (!countdownEl) return;

          function tick() {
            const now = new Date();
            const reset = new Date(now);
            // Reset at 00:00 UTC so everyone shares the same daily word window
            reset.setUTCHours(24, 0, 0, 0);
            const diff = Math.max(0, Math.floor((reset - now) / 1000));
            const h = String(Math.floor(diff / 3600)).padStart(2, '0');
            const m = String(Math.floor((diff % 3600) / 60)).padStart(2, '0');
            const s = String(diff % 60).padStart(2, '0');
            countdownEl.textContent = `⏱ ${h}:${m}:${s}`;
          }
          
          tick();
          setInterval(tick, 1000);
        },

        updateFlickWordStats() {
          // Load stats from localStorage
          const results = JSON.parse(localStorage.getItem('flickword:results') || '{}');
          const today = new Date().toISOString().slice(0, 10);
          
          // Calculate streak
          let streak = 0;
          let currentDate = new Date();
          
          while (true) {
            const dateStr = currentDate.toISOString().slice(0, 10);
            if (results[dateStr] && results[dateStr].won) {
              streak++;
              currentDate.setDate(currentDate.getDate() - 1);
            } else {
              break;
            }
          }
          
          // Find best score (lowest number of guesses)
          let bestScore = '-';
          let gamesPlayed = 0;
          
          Object.values(results).forEach(result => {
            if (result.won) {
              gamesPlayed++;
              if (bestScore === '-' || result.guesses < bestScore) {
                bestScore = result.guesses;
              }
            }
          });
          
          // Update UI
          const streakEl = document.getElementById('streakCount');
          const bestScoreEl = document.getElementById('bestScore');
          const gamesPlayedEl = document.getElementById('gamesPlayed');
          
          if (streakEl) streakEl.textContent = streak;
          if (bestScoreEl) bestScoreEl.textContent = bestScore;
          if (gamesPlayedEl) gamesPlayedEl.textContent = gamesPlayed;
        },

        updateWordHint() {
          const hintEl = document.getElementById('wordHint');
          if (!hintEl) return;
          
          // Get today's word first letter (this matches the game logic)
          const now = new Date();
          const start = new Date("2023-01-01");
          const days = Math.floor((now - start) / (1000 * 60 * 60 * 24));
          const words = ["bliss", "crane", "flick", "gravy", "masks", "toast", "crown", "spine", "tiger", "pride"];
          const todayWord = words[days % words.length];
          
          hintEl.textContent = todayWord.charAt(0).toUpperCase();
        },

        handleFlickWordResult(result) {
          console.log('🎯 FlickWord result received:', result);
          
          // Save result to localStorage
          const results = JSON.parse(localStorage.getItem('flickword:results') || '{}');
          results[result.date] = result;
          localStorage.setItem('flickword:results', JSON.stringify(results));
          
          // Update stats display
          this.updateFlickWordStats();
          
          // Show notification
          if (result.won) {
            const message = `🎉 Word solved in ${result.guesses} guesses!`;
            this.showNotification(message, 'success');
          } else {
            const message = `😔 Better luck tomorrow! The word was: ${result.target}`;
            this.showNotification(message, 'info');
          }
        },

        handlePostLoginUsernameSetup(user) {
          console.log('👤 Handling post-login username setup for user:', user.email);
          
          // Check if user already has a username in appData
          const existingUsername = this.appData?.settings?.displayName;
          
          if (existingUsername && existingUsername.trim()) {
            // User already has a username - populate the input field and update header
            console.log('✅ Found existing username:', existingUsername);
            
            // Populate the username input field
            const displayNameInput = document.getElementById('displayNameInput');
            if (displayNameInput) {
              displayNameInput.value = existingUsername;
              console.log('✅ Populated username input field with:', existingUsername);
            }
            
            // Update the left-side container with the username
            this.updateLeftSideUsername();
            
          } else {
            // No username exists - prompt user to enter one
            console.log('❌ No username found, prompting user to enter one');
            
            // Show a modal to prompt for username
            this.showUsernamePromptModal(user.email);
          }
        },

        showUsernamePromptModal(userEmail) {
          console.log('📝 Showing username prompt modal for:', userEmail);
          
          // Create and show a modal asking for username
          const modalHTML = `
            <div class="modal-backdrop" id="usernamePromptModal" style="display: flex; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000; align-items: center; justify-content: center;">
              <div class="modal" style="background: var(--card); border-radius: 12px; padding: 24px; max-width: 400px; width: 90%; box-shadow: 0 10px 25px rgba(0,0,0,0.3);">
                <h3 style="margin: 0 0 16px 0; color: var(--text);">Welcome! 👋</h3>
                <p style="margin: 0 0 20px 0; color: var(--text); line-height: 1.5;">What would you like us to call you?</p>
                <input 
                  type="text" 
                  id="newUsernameInput" 
                  class="search-input" 
                  placeholder="Enter your name"
                  style="width: 100%; margin: 15px 0;"
                />
                <div style="display: flex; gap: 10px; justify-content: flex-end;">
                  <button class="btn secondary" onclick="closeUsernamePromptModal()" style="min-width: 80px;">Skip</button>
                  <button class="btn primary" onclick="saveUsernameFromPrompt()" style="min-width: 80px;">Save</button>
                </div>
              </div>
            </div>
          `;
          
          // Insert the modal
          document.body.insertAdjacentHTML('beforeend', modalHTML);
          console.log('✅ Modal HTML inserted into DOM');
          
          // Check if modal was created
          const modal = document.getElementById('usernamePromptModal');
          if (modal) {
            console.log('✅ Modal element found in DOM');
            console.log('🔍 Modal display style:', modal.style.display);
            console.log('🔍 Modal visibility:', modal.style.visibility);
            console.log('🔍 Modal z-index:', modal.style.zIndex);
          } else {
            console.log('❌ Modal element NOT found in DOM');
          }
          
          // Focus the input field
          setTimeout(() => {
            const input = document.getElementById('newUsernameInput');
            if (input) {
              input.focus();
              input.select();
              console.log('✅ Input field focused and selected');
            } else {
              console.log('❌ Input field not found');
            }
          }, 100);
        },

        initFirebase() {
          console.log('🔥 Initializing Firebase...');
          // Initialize Firebase if available
          if (typeof firebase !== 'undefined') {
            console.log('✅ Firebase available, setting up auth listener');
            firebase.auth().onAuthStateChanged((user) => {
              console.log('👤 Firebase auth state changed:', user ? `User: ${user.email}` : 'No user');
              this.currentUser = user;
              this.updateAccountButton();
              if (user) {
                console.log('✅ User signed in, updating UI');
                this.showNotification('Signed in successfully', 'success');
                
                // Handle username setup after login
                this.handlePostLoginUsernameSetup(user);
              } else {
                console.log('❌ No user signed in');
              }
            });
          } else {
            console.log('❌ Firebase not available');
          }
        },

        updateAccountButton() {
          const accountBtn = document.getElementById('accountBtn');
          if (accountBtn) {
            console.log('🔧 Updating account button, currentUser:', this.currentUser);
            if (this.currentUser) {
              // Show friendly name instead of full email
              const email = this.currentUser.email || 'Account';
              let displayText = email;
              
              // If it's an email, extract just the name part
              if (email.includes('@')) {
                const emailName = email.split('@')[0];
                // Take only the part before the first dot for cleaner display
                const cleanName = emailName.split('.')[0];
                displayText = cleanName.charAt(0).toUpperCase() + cleanName.slice(1);
              }
              
              accountBtn.textContent = displayText;
              accountBtn.title = `Signed in as ${email} - Click to sign out`;
              console.log('✅ Account button updated to show friendly name:', displayText);
            } else {
              accountBtn.textContent = 'Sign In';
              accountBtn.title = 'Click to sign in';
              console.log('✅ Account button updated to show Sign In');
            }
          } else {
            console.error('❌ Account button not found');
          }
        },

        setupEventListeners() {
          console.log('🔧 Setting up event listeners...');
          
          // Set up tab event listeners
          console.log('🔧 Setting up tab event listeners...');
          const bindTab = (id, fn) => {
            const el = document.getElementById(id);
            if (el) {
              el.onclick = fn;
              console.log(`✅ Tab event listener set up for ${id}`);
            } else {
              console.error(`❌ Tab element not found: ${id}`);
            }
          };
          
          // Set up keyboard shortcuts
          this.setupKeyboardShortcuts();
          
          // Set up network monitoring
          this.setupNetworkMonitoring();

          // Bind tab click handlers
          bindTab("homeTab", () => this.switchTab("home"));
          bindTab("watchingTab", () => this.switchTab("watching"));
          bindTab("wishlistTab", () => this.switchTab("wishlist"));
          bindTab("watchedTab", () => this.switchTab("watched"));
          bindTab("discoverTab", () => this.switchTab("discover"));
          
          // Settings button is now in the header, not in tab container
          const settingsBtn = document.getElementById('settingsTab');
          if (settingsBtn) {
            const self = this;
            settingsBtn.addEventListener('click', function() {
              self.switchTab("settings");
            });
          }
          
          console.log('✅ All tab event listeners set up');

          // Language toggle - already handled by HTML onchange attribute
          
          // Set up keyboard shortcuts
          this.setupKeyboardShortcuts();

          // Theme toggle
          const themeBtn = document.getElementById('darkModeToggle');
          if (themeBtn) {
            const self = this;
            themeBtn.addEventListener('click', function() {
              self.toggleTheme();
            });
          }

          // Mardi Gras toggle
          const mardiBtn = document.getElementById('mardiToggle');
          if (mardiBtn) {
            const self = this;
            mardiBtn.addEventListener('click', function() {
              self.toggleMardiGras();
            });
          }

          // Account button - show sign in modal or name modal based on auth state
          const accountBtn = document.getElementById('accountBtn');
          if (accountBtn) {
            console.log('🔧 Setting up account button event listener');
            const self = this; // Preserve 'this' context
            accountBtn.addEventListener('click', function() {
              console.log('🔐 Account button clicked, currentUser:', self.currentUser);
              if (self.currentUser) {
                // User is signed in, show sign out modal
                console.log('👤 User signed in, showing sign out modal');
                self.showSignOutModal();
              } else {
                // User is not signed in, show sign in modal
                console.log('🔑 User not signed in, showing sign in modal');
                if (typeof showSignInModal === 'function') {
                  showSignInModal();
                } else {
                  console.error('❌ showSignInModal function not available');
                }
              }
            });
            console.log('✅ Account button event listener set up successfully');
          } else {
            console.error('❌ Account button not found');
          }
        },

        toggleTheme() {
          console.log('🎨 Theme toggle clicked, current theme:', this.appData.settings.theme);
          this.appData.settings.theme = this.appData.settings.theme === 'light' ? 'dark' : 'light';
          console.log('🎨 New theme:', this.appData.settings.theme);
          this.saveData();
          this.applyTheme();
          
          // Creative theme change messages
          let message;
          if (this.appData.settings.theme === 'dark') {
            message = '🌙 Welcome to the dark side!';
          } else {
            message = '☀️ Let there be light!';
          }
          
          this.showNotification(message, 'info');
        },

        toggleMardiGras() {
          console.log('🎭 Mardi Gras toggle clicked');
          const root = document.getElementById("appRoot");
          if (root) {
            const isMardiGras = root.classList.contains("mardi");
            if (isMardiGras) {
              root.classList.remove("mardi");
              localStorage.setItem('flicklet-mardi-gras', 'false');
              this.showNotification('🎭 Mardi Gras mode disabled', 'info');
            } else {
              root.classList.add("mardi");
              localStorage.setItem('flicklet-mardi-gras', 'true');
              this.showNotification('🎭 Mardi Gras mode enabled - Let the rainbow begin!', 'info');
            }
          } else {
            console.error('❌ appRoot element not found for Mardi Gras toggle');
          }
        },

        showNameModal() {
          const name = prompt('Enter your display name:');
          if (name && name.trim()) {
            this.appData.settings.displayName = name.trim();
            this.saveData();
            this.updateAccountButton();
            this.showNotification('Display name updated!', 'success');
          }
        },

        showSignOutModal() {
          if (!this.currentUser) return;
          
          const email = this.currentUser.email || 'Account';
          const displayName = this.appData.settings.displayName || email;
          
          // Create a simple modal for sign out
          const modal = document.createElement('div');
          modal.className = 'modal-backdrop';
          modal.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
          `;
          
          const modalContent = document.createElement('div');
          modalContent.className = 'modal';
          modalContent.style.cssText = `
            background: white;
            padding: 24px;
            border-radius: 12px;
            max-width: 400px;
            text-align: center;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
          `;
          
          modalContent.innerHTML = `
            <h3 style="margin: 0 0 16px 0; color: #333;">Account</h3>
            <p style="margin: 0 0 20px 0; color: #666;">Signed in as <strong>${displayName}</strong></p>
            <p style="margin: 0 0 20px 0; color: #666;">Email: ${email}</p>
            <div style="display: flex; gap: 12px; justify-content: center;">
              <button id="signOutBtn" class="btn" style="background: #dc3545; color: white; border: none; padding: 10px 20px; border-radius: 6px; cursor: pointer;">Sign Out</button>
              <button id="closeModalBtn" class="btn secondary" style="background: #6c757d; color: white; border: none; padding: 10px 20px; border-radius: 6px; cursor: pointer;">Cancel</button>
            </div>
          `;
          
          modal.appendChild(modalContent);
          document.body.appendChild(modal);
          
          // Add event listeners
          const signOutBtn = modal.querySelector('#signOutBtn');
          const closeModalBtn = modal.querySelector('#closeModalBtn');
          
          signOutBtn.addEventListener('click', () => {
            if (typeof auth !== 'undefined' && auth.signOut) {
              auth.signOut().then(() => {
                this.performSignOut();
                modal.remove();
              }).catch((error) => {
                console.error('Sign out error:', error);
                this.showNotification('Failed to sign out', 'error');
              });
            } else {
              // Fallback sign out
              this.performSignOut();
              modal.remove();
            }
          });
          
          closeModalBtn.addEventListener('click', () => {
            modal.remove();
          });
          
          // Close modal when clicking outside
          modal.addEventListener('click', (e) => {
            if (e.target === modal) {
              modal.remove();
            }
          });
        },

        performSignOut() {
          console.log('🚪 Performing sign out cleanup...');
          
          // Clear user authentication state
          this.currentUser = null;
          
          // Clear user-specific data from centralized appData
          this.appData.lists.watching = [];
          this.appData.lists.watched = [];
          this.appData.lists.wishlist = [];
          this.appData.settings.displayName = '';
          
          // Clear the global appData that the existing system uses
          if (typeof appData !== 'undefined') {
            console.log('🧹 Clearing global appData...');
            appData.tv = { watching: [], wishlist: [], watched: [] };
            appData.movies = { watching: [], wishlist: [], watched: [] };
            appData.settings.displayName = '';
          }
          
          // Save the cleared data
          this.saveData();
          
          // Update the account button
          this.updateAccountButton();
          
          // Clear localStorage data
          localStorage.removeItem('flicklet-data');
          localStorage.removeItem('tvMovieTrackerData');
          localStorage.removeItem('flicklet-login-prompted');
          
          // Refresh the UI to show empty lists
          this.updateUI();
          
          // Call existing updateUI function if available to refresh tab counts
          if (typeof updateUI === 'function') {
            console.log('🔄 Calling existing updateUI to refresh tab counts');
            updateUI();
          }
          
          // Force refresh tab counts by calling existing functions
          if (typeof rebuildStats === 'function') {
            console.log('🔄 Calling rebuildStats to refresh tab counts');
            rebuildStats();
          }
          
          // Switch to home tab to show empty state
          this.switchTab('home');
          
          this.showNotification('Signed out successfully - All data cleared', 'success');
          console.log('✅ Sign out cleanup completed');
        },

        // Translation helper
        t(key) {
          const translations = {
            en: {
              signed_in: 'Signed in successfully',
              language_changed: 'Language changed',
              theme_changed: 'Theme changed',
              name_updated: 'Display name updated!'
            },
            es: {
              signed_in: 'Sesión iniciada exitosamente',
              language_changed: 'Idioma cambiado',
              theme_changed: 'Tema cambiado',
              name_updated: '¡Nombre de pantalla actualizado!'
            }
          };
          const lang = this.appData.settings.lang || 'en';
          return translations[lang] && translations[lang][key] ? translations[lang][key] : (translations.en[key] || key);
        }
      };

      // FlickletApp will be initialized after all functions are defined
    </script>

    <!-- Main Container -->
    <div class="main-container" id="appRoot">
      <!-- Mobile Header Layout - Wireframe Implementation -->
      <div class="mobile-header-layout">
        <!-- Left Panel: Nickname and snarky comment -->
        <div class="mobile-header-left">
          <div class="mobile-username" id="mobileUsername">Welcome!</div>
          <div class="mobile-snark" id="mobileSnark">Ready to track your shows</div>
        </div>
        
        <!-- Middle Panel: Flicklet title and tag line -->
        <div class="mobile-header-center">
          <div class="mobile-title">Flicklet</div>
          <div class="mobile-subtitle">TV & Movie Tracker</div>
        </div>
        
        <!-- Right Panel: Account button and language selector -->
        <div class="mobile-header-right">
          <div class="mobile-controls">
            <button id="mobileAccountBtn" class="btn secondary" title="Sign in / Account">
              👤
            </button>
            <select id="mobileLangToggle" aria-label="Language" title="Language" onchange="changeLanguage(this.value).catch(console.error)">
              <option value="en">EN</option>
              <option value="es">ES</option>
            </select>
          </div>
        </div>
      </div>
      
      <header class="header" role="banner">
        <!-- New left-side container for username and snarky phrase -->
        <div id="usernameSnarkContainer" style="text-align: left; min-width: 200px;">
          <div id="dynamicUsername" style="font-size: 18px; font-weight: bold; color: #9c27b0; margin-bottom: 4px;">Welcome!</div>
          <div id="dynamicSnark" style="font-size: 14px; color: #7f8c8d; font-style: italic;">Ready to track your shows</div>
        </div>
        
        <div>
          <h1 id="welcomeText" class="title" data-i18n="app_title">Flicklet</h1>
          <div id="snarkySubtitle" class="subtitle" data-i18n="subtitle">TV & Movie Tracker</div>
          <div id="bingeBanner" class="binge-banner" aria-live="polite"></div>
        </div>
        <div class="user-section">
          <div id="networkStatus" class="network-status" title="Network Status">
            <span id="networkIcon">🌐</span>
          </div>
          <button id="darkModeToggle" class="btn theme-toggle" title="Toggle Dark/Light Mode">
            <span id="themeIcon">🌙</span>
          </button>
          <button
            id="mardiToggle"
            class="btn secondary"
            title="Mardi Gras mode"
          >
            🎭
          </button>
          
          <!-- Settings button in bottom left -->
          <button id="settingsTab" class="btn secondary" title="Settings">
            ⚙️
          </button>
          <div style="display: flex; align-items: center; gap: 12px;">
            <button
              id="accountBtn"
              class="btn secondary"
              title="Sign in / Account"
            >
              👤 <span data-i18n="sign_in_account">Sign In</span>
            </button>
            <select id="langToggle" aria-label="Language" title="Language" onchange="changeLanguage(this.value).catch(console.error)">
              <option value="en">EN</option>
              <option value="es">ES</option>
            </select>
          </div>
        </div>
      </header>

      <!-- Sticky Top Search -->
      <div class="top-search">
        <div id="welcomeMessage" class="welcome-message" style="display: none;">
          <small>👋 <span data-i18n="welcome_message">Welcome to Flicklet! Start by searching for a show or movie you love.</span></small>
        </div>
        <div class="search-help">
          <small>💡 <span data-i18n="search_tips">Search tips: Use * for wildcards (e.g., "marvel*" for Marvel shows)</span></small>
        </div>
        <div class="search-row">
          <input
            id="searchInput"
            class="search-input"
            placeholder=""
            data-i18n-placeholder="search_placeholder"
          />
          <select id="genreFilter" class="genre-filter">
            <option value="" data-i18n="gen">Gen</option>
          </select>
          <button id="searchBtn" class="btn search-btn">
            <span class="btn-content">🔍 <span data-i18n="search">Search</span></span>
            <span class="btn-loading" style="display: none;">⏳ <span data-i18n="searching">Searching...</span></span>
          </button>
          <button id="clearSearchBtn" class="btn secondary clear-search-btn">
            ✖️ <span data-i18n="clear">Clear</span>
          </button>
          <button id="advancedSearchBtn" class="btn secondary advanced-search-btn" onclick="toggleAdvancedSearch()" title="Advanced Search Options">
            ⚙️
          </button>
        </div>
        
        <!-- Advanced Search Options -->
        <div id="advancedSearchOptions" class="advanced-search-options" style="display: none;">
          <div class="advanced-search-grid">
            <div class="search-filter-group">
              <label for="searchType" class="filter-label">Search Type</label>
              <select id="searchType" class="search-type-filter">
                <option value="title">Title & Overview</option>
                <option value="actor">Actor/Actress</option>
                <option value="director">Director</option>
                <option value="genre">Genre</option>
                <option value="keyword">Keywords</option>
              </select>
            </div>
            
            <div class="search-filter-group">
              <label for="yearFilter" class="filter-label">Year Range</label>
              <div class="year-range">
                <input type="number" id="yearFrom" class="year-input" placeholder="From" min="1900" max="2030">
                <span class="year-separator">-</span>
                <input type="number" id="yearTo" class="year-input" placeholder="To" min="1900" max="2030">
              </div>
            </div>
            
            <div class="search-filter-group">
              <label for="ratingFilter" class="filter-label">Minimum Rating</label>
              <select id="ratingFilter" class="rating-filter">
                <option value="">Any Rating</option>
                <option value="9">9+ (Excellent)</option>
                <option value="8">8+ (Very Good)</option>
                <option value="7">7+ (Good)</option>
                <option value="6">6+ (Fair)</option>
                <option value="5">5+ (Average)</option>
              </select>
            </div>
            
            <div class="search-filter-group">
              <label for="mediaTypeFilter" class="filter-label">Media Type</label>
              <select id="mediaTypeFilter" class="media-type-filter">
                <option value="">All Types</option>
                <option value="movie">Movies Only</option>
                <option value="tv">TV Shows Only</option>
              </select>
            </div>
            
            <div class="search-filter-group">
              <label for="sortByFilter" class="filter-label">Sort By</label>
              <select id="sortByFilter" class="sort-by-filter">
                <option value="relevance">Relevance</option>
                <option value="title">Title A-Z</option>
                <option value="year">Year (Newest First)</option>
                <option value="rating">Rating (Highest First)</option>
                <option value="popularity">Popularity</option>
              </select>
            </div>
            
            <div class="search-filter-group">
              <label for="languageFilter" class="filter-label">Language</label>
              <select id="languageFilter" class="language-filter">
                <option value="">Any Language</option>
                <option value="en">English</option>
                <option value="es">Spanish</option>
                <option value="fr">French</option>
                <option value="de">German</option>
                <option value="it">Italian</option>
                <option value="pt">Portuguese</option>
                <option value="ru">Russian</option>
                <option value="ja">Japanese</option>
                <option value="ko">Korean</option>
                <option value="zh">Chinese</option>
              </select>
            </div>
          </div>
          
          <div class="advanced-search-actions">
            <button id="applyFiltersBtn" class="btn primary" onclick="applyAdvancedFilters()">
              ✅ Apply Filters
            </button>
            <button id="resetFiltersBtn" class="btn secondary" onclick="resetAdvancedFilters()">
              🔄 Reset All
            </button>
          </div>
        </div>
        <div
          id="tagFilterRow"
          class="tag-filters"
          aria-label="Tag filters"
        ></div>
      </div>

      <div class="tab-container">
        <button id="homeTab" class="tab active" title="Overview of your TV & movie tracking">🏠 <span data-i18n="home">Home</span></button>
        <button id="watchingTab" class="tab" title="Shows and movies you're currently watching">
          ▶️ <span data-i18n="currently_watching">Currently Watching</span>
          <span class="tab-badge" id="watchingBadge">0</span>
        </button>
        <button id="wishlistTab" class="tab" title="Shows and movies you want to watch later">
          📖 <span data-i18n="want_to_watch">Want to Watch</span>
          <span class="tab-badge" id="wishlistBadge">0</span>
        </button>
        <button id="watchedTab" class="tab" title="Shows and movies you've already finished">
          ✅ <span data-i18n="already_watched">Already Watched</span>
          <span class="tab-badge" id="watchedBadge">0</span>
        </button>
        <button id="discoverTab" class="tab" title="Get personalized recommendations based on your taste">✨ <span data-i18n="discover">Discover</span></button>
      </div>

      <!-- FlickWord Daily Challenge Card -->
      <div id="flickwordCard" class="flickword-card" style="display: none;">
        <div class="flickword-header">
          <h3 class="flickword-title">🎯 Daily Word Challenge <span class="onboarding-hint"><span class="tooltip">A fun bonus game to play while you're here! Try to guess today's word.</span></span></h3>
          <div class="flickword-countdown" id="dailyCountdown">⏱ 00:00:00</div>
        </div>
        <div class="flickword-stats">
          <div class="stat-item">
            <span class="stat-label">🔥 Streak</span>
            <span class="stat-value" id="streakCount">0</span>
          </div>
          <div class="stat-item">
            <span class="stat-label">🏆 Best</span>
            <span class="stat-value" id="bestScore">-</span>
          </div>
          <div class="stat-item">
            <span class="stat-label">📊 Played</span>
            <span class="stat-value" id="gamesPlayed">0</span>
          </div>
        </div>
        <div class="flickword-actions">
          <button id="playFlickwordBtn" class="btn primary">Play Today's Word</button>
          <div class="flickword-hint">💡 Hint: Today's word starts with "<span id="wordHint">?</span>"</div>
        </div>
      </div>

      <!-- Results -->
      <div id="searchResults" class="section" style="display: none">
                  <h3>
            🎯 <span data-i18n="search_results">Search Results</span> <span class="count" id="resultsCount">0</span>
          </h3>
          
          <!-- Active Filters Display -->
          <div id="activeFiltersDisplay" class="active-filters" style="display: none;">
            <div class="active-filters-header">
              <span class="filter-icon">🔍</span>
              <span class="filter-title">Active Filters:</span>
            </div>
            <div id="activeFiltersList" class="active-filters-list"></div>
            <button class="clear-filters-btn" onclick="resetAdvancedFilters()">Clear All</button>
          </div>
          
        <div id="searchResultsList" class="list-container"></div>
        
        <!-- Skeleton loading state for search results -->
        <div id="searchSkeleton" class="skeleton-content" style="display: none;">
          <div class="skeleton skeleton-card"></div>
          <div class="skeleton skeleton-card"></div>
          <div class="skeleton skeleton-card"></div>
        </div>
      </div>

      <!-- Home -->
      <div id="homeSection" class="tab-section">
        <div class="stats">
          <div class="stat" id="bingeMeter"></div>
        </div>
        
        <!-- Skeleton loading state for home content -->
        <div id="homeSkeleton" class="skeleton-content" style="display: none;">
          <div class="skeleton skeleton-card"></div>
          <div class="skeleton skeleton-text"></div>
          <div class="skeleton skeleton-text short"></div>
          <div class="skeleton skeleton-button"></div>
        </div>


      </div>

      <main id="main" role="main">

      <!-- Watching -->
      <div id="watchingSection" class="tab-section" style="display: none">
        <div class="section">
          <div class="section-header">
            <h3>
              ▶️ <span data-i18n="currently_watching">Currently Watching</span>
              <span class="count" id="watchingCount">0</span>
            </h3>
          </div>
          <div id="watchingList" class="list-container"></div>
          
          <!-- Skeleton loading state for watching list -->
          <div id="watchingSkeleton" class="skeleton-content" style="display: none;">
            <div class="skeleton skeleton-card"></div>
            <div class="skeleton skeleton-card"></div>
            <div class="skeleton skeleton-card"></div>
          </div>
        </div>
      </div>

      <!-- Wishlist -->
      <div id="wishlistSection" class="tab-section" style="display: none">
        <div class="section">
          <div class="section-header">
            <h3>
              📖 <span data-i18n="want_to_watch">Want to Watch</span>
              <span class="count" id="wishlistCount">0</span>
            </h3>
          </div>
          <div id="wishlistList" class="list-container"></div>
          
          <!-- Skeleton loading state for wishlist -->
          <div id="wishlistSkeleton" class="skeleton-content" style="display: none;">
            <div class="skeleton skeleton-card"></div>
            <div class="skeleton skeleton-card"></div>
            <div class="skeleton skeleton-card"></div>
          </div>
        </div>
      </div>

      <!-- Watched -->
      <div id="watchedSection" class="tab-section" style="display: none">
        <div class="section">
          <div class="section-header">
            <h3>
              ✅ <span data-i18n="already_watched">Already Watched</span>
              <span class="count" id="watchedCount">0</span>
            </h3>
          </div>
          <div id="watchedList" class="list-container"></div>
          
          <!-- Skeleton loading state for watched list -->
          <div id="watchedSkeleton" class="skeleton-content" style="display: none;">
            <div class="skeleton skeleton-card"></div>
            <div class="skeleton skeleton-card"></div>
            <div class="skeleton skeleton-card"></div>
          </div>
        </div>
      </div>

      <!-- Discover -->
              <div id="discoverSection" class="tab-section" style="display: none">
          <div class="section">
            <h3>✨ <span data-i18n="discover">Discover</span></h3>
            <p data-i18n="discover_description">Recommendations based on your likes and ratings.</p>
            <div id="discoverList" class="list-container"></div>
            
            <!-- Skeleton loading state for discover list -->
            <div id="discoverSkeleton" class="skeleton-content" style="display: none;">
              <div class="skeleton skeleton-card"></div>
              <div class="skeleton skeleton-card"></div>
              <div class="skeleton skeleton-card"></div>
            </div>
          </div>
        </div>

      <!-- Settings / Profile -->
              <div id="settingsSection" class="tab-section" style="display: none">
          <div class="section">
            <h3>⚙️ <span data-i18n="settings">Settings</span></h3>

          <div style="margin-bottom: 20px;">
            <label for="displayNameInput" style="display: block; margin-bottom: 8px; font-weight: 500; color: var(--text);">
              What would you like us to call you?
            </label>
            <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 15px;">
              <input
                id="displayNameInput"
                class="search-input"
                placeholder="Enter your name"
                style="width: 25%; min-width: 150px; max-width: 200px;"
              />
              <button id="saveNameBtn" class="btn secondary" onclick="saveDisplayName()">
                💾 <span data-i18n="save_name">Save</span>
              </button>

            </div>
            <label style="display: flex; gap: 6px; align-items: center">
              <input type="checkbox" id="proToggle" /> <span data-i18n="pro_simulate">Pro (simulate)</span>
            </label>
            <div id="proFeatures" style="display: none; margin-top: 8px; padding: 12px; background: var(--card); border-radius: 8px; font-size: 0.9rem; border: 2px solid var(--primary);">
              <strong data-i18n="pro_features">🚀 Pro Features:</strong>
              <ul style="margin: 6px 0; padding-left: 20px;">
                <li data-i18n="pro_feature_analytics">📊 Advanced analytics & binge insights</li>
                <li data-i18n="pro_feature_categories">🏷️ Custom watchlist categories & tags</li>
                <li data-i18n="pro_feature_export">📤 Export to CSV, JSON & PDF formats</li>
                <li data-i18n="pro_feature_support">🎯 Priority customer support</li>
                <li data-i18n="pro_feature_early_access">⚡ Early access to new features</li>
                <li data-i18n="pro_feature_backup">☁️ Cloud backup & cross-device sync</li>
                <li data-i18n="pro_feature_recommendations">🎬 Personalized AI recommendations</li>
                <li data-i18n="pro_feature_stats">📈 Detailed watching statistics</li>
              </ul>
            </div>
          </div>

          <h4 data-i18n="backup_import">Backup & Import</h4>
                      <div style="margin-bottom: 20px;">
              <h5 style="margin-bottom: 12px; color: var(--text);">📊 Data Statistics</h5>
              <div id="dataStats" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 12px; margin-bottom: 20px;">
                <div style="text-align: center; padding: 12px; background: var(--card); border-radius: 8px; border: 1px solid var(--border);">
                  <div style="font-size: 24px; font-weight: bold; color: var(--primary);" id="totalShows">0</div>
                  <div style="font-size: 12px; color: var(--text-secondary);">TV Shows</div>
                </div>
                <div style="text-align: center; padding: 12px; background: var(--card); border-radius: 8px; border: 1px solid var(--border);">
                  <div style="font-size: 24px; font-weight: bold; color: var(--primary);" id="totalMovies">0</div>
                  <div style="font-size: 12px; color: var(--text-secondary);">Movies</div>
                </div>
                <div style="text-align: center; padding: 12px; background: var(--card); border-radius: 8px; border: 1px solid var(--border);">
                  <div style="font-size: 24px; font-weight: bold; color: var(--primary);" id="totalItems">0</div>
                  <div style="font-size: 12px; color: var(--text-secondary);">Total Items</div>
                </div>
              </div>
              
              <div style="margin-bottom: 15px;">
                <button
                  id="exportDataBtn"
                  class="btn primary"
                  onclick="exportAppData()"
                  style="width: 25%; min-width: 150px; margin-bottom: 8px;"
                >
                  📤 <span data-i18n="export_data">Export Data</span>
                </button>
                <p style="margin: 0; font-size: 0.9rem; color: var(--text-secondary); line-height: 1.4;">
                  Download a backup of all your TV shows, movies, and settings
                </p>
              </div>
            
            <div style="margin-bottom: 15px;">
              <button
                id="importDataBtn"
                class="btn secondary"
                onclick="importAppData()"
                style="width: 25%; min-width: 150px; margin-bottom: 8px;"
              >
                📥 <span data-i18n="import_data">Import Data</span>
              </button>
              <p style="margin: 0; font-size: 0.9rem; color: var(--text-secondary); line-height: 1.4;">
                Restore your data from a previous backup file
              </p>
            </div>
            
            <div style="margin-bottom: 15px;">
              <button
                id="shareListBtn"
                class="btn primary"
                onclick="openShareSelectionModal()"
                style="width: 25%; min-width: 150px; margin-bottom: 8px;"
              >
                🔗 <span data-i18n="share_selected">Select Items to Share</span>
              </button>
                            <p style="margin: 0; font-size: 0.9rem; color: var(--text-secondary); line-height: 1.4;">
                Click here to select what TV shows and movies to share with your friends
              </p>
            </div>
            
            <div>
              <button id="clearAllBtn" class="btn danger" style="width: 25%; min-width: 150px; margin-bottom: 8px;">
                🗑️ <span data-i18n="nuclear_option">Nuclear Option</span>
              </button>
              <p style="margin: 0; font-size: 0.9rem; color: var(--text-secondary); line-height: 1.4;">
                Clear all your data and start fresh (this action cannot be undone)
              </p>
            </div>
          </div>

          <h4 data-i18n="notifications">Notifications</h4>
          <p style="margin: 0 0 15px 0; font-size: 0.9rem; color: var(--text-secondary); line-height: 1.4;">
            Choose which types of notifications you'd like to receive about your TV shows and movies
          </p>
          <div
            style="
              display: flex;
              gap: 10px;
              flex-wrap: wrap;
              align-items: center;
              margin-bottom: 8px;
            "
          >
            <label
              ><input type="checkbox" id="notifEpisodes" /> <span data-i18n="episode_alerts">Upcoming episode alerts</span></label
            >
            <label
              ><input type="checkbox" id="notifDiscover" /> <span data-i18n="weekly_discover">Weekly discover picks</span></label
            >
            <label
              ><input type="checkbox" id="notifDigest" /> <span data-i18n="monthly_digest">Monthly stats digest</span></label
            >
          </div>

          <h4>🚫 Not Interested Management</h4>
          <p style="margin: 0 0 15px 0; font-size: 0.9rem; color: var(--text-secondary); line-height: 1.4;">
            Manage shows and movies you've marked as not interested. These won't appear in your recommendations.
          </p>
          <div style="margin-bottom: 15px;">
            <button
              id="manageNotInterestedBtn"
              class="btn secondary"
              onclick="openNotInterestedModal()"
              style="width: 25%; min-width: 150px; margin-bottom: 8px;"
            >
              🚫 Manage Not Interested List
            </button>
            <p style="margin: 0; font-size: 0.9rem; color: var(--text-secondary); line-height: 1.4;">
              View and remove items from your not interested list
            </p>
          </div>

          <!-- Share Selection Modal -->
          <div id="shareSelectionModal" class="modal-backdrop" style="display: none;">
            <div class="modal share-modal" style="max-width: 800px; max-height: 80vh;">
              <h3>🔗 <span data-i18n="share_selected">Share Selected Items</span></h3>
              
              <!-- Select All Controls -->
              <div class="select-all-controls" style="margin-bottom: 20px; padding: 15px; background: var(--card); border-radius: 8px;">
                <div style="display: flex; gap: 15px; flex-wrap: wrap; align-items: center;">
                  <label style="display: flex; align-items: center; gap: 8px;">
                    <input type="checkbox" id="selectAllWatching" />
                    <strong>📺 <span data-i18n="currently_watching">Currently Watching</span></strong>
                  </label>
                  <label style="display: flex; align-items: center; gap: 8px;">
                    <input type="checkbox" id="selectAllWishlist" />
                    <strong>📖 <span data-i18n="want_to_watch">Want to Watch</span></strong>
                  </label>
                  <label style="display: flex; align-items: center; gap: 8px;">
                    <input type="checkbox" id="selectAllWatched" />
                    <strong>✅ <span data-i18n="already_watched">Already Watched</span></strong>
                  </label>
                  <label style="display: flex; align-items: center; gap: 8px;">
                    <input type="checkbox" id="selectAllEverything" />
                    <strong>🌟 <span data-i18n="select_all_everything">Select All Everything</span></strong>
                  </label>
                </div>
              </div>

              <!-- Items Lists -->
              <div class="share-items-container" style="max-height: 400px; overflow-y: auto; margin-bottom: 20px;">
                <!-- Currently Watching -->
                <div class="share-list-section">
                  <h4>📺 <span data-i18n="currently_watching">Currently Watching</span></h4>
                  <div id="shareWatchingList" class="share-items-list"></div>
                </div>
                
                <!-- Want to Watch -->
                <div class="share-list-section">
                  <h4>📖 <span data-i18n="want_to_watch">Want to Watch</span></h4>
                  <div id="shareWishlistList" class="share-items-list"></div>
                </div>
                
                <!-- Already Watched -->
                <div class="share-list-section">
                  <h4>✅ <span data-i18n="already_watched">Already Watched</span></h4>
                  <div id="shareWatchedList" class="share-items-list"></div>
                </div>
              </div>

                            <!-- Action Buttons -->
              <div class="modal-actions" style="display: flex; gap: 10px; justify-content: center;">
                <button id="generateShareLinkBtn" class="btn success" style="display: none;" onclick="generateShareLinkFromSelected()">
                  📋 <span data-i18n="generate_share_link">Select what to share</span>
                </button>
                <button id="copyShareBtn" class="btn primary" style="display: none;" onclick="copyShareList()">
                  📋 Copy
                </button>
                <button id="closeShareModalBtn" class="btn secondary">
                  ✖️ <span data-i18n="close">Close</span>
                </button>
              </div>
            </div>
          </div>
  
          <h4 data-i18n="stats">Stats</h4>
          <div id="statsBasic" class="feedback-card">
            <div id="statsBasicBody" data-i18n="loading">Loading…</div>
          </div>
          <div id="statsPro" class="feedback-card" style="display: none">
            <strong data-i18n="pro">Pro</strong>
            <div id="statsProBody" data-i18n="loading">Loading…</div>
          </div>
          </div>
      </div>
    </div>

    <!-- Firebase (compat for simplicity) -->
      </main>

    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>

    <script>
      /* ============== i18n (EN/ES) ============== */
      const I18N = {
        en: {
          go_dark: "🌙 Go Dark",
          go_light: "☀️ Go Light",
          app_title: "Flicklet",
          subtitle: "TV & Movie Tracker",
          binge_total: "Total Binge Time",
          currently_watching: "Currently Watching",
          want_to_watch: "Want to Watch",
          already_watched: "Already Watched",
          streaming_on: "Streaming",
          clear: "Clear",
          series_complete: "Series Complete",
          coming_soon: "Coming Soon",
          currently_airing: "Currently Airing",
          next: "Next",
          last: "Last",
          start: "Start",
          because_you_liked: "Because you liked",
          search_placeholder: "Search for shows or movies...",
          search_tips: "Search tips: Use * for wildcards (e.g., \"marvel*\" for Marvel shows)",
        welcome_message: "Welcome to Flicklet! Start by searching for a show or movie you love.",
          all_genres: "All Genres",
          search: "Search",
          notes_tags: "Notes/Tags",
          remove: "Remove",
          your_rating: "Your Rating",
          welcome_title: "Welcome! What should we call you?",
          welcome_subtitle: "This will personalize your headers and stats.",
          display_name: "Display name",
          save: "Save",
          sign_in_title: "Sign in to sync",
          sign_in_subtitle: "Sign in to back up your lists and sync across devices.",
          continue_google: "Continue with Google",
          email_signin: "Email Sign-In",
          sign_out: "Sign Out",
          home: "Home",
          discover: "Discover",
          settings: "Settings",
          no_items: "No items.",
          no_description: "No description.",
          already_in_list: "Already in {list}.",
          moved_to: "Moved to {list}.",
          added_to: "Added to {list}.",
          // Additional English translations
          feedback: "Share Your Thoughts",
          feedback_placeholder: "Share your thoughts, feedback, quotes, confessions, or just vent here...",
          send: "Share It!",
          search_results: "Search Results",
          no_results: "No results",
          searching: "Searching...",
          advanced: "Advanced",
          search_failed: "Search failed",
          search_results_cleared: "Search results cleared due to language change.",
          please_search_again: "Please search again to see results in the new language.",
          episode_alerts: "Episode alerts",
          weekly_discover: "Weekly discover picks",
          monthly_digest: "Monthly stats digest",
          backup_import: "Backup & Import",
          nuclear_option: "Nuclear Option",
          share_this_list: "Share This List",
          share_selected: "Select Items to Share",
          share_link: "Share link",
          share_instructions: "Click to select which shows and movies to share",
          choose_file: "Choose File",
                  no_file_chosen: "No file chosen",
        next: "Next",
        last: "Last",
        upcoming_episode: "Upcoming episode",
          welcome: "Welcome",
          theme: "Theme",
          theme_description: "Switch between different visual themes for the app.",
          mardi_gras_mode: "Mardi Gras mode",
          sign_in_account: "Sign in / Account",
          language: "Language",
          all_genres: "All Genres",
          search_for_shows: "Search for shows or movies...",
          currently_watching_count: "Currently Watching",
          want_to_watch_count: "Want to Watch",
          already_watched_count: "Already Watched",
          discover_description: "Recommendations based on your likes and ratings.",
          settings_description: "Application settings",
          display_name_placeholder: "Display name",
          save_name: "Save",
          pro_simulate: "Pro (simulate)",
          notifications: "Notifications",
          stats: "Stats",
          total_items: "Total items",
          watching_count: "Watching",
          wishlist_count: "Wishlist",
          watched_count: "Watched",
          top_genres: "Top Genres",
          average_rating: "Average Rating",
          loading: "Loading...",
          failed_to_load: "Failed to load",
          not_enough_signals: "Not enough signals yet. Like or rate a few items first.",
          recommendations_failed: "Failed to load recommendations.",
          building_recommendations: "Building recommendations...",
          remove_confirmation: "Remove \"{title}\" from this list?",
          already_in_list_warning: "Already in {list}.",
          moved_to_list: "Moved to {list}.",
          added_to_list: "Added to {list}.",
          cloud_sync_ok: "Cloud sync OK",
          cloud_load_failed: "Cloud load failed. Using local.",
          cloud_sync_failed: "Cloud sync failed. Saved locally.",
          signed_in: "Signed in",
          signed_out: "Signed out",
          login_failed: "Login failed",
          name_saved: "Name saved!",
          enter_name_first: "Enter a name first.",
          imported_backup: "Imported backup.",
          invalid_file: "Invalid file.",
          all_data_cleared: "All data cleared.",
          share_link_generated: "Share link generated.",
          generate_share_link: "Select what to share",
          select_all_everything: "Select All Everything",
          close: "Close",
          no_items_selected: "No items selected",
          no_items_in_list: "No items in this list",
          switch_to_share: "Switch to Watching/Wishlist/Watched to share.",
          imported_from_link: "Imported list from link",
          could_not_read_item: "Couldn't read item details. Try again.",
          upcoming_episode_alert: "Upcoming: {title} • {date}",
          streaming_horoscope: "Streaming Horoscope",
          feedback_working: "Share your thoughts! Give us app feedback, tell us what's working (or not), share a quote for our rotation, make a confession, or just vent. We're listening!",
        feedback_subtitle: "💬 App feedback • 💭 Random thoughts • 💬 Quote submissions • 🤫 Anonymous confessions • 😤 Venting welcome",
          quote_loading: "Loading quote of questionable value...",
          // Quote translations
          quote_1: "I am serious... and don't call me Shirley.",
          quote_2: "Streaming is a lifestyle, not a choice.",
          quote_3: "Binge now. Cry later.",
          quote_4: "One does not simply watch one episode.",
          quote_5: "You had me at 'skip recap.'",
          quote_6: "Art is long, episodes are longer.",
          quote_7: "We were on a break! From reality.",
          quote_8: "I came, I saw, I queued it.",
          quote_9: "To stream, perchance to nap.",
          quote_10: "In this house we respect the 'Are you still watching?' prompt.",
          quote_11: "The algorithm thinks I'm complicated. It's right.",
          quote_12: "If found, return to the couch.",
          quote_13: "My love language is 'skip ad.'",
          quote_14: "I contain multitudes and several watchlists.",
          quote_15: "Sundays are for pilots and denial.",
          quote_16: "Ctrl+Z for life, play for comfort.",
          quote_17: "I fear no man, but I fear finales.",
          quote_18: "This app gets me. Terrifying.",
          quote_19: "Plot holes are just cardio for the brain.",
          quote_20: "We accept the dopamine we think we deserve.",
          quote_21: "I have never finished anything. Except seasons.",
          quote_22: "Today's vibe: closed captions and open snacks.",
          quote_23: "Foreshadowing? I hardly know her.",
          quote_24: "Character development is my cardio.",
          quote_25: "If the title card hits, I'm staying.",
          quote_26: "Minimalism, but for episodes.",
          quote_27: "'Are you still watching?' yes, Netflix, I'm thriving.",
          quote_28: "I ship productivity with naps.",
          quote_29: "Comfort show supremacy.",
          quote_30: "This queue is a personality test I'm failing.",
          // Horoscope translations
          you_love_a_slow_burn_and_fast_wifi: "You love a slow burn and fast Wi‑Fi.",
          youre_allergic_to_laugh_tracks: "You're allergic to laugh tracks.",
          you_pause_for_snacks_like_its_a_ritual: "You pause for snacks like it's a ritual.",
          you_are_a_spoiler_ninja_and_an_ending_apologist: "You are a spoiler ninja and an ending apologist.",
          you_think_limited_series_means_limits_dont_apply_to_you: "You think 'limited series' means limits don't apply to you.",
          you_fastforward_opening_credits_but_respect_end_credits: "You fast‑forward opening credits but respect end credits.",
          you_crave_vibes_plot_bold_choice: "You crave vibes > plot. Bold choice.",
          you_treat_recommended_for_you_as_a_dare: "You treat 'recommended for you' as a dare.",
          you_chase_vibes_like_a_sommelier_of_scenes: "You chase vibes like a sommelier of scenes.",
          you_watch_with_subtitles_you_are_cultured_and_quiet: "You watch with subtitles; you are cultured (and quiet).",
          you_fear_the_finale_but_press_play_anyway: "You fear the finale but press play anyway.",
          you_bookmark_chaos_and_call_it_variety: "You bookmark chaos and call it variety.",
          you_own_three_blankets_all_the_good_one: "You own three blankets. All 'the good one'.",
          you_pretend_the_algorithm_is_your_friend: "You pretend the algorithm is your friend.",
          you_rewatch_comfort_episodes_like_vitamins: "You rewatch comfort episodes like vitamins.",
          you_hoard_tabs_and_storylines_with_equal_skill: "You hoard tabs and storylines with equal skill.",
          you_skip_recaps_then_google_plot_summaries_iconic: "You skip recaps, then Google plot summaries. Iconic.",
          // Additional missing horoscope translations
          you_are_a_chaotic_good_you_like_drama_but_call_it_cinema: "You are a Chaotic Good. You like drama but call it 'cinema.'",
          binge_minimalist_planning_watching: "Binge Minimalist: 90% planning, 10% watching.",
          comfort_chaos_and_clever_twists: "Comfort, chaos, and clever twists. In that order.",
          on_your_rewatch_arc_brave: "On your 14th rewatch arc. Brave.",
          fueled_by_snacks_and_unresolved_plotlines: "63% fueled by snacks and unresolved plotlines.",
          human_embodiment_of_skip_intro: "Human embodiment of 'skip intro.'",
          your_spirit_animal_is_a_loading_spinner: "Your spirit animal is a loading spinner.",
          you_collect_pilots_like_pokemon: "You collect pilots like Pokémon.",
          you_claim_you_hate_cliffhangers_you_dont: "You claim you hate cliffhangers. You don't.",
          you_alphabetize_your_watchlist_and_then_ignore_it: "You alphabetize your watchlist and then ignore it.",
          you_believe_one_more_episode_is_a_contract_with_destiny: "You believe 'one more episode' is a contract with destiny.",
          you_rate_with_your_heart_not_the_stars: "You rate with your heart, not the stars.",
          youre_here_to_procrastinate_responsibly: "You're here to procrastinate responsibly.",
          export: "Export",
          unknown_title: "Unknown Title",
          no_image: "No Image",
          like: "Like",
          dislike: "Dislike",
          rate_out_of_5: "Rate {n} out of 5",
          notifications_enabled: "Notifications enabled! You'll get episode reminders.",
          pro_features: "Pro Features:",
          pro_feature_analytics: "Advanced analytics & insights",
          pro_feature_categories: "Custom watchlist categories",
          pro_feature_export: "Export to multiple formats",
          pro_feature_support: "Priority customer support",
          pro_feature_early_access: "Early access to new features",
          pro_feature_backup: "Cloud backup & cross-device sync",
          pro_feature_recommendations: "Personalized AI recommendations",
          pro_feature_stats: "Detailed watching statistics",
          pro: "Pro",
          // Genre translations
          action: "Action",
          adventure: "Adventure",
          animation: "Animation",
          comedy: "Comedy",
          crime: "Crime",
          documentary: "Documentary",
          drama: "Drama",
          family: "Family",
          fantasy: "Fantasy",
          history: "History",
          horror: "Horror",
          music: "Music",
          mystery: "Mystery",
          romance: "Romance",
          science_fiction: "Science Fiction",
          tv_movie: "TV Movie",
          thriller: "Thriller",
          war: "War",
          western: "Western",
          // Additional genre combinations
          action_adventure: "Action & Adventure",
          kids: "Kids",
          news: "News",
          reality: "Reality",
          sci_fi_fantasy: "Sci-Fi & Fantasy",
          soap: "Soap",
          talk: "Talk",
          war_politics: "War & Politics",
          // Additional missing genres
          talk_show: "Talk Show",
          // Additional TMDB genre variations
          reality_tv: "Reality TV",
        },
        es: {
          // Genre translations
          action: "Acción",
          adventure: "Aventura",
          animation: "Animación",
          comedy: "Comedia",
          crime: "Crimen",
          documentary: "Documental",
          drama: "Drama",
          family: "Familiar",
          fantasy: "Fantasía",
          history: "Historia",
          horror: "Terror",
          music: "Música",
          mystery: "Misterio",
          romance: "Romance",
          science_fiction: "Ciencia ficción",
          tv_movie: "Película de TV",
          thriller: "Suspenso",
          war: "Guerra",
          western: "Western",
          // Add Spanish genre names that TMDB returns
          animación: "Animación",
          comedia: "Comedia",
          crimen: "Crimen",
          documental: "Documental",
          familiar: "Familiar",
          misterio: "Misterio",
          // Additional genre combinations
          action_adventure: "Acción y Aventura",
          kids: "Niños",
          news: "Noticias",
          reality: "Realidad",
          sci_fi_fantasy: "Ciencia Ficción y Fantasía",
          soap: "Telenovela",
          talk: "Programa de Entrevistas",
          war_politics: "Guerra y Política",
          // Additional missing genres
          talk_show: "Programa de Entrevistas",
          // Additional TMDB genre variations
          reality_tv: "Realidad TV",
          // Fix for specific genres still in English
          sci_fi_fantasy: "Ciencia Ficción y Fantasía",
          action_adventure: "Acción y Aventura",
          go_dark: "🌙 Modo oscuro",
          go_light: "☀️ Modo claro",
          app_title: "Flicklet",
          subtitle: "Seguimiento de series y películas",
          binge_total: "Tiempo total de maratón",
          currently_watching: "Viendo actualmente",
          want_to_watch: "Quiero ver",
          already_watched: "Ya visto",
          streaming_on: "En",
          clear: "Limpiar",
          series_complete: "Serie terminada",
          coming_soon: "Próximamente",
          currently_airing: "En emisión",
          next: "Próx.",
          last: "Últ.",
          start: "Comenzar",
          because_you_liked: "Porque te gustó",
          search_placeholder: "Buscar series o películas...",
          search_tips: "Consejos de búsqueda: Usa * para comodines (ej: \"marvel*\" para series de Marvel)",
          all_genres: "Todos los géneros",
          search: "Buscar",
          notes_tags: "Notas/Etiquetas",
          remove: "Eliminar",
          your_rating: "Tu calificación",
          welcome_title: "¡Bienvenido! ¿Cómo te llamamos?",
          welcome_subtitle: "Esto personalizará tus encabezados y estadísticas.",
          display_name: "Nombre para mostrar",
          save: "Guardar",
          sign_in_title: "Iniciar sesión para sincronizar",
          sign_in_subtitle: "Inicia sesión para respaldar tus listas y sincronizar entre dispositivos.",
          continue_google: "Continuar con Google",
          email_signin: "Iniciar sesión con email",
          sign_out: "Cerrar sesión",
          home: "Inicio",
          discover: "Descubrir",
          settings: "Configuración",
          no_items: "No hay elementos.",
          no_description: "Sin descripción.",
          already_in_list: "Ya está en {list}.",
          moved_to: "Movido a {list}.",
          added_to: "Agregado a {list}.",
          // Additional Spanish translations
          feedback: "Comentarios",
          feedback_placeholder: "Tu comentario...",
          send: "Enviar",
          search_results: "Resultados de búsqueda",
          no_results: "Sin resultados",
          searching: "Buscando...",
          search_failed: "Búsqueda falló",
          search_results_cleared: "Resultados de búsqueda borrados debido al cambio de idioma.",
          please_search_again: "Por favor busca de nuevo para ver resultados en el nuevo idioma.",
          episode_alerts: "Alertas de episodios",
          weekly_discover: "Descubrimientos semanales",
          monthly_digest: "Resumen mensual",
          backup_import: "Respaldo e importación",
          nuclear_option: "Opción nuclear",
          share_this_list: "Compartir esta lista",
          share_selected: "Compartir Elementos Seleccionados",
          share_link: "Enlace de compartir",
          share_instructions: "Haz clic para seleccionar qué series y películas compartir",
          choose_file: "Elegir Archivo",
                  no_file_chosen: "Ningún archivo elegido",
        next: "Próximo",
        last: "Último",
        upcoming_episode: "Episodio próximo",
          welcome: "Bienvenido",
          theme: "Tema",
          theme_description: "Cambia entre diferentes temas visuales para la aplicación.",
          mardi_gras_mode: "Modo Mardi Gras",
          sign_in_account: "Iniciar sesión / Cuenta",
          language: "Idioma",
          all_genres: "Todos los géneros",
          search_for_shows: "Buscar series o películas...",
          currently_watching_count: "Viendo actualmente",
          want_to_watch_count: "Quiero ver",
          already_watched_count: "Ya visto",
          discover_description: "Recomendaciones basadas en tus gustos y calificaciones.",
          settings_description: "Configuración de la aplicación",
          display_name_placeholder: "Nombre para mostrar",
          save_name: "Guardar",
          pro_simulate: "Pro (simular)",
          notifications: "Notificaciones",
          stats: "Estadísticas",
          total_items: "Total de elementos",
          watching_count: "Viendo",
          wishlist_count: "Lista de deseos",
          watched_count: "Visto",
          top_genres: "Géneros principales",
          average_rating: "Calificación promedio",
          loading: "Cargando...",
          failed_to_load: "Falló al cargar",
          not_enough_signals: "No hay suficientes señales. Dale me gusta o califica algunos elementos primero.",
          recommendations_failed: "Falló al cargar recomendaciones.",
          building_recommendations: "Construyendo recomendaciones...",
          remove_confirmation: "¿Eliminar \"{title}\" de esta lista?",
          already_in_list_warning: "Ya está en {list}.",
          moved_to_list: "Movido a {list}.",
          added_to_list: "Agregado a {list}.",
          cloud_sync_ok: "Sincronización en la nube OK",
          cloud_load_failed: "Carga de la nube falló. Usando local.",
          cloud_sync_failed: "Sincronización en la nube falló. Guardado localmente.",
          signed_in: "Sesión iniciada",
          signed_out: "Sesión cerrada",
          login_failed: "Inicio de sesión falló",
          name_saved: "¡Nombre guardado!",
          enter_name_first: "Ingresa un nombre primero.",
          imported_backup: "Respaldo importado.",
          invalid_file: "Archivo inválido.",
          all_data_cleared: "Todos los datos borrados.",
          share_link_generated: "Enlace de compartir generado.",
          generate_share_link: "Generar Enlace de Compartir",
          select_all_everything: "Seleccionar Todo",
          close: "Cerrar",
          no_items_selected: "No hay elementos seleccionados",
          no_items_in_list: "No hay elementos en esta lista",
          switch_to_share: "Cambia a Ver/Lista de deseos/Visto para compartir.",
          imported_from_link: "Lista importada desde enlace",
          could_not_read_item: "No se pudieron leer los detalles del item. Intenta de nuevo.",
          upcoming_episode_alert: "Próximo: {title} • {date}",
          streaming_horoscope: "Horóscopo de streaming",
          feedback_working: "Dinos qué está funcionando y qué no. Sé directo.",
          quote_loading: "Cargando cita de valor cuestionable...",
          // Quote translations
          quote_1: "Soy serio... y no me llames Shirley.",
          quote_2: "El streaming es un estilo de vida, no una elección.",
          quote_3: "Maratón ahora. Llora después.",
          quote_4: "Uno no simplemente ve un episodio.",
          quote_5: "Me tuviste en 'saltar resumen.'",
          quote_6: "El arte es largo, los episodios son más largos.",
          quote_7: "¡Estábamos en una pausa! De la realidad.",
          quote_8: "Vine, vi, lo puse en cola.",
          quote_9: "Transmitir, tal vez dormir.",
          quote_10: "En esta casa respetamos el aviso '¿Sigues viendo?'",
          quote_11: "El algoritmo piensa que soy complicado. Tiene razón.",
          quote_12: "Si se encuentra, devolver al sofá.",
          quote_13: "Mi lenguaje del amor es 'saltar anuncio.'",
          quote_14: "Contengo multitudes y varias listas de reproducción.",
          quote_15: "Los domingos son para pilotos y negación.",
          quote_16: "Ctrl+Z para la vida, reproducir para comodidad.",
          quote_17: "No temo a ningún hombre, pero temo a los finales.",
          quote_18: "Esta aplicación me entiende. Aterrador.",
          quote_19: "Los agujeros de trama son solo cardio para el cerebro.",
          quote_20: "Aceptamos la dopamina que creemos merecer.",
          quote_21: "Nunca he terminado nada. Excepto temporadas.",
          quote_22: "Vibra de hoy: subtítulos cerrados y aperitivos abiertos.",
          quote_23: "¿Presagio? Apenas la conozco.",
          quote_24: "El desarrollo de personajes es mi cardio.",
          quote_25: "Si golpea la tarjeta de título, me quedo.",
          quote_26: "Minimalismo, pero para episodios.",
          quote_27: "'¿Sigues viendo?' sí, Netflix, estoy prosperando.",
          quote_28: "Envío productividad con siestas.",
          quote_29: "Supremacía del programa de comodidad.",
          quote_30: "Esta cola es una prueba de personalidad que estoy fallando.",
          // Horoscope translations in Spanish
          you_love_a_slow_burn_and_fast_wifi: "Te encanta el desarrollo lento y el Wi‑Fi rápido.",
          youre_allergic_to_laugh_tracks: "Eres alérgico a las risas enlatadas.",
          you_pause_for_snacks_like_its_a_ritual: "Pausas para bocadillos como si fuera un ritual.",
          you_are_a_spoiler_ninja_and_an_ending_apologist: "Eres un ninja de spoilers y un apologista de finales.",
          you_think_limited_series_means_limits_dont_apply_to_you: "Crees que 'serie limitada' significa que los límites no se aplican a ti.",
          you_fastforward_opening_credits_but_respect_end_credits: "Avanzas rápidamente los créditos iniciales pero respetas los finales.",
          you_crave_vibes_plot_bold_choice: "Anhelas vibes > trama. Elección audaz.",
          you_treat_recommended_for_you_as_a_dare: "Tratas 'recomendado para ti' como un desafío.",
          you_chase_vibes_like_a_sommelier_of_scenes: "Persigues vibes como un sommelier de escenas.",
          you_watch_with_subtitles_you_are_cultured_and_quiet: "Ves con subtítulos; eres culto (y silencioso).",
          you_fear_the_finale_but_press_play_anyway: "Temes el final pero presionas play de todos modos.",
          you_bookmark_chaos_and_call_it_variety: "Marcas el caos y lo llamas variedad.",
          you_own_three_blankets_all_the_good_one: "Tienes tres mantas. Todas 'la buena'.",
          you_pretend_the_algorithm_is_your_friend: "Finges que el algoritmo es tu amigo.",
          you_rewatch_comfort_episodes_like_vitamins: "Revés episodios de consuelo como vitaminas.",
          you_hoard_tabs_and_storylines_with_equal_skill: "Acumulas pestañas e historias con igual habilidad.",
          you_skip_recaps_then_google_plot_summaries_iconic: "Saltas los resúmenes, luego buscas en Google. Icónico.",
          // Additional missing horoscope translations
          you_are_a_chaotic_good_you_like_drama_but_call_it_cinema: "Eres un Caótico Bueno. Te gusta el drama pero lo llamas 'cine.'",
          binge_minimalist_planning_watching: "Minimalista de maratón: 90% planificación, 10% visualización.",
          comfort_chaos_and_clever_twists: "Comodidad, caos y giros inteligentes. En ese orden.",
          on_your_rewatch_arc_brave: "En tu arco de re-visualización número 14. Valiente.",
          fueled_by_snacks_and_unresolved_plotlines: "63% alimentado por bocadillos y tramas sin resolver.",
          human_embodiment_of_skip_intro: "Encarnación humana de 'saltar intro.'",
          your_spirit_animal_is_a_loading_spinner: "Tu animal espiritual es un indicador de carga.",
          you_collect_pilots_like_pokemon: "Coleccionas pilotos como Pokémon.",
          you_claim_you_hate_cliffhangers_you_dont: "Dices que odias los cliffhangers. No es cierto.",
          you_alphabetize_your_watchlist_and_then_ignore_it: "Alfabetizas tu lista de reproducción y luego la ignoras.",
          you_believe_one_more_episode_is_a_contract_with_destiny: "Crees que 'un episodio más' es un contrato con el destino.",
          you_rate_with_your_heart_not_the_stars: "Calificas con tu corazón, no con las estrellas.",
          youre_here_to_procrastinate_responsibly: "Estás aquí para procrastinar responsablemente.",
          export: "Exportar",
          unknown_title: "Título Desconocido",
          no_image: "Sin Imagen",
          like: "Me Gusta",
          dislike: "No Me Gusta",
          rate_out_of_5: "Calificar {n} de 5",
          notifications_enabled: "Notificaciones habilitadas! Recibirás recordatorios de episodios.",
          pro_features: "Características Pro:",
          pro_feature_analytics: "Análisis avanzado e insights",
          pro_feature_categories: "Categorías personalizadas de lista de deseos",
          pro_feature_export: "Exportar a múltiples formatos",
          pro_feature_support: "Soporte prioritario al cliente",
          pro_feature_early_access: "Acceso temprano a nuevas funciones",
          pro_feature_backup: "Respaldo en la nube y sincronización entre dispositivos",
          pro_feature_recommendations: "Recomendaciones personalizadas con IA",
          pro_feature_stats: "Estadísticas detalladas de visualización",
          pro: "Pro",
        },
      };
      function t(k) {
        const lang = appData?.settings?.lang || "en";
        const translation = (I18N[lang] && I18N[lang][k]) || I18N.en[k] || k;

        return translation;
      }
      function applyTranslations() {
        const elements = document.querySelectorAll("[data-i18n]");
        
        elements.forEach((el) => {
          const k = el.getAttribute("data-i18n");
          if (k) {
            const translation = t(k);
    
            el.textContent = translation;
          }
        });
        
        // Handle placeholder translations
        const placeholderElements = document.querySelectorAll("[data-i18n-placeholder]");

        
        placeholderElements.forEach((el) => {
          const k = el.getAttribute("data-i18n-placeholder");
          if (k) {
            const translation = t(k);
    
            el.placeholder = translation;
          }
        });
      }
      function formatDateShort(dateStr) {
        if (!dateStr) return "";
        const lang = appData?.settings?.lang === "es" ? "es-ES" : "en-US";
        const d = new Date(dateStr);
        if (Number.isNaN(d.getTime())) return dateStr;
        return d.toLocaleDateString(lang, {
          month: "short",
          day: "numeric",
          year: "numeric",
        });
      }
      
      function updateFileLabel(input) {
        const label = document.getElementById("fileLabel");
        if (label) {
          if (input.files && input.files[0]) {
            label.textContent = input.files[0].name;
          } else {
            label.textContent = t("no_file_chosen");
          }
        }
      }

      /* ============== Firebase (config) ============== */
      firebase.initializeApp({
        apiKey: "AIzaSyDEiqf8cxQJ11URcQeE8jqq5EMa5M6zAXM",
        authDomain: "flicklet-71dff.firebaseapp.com",
        projectId: "flicklet-71dff",
        storageBucket: "flicklet-71dff.firebasestorage.app",
        messagingSenderId: "1034923556763",
        appId: "1:1034923556763:web:bba5489cd1d9412c9c2b3e",
      });
      const auth = firebase.auth();
      const db = firebase.firestore();
      let currentUser = null;

      /* ============== App constants / state ============== */
      const DEV = ["localhost","127.0.0.1","::1"].includes(location.hostname) || !!location.port;
      const TMDB_IMG_BASE = "https://image.tmdb.org/t/p/w200";
      const API_BASE = DEV
        ? "https://api.themoviedb.org/3"
        : "/.netlify/functions/tmdb";
      const TMDB_KEY = "b7247bb415b50f25b5e35e2566430b96";

      const appData = {
        tv: { watching: [], wishlist: [], watched: [] },
        movies: { watching: [], wishlist: [], watched: [] },
        settings: {
          theme: "light",
          displayName: "",
          lang: "en",
          pro: false,
          notif: { episodes: false, discover: false, digest: false },
        },
      };

      /* ============== TMDB Localization System ============== */
      const TMDB = {
        base: "https://api.themoviedb.org/3",
        key: window.TMDB_API_KEY || "b7247bb415b50f25b5e35e2566430b96"
      };

      const localizedCache = new Map(); // key: `${lang}:${type}:${id}` -> payload

      async function tmdbFetch(path, lang) {
        const url = `${TMDB.base}${path}?language=${encodeURIComponent(lang)}&api_key=${encodeURIComponent(TMDB.key)}`;
        const r = await fetch(url);
        if (!r.ok) throw new Error(`TMDB ${r.status} on ${path}`);
        return r.json();
      }

            async function fetchLocalizedCore({ id, type }, lang) {
        
        const cacheKey = `${lang}:${type}:${id}`;
        if (localizedCache.has(cacheKey)) {
          
          return localizedCache.get(cacheKey);
        }
        
        const path = type === "tv" ? `/tv/${id}` : `/movie/${id}`;
        
        try {
          let data = await tmdbFetch(path, lang);
          
          // Minimal fields used by the cards
          let title = (data.title || data.name || "").trim();
          let overview = (data.overview || "").trim();
          const networks = Array.isArray(data.networks) ? data.networks.map(n => n?.name).filter(Boolean) : [];
          
          // Fallback to en-US if locale returns empty strings
          if ((!title || !overview) && lang !== "en-US") {
            try {
              const en = await tmdbFetch(path, "en-US");
              title = title || (en.title || en.name || "");
              overview = overview || (en.overview || "");
            } catch (fallbackError) {
              // Silent fallback - use original data
            }
          }
          
          const result = { title, overview, networks };
          localizedCache.set(cacheKey, result);
          return result;
        } catch (error) {
          // Handle 404 and other errors gracefully
          return null;
        }
      }

      // Preserve user-specific fields when merging
      function mergeLocalizedFields(original, localized) {
        // Do NOT touch user data (notes, tags, rating, list position, etc.)
        return {
          ...original,
          title: localized.title || original.title || original.name || "",
          name: undefined, // normalize to title for rendering
          overview: localized.overview ?? original.overview ?? "",
          networks: localized.networks ?? original.networks ?? []
        };
      }

      // --- Rehydrate lists in the chosen locale ---
      async function rehydrateListsForLocale(lang) {
        // Guards
        if (!appData || !appData.movies || !appData.tv) {
          return;
        }

        const lists = ["watching", "wishlist", "watched"];
        const allItems = [];
        
        // Process movies
        for (const list of lists) {
          const arr = appData.movies[list] || [];
          for (let i = 0; i < arr.length; i++) {
            const item = arr[i];
            if (item && (item.id || item.tmdbId)) {
              // Normalize the ID and determine type
              const id = Number(item.id ?? item.tmdbId);
              // Better type detection - avoid 'person' type
              let type = item.media_type;
              if (!type || type === "person") {
                // Infer from available fields
                if (item.first_air_date || item.episode_run_time || item.number_of_seasons) {
                  type = "tv";
                } else if (item.release_date || item.runtime) {
                  type = "movie";
                } else {
                  // Default to movie for items in movies list
                  type = "movie";
                }
              }
              
              if (id && type && type !== "person") {
                allItems.push({ 
                  item, 
                  list, 
                  category: "movies",
                  arrayIndex: i,
                  id,
                  type
                });
              }
            }
          }
        }
        
        // Process TV shows
        for (const list of lists) {
          const arr = appData.tv[list] || [];
          for (let i = 0; i < arr.length; i++) {
            const item = arr[i];
            if (item && (item.id || item.tmdbId)) {
              // Normalize the ID and determine type
              const id = Number(item.id ?? item.tmdbId);
              // Better type detection - avoid 'person' type
              let type = item.media_type;
              if (!type || type === "person") {
                // Infer from available fields
                if (item.first_air_date || item.episode_run_time || item.number_of_seasons) {
                  type = "tv";
                } else if (item.release_date || item.runtime) {
                  type = "movie";
                } else {
                  // Default to tv for items in tv list
                  type = "tv";
                }
              }
              
              if (id && type && type !== "person") {
                allItems.push({ 
                  item, 
                  list, 
                  category: "tv",
                  arrayIndex: i,
                  id,
                  type
                });
              }
            }
          }
        }

        // Process items sequentially to avoid rate limits and race conditions
        let successCount = 0;
        

        
        for (const { item, list, category, arrayIndex, id, type } of allItems) {
          try {
            const localized = await fetchLocalizedCore({ id, type }, lang);
            
            // Skip items that couldn't be localized (404 errors, etc.)
            if (!localized) {
              continue;
            }
            
            const merged = mergeLocalizedFields({ ...item, id, type }, localized);
            
            // Write back into the correct array position
            appData[category][list][arrayIndex] = merged;
            successCount++;
            
          } catch (error) {
            console.warn(`Failed to localize ${type}/${id}:`, error.message);
          }
          
          // Small delay to be nice to TMDB API
          if (allItems.length > 10) {
            await new Promise(resolve => setTimeout(resolve, 100));
          }
        }
      }

      /* ============== Small utilities ============== */
      function toB64Url(str) {
        const bin = new TextEncoder().encode(str);
        let b64 = btoa(String.fromCharCode(...bin));
        return b64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/,'');
      }
      function fromB64Url(b64url) {
        const b64 = b64url.replace(/-/g,'+').replace(/_/g,'/') + '==='.slice((b64url.length + 3) % 4);
        const bytes = Uint8Array.from(atob(b64), c => c.charCodeAt(0));
        return new TextDecoder().decode(bytes);
      }
      function showNotification(msg, type = "info") {
        console.log(`🔔 Global showNotification called: "${msg}" (${type})`);
        // Use the centralized notification system
        if (window.FlickletApp && typeof window.FlickletApp.showNotification === 'function') {
          console.log('✅ Using centralized notification system');
          window.FlickletApp.showNotification(msg, type);
        } else {
          console.log('⚠️ Centralized system not available, using fallback');
          // Fallback to old system if centralized system not available
          const n = document.createElement("div");
          n.className = `notification ${type}`;
          n.textContent = msg;
          const live = document.getElementById('liveRegion');
          if (live) { live.textContent = msg; }
          document.body.appendChild(n);
          setTimeout(() => n.remove(), 2800);
        }
      }

      function updateWelcomeText() {
        try {
          // DISABLED: This function conflicts with our dynamic header system
          // The header is now managed by FlickletApp.updateHeaderWithUsername()
          console.log('🚫 updateWelcomeText disabled - header managed by FlickletApp');
          return;
          
          // OLD CODE (disabled):
          /*
          const n = (appData?.settings?.displayName || "").trim();
          
          const el = document.getElementById("welcomeText");
          if (!el) {
            console.log("welcomeText element not found");
            return;
          }
          
          // Only update if user has a display name, otherwise keep "Flicklet"
          if (n) {
            const pool = [
              "Chaos",
              "Questionable Taste",
              "Binge Empire",
              "Streaming Madness",
              "Watch List",
            ];
            const newText = `${n}'s ${pool[Math.floor(Math.random() * pool.length)]}`;
            el.textContent = newText;
          } else {
            // Keep the original "Flicklet" title
            el.textContent = t("app_title");
          }
          */

        } catch (e) {
          console.warn("updateWelcomeText failed:", e);
        }
      }

      function loadAppData() {
        try {
          const saved = localStorage.getItem("tvMovieTrackerData");
          if (saved) {
            const parsed = JSON.parse(saved);
            Object.assign(appData, {
              tv: parsed.tv || { watching: [], wishlist: [], watched: [] },
              movies: parsed.movies || {
                watching: [],
                wishlist: [],
                watched: [],
              },
              settings: {
                theme: parsed.settings?.theme ?? "light",
                displayName: parsed.settings?.displayName ?? "",
                lang: parsed.settings?.lang ?? "en",
                pro: !!parsed.settings?.pro,
                notif: parsed.settings?.notif || {
                  episodes: false,
                  discover: false,
                  digest: false,
                },
              },
            });
          }
        } catch (e) {
          console.warn("Local load failed", e);
        }
        if (appData.settings.theme === "dark")
          document.body.classList.add("dark-mode");
        
        // Language toggle is now handled by the onchange event directly

        
        // Only update welcome text if we have a display name
        if (appData.settings.displayName && appData.settings.displayName.trim()) {
          updateWelcomeText();
        }
        applyTranslations();
        
        // Sync data with FlickletApp if available
        if (window.FlickletApp && window.FlickletApp.appData) {
          console.log('🔄 Syncing appData with FlickletApp after loadAppData');
          // Update FlickletApp's appData with the loaded data
          window.FlickletApp.appData = { ...appData };
          console.log('✅ FlickletApp appData synced:', window.FlickletApp.appData);
          
          // Update the header with the synced data
          if (typeof window.FlickletApp.updateHeaderWithUsername === 'function') {
            window.FlickletApp.updateHeaderWithUsername();
          }
        }
        
        // Refresh the current tab content after app data is loaded
        setTimeout(() => {
          const currentTab = document.querySelector(".tab-section[style*='display: block']") || 
                            document.querySelector(".tab-section[style*='display: flex']");
          if (currentTab && currentTab.id !== "homeSection") {
            if (currentTab.id === "watchingSection") {
              const items = appData.tv.watching.concat(appData.movies.watching);
              if (typeof updateList === "function") updateList("watchingList", items);
            } else if (currentTab.id === "wishlistSection") {
              const items = appData.tv.wishlist.concat(appData.movies.wishlist);
              if (typeof updateList === "function") updateList("wishlistList", items);
            } else if (currentTab.id === "watchedSection") {
              const items = appData.tv.watched.concat(appData.movies.watched);
              if (typeof updateList === "function") updateList("watchedList", items);
            } else if (currentTab.id === "discoverSection") {
              if (typeof renderDiscover === "function") renderDiscover();
            }
          }
        }, 100);
      }

      function sanitizeForFirestore(value) {
        if (value === undefined) return undefined;
        if (value === null) return null;
        const t = typeof value;
        if (t === "string" || t === "boolean") return value;
        if (t === "number") return Number.isFinite(value) ? value : null;
        if (value instanceof Date) return value;
        if (Array.isArray(value))
          return value.map(sanitizeForFirestore).filter((v) => v !== undefined);
        if (t === "object") {
          const out = {};
          for (const [k, v] of Object.entries(value)) {
            const c = sanitizeForFirestore(v);
            if (c !== undefined) out[k] = c;
          }
          return out;
        }
        return undefined;
      }

      async function loadUserDataFromCloud(uid) {
        try {
          const snap = await db.collection("users").doc(uid).get();
          if (!snap.exists) return;
          const cloud = snap.data() || {};
          
          // Preserve local settings before any cloud operations
          const localDisplayName = (appData.settings?.displayName || "").trim();
          const localLanguage = (appData.settings?.lang || "en");
          
          
          if (cloud.watchlists) {
            if (cloud.watchlists.tv) appData.tv = cloud.watchlists.tv;
            if (cloud.watchlists.movies)
              appData.movies = cloud.watchlists.movies;
          }
                      if (cloud.settings) {
              const incoming = { ...cloud.settings };
              // Always preserve local display name if it exists
              if (localDisplayName) {
                incoming.displayName = localDisplayName;
              }
              // Don't override language setting from cloud - let user's choice persist
              appData.settings = { ...appData.settings, ...incoming };
            }

          if (typeof cloud.pro === "boolean") appData.settings.pro = cloud.pro;

          // Ensure display name is preserved after sanitization
          const cleaned = sanitizeForFirestore({
            tv: appData.tv,
            movies: appData.movies,
            settings: appData.settings,
          });
          appData.tv = cleaned.tv || {
            watching: [],
            wishlist: [],
            watched: [],
          };
          appData.movies = cleaned.movies || {
            watching: [],
            wishlist: [],
            watched: [],
          };
          appData.settings = cleaned.settings || appData.settings;
          
          // Restore local settings if they were lost during sanitization
          if (localDisplayName && (!appData.settings.displayName || !appData.settings.displayName.trim())) {
            appData.settings.displayName = localDisplayName;
          }
          // Don't restore language setting - let user's choice persist

          localStorage.setItem("tvMovieTrackerData", JSON.stringify(appData));
          
          // Prevent dropdown resets during language changes
          if (!window.isChangingLanguage) {
            const langSel = document.getElementById("langToggle");
            if (langSel) {
                          langSel.value = appData.settings.lang || "en";
          }
        }
          
          applyTranslations();
          // updateWelcomeText?.(); // DISABLED - conflicts with dynamic header system
          if (typeof updateUI === "function") updateUI();
          
          showNotification(t("cloud_sync_ok"), "success");
        } catch (e) {
          console.warn("load cloud failed", e);
          showNotification(t("cloud_load_failed"), "warning");
        }
      }

      async function saveAppData() {
        // Use centralized save if available
        if (window.FlickletApp && typeof window.FlickletApp.saveData === 'function') {
          window.FlickletApp.saveData();
          return;
        }
        
        // Fallback to old system
        localStorage.setItem("tvMovieTrackerData", JSON.stringify(appData));
        
        // Prevent dropdown resets during language changes
        if (!window.isChangingLanguage) {
          const langSel = document.getElementById("langToggle");
          if (langSel) {
            langSel.value = appData.settings.lang || "en";
          }
        }

        applyTranslations?.();
        // updateWelcomeText?.(); // DISABLED - conflicts with dynamic header system
        updateUI?.();

        if (!currentUser) return;
        try {
          const payload = sanitizeForFirestore({
            watchlists: { tv: appData.tv, movies: appData.movies },
            settings: appData.settings,
            pro: !!appData.settings.pro,
            lastUpdated: firebase.firestore.FieldValue.serverTimestamp(),
          });
          await db
            .collection("users")
            .doc(currentUser.uid)
            .set(payload, { merge: true });
        } catch (error) {
          console.error("cloud sync failed", error);
          showNotification(t("cloud_sync_failed"), "warning");
        }
      }

      /* ============== Auth helpers ============== */
      function login() {
        const provider = new firebase.auth.GoogleAuthProvider();
        return auth.signInWithPopup(provider).catch((err) => {
          const msg = String(err?.message || "");
          const code = err?.code || "";
          const coopBlocked =
            msg.includes("Cross-Origin-Opener-Policy") ||
            msg.includes("window.close") ||
            msg.includes("message channel closed") ||
            code === "auth/popup-closed-by-user" ||
            code === "auth/popup-blocked" ||
            code === "auth/cancelled-popup-request";
          if (coopBlocked) return auth.signInWithRedirect(provider);
          throw err;
        });
      }
      function emailLogin() {
        return new Promise((resolve, reject) => {
          openModal(
            "Email Sign In",
            `
              <div style="margin-bottom: 20px;">
                <p style="margin-bottom: 16px;">Enter your email and password to sign in or create an account.</p>
                <div style="display: flex; flex-direction: column; gap: 16px; max-width: 300px; margin: 0 auto;">
                  <input id="emailInput" class="modal-input" type="email" placeholder="Email address" style="text-align: left;" />
                  <input id="passwordInput" class="modal-input" type="password" placeholder="Password" style="text-align: left;" />
                </div>
              </div>
            `,
            "email-login-modal"
          );

          // Add sign in button
          const signInBtn = document.createElement("button");
          signInBtn.className = "btn secondary";
          signInBtn.textContent = "Sign In / Create Account";
          signInBtn.style.marginBottom = "12px";
          signInBtn.style.fontSize = "14px";
          signInBtn.style.padding = "12px 18px";
          signInBtn.style.minHeight = "44px";
          signInBtn.style.width = "160px";
          signInBtn.style.flex = "0 0 160px";
          signInBtn.onclick = async () => {
            const email = document.getElementById("emailInput").value.trim();
            const password = document.getElementById("passwordInput").value.trim();
            
            if (!email || !password) {
              showNotification("Please enter both email and password", "warning");
              return;
            }

            try {
              signInBtn.disabled = true;
              signInBtn.textContent = "Signing in...";
              
              const result = await auth.signInWithEmailAndPassword(email, password);
              document.querySelector(".modal-backdrop")?.remove();
              resolve(result);
            } catch (signInError) {
              try {
                // Try to create account if sign in fails
                const result = await auth.createUserWithEmailAndPassword(email, password);
                document.querySelector(".modal-backdrop")?.remove();
                resolve(result);
              } catch (createError) {
                signInBtn.disabled = false;
                signInBtn.textContent = "Sign In / Create Account";
                showNotification(createError.message || "Failed to sign in or create account", "error");
                reject(createError);
              }
            }
          };

            // Find the specific email modal and add the button there
          const emailModal = document.querySelector('[data-testid="email-login-modal"] .modal .modal-actions');
          if (emailModal) {
            console.log('✅ Found email modal, adding sign-in button');
            // Style the modal actions container for better button layout
            emailModal.style.display = 'flex';
            emailModal.style.justifyContent = 'center';
            emailModal.style.gap = '12px';
            emailModal.style.flexWrap = 'wrap';
            emailModal.prepend(signInBtn);
          } else {
            console.log('⚠️ Email modal not found, using fallback');
            // Fallback to any modal if the specific one isn't found
            const fallbackModal = document.querySelector(".modal .modal-actions");
            if (fallbackModal) {
              console.log('✅ Found fallback modal, adding sign-in button');
              // Style the fallback modal actions container too
              fallbackModal.style.display = 'flex';
              fallbackModal.style.justifyContent = 'center';
              fallbackModal.style.gap = '12px';
              fallbackModal.style.flexWrap = 'wrap';
              fallbackModal.prepend(signInBtn);
            } else {
              console.error('❌ No modal found to add button to');
          }
          }

          // Add Enter key handlers
          const emailInput = document.getElementById("emailInput");
          const passwordInput = document.getElementById("passwordInput");
          
          if (emailInput && passwordInput) {
            emailInput.addEventListener("keydown", (e) => {
              if (e.key === "Enter") {
                passwordInput.focus();
              }
            });
            passwordInput.addEventListener("keydown", (e) => {
              if (e.key === "Enter") {
                signInBtn.click();
              }
            });
            emailInput.focus();
          }
        });
      }
      
      function appleLogin() {
        const provider = new firebase.auth.OAuthProvider('apple.com');
        return auth.signInWithPopup(provider).catch((err) => {
          const msg = String(err?.message || "");
          const code = err?.code || "";
          const coopBlocked =
            msg.includes("Cross-Origin-Opener-Policy") ||
            msg.includes("window.close") ||
            msg.includes("message channel closed") ||
            code === "auth/popup-closed-by-user" ||
            code === "auth/popup-blocked" ||
            code === "auth/cancelled-popup-request";
          if (coopBlocked) return auth.signInWithRedirect(provider);
          throw err;
        });
      }
      
      window.login = login;
      window.emailLogin = emailLogin;
      window.appleLogin = appleLogin;

      function setAccountLabel(u) {
        const btn = document.getElementById("accountBtn");
        if (!btn) return;
        const manual = (appData?.settings?.displayName || "").trim();
        const firebaseName = (u?.displayName || "").trim();
        const emailPrefix = u?.email ? u.email.split("@")[0] : "";
        const chosen = manual || firebaseName || emailPrefix;
        btn.textContent = chosen
          ? `👤 ${chosen.split(/\s+/)[0]}`
          : "👤 Sign In";
      }

      /* ============== Single global auth listener ============== */
      auth.onAuthStateChanged(async (user) => {
        currentUser = user;
        setAccountLabel(user);
        
        // If user just signed in, close any open sign-in modals
        if (user) {
          const signInModals = document.querySelectorAll('.modal-backdrop[data-testid="modal-backdrop"]');
          signInModals.forEach(modal => {
            if (modal.querySelector('[data-testid="auth-modal"]')) {
              modal.remove();
            }
          });
        }

        if (user) {
          try {
            await db
              .collection("users")
              .doc(user.uid)
              .set(
                {
                  profile: {
                    email: user.email || "",
                    displayName: user.displayName || "",
                    photoURL: user.photoURL || "",
                  },
                  lastLoginAt: firebase.firestore.FieldValue.serverTimestamp(),
                },
                { merge: true }
              );

            await loadUserDataFromCloud(user.uid);

            // Refresh the current tab content after cloud data is loaded
            setTimeout(() => {
              if (typeof applyTranslations === "function") {
                applyTranslations();
              }
              // Also refresh the current tab content
              const currentTab = document.querySelector(".tab-section[style*='display: block']") || 
                                document.querySelector(".tab-section[style*='display: flex']");
              if (currentTab && currentTab.id !== "homeSection") {
                if (currentTab.id === "watchingSection") {
                  const items = appData.tv.watching.concat(appData.movies.watching);
                  if (typeof updateList === "function") updateList("watchingList", items);
                } else if (currentTab.id === "wishlistSection") {
                  const items = appData.tv.wishlist.concat(appData.movies.wishlist);
                  if (typeof updateList === "function") updateList("wishlistList", items);
                } else if (currentTab.id === "watchedSection") {
                  const items = appData.tv.watched.concat(appData.movies.watched);
                  if (typeof updateList === "function") updateList("watchedList", items);
                } else if (currentTab.id === "discoverSection") {
                  if (typeof renderDiscover === "function") renderDiscover();
                }
              }
            }, 300);

            // Check if user needs to set a display name after successful authentication
            const currentDisplayName = (appData?.settings?.displayName || "").trim();
            if (!currentDisplayName) {
              // Try to use Google/Apple profile name first
              const guess =
                (user.displayName && user.displayName.trim()) ||
                (user.email && user.email.split("@")[0]) ||
                "";
              
              if (guess) {
                // Auto-set the name from profile
                appData.settings.displayName = guess.trim();
                if (typeof saveAppData === "function") saveAppData();
                // if (typeof updateWelcomeText === "function") updateWelcomeText(); // DISABLED - conflicts with dynamic header system
                if (typeof rebuildStats === "function") rebuildStats();
                localStorage.setItem("__flicklet_onboarded__", "1");
                setAccountLabel(user);
              } else {
                // No profile name available - prompt user to set one
                setTimeout(() => {
                  if (!appData.settings.displayName || !appData.settings.displayName.trim()) {
                    // Only show if no other modal is already open
                    if (!document.querySelector('.modal-backdrop')) {
                      showNameModal(true);
                    }
                  }
                }, 500); // Small delay to ensure everything is loaded
              }
            }
          } catch (e) {
            console.warn("Cloud sync failed", e);
          }
        }
      });

      /* ======= Sign-in modal + Name onboarding ======= */
      function openModal(title, html, testId = "generic-modal") {
        const wrap = document.createElement("div");
        wrap.className = "modal-backdrop";
        wrap.setAttribute("data-testid", "modal-backdrop");
        wrap.innerHTML = `
          <div class="modal" role="dialog" aria-modal="true" aria-labelledby="modal-title" data-testid="${testId}" tabindex="-1">
            <h3 id="modal-title">${title}</h3>
            <div class="modal-body">${html}</div>
            <div class="modal-actions">
              <button class="btn secondary" data-testid="modal-close" type="button" style="width: 120px !important; flex: 0 0 120px !important; font-size: 14px !important; padding: 12px 18px !important; min-height: 44px !important;">Close</button>
            </div>
          </div>`;
        document.body.appendChild(wrap);

        const close = () => wrap.remove();
        wrap.addEventListener("click", (e) => {
          if (e.target === wrap) close();
        });
        wrap.addEventListener("keydown", (e) => {
          if (e.key === "Escape") close();
        });
        const modalEl = wrap.querySelector('.modal');
        modalEl.focus();
        
        // Style the modal actions container for consistent button layout
        const modalActions = wrap.querySelector('.modal-actions');
        if (modalActions) {
          if (testId === "auth-modal") {
            // For the main sign-in modal, ensure buttons are centered and have consistent spacing
            modalActions.style.display = 'flex';
            modalActions.style.justifyContent = 'center';
            modalActions.style.gap = '12px';
            modalActions.style.flexWrap = 'wrap';
          }
        }
        const closeBtn = wrap.querySelector('[data-testid="modal-close"]');
        closeBtn.addEventListener("click", close);
        
        // Style the close button to match other buttons in the modal
        if (testId === "email-login-modal") {
          closeBtn.style.width = "120px";
          closeBtn.style.flex = "0 0 120px";
          closeBtn.style.fontSize = "14px";
          closeBtn.style.padding = "12px 18px";
          closeBtn.style.minHeight = "44px";
        } else if (testId === "auth-modal") {
          // Make the main sign-in modal's close button match the email modal's close button
          closeBtn.style.width = "120px";
          closeBtn.style.flex = "0 0 120px";
          closeBtn.style.fontSize = "14px";
          closeBtn.style.padding = "12px 18px";
          closeBtn.style.minHeight = "44px";
        }
      }

      function showNameModal(force = false) {
        const current = (appData.settings.displayName || "").trim();
        if (!force && current) {
          return;
        }

        openModal(
          "Welcome! What should we call you?",
          `
            <div class="modal-content-wrapper">
              <p class="modal-instruction">This will personalize your headers and stats.</p>
              <input id="onboardName" class="modal-input" placeholder="Display name"
                     value="${(current || "").replace(/"/g, "&quot;")}" />
            </div>
          `,
          "name-onboarding"
        );

        const saveBtn = document.createElement("button");
        saveBtn.className = "btn success";
        saveBtn.textContent = "Save";
        saveBtn.onclick = () => {
          const v = (document.getElementById("onboardName").value || "").trim();
          if (!v) {
            const el = document.getElementById('onboardName');
            if (el) {
              el.setAttribute('aria-invalid','true');
              let err = document.getElementById('onboardError');
              if (!err) {
                err = document.createElement('div');
                err.id = 'onboardError';
                err.className = 'form-error';
                err.textContent = 'Please enter a display name.';
                el.setAttribute('aria-describedby','onboardError');
                el.insertAdjacentElement('afterend', err);
              } else { err.textContent = 'Please enter a display name.'; }
            }
            return;
          }
          appData.settings.displayName = v;
          saveAppData();
          // updateWelcomeText?.(); // DISABLED - conflicts with dynamic header system
          rebuildStats?.();
          localStorage.setItem("__flicklet_onboarded__", "1");
          document.querySelector(".modal-backdrop")?.remove();
          if (currentUser) setAccountLabel?.(currentUser);
          // Don't automatically show sign-in modal - user should authenticate first
        };
        document.querySelector(".modal .modal-actions").prepend(saveBtn);

        // Add Enter key handler to the name input
        const nameInput = document.getElementById("onboardName");
        if (nameInput) {
          nameInput.addEventListener("keydown", (e) => {
            if (e.key === "Enter") {
              e.preventDefault();
              saveBtn.click();
            }
          });
        }
      }

      function showSignInModal() {
        openModal(
          "Sign in to sync",
          `
            <p style="margin-bottom: 20px;">Sign in to back up your lists and sync across devices.</p>
            <div style="display:grid; grid-template-columns: 1fr 1fr; gap:16px; justify-content:center; align-items:center; max-width:320px; margin:0 auto;">
              <button id="googleBtn" class="btn" style="font-size:14px; padding:12px 18px; min-height:44px;">🔒 Google</button>
              <button id="appleBtn" class="btn secondary" style="font-size:14px; padding:12px 18px; min-height:44px;">🍎 Apple</button>
              <button id="emailBtn" class="btn secondary" style="font-size:14px; padding:12px 18px; min-height:44px; grid-column: 1 / -1;">✉️ Email</button>
              <button id="signOutBtn" class="btn secondary" style="display:none; font-size:14px; padding:12px 18px; min-height:44px;">Sign Out</button>
            </div>
          `,
          "auth-modal"
        );

        const google = document.getElementById("googleBtn");
        const apple = document.getElementById("appleBtn");
        const email = document.getElementById("emailBtn");
        const out = document.getElementById("signOutBtn");

        if (currentUser) {
          google.style.display = "none";
          apple.style.display = "none";
          email.style.display = "none";
          out.style.display = "block";
          out.style.gridColumn = "1 / -1";
          out.style.margin = "0 auto";
          out.onclick = () =>
            auth.signOut().then(() => {
              showNotification(t("signed_out"), "success");
              document.querySelector(".modal-backdrop")?.remove();
              setAccountLabel?.(null);
            });
        } else {
          google.onclick = () =>
            login()
              .then(() => {
                showNotification(t("signed_in"), "success");
                // Close all modals to ensure the sign-in modal is removed
                const modals = document.querySelectorAll(".modal-backdrop");
                modals.forEach(modal => modal.remove());
                // auth listener will call setAccountLabel and sync
              })
              .catch((e) => {
                let message = 'Sign in failed';
                if (e.message) {
                  if (e.message.includes('popup')) {
                    message = 'Sign in failed: Popup was blocked. Please try again.';
                  } else if (e.message.includes('network')) {
                    message = 'Sign in failed: Network error. Please check your connection.';
                  } else if (e.message.includes('invalid')) {
                    message = 'Sign in failed: Invalid credentials. Please try again.';
                  } else {
                    message = `Sign in failed: ${e.message}. Please try again.`;
                  }
                }
                showNotification(message, 'error');
              });

          apple.onclick = () =>
            appleLogin()
              .then(() => {
                showNotification(t("signed_in"), "success");
                // Close all modals to ensure the sign-in modal is removed
                const modals = document.querySelectorAll(".modal-backdrop");
                modals.forEach(modal => modal.remove());
                // auth listener will call setAccountLabel and sync
              })
              .catch((e) => {
                let message = 'Sign in failed';
                if (e.message) {
                  if (e.message.includes('popup')) {
                    message = 'Sign in failed: Popup was blocked. Please try again.';
                  } else if (e.message.includes('network')) {
                    message = 'Sign in failed: Network error. Please check your connection.';
                  } else if (e.message.includes('invalid')) {
                    message = 'Sign in failed: Invalid credentials. Please try again.';
                  } else {
                    message = `Sign in failed: ${e.message}. Please try again.`;
                  }
                }
                showNotification(message, 'error');
              });

          email.onclick = () => {
            // Close the main sign-in modal first
            document.querySelector(".modal-backdrop")?.remove();
            
            // Then open the email modal
            emailLogin()
              .then(() => {
                showNotification(t("signed_in"), "success");
                // auth listener will call setAccountLabel and sync
              })
              .catch((e) => {
                let message = 'Sign in failed';
                if (e.message) {
                  if (e.message.includes('popup')) {
                    message = 'Sign in failed: Popup was blocked. Please try again.';
                  } else if (e.message.includes('network')) {
                    message = 'Sign in failed: Network error. Please check your connection.';
                  } else if (e.message.includes('invalid')) {
                    message = 'Sign in failed: Invalid credentials. Please try again.';
                  } else {
                    message = `Sign in failed: ${e.message}. Please try again.`;
                  }
                }
                showNotification(message, 'error');
              });
          };
        }
      }

      function escapeHtml(str) {
        return (str || "").replace(
          /[&<>"']/g,
          (s) =>
            ({
              "&": "&amp;",
              "<": "&lt;",
              ">": "&gt;",
              '"': "&quot;",
              "'": "&#39;",
            }[s])
        );
      }

      /* ============== TMDB helpers (Localization + Fallback) ============== */
      function langQuery() {
        return appData.settings.lang === "es"
          ? "&language=es-ES"
          : "&language=en-US";
      }

      async function tmdbGet(endpoint, params = "", tryFallback = true) {
        const lang = langQuery();
        let url;

        if (DEV) {
          const sep = params && params[0] === "&" ? "" : "&";
          url = `${API_BASE}/${endpoint}?api_key=${encodeURIComponent(
            TMDB_KEY
          )}${sep}${params}${lang}`;
        } else {
          url = `${API_BASE}?endpoint=${endpoint}${params}${lang}`;
        }

        const r = await fetch(url);
        if (r.ok) {
          const data = await r.json();
          if (
            tryFallback &&
            (!data || (Array.isArray(data.results) && !data.results.length))
          ) {
            const fallback = DEV
              ? `${API_BASE}/${endpoint}?api_key=${encodeURIComponent(
                  TMDB_KEY
                )}${params}&language=en-US`
              : `${API_BASE}?endpoint=${endpoint}${params}&language=en-US`;
            const r2 = await fetch(fallback);
            if (r2.ok) return await r2.json();
          }
          return data;
        }

        if (tryFallback) {
          const fallback = DEV
            ? `${API_BASE}/${endpoint}?api_key=${encodeURIComponent(
                TMDB_KEY
              )}${params}&language=en-US`
            : `${API_BASE}?endpoint=${endpoint}${params}&language=en-US`;
          const r2 = await fetch(fallback);
          if (r2.ok) return await r2.json();
        }
        throw new Error(`TMDB request failed: ${r.status}`);
      }
      



        

        


      async function fetchShowData(query, page = 1, genre = "") {
        let endpoint, params;
        if (genre && !query) {
          endpoint = "discover/tv";
          params = `&page=${page}&with_genres=${genre}`;
        } else {
          endpoint = "search/multi";
          params = `&page=${page}${
            query ? `&query=${encodeURIComponent(query)}` : ""
          }`;
        }

        const data = await tmdbGet(endpoint, params, true);
        const enhanced = await Promise.all(
          (data.results || []).map(async (item) => {
            try {
              if (item.media_type === "tv" || item.first_air_date) {
                const d = await tmdbGet(`tv/${item.id}`, "", true);
                return {
                  ...item,
                  status: d.status,
                  number_of_seasons: d.number_of_seasons,
                  number_of_episodes: d.number_of_episodes,
                  last_air_date: d.last_air_date,
                  first_air_date: d.first_air_date,
                  next_episode_to_air: d.next_episode_to_air,
                  last_episode_to_air: d.last_episode_to_air,
                  in_production: d.in_production,
                  genres: d.genres,
                  networks: d.networks || [],
                  episode_run_time: d.episode_run_time || [45],
                  runtime: d.episode_run_time ? d.episode_run_time[0] : 45,
                };
              } else if (item.media_type === "movie" || item.release_date) {
                const d = await tmdbGet(`movie/${item.id}`, "", true);
                return {
                  ...item,
                  status: d.status,
                  release_date: d.release_date,
                  genres: d.genres,
                  runtime: d.runtime || 120,
                };
              }
            } catch (_) {}
            return item;
          })
        );
        return enhanced;
      }

              async function loadGenres() {
        try {
          const data = await tmdbGet("genre/tv/list", "", true);
          
          const sel = document.getElementById("genreFilter");
          if (!sel) return;
          console.log("Genre filter before loading:", sel.style.width, sel.offsetWidth);
          sel.innerHTML = "";
          const all = document.createElement("option");
          all.value = "";
          all.textContent = t("gen");
          sel.appendChild(all);
          
          (data.genres || []).forEach((g) => {
            const opt = document.createElement("option");
            opt.value = String(g.id);
            // Try to translate the genre name, fallback to original if no translation
            let genreKey = g.name.toLowerCase().replace(/\s+/g, '_');
    
            
            // Handle special cases
            if (genreKey === "action_&_adventure") genreKey = "action_adventure";
            if (genreKey === "sci-fi_&_fantasy") genreKey = "sci_fi_fantasy";
            if (genreKey === "war_&_politics") genreKey = "war_politics";
            if (genreKey === "talk_show") genreKey = "talk_show";
            
            const translation = t(genreKey);

            opt.textContent = translation || g.name;
            sel.appendChild(opt);
          });
          
          console.log("Genre filter after loading:", sel.style.width, sel.offsetWidth);
          
        } catch (e) {
          console.error("loadGenres error:", e);
        }
      }

      /* ============== Episode reminders (Enhanced notifications) ============== */
      function checkUpcomingEpisodes() {
        if (!appData.settings?.notif?.episodes) return;
        
        const now = new Date();
        const soonMs = 36 * 60 * 60 * 1000; // 36 hours
        const verySoonMs = 24 * 60 * 60 * 1000; // 24 hours
        
        const watching = [
          ...appData.tv.watching,
          ...appData.movies.watching,
        ].filter((it) => it.media_type === "tv" || it.first_air_date);
        
        watching.forEach((it) => {
          const nextAir = it.next_episode_to_air?.air_date || null;
          if (!nextAir) return;
          
          const airDate = new Date(nextAir + "T00:00:00Z");
          const diff = airDate - now;
          
          if (diff >= 0 && diff <= soonMs) {
            const title = it.name || it.title;
            const dateStr = formatDateShort(nextAir);
            const message = t("upcoming_episode_alert").replace("{title}", title).replace("{date}", dateStr);
            
            // Show notification with proper localization
            showNotification(message, "success");
            
            
          }
        });
      }
      
      // Request notification permission on app load
      function requestNotificationPermission() {
        if ("Notification" in window && Notification.permission === "default") {
          Notification.requestPermission().then(permission => {
            if (permission === "granted") {
              showNotification(t("notifications_enabled"), "success");
            }
          });
        }
      }
      

      async function changeLanguage(newLang) {
        // Use centralized language change if available
        if (window.FlickletApp && typeof window.FlickletApp.changeLanguage === 'function') {
          window.FlickletApp.changeLanguage(newLang);
          return;
        }
        
        // Fallback to old system
        // Set a flag to prevent dropdown resets during language change
        window.isChangingLanguage = true;
        
        // Update app data
        if (window.appData?.settings) {
          window.appData.settings.lang = newLang;
        }
        if (appData?.settings) {
          appData.settings.lang = newLang;
        }
        
        // Ensure language dropdown options are preserved
        const langToggle = document.getElementById("langToggle");
        if (langToggle && langToggle.children.length < 2) {
          // Restore options if they were lost
          langToggle.innerHTML = `
            <option value="en">EN</option>
            <option value="es">ES</option>
          `;
        }
        
        // Apply translations FIRST (before rehydration)
        applyTranslations?.();
        
        // Show loading state
        const currentTab = document.querySelector(".tab.active")?.id?.replace("Tab", "");
        if (currentTab && ["watching", "wishlist", "watched"].includes(currentTab)) {
          const listContainer = document.getElementById(currentTab + "List");
          if (listContainer) {
            listContainer.innerHTML = `<div style="text-align: center; padding: 20px;">${t("loading")}...</div>`;
          }
        }
        
        try {
          // Rehydrate lists with localized TMDB data
          await rehydrateListsForLocale(newLang);
          
          // Save the data AFTER rehydration completes
          saveAppData?.();
          
          // Update UI AFTER rehydration completes
          updateUI?.();
          
        } catch (error) {
          console.warn("Failed to rehydrate lists for locale:", error);
          // Still save and update UI even if rehydration fails
          saveAppData?.();
          updateUI?.();
        }
        
        // Force refresh of genre dropdown
        setTimeout(() => {
          if (typeof loadGenres === "function") {
            loadGenres();
          }
        }, 200);
        
        // Show notification
        const langName = newLang === "es" ? "Spanish" : "English";
        showNotification(`Language changed to ${langName}`, "success");
        
        // Clear the flag after operations complete
        setTimeout(() => {
          window.isChangingLanguage = false;
        }, 3000);
        
        // Final refresh of horoscope and quote
        setTimeout(() => {
          const hEl = document.getElementById("fakeFortune");
          const qEl = document.getElementById("randomQuote");
          if (hEl) {
            hEl.textContent = pickDailyHoroscope();
          }
          if (qEl) {
            qEl.textContent = drawQuote();
          }
          
          const fileInput = document.getElementById("importFile");
          if (fileInput) {
            updateFileLabel(fileInput);
          }
          
          // Refresh search results if they're visible
          refreshSearchResults();
        }, 600);
      }

      /* ============== Discover (Phase 1) ============== */
      function buildUserProfileVector() {
        const liked = getAllItems().filter(
          (it) => it.likeStatus === "like" || (Number(it.userRating) || 0) >= 4
        );
        const genreCounts = {};
        liked.forEach((it) =>
          (it.genres || []).forEach(
            (g) => (genreCounts[g.id] = (genreCounts[g.id] || 0) + 1)
          )
        );
        return genreCounts;
      }

      async function fetchDiscover() {
        const profile = buildUserProfileVector();
        
        // Get more diverse content sources
        const [trendingTv, trendingMovie, popularTv, popularMovie] = await Promise.all([
          tmdbGet("trending/tv/week", "", true).catch(() => ({ results: [] })),
          tmdbGet("trending/movie/week", "", true).catch(() => ({ results: [] })),
          tmdbGet("tv/popular", "", true).catch(() => ({ results: [] })),
          tmdbGet("movie/popular", "", true).catch(() => ({ results: [] }))
        ]);
        
        const pool = [
          ...(trendingTv.results || []),
          ...(trendingMovie.results || []),
          ...(popularTv.results || []),
          ...(popularMovie.results || [])
        ];

        // Remove duplicates by ID
        const uniquePool = pool.filter((item, index, self) => 
          index === self.findIndex(t => t.id === item.id)
        );

        // Get all user's current items to exclude from recommendations
        const userItems = getAllItems();
        const userItemIds = new Set(userItems.map(item => item.id || item.tmdbId));

        // Filter out items that are already on user's lists
        const availablePool = uniquePool.filter(item => !userItemIds.has(item.id));

        const scored = availablePool
          .map((it) => {
            const g = (it.genres || it.genre_ids || []).map((x) =>
              typeof x === "number" ? { id: x } : x
            );
            const score = g.reduce((m, gg) => m + (profile[gg.id] || 0), 0);
            
            // Add bonus points for highly rated content
            const rating = Number(it.vote_average) || 0;
            const ratingBonus = rating >= 8 ? 2 : rating >= 7 ? 1 : 0;
            
            return { ...it, _score: score + ratingBonus };
          })
          .filter((it) => it._score > 0)
          .sort((a, b) => b._score - a._score);

        // If no personalized recommendations, fall back to top-rated content
        if (scored.length === 0) {
          const fallback = availablePool
            .filter(it => (Number(it.vote_average) || 0) >= 7)
            .sort((a, b) => (Number(b.vote_average) || 0) - (Number(a.vote_average) || 0))
            .slice(0, 10);
          
          return await Promise.all(
            fallback.map(async (it) => {
              try {
                if (it.media_type === "tv" || it.first_air_date) {
                  const d = await tmdbGet(`tv/${it.id}`, "", true);
                  return { ...it, ...d, because: "Popular and highly-rated content" };
                } else {
                  const d = await tmdbGet(`movie/${it.id}`, "", true);
                  return { ...it, ...d, because: "Popular and highly-rated content" };
                }
              } catch (_) {
                return it;
              }
            })
          );
        }

        const top = await Promise.all(
          scored.slice(0, 20).map(async (it) => {
            try {
              if (it.media_type === "tv" || it.first_air_date) {
                const d = await tmdbGet(`tv/${it.id}`, "", true);
                return { ...it, ...d, because: pickBecauseLabel() };
              } else {
                const d = await tmdbGet(`movie/${it.id}`, "", true);
                return { ...it, ...d, because: pickBecauseLabel() };
              }
            } catch (_) {
              return it;
            }
          })
        );
        return top;

        function pickBecauseLabel() {
          const liked = getAllItems().filter(
            (x) => x.likeStatus === "like" || (Number(x.userRating) || 0) >= 4
          );
          if (!liked.length) return "";
          const anchor = liked[Math.floor(Math.random() * liked.length)];
          const title = anchor.name || anchor.title || "this";
          return `${t("because_you_liked")} "${title}"`;
        }
      }

      /* ============== Notes & Tags ============== */
      function openNotesTagsModal(itemId) {
        const item = findItem(itemId);
        if (!item) return;
        const currentNotes = item.notes || "";
        const currentTags = Array.isArray(item.tags)
          ? item.tags.join(", ")
          : item.tags || "";
        openModal(
          "Notes & Tags",
          `
            <label>Notes</label>
            <textarea id="notesText" style="width:100%; min-height:120px;">${escapeHtml(
              currentNotes
            )}</textarea>
            <label style="margin-top:8px; display:block;">Tags (comma-separated)</label>
            <input id="tagsInput" class="search-input" value="${escapeHtml(
              currentTags
            )}" />
          `,
          "notes-tags-modal"
        );

        const saveBtn = document.createElement("button");
        saveBtn.className = "btn success";
        saveBtn.textContent = "Save";
        saveBtn.onclick = () => {
          const notes = (
            document.getElementById("notesText").value || ""
          ).trim();
          const tagsRaw = (
            document.getElementById("tagsInput").value || ""
          ).trim();
          const tags = tagsRaw
            ? tagsRaw
                .split(",")
                .map((s) => s.trim())
                .filter(Boolean)
            : [];
          const it = findItem(itemId);
          if (!it) return;
          it.notes = notes;
          it.tags = tags;
          saveAppData?.();
          updateTagFiltersUI?.();
          updateUI?.();
          document.querySelector(".modal-backdrop")?.remove();
        };
        document.querySelector(".modal .modal-actions").prepend(saveBtn);
      }

      function updateTagFiltersUI() {
        const all = new Set();
        getAllItems().forEach((it) =>
          (it.tags || []).forEach((tag) => all.add(tag))
        );
        const row = document.getElementById("tagFilterRow");
        row.innerHTML = "";
        [...all].sort().forEach((tag) => {
          const btn = document.createElement("button");
          btn.className =
            "tag-pill" + (activeTagFilters.has(tag) ? " active" : "");
          btn.textContent = `#${tag}`;
          btn.onclick = () => {
            if (activeTagFilters.has(tag)) activeTagFilters.delete(tag);
            else activeTagFilters.add(tag);
            updateTagFiltersUI();
            updateUI();
          };
          row.appendChild(btn);
        });
        if (all.size === 0) row.innerHTML = "";
      }

      function filterByTags(items) {
        if (!activeTagFilters.size) return items;
        return items.filter((it) => {
          const tags = new Set(it.tags || []);
          for (const tag of activeTagFilters) if (!tags.has(tag)) return false;
          return true;
        });
      }

      /* ============== Shareable lists (read-only links) ============== */
      function openShareSelectionModal() {
        console.log('🔗 Opening share selection modal');
        
        // Check if modal exists
        const modal = document.getElementById('shareSelectionModal');
        if (!modal) {
          console.error('❌ Share selection modal not found!');
          return;
        }
        
        console.log('✅ Modal found, populating...');
        
        // Populate the modal with all items from all lists
        populateShareModal();
        
        // Show the modal
        modal.style.display = 'flex';
        console.log('✅ Modal displayed');
        
        // Add click outside to close functionality
        modal.onclick = function(e) {
          if (e.target === modal) {
            closeShareSelectionModal();
          }
        };
      }

      function openNotInterestedModal() {
        console.log('🚫 Opening not interested modal');
        
        // Create modal HTML
        const modalHTML = `
          <div class="modal-backdrop" id="notInterestedModal" style="display: flex; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000; align-items: center; justify-content: center;">
            <div class="modal" style="background: var(--card); border-radius: 12px; padding: 24px; max-width: 600px; width: 90%; max-height: 80vh; overflow-y: auto;">
              <h3 style="margin: 0 0 16px 0; color: var(--text);">🚫 Not Interested List</h3>
              <p style="margin: 0 0 20px 0; color: var(--text-secondary); font-size: 0.9rem;">
                These shows and movies won't appear in your recommendations. You can remove items to see them again.
              </p>
              <div id="notInterestedList" style="margin-bottom: 20px;">
                <!-- Items will be populated here -->
              </div>
              <div style="display: flex; gap: 10px; justify-content: flex-end;">
                <button class="btn secondary" onclick="closeNotInterestedModal()">Close</button>
              </div>
            </div>
          </div>
        `;
        
        // Insert modal into DOM
        document.body.insertAdjacentHTML('beforeend', modalHTML);
        
        // Populate the list
        populateNotInterestedList();
        
        // Add click outside to close functionality
        const modal = document.getElementById('notInterestedModal');
        modal.onclick = function(e) {
          if (e.target === modal) {
            closeNotInterestedModal();
          }
        };
      }

      function populateNotInterestedList() {
        const container = document.getElementById('notInterestedList');
        if (!container) return;
        
        if (!appData.notInterested || appData.notInterested.length === 0) {
          container.innerHTML = `
            <div style="text-align: center; padding: 40px; color: var(--text-secondary); font-style: italic;">
              <div style="font-size: 2rem; margin-bottom: 16px;">🎉</div>
              <div>No items marked as not interested!</div>
              <div style="font-size: 0.9rem; margin-top: 8px;">Your recommendations are clean and fresh.</div>
            </div>
          `;
          return;
        }
        
        container.innerHTML = '';
        appData.notInterested.forEach((item, index) => {
          const itemDiv = document.createElement('div');
          itemDiv.className = 'not-interested-item';
          itemDiv.style.cssText = `
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px;
            margin: 8px 0;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 8px;
          `;
          
          const dateAdded = new Date(item.dateAdded).toLocaleDateString();
          
          itemDiv.innerHTML = `
            <div>
              <div style="font-weight: 500; margin-bottom: 4px;">${item.title}</div>
              <div style="font-size: 0.85rem; color: var(--text-secondary);">
                ${item.mediaType === 'tv' ? '📺 TV Series' : '🎬 Movie'} • Added ${dateAdded}
              </div>
            </div>
            <button class="btn danger" onclick="removeFromNotInterested(${index})" style="padding: 6px 12px; font-size: 0.85rem;">
              🗑️ Remove
            </button>
          `;
          
          container.appendChild(itemDiv);
        });
      }

      function removeFromNotInterested(index) {
        if (appData.notInterested && appData.notInterested[index]) {
          const item = appData.notInterested[index];
          appData.notInterested.splice(index, 1);
          saveAppData?.();
          
          showNotification?.(`"${item.title}" removed from not interested list`, 'success');
          
          // Refresh the list
          populateNotInterestedList();
          
          // Update discover list if it's currently visible
          if (typeof renderDiscover === 'function') {
            renderDiscover();
          }
        }
      }

      function closeNotInterestedModal() {
        const modal = document.getElementById('notInterestedModal');
        if (modal) {
          modal.remove();
        }
      }

      function populateShareModal() {
        console.log('📋 Populating share modal with items');
        
        // Get all items from all lists
        const watchingItems = [...(appData.tv.watching || []), ...(appData.movies.watching || [])];
        const wishlistItems = [...(appData.tv.wishlist || []), ...(appData.movies.wishlist || [])];
        const watchedItems = [...(appData.tv.watched || []), ...(appData.movies.watched || [])];
        
        console.log(`📊 Found ${watchingItems.length} watching, ${wishlistItems.length} wishlist, ${watchedItems.length} watched items`);
        
        // Populate each list section
        populateShareList('shareWatchingList', watchingItems, 'watching');
        populateShareList('shareWishlistList', wishlistItems, 'wishlist');
        populateShareList('shareWatchedList', watchedItems, 'watched');
        
        // Set up select all functionality
        setupSelectAllControls();
        
        // Update generate button state
        updateGenerateButtonState();
      }

      function populateShareList(containerId, items, listType) {
        const container = document.getElementById(containerId);
        if (!container) {
          console.error(`❌ Container not found: ${containerId}`);
          return;
        }
        
        container.innerHTML = '';
        
        if (items.length === 0) {
          container.innerHTML = `<div style="text-align: center; padding: 20px; color: var(--text-secondary); font-style: italic;">
            ${t("no_items_in_list") || "No items in this list"}
          </div>`;
          return;
        }
        
        items.forEach((item, index) => {
          const itemDiv = document.createElement('div');
          itemDiv.className = 'share-item';
          itemDiv.innerHTML = `
            <input type="checkbox" id="share_${listType}_${index}" data-list="${listType}" data-index="${index}" onchange="updateGenerateButtonState()">
            <div class="share-item-info">
              <div class="share-item-title">${item.title || item.name || 'Unknown Title'}</div>
              <div class="share-item-meta">
                ${item.media_type === 'tv' ? '📺 TV Series' : '🎬 Movie'} • 
                ${item.first_air_date ? new Date(item.first_air_date).getFullYear() : 'Unknown Year'}
                ${item.vote_average ? ` • ⭐ ${item.vote_average}/10` : ''}
              </div>
            </div>
          `;
          container.appendChild(itemDiv);
        });
      }

      function setupSelectAllControls() {
        // Select all for watching
        const selectAllWatching = document.getElementById('selectAllWatching');
        if (selectAllWatching) {
          selectAllWatching.onchange = function() {
            const checkboxes = document.querySelectorAll('#shareWatchingList input[type="checkbox"]');
            checkboxes.forEach(cb => cb.checked = this.checked);
            updateGenerateButtonState();
          };
        }
        
        // Select all for wishlist
        const selectAllWishlist = document.getElementById('selectAllWishlist');
        if (selectAllWishlist) {
          selectAllWishlist.onchange = function() {
            const checkboxes = document.querySelectorAll('#shareWishlistList input[type="checkbox"]');
            checkboxes.forEach(cb => cb.checked = this.checked);
            updateGenerateButtonState();
          };
        }
        
        // Select all for watched
        const selectAllWatched = document.getElementById('selectAllWatched');
        if (selectAllWatched) {
          selectAllWatched.onchange = function() {
            const checkboxes = document.querySelectorAll('#shareWatchedList input[type="checkbox"]');
            checkboxes.forEach(cb => cb.checked = this.checked);
            updateGenerateButtonState();
          };
        }
        
        // Select all everything
        const selectAllEverything = document.getElementById('selectAllEverything');
        if (selectAllEverything) {
          selectAllEverything.onchange = function() {
            const allCheckboxes = document.querySelectorAll('.share-items-list input[type="checkbox"]');
            allCheckboxes.forEach(cb => cb.checked = this.checked);
            
            // Also check the individual select all checkboxes
            if (this.checked) {
              selectAllWatching.checked = true;
              selectAllWishlist.checked = true;
              selectAllWatched.checked = true;
            } else {
              selectAllWatching.checked = false;
              selectAllWishlist.checked = false;
              selectAllWatched.checked = false;
            }
            
            updateGenerateButtonState();
          };
        }
      }

      function updateGenerateButtonState() {
        const generateBtn = document.getElementById('generateShareLinkBtn');
        if (!generateBtn) return;
        
        const checkedBoxes = document.querySelectorAll('.share-items-list input[type="checkbox"]:checked');
        const hasCheckedItems = checkedBoxes.length > 0;
        
        generateBtn.disabled = !hasCheckedItems;
        
        // Show "Copy" button when items are selected
        const copyBtn = document.getElementById("copyShareBtn");
        if (copyBtn) {
          if (hasCheckedItems) {
            copyBtn.style.display = "inline-block";
          } else {
            copyBtn.style.display = "none";
          }
        }
      }

      function generateShareLinkFromSelected() {
        const checkedBoxes = document.querySelectorAll('.share-items-list input[type="checkbox"]:checked');
        
        if (checkedBoxes.length === 0) {
          showNotification(t("no_items_selected") || "No items selected", "warning");
          return;
        }
        
        // Group selected items by list type
        const selectedItems = {
          watching: [],
          wishlist: [],
          watched: []
        };
        
        checkedBoxes.forEach(checkbox => {
          const listType = checkbox.getAttribute('data-list');
          const index = parseInt(checkbox.getAttribute('data-index'));
          
          if (listType && !isNaN(index)) {
            const listKey = listType === 'watching' ? 'watching' : listType === 'wishlist' ? 'wishlist' : 'watched';
            const items = [...(appData.tv[listKey] || []), ...(appData.movies[listKey] || [])];
            
            if (items[index]) {
              const item = items[index];
              // Only include essential fields for sharing - this will make URLs much shorter!
              const minimalItem = {
                id: item.id,
                title: item.title || item.name,
                type: item.type || 'tv',
                media_type: item.media_type || 'tv',
                poster_path: item.poster_path,
                overview: item.overview,
                first_air_date: item.first_air_date,
                vote_average: item.vote_average
              };
              selectedItems[listKey].push(minimalItem);
            }
          }
        });
        
        console.log('📋 Selected items (minimal data):', selectedItems);
        
        // Create a human-readable text list instead of a complex URL
        let shareText = "📺 My TV & Movie Lists\n\n";
        
        // Add items by list with clear headers
        if (selectedItems.watching.length > 0) {
          shareText += "🔴 Currently Watching:\n";
          selectedItems.watching.forEach(item => {
            const network = item.networks?.[0] || "Unknown Service";
            shareText += `  • ${item.title} (${network})\n`;
          });
          shareText += "\n";
        }
        
        if (selectedItems.wishlist.length > 0) {
          shareText += "🟡 Want to Watch:\n";
          selectedItems.wishlist.forEach(item => {
            const network = item.networks?.[0] || "Unknown Service";
            shareText += `  • ${item.title} (${network})\n`;
          });
          shareText += "\n";
        }
        
        if (selectedItems.watched.length > 0) {
          shareText += "🟢 Already Watched:\n";
          selectedItems.watched.forEach(item => {
            const network = item.networks?.[0] || "Unknown Service";
            shareText += `  • ${item.title} (${network})\n`;
          });
          shareText += "\n";
        }
        
        // Update the share output to show the text list
        const shareLinkOut = document.getElementById("shareLinkOut");
        if (shareLinkOut) {
          shareLinkOut.value = shareText;
          shareLinkOut.style.height = "auto";
          shareLinkOut.style.minHeight = "200px";
          shareLinkOut.style.fontFamily = "monospace";
          shareLinkOut.style.whiteSpace = "pre-wrap";
          shareLinkOut.style.resize = "vertical";
          shareLinkOut.style.overflowY = "auto";
        }
        
        // Hide "Select what to share" button, show "Copy" button
        const generateBtn = document.getElementById("generateShareLinkBtn");
        const copyBtn = document.getElementById("copyShareBtn");
        
        if (generateBtn && copyBtn) {
          generateBtn.style.display = "none";
          copyBtn.style.display = "inline-block";
        }
        
        console.log('✅ Share text generated:', shareText);
      }



      function copyShareList() {
        console.log('🔍 Copy button clicked!');
        
        // Generate the list first
        const checkedBoxes = document.querySelectorAll('.share-items-list input[type="checkbox"]:checked');
        
        if (checkedBoxes.length === 0) {
          showNotification("No items selected", "warning");
          return;
        }
        
        console.log('📝 Generating list for', checkedBoxes.length, 'items...');
        
        // Group selected items by list type
        const selectedItems = {
          watching: [],
          wishlist: [],
          watched: []
        };
        
        checkedBoxes.forEach(checkbox => {
          const listType = checkbox.getAttribute('data-list');
          const index = parseInt(checkbox.getAttribute('data-index'));
          
          if (listType && !isNaN(index)) {
            const listKey = listType === 'watching' ? 'watching' : listType === 'wishlist' ? 'wishlist' : 'watched';
            const items = [...(appData.tv[listKey] || []), ...(appData.movies[listKey] || [])];
            
            if (items[index]) {
              const item = items[index];
              // Only include essential fields for sharing
              const minimalItem = {
                id: item.id,
                title: item.title || item.name,
                type: item.type || 'tv',
                media_type: item.media_type || 'tv',
                poster_path: item.poster_path,
                overview: item.overview,
                first_air_date: item.first_air_date,
                vote_average: item.vote_average
              };
              selectedItems[listKey].push(minimalItem);
            }
          }
        });
        
        console.log('📋 Selected items:', selectedItems);
        
        // Create the shareable text
        let shareText = "📺 My TV & Movie Lists\n\n";
        
        if (selectedItems.watching.length > 0) {
          shareText += "🔴 Currently Watching:\n";
          selectedItems.watching.forEach(item => {
            const network = item.networks?.[0] || "Unknown Service";
            shareText += `  • ${item.title} (${network})\n`;
          });
          shareText += "\n";
        }
        
        if (selectedItems.wishlist.length > 0) {
          shareText += "🟡 Want to Watch:\n";
          selectedItems.wishlist.forEach(item => {
            const network = item.networks?.[0] || "Unknown Service";
            shareText += `  • ${item.title} (${network})\n`;
          });
          shareText += "\n";
        }
        
        if (selectedItems.watched.length > 0) {
          shareText += "🟢 Already Watched:\n";
          selectedItems.watched.forEach(item => {
            const network = item.networks?.[0] || "Unknown Service";
            shareText += `  • ${item.title} (${network})\n`;
          });
          shareText += "\n";
        }
        
        console.log('📋 Share text generated:', shareText);
        
        // Copy the text to clipboard
        navigator.clipboard.writeText(shareText).then(() => {
          console.log('📋 Text copied to clipboard');
          
          // Show copy confirmation
          showNotification('List copied', 'success');
          
          // Close the modal and return to settings page
          closeShareSelectionModal();
          
          // Show instruction notification after returning to settings
          setTimeout(() => {
            showNotification('📤 Paste this in a text message or email to share', 'info');
          }, 500);
        }).catch(err => {
          console.error('❌ Failed to copy:', err);
          showNotification('Failed to copy list', 'error');
        });
      }

      function saveDisplayName() {
        const displayNameInput = document.getElementById("displayNameInput");
        const newName = displayNameInput.value.trim();
        
        if (!newName) {
          showNotification("Please enter a name", "warning");
          return;
        }
        
        // Check if user is logged in
        if (!currentUser) {
          showNotification("Please sign in to save your name", "warning");
          return;
        }
        
        // Check if username already exists for this login
        const existingName = appData?.settings?.displayName;
        if (existingName && existingName !== newName) {
          // Show custom confirmation modal instead of browser confirm()
          showUsernameOverwriteModal(existingName, newName);
          return;
        }
        
        // If no existing name or same name, save directly
        saveUsernameDirectly(newName);
        

      }
      
      function showUsernameOverwriteModal(existingName, newName) {
        // Create custom modal HTML
        const modalHTML = `
          <div class="modal-backdrop" style="display: flex; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000; align-items: center; justify-content: center;">
            <div class="modal" style="background: var(--card); border-radius: 12px; padding: 24px; max-width: 400px; width: 90%; box-shadow: 0 10px 25px rgba(0,0,0,0.3);">
              <h3 style="margin: 0 0 16px 0; color: var(--text);">⚠️ Username Already Exists</h3>
              <p style="margin: 0 0 20px 0; color: var(--text); line-height: 1.5;">
                A username <strong>"${existingName}"</strong> already exists for this account.<br><br>
                Do you want to overwrite it with <strong>"${newName}"</strong>?
              </p>
              <div style="display: flex; gap: 12px; justify-content: flex-end;">
                <button class="btn secondary" onclick="closeUsernameOverwriteModal()" style="min-width: 80px;">
                  Cancel
                </button>
                <button class="btn primary" onclick="confirmUsernameOverwrite('${newName}')" style="min-width: 80px;">
                  Overwrite
                </button>
              </div>
            </div>
          </div>
        `;
        
        // Add modal to page
        document.body.insertAdjacentHTML('beforeend', modalHTML);
      }
      
      function closeUsernameOverwriteModal() {
        // Remove all modal-backdrop elements to be safe
        document.querySelectorAll('.modal-backdrop').forEach(modal => {
          if (modal.querySelector('.modal h3')?.textContent.includes('Username Already Exists')) {
            modal.remove();
          }
        });
      }
      
      function confirmUsernameOverwrite(newName) {
        // Close the modal
        closeUsernameOverwriteModal();
        
        // Save the username
        saveUsernameDirectly(newName);
      }
      
      function saveUsernameDirectly(newName) {
        // Save the new username
        if (!appData.settings) appData.settings = {};
        appData.settings.displayName = newName;
        
        // Also update FlickletApp's appData to keep them in sync
        if (window.FlickletApp && window.FlickletApp.appData) {
          if (!window.FlickletApp.appData.settings) {
            window.FlickletApp.appData.settings = {};
          }
          window.FlickletApp.appData.settings.displayName = newName;
          console.log('✅ Synced username to FlickletApp appData:', newName);
        }
        
        // Save to localStorage
        localStorage.setItem('flicklet-data', JSON.stringify(appData));
        
        // Save to Firebase if user is logged in
        if (currentUser && saveAppData) {
          saveAppData();
        }
        
        showNotification(`Name saved as "${newName}"`, "success");
        
        // Update the left-side container to show the new username
        // Use a small delay to ensure data is fully synced
        setTimeout(() => {
          if (window.FlickletApp && typeof window.FlickletApp.updateLeftSideUsername === 'function') {
            console.log('🔄 Updating left-side container after username save (delayed)');
            window.FlickletApp.updateLeftSideUsername();
          }
        }, 50);
      }
      
      function closeUsernamePromptModal() {
        const modal = document.getElementById('usernamePromptModal');
        if (modal) {
          modal.remove();
        }
      }
      
      function saveUsernameFromPrompt() {
        const input = document.getElementById('newUsernameInput');
        const newName = input?.value?.trim();
        
        if (!newName) {
          showNotification("Please enter a name", "warning");
          return;
        }
        
        // Close the modal first
        closeUsernamePromptModal();
        
        // Update the FlickletApp's appData first
        if (window.FlickletApp && window.FlickletApp.appData) {
          if (!window.FlickletApp.appData.settings) {
            window.FlickletApp.appData.settings = {};
          }
          window.FlickletApp.appData.settings.displayName = newName;
          console.log('✅ Updated FlickletApp appData with username:', newName);
        }
        
        // Save the username using existing function
        saveUsernameDirectly(newName);
        
        // Note: saveUsernameDirectly() already calls updateHeaderWithUsername()
        // No need to call it again here
      }
      


      function closeShareSelectionModal() {
        const modal = document.getElementById('shareSelectionModal');
        if (modal) {
          modal.style.display = 'none';
        }
      }

      // Legacy function for backward compatibility
      function generateShareLinkForCurrentTab() {
        console.log('⚠️ Using legacy share function - redirecting to new modal');
        openShareSelectionModal();
      }

      function tryImportFromShareLink() {
        const hash = location.hash || "";
        const m = hash.match(/#share=([A-Za-z0-9_\-]+)/);
        if (!m) return;
        try {
          const decoded = JSON.parse(fromB64Url(m[1]));
          if (decoded && decoded.v === 1) {
            if (decoded.selected && decoded.items) {
              // New format: selected items from multiple lists
              console.log('📥 Importing selected items from share link');
              
              // Import minimal data items - they'll be enhanced when needed
              Object.keys(decoded.items).forEach(listKey => {
                if (Array.isArray(decoded.items[listKey])) {
                  // Add items to the appropriate list
                  decoded.items[listKey].forEach(item => {
                    if (item.media_type === 'tv') {
                      if (!appData.tv[listKey]) appData.tv[listKey] = [];
                      appData.tv[listKey].push(item);
                    } else if (item.media_type === 'movie') {
                      if (!appData.movies[listKey]) appData.movies[listKey] = [];
                      appData.movies[listKey].push(item);
                    }
                  });
                }
              });
            } else if (decoded.list) {
              // Legacy format: single list
              console.log('📥 Importing legacy format share link');
              if (Array.isArray(decoded.tv))
                appData.tv[decoded.list] = decoded.tv;
              if (Array.isArray(decoded.movies))
                appData.movies[decoded.list] = decoded.movies;
            }
            
            saveAppData?.();
            updateUI?.();
            showNotification(t("imported_from_link"), "success");
          }
        } catch (e) {
          console.warn("share import failed", e);
        }
      }

      /* ============== UI helpers ============== */
      function getSeriesPill(item) {
        if (!item || (item.media_type !== "tv" && !item.first_air_date))
          return "";
        const status = (item.status || "").toLowerCase();
        const nextAir = item.next_episode_to_air?.air_date || null;
        const lastAir =
          item.last_episode_to_air?.air_date || item.last_air_date || null;
        const firstAir = item.first_air_date || null;

        const today = new Date();
        today.setHours(0, 0, 0, 0);
        const firstAirFuture = firstAir ? new Date(firstAir) > today : false;

        let mode;
        if (["ended", "canceled", "cancelled"].includes(status)) mode = "ended";
        else if (
          ["planned", "pilot"].includes(status) ||
          firstAirFuture ||
          (status === "in production" && !lastAir)
        )
          mode = "upcoming";
        else mode = "ongoing";

        let label = "",
          cls = "";
        if (mode === "ended") {
          cls = "status-ended";
          label = `${t("series_complete")}${
            lastAir ? ` • ${formatDateShort(lastAir)}` : ""
          }`;
        } else if (mode === "upcoming") {
          cls = "status-upcoming";
          const when = firstAir || nextAir;
          label = `${t("coming_soon")}${
            when ? ` • ${formatDateShort(when)}` : ""
          }`;
        } else {
          cls = "status-ongoing";
          const when = nextAir
            ? `${t("next")}: ${formatDateShort(nextAir)}`
            : lastAir
            ? `${t("last")}: ${formatDateShort(lastAir)}`
            : null;
          label = [t("currently_airing"), when].filter(Boolean).join(" • ");
        }

        const title = [
          item.status || null,
          nextAir ? `${t("next")}: ${formatDateShort(nextAir)}` : null,
          lastAir ? `${t("last")}: ${formatDateShort(lastAir)}` : null,
        ]
          .filter(Boolean)
          .join(" • ");

        return `<span class="series-pill ${cls}" title="${title}">${label}</span>`;
      }

      async function ensureTvDetails(item, card) {
        if (item.media_type !== "tv" && !item.first_air_date) return;
        const needs = !(
          item.status &&
          (item.next_episode_to_air || item.last_air_date) &&
          item.networks
        );
        if (!needs) return;
        try {
          const d = await tmdbGet(`tv/${item.id}`, "", true);
          Object.assign(item, {
            status: d.status,
            number_of_seasons: d.number_of_seasons,
            number_of_episodes: d.number_of_episodes,
            last_air_date: d.last_air_date,
            first_air_date: d.first_air_date,
            next_episode_to_air: d.next_episode_to_air,
            last_episode_to_air: d.last_episode_to_air,
            in_production: d.in_production,
            genres: d.genres,
            networks: d.networks || [],
            episode_run_time: d.episode_run_time || [45],
            runtime:
              item.runtime ?? (d.episode_run_time ? d.episode_run_time[0] : 45),
          });
          const meta = card.querySelector(".show-meta");
          const pillWrap = card.querySelector(".rating-container");
          if (meta) {
            const networkNames = (item.networks || [])
              .map((n) => n.name)
              .join(", ");
            const date = item.first_air_date || item.release_date || "";
            const rating = item.vote_average
              ? Number(item.vote_average).toFixed(1)
              : "N/A";
            const mediaType = item.media_type || "tv";
            meta.textContent = [
              `⭐ ${rating}`,
              date ? ` • ${date.split("-")[0]}` : "",
              ` • ${mediaType.toUpperCase()}`,
              networkNames ? ` • ${t("streaming_on")}: ${networkNames}` : ""
            ].join("");
          }
          if (pillWrap) {
            const old = pillWrap.querySelector(".series-pill");
            if (old) old.remove();
            pillWrap.insertAdjacentHTML("beforeend", getSeriesPill(item));
          }
        } catch (_) {}
      }

      function createShowCard(item, isSearch = false, listTab = null) {
        // Use the passed listTab if available, otherwise fall back to currentActiveTab
        const activeTab = listTab || currentActiveTab;


        const card = document.createElement("div");
        card.className = "show-card";
        const title = item.name || item.title || t("unknown_title");
        const date = item.first_air_date || item.release_date || "";
        const rating = item.vote_average ? Number(item.vote_average).toFixed(1) : "N/A";
        const mediaType = item.media_type || (item.first_air_date ? "tv" : "movie");

        card.setAttribute("data-id", String(item.id));
        card.setAttribute("data-media-type", mediaType);

        const posterHtml = item.poster_path
          ? `<button class="poster-button" data-action="open" data-id="${item.id}" data-media-type="${mediaType}" aria-label="Open on TMDB"><img class="show-poster" src="${TMDB_IMG_BASE}${item.poster_path}" alt="${escapeHtml(title)}"></button>`
          : `<button class="poster-button" data-action="open" data-id="${item.id}" data-media-type="${mediaType}" aria-label="Open on TMDB"><div class="poster-placeholder">${t("no_image")}</div></button>`;

        const runtimeMinutes =
          Number(item.runtime) ||
          (mediaType === "tv"
            ? (Array.isArray(item.episode_run_time) && Number(item.episode_run_time[0])) || 45
            : 120);
        card.setAttribute("data-runtime-minutes", String(runtimeMinutes));

        const networkNames = (item.networks || []).map((n) => n.name).join(", ");

        let actions = "";
        if (isSearch) {
          actions = `
        <div class="show-actions">
          <button class="btn" data-action='addFromCache' data-id='${Number(item.id)}' data-list='watching'>▶️ ${t("currently_watching")}</button>
          <button class="btn" data-action='addFromCache' data-id='${Number(item.id)}' data-list='wishlist'>📖 ${t("want_to_watch")}</button>
          <button class="btn" data-action='addFromCache' data-id='${Number(item.id)}' data-list='watched'>✅ ${t("already_watched")}</button>
          <button class="btn danger" data-action='notInterested' data-id='${Number(item.id)}' data-media-type='${mediaType}'>🚫 Not Interested</button>
        </div>`;
        } else {
          const likeStatus = item.likeStatus || "none";
          const userRating = item.userRating || 0;

          const stars = [1,2,3,4,5].map((n) =>
            `<button type="button" class="star-btn ${n <= userRating ? "active" : ""}"
                    aria-label="${t("rate_out_of_5").replace("{n}", n)}"
                    aria-pressed="${n <= userRating}"
                    data-action="rate" data-id="${item.id}" data-rating="${n}">${n <= userRating ? "★" : "☆"}</button>`
          ).join("");
          actions = `
            <div class="rating-container">
              <span>${t("your_rating")}:</span>
              <div class="star-rating">${stars}</div>
              <div class="like-dislike">
                <button class="like-btn ${likeStatus === "like" ? "active" : ""}" data-action="like" data-id="${item.id}" aria-pressed="${likeStatus === "like"}" aria-label="${t("like")}">👍</button>
                <button class="dislike-btn ${likeStatus === "dislike" ? "active" : ""}" data-action="dislike" data-id="${item.id}" aria-pressed="${likeStatus === "dislike"}" aria-label="${t("dislike")}">👎</button>
              </div>
              ${mediaType === "tv" ? getSeriesPill(item) : ""}
            </div>

            <div class="show-actions" style="margin-top:6px; display:flex; gap:8px; flex-wrap:wrap">
                      ${activeTab !== "watching" ? `<button class="btn secondary" data-action="move" data-id="${item.id}" data-list="watching">→ ${t("currently_watching")}</button>` : ''}
        ${activeTab !== "wishlist" ? `<button class="btn secondary" data-action="move" data-id="${item.id}" data-list="wishlist">→ ${t("want_to_watch")}</button>` : ''}
        ${activeTab !== "watched" ? `<button class="btn secondary" data-action="move" data-id="${item.id}" data-list="watched">→ ${t("already_watched")}</button>` : ''}
              <button class="btn" data-action="notes" data-id="${item.id}">✎ ${t("notes_tags")}</button>
              <button class="btn danger" data-action="remove" data-id="${item.id}">🗑️ ${t("remove")}</button>
            </div>`;
        }

        card.innerHTML = `
          ${posterHtml}
          <div class="show-details">
            <h4 class="show-title">
              <button class="btn-link" data-action="open" data-id="${item.id}" data-media-type="${mediaType}" aria-label="Open ${escapeHtml(title)} on TMDB">
                ${escapeHtml(title)} <span aria-hidden="true" style="opacity:.6">🔗</span>
              </button>
            </h4>
            <div class="show-meta"></div>
            <div class="show-overview">${escapeHtml(item.overview || t("no_description"))}</div>
            ${actions}
          </div>`;

        const meta = card.querySelector(".show-meta");
        if (meta) {
          meta.textContent = [
            `⭐ ${rating}`,
            date ? ` • ${date.split("-")[0]}` : "",
            ` • ${mediaType.toUpperCase()}`,
            networkNames ? ` • ${t("streaming_on")}: ${networkNames}` : ""
          ].join("");
        }

        // Add direct click handlers to star rating buttons
        const starButtons = card.querySelectorAll(".star-btn");
        starButtons.forEach(starBtn => {
          starBtn.addEventListener("click", (e) => {
            e.preventDefault();
            e.stopPropagation();
            const rating = Number(starBtn.getAttribute("data-rating"));
            const id = Number(starBtn.getAttribute("data-id"));
            setRating(id, rating);
            
            // Update the visual state of all stars in this card
            const allStars = card.querySelectorAll(".star-btn");
            allStars.forEach((star, index) => {
              const starRating = index + 1;
              if (starRating <= rating) {
                star.classList.add("active");
                star.setAttribute("aria-pressed", "true");
              } else {
                star.classList.remove("active");
                star.setAttribute("aria-pressed", "false");
              }
            });
          });
        });

        ensureTvDetails(item, card);
        return card;
      }

      function openTMDBLink(id, type) {
        window.open(`https://www.themoviedb.org/${type}/${id}`, "_blank");
      }

      /* Lists & ops */
      function getAllItems() {
        return ["tv", "movies"].flatMap((cat) =>
          ["watching", "wishlist", "watched"].flatMap(
            (lst) => appData[cat][lst] || []
          )
        );
      }
      function addToList(item, list) {
        // --- normalize incoming search item ---
        const norm = { ...item };
        if (norm.id != null) norm.id = Number(norm.id);
        if (!norm.media_type) {
          norm.media_type = norm.first_air_date ? "tv" : "movie";
        }

        const cat =
          norm.media_type === "tv" || norm.first_air_date ? "tv" : "movies";

        // Already in target?
        const inTarget = (appData[cat][list] || []).some(
          (s) => Number(s.id) === Number(norm.id)
        );
        if (inTarget) {
          showNotification(
            t("already_in_list_warning").replace("{list}", list.replace("wishlist", t("want_to_watch"))),
            "warning"
          );
          return;
        }
        // Remove from everywhere else (both cats; all lists)
        let foundElsewhere = false;
        ["tv", "movies"].forEach((c) => {
          ["watching", "wishlist", "watched"].forEach((lst) => {
            const before = appData[c][lst].length;
            appData[c][lst] = appData[c][lst].filter(
              (s) => Number(s.id) !== Number(norm.id)
            );
            if (appData[c][lst].length !== before) foundElsewhere = true;
          });
        });

        // Add to target
        appData[cat][list].unshift(norm);
        saveAppData();
        updateUI();

        // Generate snarky feedback message for adding from search
        const title = norm.name || norm.title || "This show";
        let message = "";
        
        if (list === "watching") {
          message = `"${title}" is now in the spotlight! ✨`;
        } else if (list === "wishlist") {
          message = `"${title}" added to the queue! 📋`;
        } else if (list === "watched") {
          message = `"${title}" marked as watched! ✅`;
        }
        
        if (message) {
          showNotification(message, "success");
        }
      }

      function moveItem(id, dest) {
        console.log(`🔄 moveItem called: id=${id}, dest=${dest}`);
        
        const item = findItem(id);
        if (!item) {
          console.log(`❌ Item not found: id=${id}`);
          return;
        }
        
        // Find where the item currently is
        let currentList = null;
        ["tv", "movies"].forEach((cat) =>
          ["watching", "wishlist", "watched"].forEach((lst) => {
            if (appData[cat][lst].some((s) => s.id === id)) {
              currentList = lst;
            }
            appData[cat][lst] = appData[cat][lst].filter((s) => s.id !== id);
          })
        );
        
        const cat = item.media_type === "tv" ? "tv" : "movies";
        appData[cat][dest].unshift(item);
        saveAppData?.();
        updateUI?.();
        
        // Generate snarky feedback message
        const title = item.name || item.title || "This show";
        let message = "";
        
        if (dest === "watching") {
          if (currentList === "wishlist") {
            message = `"${title}" must be in the front of the line! 🚀`;
          } else if (currentList === "watched") {
            message = `"${title}" is back from the dead! 🧟‍♂️`;
          } else {
            message = `"${title}" is now in the spotlight! ✨`;
          }
        } else if (dest === "wishlist") {
          if (currentList === "watching") {
            message = `Successfully put "${title}" in the backseat! 🚗`;
          } else if (currentList === "watched") {
            message = `"${title}" is back on the wishlist! 📝`;
          } else {
            message = `"${title}" added to the queue! 📋`;
          }
        } else if (dest === "watched") {
          if (currentList === "watching") {
            message = `Well, at least we can say we accomplished something! 👏`;
          } else if (currentList === "wishlist") {
            message = `"${title}" jumped straight to completion! 🎯`;
          } else {
            message = `"${title}" marked as watched! ✅`;
          }
        }
        
        if (message) {
          showNotification(message, "success");
        }
      }
      function setRating(id, rating) {
        const it = findItem(id);
        if (!it) {
          return;
        }
        it.userRating = rating;
        saveAppData?.();
        updateUI?.();
      }
      function setLikeStatus(id, status) {
        const it = findItem(id);
        if (!it) return;
        it.likeStatus = status;
        saveAppData?.();
        updateUI?.();
      }
      
      function markAsNotInterested(id, mediaType) {
        console.log('🚫 Marking item as not interested:', id, mediaType);
        console.log('🚫 appData:', appData);
        console.log('🚫 searchItemCache size:', searchItemCache.size);
        
        // Add to not interested list in appData
        if (!appData.notInterested) {
          appData.notInterested = [];
          console.log('🚫 Initialized notInterested array');
        }
        
        // Check if already in not interested list
        const existingIndex = appData.notInterested.findIndex(item => 
          item.id === id && item.mediaType === mediaType
        );
        
        console.log('🚫 Existing index:', existingIndex);
        
        if (existingIndex === -1) {
          // Get item details from cache or create basic info
          const cachedItem = searchItemCache.get(Number(id));
          console.log('🚫 Cached item:', cachedItem);
          
          const itemInfo = {
            id: id,
            mediaType: mediaType,
            title: cachedItem?.name || cachedItem?.title || 'Unknown',
            dateAdded: new Date().toISOString()
          };
          
          console.log('🚫 Item info to add:', itemInfo);
          
          appData.notInterested.push(itemInfo);
          console.log('✅ Added to not interested list:', itemInfo);
          console.log('🚫 Updated appData.notInterested:', appData.notInterested);
          
          // Save the updated data
          if (typeof saveAppData === 'function') {
            console.log('🚫 Calling saveAppData');
            saveAppData();
          } else {
            console.log('⚠️ saveAppData function not found');
          }
          
          // Show confirmation
          if (typeof showNotification === 'function') {
            showNotification(`"${itemInfo.title}" marked as not interested`, 'info');
          } else {
            console.log('⚠️ showNotification function not found');
          }
          
          // Remove the card from the discover list
          const card = document.querySelector(`[data-id="${id}"][data-media-type="${mediaType}"]`);
          console.log('🚫 Found card:', card);
          if (card) {
            card.style.opacity = '0.5';
            card.style.pointerEvents = 'none';
            setTimeout(() => {
              card.remove();
            }, 500);
          }
          
          // No need to refresh the entire discover list - just let the card fade out
          // The item will be filtered out on the next natural refresh
        } else {
          console.log('⚠️ Item already marked as not interested');
          if (typeof showNotification === 'function') {
            showNotification('Already marked as not interested', 'info');
          }
        }
      }
      function removeItemFromCurrentList(id) {
        const item = findItem(id);
        if (!item) return;
        if (!confirm(t("remove_confirmation").replace("{title}", item.title || item.name)))
          return;
        ["tv", "movies"].forEach((cat) =>
          ["watching", "wishlist", "watched"].forEach((lst) => {
            appData[cat][lst] = appData[cat][lst].filter((s) => s.id !== id);
          })
        );
        saveAppData?.();
        updateUI?.();
      }
      function findItem(id) {
        for (const cat of ["tv", "movies"]) {
          for (const lst of ["watching", "wishlist", "watched"]) {
            const f = appData[cat][lst].find((s) => s.id === id);
            if (f) return f;
          }
        }
        return null;
      }

      /* Binge calc / banners / meter */
      function calculateBingeTime({ scope = "all" } = {}) {
        const cards =
          scope === "watching"
            ? [
                ...document.querySelectorAll(
                  "#watchingList .show-card[data-runtime-minutes]"
                ),
              ]
            : [
                ...document.querySelectorAll(
                  ".show-card[data-runtime-minutes]"
                ),
              ];
        const total = cards.reduce(
          (m, c) => m + (parseInt(c.getAttribute("data-runtime-minutes")) || 0),
          0
        );
        const h = Math.floor(total / 60),
          m = total % 60,
          d = Math.floor(h / 24),
          rh = h % 24;
        let str = "";
        if (d) str += `${d}d `;
        if (rh) str += `${rh}h `;
        str += `${m}m`;
        return { totalMinutes: total, timeStr: str, showCount: cards.length };
      }
      function updateBingeMeter() {
        const stats = calculateBingeTime({ scope: "all" });
        const el = document.getElementById("bingeMeter");
        el.innerHTML = `<div class="stat-num">${
          stats.timeStr
        }</div><div class="stat-label">${t("binge_total")}</div>`;
      }
      function updateBingeBanner() {
        const stats = calculateBingeTime({ scope: "watching" });
        const banner = document.getElementById("bingeBanner");
        const msgs =
          appData.settings.lang === "es"
            ? [
                "de decisiones cuestionables en cola. 🎭",
                "de procrastinación medida con precisión. 🤡",
                "de vergüenza en streaming calculada. 📺",
                "de maratón sin arrepentimientos (mentira). 🍿",
              ]
            : [
                "of questionable life choices queued! 🎭",
                "of procrastination precisely measured. 🤡",
                "of streaming shame calculated. 📺",
                "of binge you definitely won't regret. 🍿",
              ];
        const msg = msgs[Math.floor(Math.random() * msgs.length)];
        banner.innerHTML = `
          <span class="binge-time" id="bingeTimeText">${
            stats.timeStr
          }</span>
          <span class="binge-label">${msg}</span>
          <button class="binge-cta" id="startBingeBtn" type="button" aria-label="${t(
            "start"
          )}">${t("start")} ▶</button>`;
        document
          .getElementById("startBingeBtn")
          ?.addEventListener("click", () => {
            switchToTab("watching");
            setTimeout(
              () =>
                document
                  .getElementById("watchingList")
                  ?.scrollIntoView({ behavior: "smooth", block: "start" }),
              120
            );
          });
      }

      /* Stats v2 */
      function rebuildStats() {
        const totals = {
          watching:
            (appData.tv.watching?.length || 0) +
            (appData.movies.watching?.length || 0),
          wishlist:
            (appData.tv.wishlist?.length || 0) +
            (appData.movies.wishlist?.length || 0),
          watched:
            (appData.tv.watched?.length || 0) +
            (appData.movies.watched?.length || 0),
        };
        const total = totals.watching + totals.wishlist + totals.watched;
        document.getElementById("statsBasicBody").innerHTML = `
          <ul>
            <li>${t("total_items")}: <strong>${total}</strong></li>
            <li>${t("watching_count")}: <strong>${
              totals.watching
            }</strong> • ${t("wishlist_count")}: <strong>${
          totals.wishlist
        }</strong> • ${t("watched_count")}: <strong>${totals.watched}</strong></li>
            <li>${t("binge_total")}: <strong>${
          calculateBingeTime().timeStr
        }</strong></li>
          </ul>`;

        const proWrap = document.getElementById("statsPro");
        proWrap.style.display = appData.settings.pro ? "block" : "none";
        if (appData.settings.pro) {
          const byGenre = {};
          getAllItems().forEach((it) =>
            (it.genres || []).forEach(
              (g) => (byGenre[g.name] = (byGenre[g.name] || 0) + 1)
            )
          );
          const topGenres = Object.entries(byGenre)
            .sort((a, b) => b[1] - a[1])
            .slice(0, 5);
          const r = getAllItems()
            .map((x) => Number(x.userRating) || 0)
            .filter(Boolean);
          const avgRating = r.length
            ? (r.reduce((m, v) => m + v, 0) / r.length).toFixed(2)
            : "N/A";
          document.getElementById(
            "statsProBody"
          ).innerHTML = `<div><strong>${t("top_genres")}:</strong> ${
            topGenres.map(([g, c]) => `${g} (${c})`).join(", ") || "N/A"
          }</div>
                           <div><strong>${t("average_rating")}:</strong> ${avgRating}</div>`;
        }
      }

      /* Tabs + list rendering + search */
      function switchToTab(tab) {
        // Set the current active tab
        currentActiveTab = tab;

        // Hide/clear search so tab change is obvious
        try {
          const results = document.getElementById("searchResults");
          if (results) {
            results.style.display = "none";
            results.innerHTML = "";
          }
          const qEl = document.getElementById("searchInput");
          if (qEl) qEl.value = "";
        } catch {}

        document
          .querySelectorAll(".tab")
          .forEach((t) => t.classList.remove("active"));
        document.getElementById(tab + "Tab").classList.add("active");
        document
          .querySelectorAll(".tab-section")
          .forEach((s) => (s.style.display = "none"));
        document.getElementById(tab + "Section").style.display = "block";

        if (tab === "discover") renderDiscover();
        if (tab === "settings") {
          // Populate the display name input with current value
          const displayNameInput = document.getElementById("displayNameInput");
          if (displayNameInput) {
            displayNameInput.value = appData?.settings?.displayName || "";
            
            // Add Enter key handling
            displayNameInput.addEventListener("keydown", (e) => {
              if (e.key === "Enter") {
                e.preventDefault();
                document.getElementById("saveNameInput")?.click();
              }
            });
          }
        }
        
        // Apply translations to the newly visible tab content
        setTimeout(() => {
          if (typeof applyTranslations === "function") {
            applyTranslations();
          }
        }, 100);
      }

      window.switchToTab = switchToTab;

      async function renderDiscover() {
        const list = document.getElementById("discoverList");
        list.innerHTML = t("building_recommendations");
        try {
          const recs = await fetchDiscover();
          if (!recs.length) {
            list.innerHTML = t("not_enough_signals");
            return;
          }
          
          // Apply tag filters to recommendations if they exist
          let filteredRecs = typeof filterByTags === "function" ? filterByTags(recs) : recs;
          
          // Filter out items marked as "not interested"
          if (appData.notInterested && appData.notInterested.length > 0) {
            const notInterestedIds = appData.notInterested.map(item => item.id);
            filteredRecs = filteredRecs.filter(item => !notInterestedIds.includes(item.id));
            console.log(`🚫 Filtered out ${recs.length - filteredRecs.length} items marked as not interested`);
          }
          
          if (!filteredRecs.length) {
            // Check if it's due to tag filtering or no available recommendations
            if (recs.length === 0) {
              list.innerHTML = t("not_enough_signals");
            } else {
              list.innerHTML = t("no_results");
            }
            return;
          }
          
          list.innerHTML = "";
          filteredRecs.forEach((it) => {
            // Cache the item before creating the card
            cacheSearchItem(it);
            const card = createShowCard(it, true); // true => search-mode actions (move buttons)
            const meta = card.querySelector(".show-meta");
            if (meta && it.because) {
              const el = document.createElement("div");
              el.style.fontSize = ".85rem";
              el.style.opacity = ".8";
              el.textContent = it.because;
              meta.appendChild(el);
            }
            list.appendChild(card);
          });
        } catch {
          list.innerHTML = t("recommendations_failed");
        }
      }

      function updateList(containerId, items) {
        const c = document.getElementById(containerId);
        if (!c) return;
        if (!items || !items.length) {
          c.innerHTML = `<div class="empty-state">${t("no_items")}</div>`;
          return;
        }
        
        // Determine which tab this list belongs to based on containerId
        let listTab = "home";
        if (containerId === "watchingList") listTab = "watching";
        else if (containerId === "wishlistList") listTab = "wishlist";
        else if (containerId === "watchedList") listTab = "watched";
        
        c.innerHTML = "";
        items.forEach((it) => c.appendChild(createShowCard(it, false, listTab)));
      }

      function updateUI() {

        const totals = {
          watching:
            (appData.tv.watching?.length || 0) +
            (appData.movies.watching?.length || 0),
          wishlist:
            (appData.tv.wishlist?.length || 0) +
            (appData.movies.wishlist?.length || 0),
          watched:
            (appData.tv.watched?.length || 0) +
            (appData.movies.watched?.length || 0),
        };
        const totalAll = totals.watching + totals.wishlist + totals.watched;

        const setText = (id, v) => {
          const el = document.getElementById(id);
          if (el) el.textContent = String(v);
        };
        setText("watchingBadge", totals.watching);
        setText("watchingCount", totals.watching);
        setText("wishlistBadge", totals.wishlist);
        setText("wishlistCount", totals.wishlist);
        setText("watchedBadge", totals.watched);
        setText("watchedCount", totals.watched);
        setText("totalCount", totalAll);

        if (typeof updateTagFiltersUI === "function") updateTagFiltersUI();

        const maybeFilter = (arr) =>
          typeof filterByTags === "function" ? filterByTags(arr) : arr;
        const watching = maybeFilter([
          ...(appData.tv.watching || []),
          ...(appData.movies.watching || []),
        ]);
        const wishlist = maybeFilter([
          ...(appData.tv.wishlist || []),
          ...(appData.movies.wishlist || []),
        ]);
        const watched = maybeFilter([
          ...(appData.tv.watched || []),
          ...(appData.movies.watched || []),
        ]);

        updateList("watchingList", watching);
        updateList("wishlistList", wishlist);
        updateList("watchedList", watched);

        // updateBingeMeter?.(); // Disabled - removed from home page
        // updateBingeBanner?.(); // Disabled - removed from front page
        
        // Ensure home page blocks are inserted (quotes, horoscope, feedback)
        const blocksResult = ensureBlocks?.();
        
        applyTranslations?.();
        
        rebuildStats?.();
      }
      // Cache search results so we don't inline JSON into onclick
      const searchItemCache = new Map();
      // Make it globally accessible for language switching
      window.searchItemCache = searchItemCache;

      function cacheSearchItem(it) {
        if (it && it.id != null) searchItemCache.set(Number(it.id), it);
      }

      function addToListFromCache(id, list) {
        const it = searchItemCache.get(Number(id));
        if (!it) {
          showNotification(t("could_not_read_item"), "warning");
          return;
        }
        addToList(it, list);
      }
      window.addToListFromCache = addToListFromCache; // used by inline handlers

      /* ---------- DATA EXPORT/IMPORT HELPERS ---------- */
      function exportAppData() {
        if (window.flickletApp && typeof window.flickletApp.exportAppData === 'function') {
          window.flickletApp.exportAppData();
        } else {
          console.error('❌ FlickletApp not available for export');
          alert('Export functionality not available. Please refresh the page and try again.');
        }
      }
      
      function importAppData() {
        if (window.flickletApp && typeof window.flickletApp.importAppData === 'function') {
          window.flickletApp.importAppData();
        } else {
          console.error('❌ FlickletApp not available for import');
          alert('Import functionality not available. Please refresh the page and try again.');
        }
      }
      
      /* ---------- ADVANCED SEARCH HELPERS ---------- */
      function toggleAdvancedSearch() {
        const advancedOptions = document.getElementById('advancedSearchOptions');
        const advancedBtn = document.getElementById('advancedSearchBtn');
        
        if (advancedOptions.style.display === 'none') {
          advancedOptions.style.display = 'block';
          advancedBtn.style.background = 'linear-gradient(45deg, var(--primary), var(--purple))';
          advancedBtn.style.color = 'white';
          advancedBtn.title = 'Hide Advanced Search Options';
        } else {
          advancedOptions.style.display = 'none';
          advancedBtn.style.background = '';
          advancedBtn.style.color = '';
          advancedBtn.title = 'Advanced Search Options';
        }
      }
      
      function applyAdvancedFilters() {
        console.log('🔍 Applying advanced search filters...');
        
        // Get all filter values
        const filters = {
          searchType: document.getElementById('searchType')?.value || 'title',
          yearFrom: document.getElementById('yearFrom')?.value || '',
          yearTo: document.getElementById('yearTo')?.value || '',
          rating: document.getElementById('ratingFilter')?.value || '',
          mediaType: document.getElementById('mediaTypeFilter')?.value || '',
          language: document.getElementById('languageFilter')?.value || '',
          sortBy: document.getElementById('sortByFilter')?.value || 'relevance'
        };
        
        // Store filters for search
        window.currentSearchFilters = filters;
        
        // Update active filters display
        if (window.flickletApp && typeof window.flickletApp.updateActiveFiltersDisplay === 'function') {
          window.flickletApp.updateActiveFiltersDisplay();
        }
        
        // Show confirmation
        const filterSummary = [];
        if (filters.searchType && filters.searchType !== 'title') {
          const searchTypeLabels = {
            'actor': 'Actor/Actress',
            'director': 'Director',
            'genre': 'Genre',
            'keyword': 'Keywords'
          };
          filterSummary.push(`Search: ${searchTypeLabels[filters.searchType]}`);
        }
        if (filters.yearFrom || filters.yearTo) {
          filterSummary.push(`Year: ${filters.yearFrom || 'Any'} - ${filters.yearTo || 'Any'}`);
        }
        if (filters.rating) {
          filterSummary.push(`Rating: ${filters.rating}+`);
        }
        if (filters.mediaType) {
          filterSummary.push(`Type: ${filters.mediaType === 'movie' ? 'Movies' : 'TV Shows'}`);
        }
        if (filters.language) {
          filterSummary.push(`Language: ${filters.language.toUpperCase()}`);
        }
        if (filters.sortBy !== 'relevance') {
          filterSummary.push(`Sort: ${filters.sortBy}`);
        }
        
        if (filterSummary.length > 0) {
          if (window.flickletApp && typeof window.flickletApp.showSuccess === 'function') {
            window.flickletApp.showSuccess(
              'Filters applied!',
              `Active filters: ${filterSummary.join(', ')}`
            );
          }
        }
        
        // Perform search with filters
        if (typeof performSearch === 'function') {
          performSearch();
        }
      }
      
      function removeFilter(filterType) {
        console.log(`🗑️ Removing filter: ${filterType}`);
        
        // Clear the specific filter
        switch (filterType) {
          case 'searchType':
            document.getElementById('searchType').value = 'title';
            break;
          case 'year':
            document.getElementById('yearFrom').value = '';
            document.getElementById('yearTo').value = '';
            break;
          case 'rating':
            document.getElementById('ratingFilter').value = '';
            break;
          case 'mediaType':
            document.getElementById('mediaTypeFilter').value = '';
            break;
          case 'language':
            document.getElementById('languageFilter').value = '';
            break;
          case 'sortBy':
            document.getElementById('sortByFilter').value = 'relevance';
            break;
        }
        
        // Update stored filters
        if (window.currentSearchFilters) {
          if (filterType === 'searchType') {
            window.currentSearchFilters.searchType = 'title';
          } else if (filterType === 'year') {
            window.currentSearchFilters.yearFrom = '';
            window.currentSearchFilters.yearTo = '';
          } else if (filterType === 'sortBy') {
            window.currentSearchFilters.sortBy = 'relevance';
          } else {
            window.currentSearchFilters[filterType] = '';
          }
        }
        
        // Update display
        if (window.flickletApp && typeof window.flickletApp.updateActiveFiltersDisplay === 'function') {
          window.flickletApp.updateActiveFiltersDisplay();
        }
        
        // Re-run search with updated filters
        if (typeof performSearch === 'function') {
          performSearch();
        }
      }
      
      function resetAdvancedFilters() {
        console.log('🔄 Resetting advanced search filters...');
        
        // Clear all filter inputs
        document.getElementById('searchType').value = 'title';
        document.getElementById('yearFrom').value = '';
        document.getElementById('yearTo').value = '';
        document.getElementById('ratingFilter').value = '';
        document.getElementById('mediaTypeFilter').value = '';
        document.getElementById('languageFilter').value = '';
        document.getElementById('sortByFilter').value = 'relevance';
        
        // Clear stored filters
        window.currentSearchFilters = null;
        
        // Show confirmation
        if (window.flickletApp && typeof window.flickletApp.showSuccess === 'function') {
          window.flickletApp.showSuccess('Filters reset', 'All search filters have been cleared');
        }
      }
      
      /* ---------- SEARCH HELPERS ---------- */
      async function performSearch() {
        try {
          const qEl = document.getElementById("searchInput");
          const gEl = document.getElementById("genreFilter");
          const out = document.getElementById("searchResults");
          const skeleton = document.getElementById("searchSkeleton");
          if (!qEl || !out) return;

          const q = (qEl.value || "").trim();
          const genre = gEl ? gEl.value || "" : "";
          if (!q) {
            clearSearch();
            return;
          }

          // Show loading state
          out.style.display = "none";
          if (skeleton) skeleton.style.display = "block";
          
          // Show button loading state
          const searchBtn = document.getElementById("searchBtn");
          if (searchBtn) {
            searchBtn.classList.add("loading");
          }
          
          out.innerHTML = t("searching");

          if (typeof tmdbGet !== "function") {
            out.innerHTML = "Search service not ready.";
            return;
          }
          
          // Get search type and other filters
          const searchType = document.getElementById("searchType")?.value || "title";
          const filters = window.currentSearchFilters || {};
          
          let data;
          let results = [];
          
          // Use different TMDB endpoints based on search type
          switch (searchType) {
            case "actor":
              // Search for people (actors/actresses)
              data = await tmdbGet("search/person", `&query=${encodeURIComponent(q)}`);
              results = data?.results || [];
              break;
              
            case "director":
              // Search for people (directors)
              data = await tmdbGet("search/person", `&query=${encodeURIComponent(q)}`);
              results = data?.results || [];
              break;
              
            case "genre":
              // Search by genre - we'll need to get genre ID first
              const genreData = await tmdbGet("genre/movie/list", "");
              const genreMatch = genreData?.genres?.find(g => 
                g.name.toLowerCase().includes(q.toLowerCase())
              );
              if (genreMatch) {
                data = await tmdbGet("discover/movie", `&with_genres=${genreMatch.id}`);
                results = data?.results || [];
              }
              break;
              
            case "keyword":
              // Search by keywords
              const keywordData = await tmdbGet("search/keyword", `&query=${encodeURIComponent(q)}`);
              if (keywordData?.results?.length > 0) {
                const keywordId = keywordData.results[0].id;
                data = await tmdbGet("discover/movie", `&with_keywords=${keywordId}`);
                results = data?.results || [];
              }
              break;
              
            default:
              // Default: search multi (title & overview)
              data = await tmdbGet("search/multi", `&query=${encodeURIComponent(q)}`);
              results = data?.results || [];
              break;
          }
          
          // Apply genre filter if specified
          if (genre) {
            results = results.filter((r) => (r.genre_ids || []).includes(Number(genre)));
          }
          
          // Apply advanced filters if available
          if (window.currentSearchFilters) {
            const filters = window.currentSearchFilters;
            
            results = results.filter(item => {
              // Year filter
              if (filters.yearFrom && item.release_date) {
                const itemYear = new Date(item.release_date).getFullYear();
                if (itemYear < parseInt(filters.yearFrom)) return false;
              }
              if (filters.yearTo && item.release_date) {
                const itemYear = new Date(item.release_date).getFullYear();
                if (itemYear > parseInt(filters.yearTo)) return false;
              }
              
              // Rating filter
              if (filters.rating && item.vote_average) {
                if (item.vote_average < parseFloat(filters.rating)) return false;
              }
              
              // Media type filter
              if (filters.mediaType) {
                if (filters.mediaType === 'movie' && item.media_type !== 'movie') return false;
                if (filters.mediaType === 'tv' && item.media_type !== 'tv') return false;
              }
              
              return true;
            });
            
            // Sort results
            if (filters.sortBy && filters.sortBy !== 'relevance') {
              results.sort((a, b) => {
                switch (filters.sortBy) {
                  case 'title':
                    return (a.title || a.name || '').localeCompare(b.title || b.name || '');
                  case 'year':
                    const yearA = new Date(a.release_date || a.first_air_date || 0).getFullYear();
                    const yearB = new Date(b.release_date || b.first_air_date || 0).getFullYear();
                    return yearB - yearA; // Newest first
                  case 'rating':
                    return (b.vote_average || 0) - (a.vote_average || 0); // Highest first
                  case 'popularity':
                    return (b.popularity || 0) - (a.popularity || 0); // Most popular first
                  default:
                    return 0;
                }
              });
            }
          }

          if (!results.length) {
            out.innerHTML = t("no_results");
            return;
          }

          // --- Cache every result before rendering ---
          // Hide loading state and show results
          if (skeleton) skeleton.style.display = "none";
          out.style.display = "block";
          
          // Hide button loading state
          if (searchBtn) {
            searchBtn.classList.remove("loading");
          }
          
          out.innerHTML = "";
          results.forEach((it) => {
            cacheSearchItem(it);
            out.appendChild(createShowCard(it, true)); // true => search-mode actions
          });
        } catch (err) {
          console.error("performSearch error", err);
          const out = document.getElementById("searchResults");
          
          // Show user-friendly error message
          const errorMessage = "Search failed. Please check your internet connection and try again.";
          const errorDetails = err.message || "Unknown error occurred";
          
          // Use the new error handling system
          if (window.flickletApp && typeof window.flickletApp.showError === 'function') {
            window.flickletApp.showError(errorMessage, errorDetails, 'performSearch');
          } else {
            // Fallback to old method
            if (out) out.innerHTML = t("search_failed");
          }
          
          // Hide loading state on error
          if (skeleton) skeleton.style.display = "none";
          out.style.display = "block";
          
          // Hide button loading state on error
          if (searchBtn) {
            searchBtn.classList.remove("loading");
          }
        }
      }

      function clearSearch() {
        const qEl = document.getElementById("searchInput");
        const out = document.getElementById("searchResults");
        if (qEl) qEl.value = "";
        if (out) {
          out.innerHTML = "";
          out.style.display = "none";
        }
      }

      function refreshSearchResults() {
        console.log('🔄 refreshSearchResults called');
        const out = document.getElementById("searchResults");
        if (out && out.style.display !== "none") {
          console.log('📱 Search results container is visible');
          // Check if we have cached results
          const results = Array.from(out.children);
          console.log('🔍 Found', results.length, 'search result elements');
          if (results.length > 0) {
            // If cache is empty (was cleared for language change), show message
            if (searchItemCache.size === 0) {
              console.log('🗑️ Cache is empty, showing language change message');
              out.innerHTML = `<div style="text-align: center; padding: 20px; color: #666;">
                <p>${t("search_results_cleared") || "Search results cleared due to language change."}</p>
                <p>${t("please_search_again") || "Please search again to see results in the new language."}</p>
              </div>`;
              return;
            }
            
            console.log('🔄 Re-rendering', results.length, 'search results');
            // Re-render search results with current language
            out.innerHTML = "";
            results.forEach((it) => {
              const itemId = it.querySelector('[data-action]')?.getAttribute('data-id');
              if (itemId) {
                const cachedItem = searchItemCache.get(Number(itemId));
                if (cachedItem) {
                  out.appendChild(createShowCard(cachedItem, true));
                }
              }
            });
          } else {
            console.log('📱 No search result elements found');
          }
        } else {
          console.log('📱 Search results container is not visible');
        }
        
        // Also refresh discover section if it's visible
        const discoverSection = document.getElementById("discoverSection");
        if (discoverSection && discoverSection.style.display !== "none") {
          if (typeof renderDiscover === "function") {
            renderDiscover();
          }
        }
      }

      // Tag filters / state used by updateTagFiltersUI
      let currentActiveTab = "home";
      let searchCache = [];
      let currentPage = 1;
      let showTVOnly = false,
        showMoviesOnly = false;
      let activeTagFilters = new Set();

      /* ============== Personality Patch Script ============== */
      (function() {
        // ---------- Big pools (edit as you like) ----------
        const FORTUNES = [
          "You are a Chaotic Good. You like drama but call it 'cinema.'",
          "Binge Minimalist: 90% planning, 10% watching.",
          "Comfort, chaos, and clever twists. In that order.",
          "On your 14th rewatch arc. Brave.",
          "63% fueled by snacks and unresolved plotlines.",
          "Human embodiment of 'skip intro'.",
          "Your spirit animal is a loading spinner.",
          "You collect pilots like Pokémon.",
          "You claim you hate cliffhangers. You don't.",
          "You alphabetize your watchlist and then ignore it.",
          "You believe 'one more episode' is a contract with destiny.",
          "You rate with your heart, not the stars.",
          "You're here to procrastinate responsibly.",
          "You love a slow burn and fast Wi‑Fi.",
          "You're allergic to laugh tracks.",
          "You pause for snacks like it's a ritual.",
          "You are a spoiler ninja and an ending apologist.",
          "You think 'limited series' means limits don't apply to you.",
          "You fast‑forward opening credits but respect end credits.",
          "You crave vibes > plot. Bold choice.",
          "You treat 'recommended for you' as a dare.",
          "You chase vibes like a sommelier of scenes.",
          "You watch with subtitles; you are cultured (and quiet).",
          "You fear the finale but press play anyway.",
          "You bookmark chaos and call it variety.",
          "You own three blankets. All 'the good one'.",
          "You pretend the algorithm is your friend.",
          "You rewatch comfort episodes like vitamins.",
          "You hoard tabs and storylines with equal skill.",
          "You skip recaps, then Google plot summaries. Iconic.",
        ];

        const QUOTES = [
          `"I am serious... and don't call me Shirley." — *Airplane!*`,
          `"Streaming is a lifestyle, not a choice." — Ancient Proverb`,
          `"Binge now. Cry later." — You, last night at 2AM`,
          `"One does not simply watch one episode." — Boromir, probably`,
          `"You had me at 'skip recap.'"`,
          `"Art is long, episodes are longer." — Someone with no plans`,
          `"We were on a break! From reality."`,
          `"I came, I saw, I queued it."`,
          `"To stream, perchance to nap." — Hamlet (director's cut)`,
          `"In this house we respect the 'Are you still watching?' prompt."`,
          `"The algorithm thinks I'm complicated. It's right."`,
          `"If found, return to the couch."`,
          `"My love language is 'skip ad.'"`,
          `"I contain multitudes and several watchlists."`,
          `"Sundays are for pilots and denial."`,
          `"Ctrl+Z for life, play for comfort."`,
          `"I fear no man, but I fear finales."`,
          `"This app gets me. Terrifying."`,
          `"Plot holes are just cardio for the brain."`,
          `"We accept the dopamine we think we deserve."`,
          `"I have never finished anything. Except seasons."`,
          `"Today's vibe: closed captions and open snacks."`,
          `"Foreshadowing? I hardly know her."`,
          `"Character development is my cardio."`,
          `"If the title card hits, I'm staying."`,
          `"Minimalism, but for episodes."`,
          `"'Are you still watching?' yes, Netflix, I'm thriving."`,
          `"I ship productivity with naps."`,
          `"Comfort show supremacy."`,
          `"This queue is a personality test I'm failing."`,
        ];

        // ---------- Utilities ----------
        const STORAGE_KEYS = {
          QUOTE_DECK: "__flicklet_quote_deck_v1__",
        };

        function dayOfYear(d = new Date()) {
          const start = new Date(d.getFullYear(), 0, 0);
          const diff = d - start;
          return Math.floor(diff / 86400000); // ms->days
        }

        // Cheap stable hash for a string
        function hashString(str) {
          let h = 2166136261 >>> 0;
          for (let i = 0; i < str.length; i++) {
            h ^= str.charCodeAt(i);
            h = Math.imul(h, 16777619);
          }
          return h >>> 0;
        }

        // Fisher‑Yates shuffle
        function shuffle(arr) {
          const a = arr.slice();
          for (let i = a.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [a[i], a[j]] = [a[j], a[i]];
          }
          return a;
        }

        // ---------- Horoscope (daily, deterministic) ----------
        function pickDailyHoroscope() {
          // Try to personalize with displayName if it exists in your appData
          let name = "";
          try {
            name = (window.appData?.settings?.displayName || "").trim();
          } catch {}
          const seed = (dayOfYear() + hashString(name)).toString();
          const idx = hashString(seed) % FORTUNES.length;
          const fortune = FORTUNES[idx];
          
          // Try to translate the fortune if we have a translation key
          const fortuneKey = fortune.toLowerCase().replace(/[^a-z\s]/g, '').replace(/\s+/g, '_');
          const translation = t(fortuneKey);
          
  
          return translation || fortune;
        }
        
        // Make functions globally accessible
        window.pickDailyHoroscope = pickDailyHoroscope;
        window.drawQuote = drawQuote;

        // ---------- Quotes (deck‑based, no repeats until exhausted) ----------
        function getQuoteDeck() {
          try {
            const raw = localStorage.getItem(STORAGE_KEYS.QUOTE_DECK);
            if (raw) {
              const deck = JSON.parse(raw);
              if (Array.isArray(deck) && deck.every(Number.isInteger))
                return deck;
            }
          } catch {}
          // Build a fresh shuffled deck of indices
          const fresh = shuffle([...QUOTES.keys()]);
          localStorage.setItem(
            STORAGE_KEYS.QUOTE_DECK,
            JSON.stringify(fresh)
          );
          return fresh;
        }

        function drawQuote() {
          const deck = getQuoteDeck();
          const next = deck.shift();
          const quoteIndex = next || 0;
          // Get translated quote based on current language
          const quoteKey = `quote_${quoteIndex + 1}`;
          const quote = t(quoteKey) || QUOTES[quoteIndex] || QUOTES[0];
          // Save remaining deck; if empty, rebuild next time
          try {
            if (deck.length) {
              localStorage.setItem(
                STORAGE_KEYS.QUOTE_DECK,
                JSON.stringify(deck)
              );
            } else {
              localStorage.removeItem(STORAGE_KEYS.QUOTE_DECK);
            }
          } catch {}
          return quote;
        }

        // ---------- DOM injection (idempotent) ----------
        window.ensureBlocks = function() {
          const home = document.getElementById("homeSection");
          if (!home) {
    
            return false;
          }


          
          // If home section is empty, create a container div first
          if (!home.firstElementChild) {
            const container = document.createElement("div");
            container.id = "homeContentContainer";
            home.appendChild(container);
    
          }
          
          const anchor = home.firstElementChild;

          // Insert quotes first (after tabs, before feedback)
          if (!document.getElementById("quoteBlock")) {
            const block = document.createElement("blockquote");
            block.className = "feedback-card";
            block.id = "quoteBlock";
            block.style.textAlign = "center";
            block.style.fontStyle = "italic";
            block.innerHTML = `<p id="randomQuote">"${t("quote_loading")}"</p>`;
            anchor.insertAdjacentElement("afterend", block);
          }

          // Insert horoscope second (after quotes)
          if (!document.getElementById("personalityForecast")) {
            const card = document.createElement("div");
            card.className = "feedback-card";
            card.id = "personalityForecast";
            card.innerHTML = `
                    <h3>🧠 <span data-i18n="streaming_horoscope">Streaming Horoscope</span></h3>
        <p id="fakeFortune" style="margin:0; font-style:italic;"></p>
      `;
            const insertAfter = document.getElementById("quoteBlock") || anchor;
            insertAfter.insertAdjacentElement("afterend", card);
          }

          // Insert feedback section last (at the bottom)
          if (!document.getElementById("feedbackSection")) {
            const feedbackCard = document.createElement("div");
            feedbackCard.className = "feedback-card";
            feedbackCard.id = "feedbackSection";
            feedbackCard.innerHTML = `
                                                      <h3 data-i18n="feedback">Share Your Thoughts</h3>
                                                          <p data-i18n="feedback_working">Share your thoughts! Give us app feedback, tell us what's working (or not), share a quote for our rotation, make a confession, or just vent. We're listening!</p>
                              <p class="feedback-subtitle" data-i18n="feedback_subtitle">💬 App feedback • 💭 Random thoughts • 💬 Quote submissions • 🤫 Anonymous confessions • 😤 Venting welcome</p>
                              <form name="feedback" method="POST" data-netlify="true" class="feedback-form">
                <input type="hidden" name="form-name" value="feedback" />
                <input type="hidden" name="theme" id="feedbackThemeInput" />
                <div style="display: flex; gap: 8px; flex-wrap: wrap">
                  <textarea
                    name="message"
                    class="search-input"
                    placeholder=""
                    data-i18n-placeholder="feedback_placeholder"
                    rows="3"
                    required
                    style="resize: vertical; min-height: 60px;"
                  ></textarea>
                  <button type="submit" class="btn" data-i18n="send">Share It!</button>
                </div>
              </form>
            `;
            const insertAfter = document.getElementById("personalityForecast") || document.getElementById("quoteBlock") || anchor;
            insertAfter.insertAdjacentElement("afterend", feedbackCard);
          }

          const hEl = document.getElementById("fakeFortune");
          const qEl = document.getElementById("randomQuote");
          if (hEl) hEl.textContent = pickDailyHoroscope();
          if (qEl) qEl.textContent = drawQuote();

          return true;
        }

        const start = () => {
          console.log("🚀 start() function called");
          const result = ensureBlocks();
          if (!result) {
            requestAnimationFrame(ensureBlocks);
          }
        };

        // start() function will be called by FlickletApp.init() or the fallback initialization
      })();
    </script>

    <script>
      /* ============== bootstrap ============== */
      document.addEventListener("DOMContentLoaded", () => {
        // Use centralized initialization if available
        if (window.FlickletApp && typeof window.FlickletApp.init === 'function') {
          console.log('🚀 Using centralized FlickletApp initialization');
          window.FlickletApp.init(); // <-- CALL IT HERE
          return;
        }

        // --- FALLBACK INITIALIZATION SEQUENCE
        console.log('⚠️ Using fallback initialization sequence');
        
        // 1. Load app data first
        loadAppData?.();
        
        // 2. Try to import from share link
        tryImportFromShareLink?.();
        
        // 3. Load genres
        loadGenres?.();
        
        // 4. Restore theme from localStorage
        const savedTheme = localStorage.getItem("flicklet-theme");
        if (savedTheme === "dark") {
          document.body.classList.add("dark-mode");
        }
        
        // 5. Ensure language dropdown is properly initialized
        const ensureLanguageDropdown = () => {
          const langToggle = document.getElementById("langToggle");
          if (langToggle && langToggle.children.length < 2) {
            langToggle.innerHTML = `
              <option value="en">EN</option>
              <option value="es">ES</option>
            `;
            // Set the current language
            if (appData?.settings?.lang) {
              langToggle.value = appData.settings.lang;
            }
          }
        };
        
        // Call it immediately and also after a delay to catch any late modifications
        ensureLanguageDropdown();
        setTimeout(ensureLanguageDropdown, 100);
        
        // 6. Show home tab by default
        switchToTab("home");
        
        // 7. Update UI (which will call ensureBlocks)
        updateUI?.();
        
        // 8. Check upcoming episodes
        checkUpcomingEpisodes?.();
        
        // 9. Apply translations to the initial tab content
        setTimeout(() => {
          if (typeof applyTranslations === "function") {
            applyTranslations();
          }
        }, 200);
        
        // 10. Request notification permissions
        requestNotificationPermission?.();
        
        // 11. Initialize file label
        const importFileInput = document.getElementById("importFile");
        if (importFileInput) {
          updateFileLabel(importFileInput);
        }
        
        // 12. Paint account button based on currentUser if auth has already resolved
        if (typeof setAccountLabel === "function") setAccountLabel(currentUser);
        
        // start() function will be called by FlickletApp.init() if available
        // --- SEARCH BAR PROTECTION - Prevent it from disappearing

        
        
        
        // --- SEARCH BAR PROTECTION - CSS sticky positioning handles visibility
        // Removed aggressive visibility enforcement - CSS sticky positioning is sufficient
        
        // --- small util
        const bind = (id, fn) => {
          const el = document.getElementById(id);
          if (el) el.onclick = fn;
        };

        // Duplicate initialization sequence removed - using the one above

        // --- tabs
        bind("homeTab", () => switchToTab("home"));
        bind("watchingTab", () => switchToTab("watching"));
        bind("wishlistTab", () => switchToTab("wishlist"));
        bind("watchedTab", () => switchToTab("watched"));
        bind("discoverTab", () => switchToTab("discover"));
        bind("settingsTab", () => switchToTab("settings"));

        
        // --- delegated actions for cards & search results

        
        // Try both event delegation and direct binding
        document.addEventListener("click", (e) => {
          
          
          const btn = e.target.closest("[data-action]");
          if (!btn) {
            return;
          }
          
          const action = btn.getAttribute("data-action");
          const id = Number(btn.getAttribute("data-id"));
          const list = btn.getAttribute("data-list");
          const mediaType = btn.getAttribute("data-media-type");
          
  
          if (action === "addFromCache") {
            addToListFromCache(id, list);
          } else if (action === "move") {
            moveItem(id, list);
          } else if (action === "notes") {
            openNotesTagsModal(id);
          } else if (action === "remove") {
            removeItemFromCurrentList(id);
          } else if (action === "rate") {
            const rating = Number(btn.getAttribute("data-rating"));
            setRating(id, rating);
          } else if (action === "like") {
            setLikeStatus(id, "like");
          } else if (action === "dislike") {
            setLikeStatus(id, "dislike");
          } else if (action === "open") {
            openTMDBLink(id, mediaType);
          }
        });
// --- dark mode
        const darkBtn = document.getElementById("darkModeToggle");
        const setDarkLabel = () => {
          if (!darkBtn) return;
          const dark = document.body.classList.contains("dark-mode");
          const label = darkBtn.querySelector('span');
          if (label) {
            label.textContent = t(dark ? "go_light" : "go_dark");
          }
        };
        setDarkLabel();
        if (darkBtn) {
          darkBtn.onclick = () => {
            document.body.classList.toggle("dark-mode");
            if (window.appData?.settings) {
              appData.settings.theme = document.body.classList.contains(
                "dark-mode"
              )
                ? "dark"
                : "light";
              saveAppData?.();
            }
            setDarkLabel();
          };
        }

        // --- mardi toggle
        const root = document.getElementById("appRoot");
        bind("mardiToggle", () => root && root.classList.toggle("mardi"));
        bind("mardiOnBtn", () => root && root.classList.toggle("mardi"));

        // --- language switch (will be set up after data loads)

        // --- Name prompt moved to post-authentication flow for security best practices
        // No more name prompt on app boot - this was causing the name persistence issue

        // --- Account / Auth entry point (modal) - handled by FlickletApp.setupEventListeners()

        // --- Save name button
        bind("saveNameBtn", () => {
          const val = (document.getElementById("displayNameInput")?.value || "").trim();
          if (!val) return showNotification?.(t("enter_name_first"), "warning");
          if (appData?.settings) {
            appData.settings.displayName = val;
            saveAppData?.();
            // updateWelcomeText?.(); // DISABLED - conflicts with dynamic header system
            showNotification?.(t("name_saved"), "success");
          }
        });
        


        // --- feedback handled by Netlify Forms
      function handleFeedbackSubmit(event) {
        event.preventDefault(); // Prevent default form submission
        
        // Store current theme before form submission
        const currentTheme = document.body.classList.contains("dark-mode") ? "dark" : "light";
        const themeInput = document.getElementById("feedbackThemeInput");
        if (themeInput) {
          themeInput.value = currentTheme;
        }
        
        // Store theme in localStorage as backup
        localStorage.setItem("flicklet-theme", currentTheme);
        
        // Get form data
        const form = event.target;
        const formData = new FormData(form);
        
        // Convert to JSON for the Netlify function
        const feedbackData = {
          message: formData.get('message'),
          theme: formData.get('theme'),
          timestamp: new Date().toISOString()
        };
        
        // For local development, just show success message
        if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
          console.log('Local development mode - showing success message');
          showNotification('Thanks for sharing! Your thoughts have been received. 💭 (Local mode)', 'success');
          form.reset();
          return false;
        }
        
        // Submit to Netlify function (production only)
        fetch('/.netlify/functions/feedback', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(feedbackData)
        })
        .then(response => {
          if (response.ok) {
            showNotification('Thanks for sharing! Your thoughts have been received. 💭', 'success');
            form.reset();
          } else {
            showNotification('Oops! Something went wrong. Please try sharing again. 😅', 'error');
          }
        })
        .catch(error => {
          console.error('Feedback submission error:', error);
          showNotification('Failed to submit feedback. Please try sharing again. 😅', 'error');
        });
        
        return false;
      }



        // --- search controls (REMOVED - duplicate code that was breaking search functionality)

        // --- backup / import / clear / share
        bind("exportBtn", () => {
          const blob = new Blob([JSON.stringify(appData, null, 2)], {
            type: "application/json",
          });
          const a = document.createElement("a");
          a.href = URL.createObjectURL(blob);
          a.download = "flicklet-backup.json";
          document.body.appendChild(a);
          a.click();
          a.remove();
        });

        const importFile = document.getElementById("importFile");
        if (importFile) {
          importFile.onchange = (e) => {
            const f = e.target.files?.[0];
            if (!f) return;
            const r = new FileReader();
            r.onload = () => {
              try {
                const d = JSON.parse(r.result);
                Object.assign(appData, d);
                saveAppData?.();
                updateUI?.();
                showNotification?.(t("imported_backup"), "success");
              } catch {
                showNotification?.(t("invalid_file"), "error");
              }
            };
            r.readAsText(f);
          };
        }

        bind("clearAllBtn", () => {
          if (!confirm("This wipes everything. You sure?")) return;
          if (appData?.tv)
            appData.tv = { watching: [], wishlist: [], watched: [] };
          if (appData?.movies)
            appData.movies = { watching: [], wishlist: [], watched: [] };
          saveAppData?.();
          updateUI?.();
          showNotification?.(t("all_data_cleared"), "warning");
        });

        // Share button bindings moved to runGlobalInitialization

        // --- notification toggles
        const ep = document.getElementById("notifEpisodes");
        const dp = document.getElementById("notifDiscover");
        const md = document.getElementById("notifDigest");
        if (ep)
          ep.addEventListener("change", (e) => {
            if (appData?.settings?.notif) {
              appData.settings.notif.episodes = !!e.target.checked;
              saveAppData?.();
            }
          });
        if (dp)
          dp.addEventListener("change", (e) => {
            if (appData?.settings?.notif) {
              appData.settings.notif.discover = !!e.target.checked;
              saveAppData?.();
            }
          });
        if (md)
          md.addEventListener("change", (e) => {
            if (appData?.settings?.notif) {
              appData.settings.notif.digest = !!e.target.checked;
              saveAppData?.();
            }
          });

        // --- pro toggle
        const proToggle = document.getElementById("proToggle");
        if (proToggle) {
          proToggle.checked = !!appData?.settings?.pro;
          proToggle.addEventListener("change", (e) => {
            if (appData?.settings) {
              appData.settings.pro = !!e.target.checked;
              saveAppData?.();
              rebuildStats?.();
              
              // Show/hide Pro features explanation
              const proFeatures = document.getElementById("proFeatures");
              if (proFeatures) {
                proFeatures.style.display = e.target.checked ? "block" : "none";
              }
            }
          });
          
          // Show Pro features if already enabled
          const proFeatures = document.getElementById("proFeatures");
          if (proFeatures && proToggle.checked) {
            proFeatures.style.display = "block";
          }
        }

        console.debug("[Flicklet] Boot OK");

        // FlickletApp.init() already called at the beginning if available

      });
    </script>
  </body>
</html>