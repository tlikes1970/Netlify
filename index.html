<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <!-- Primary Meta Tags -->
  <title>Flicklet - TV & Movie Tracker</title>
  <meta name="title" content="Flicklet - TV & Movie Tracker">
  <meta name="description" content="Search, track, and rate shows & films fast. Never lose track of your binge-watching again!">
  <meta name="keywords" content="tv tracker, movie tracker, streaming, watchlist, tv shows, movies, entertainment, episode tracker">
  <meta name="author" content="Flicklet">
  
  <!-- Open Graph / Facebook -->
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://Flicklet.netlify.app/">
  <meta property="og:title" content="Flicklet - TV & Movie Tracker">
  <meta property="og:description" content="Search, track, and rate shows & films fast. Never lose track of your binge-watching again!">
  <meta property="og:image" content="https://Flicklet.netlify.app/icons/icon-512.png">
  <meta name="twitter:image" content="/icons/icon-512.png">
  
  <!-- PWA Meta Tags -->
  <meta name="application-name" content="Flicklet">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Flicklet">
  <meta name="theme-color" content="#ff6b6b">
  
  <!-- PWA Manifest -->
  <link rel="manifest" href="/manifest.json">
  
  <style>
    :root {
      --bg: #fff; --text: #000; --primary: #ff6b6b; --card: #f9f9f9; --border: #ddd;
      --success: #51cf66; --warning: #ffd43b; --danger: #ff6b6b; --purple: #845ec2;
      --blue: #4dabf7; --orange: #ff8c42; --green: #51cf66;
    }
    
    * { box-sizing: border-box; }
    
    body { 
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; 
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: var(--text); margin: 0; padding: 20px; min-height: 100vh;
      transition: all 0.3s ease;
    }
    
    .dark-mode { 
      --bg: #1a1a1a; --text: #f5f5f5; --card: #2d2d2d; --border: #444;
      background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%) !important;
    }
    
    .main-container {
      max-width: 1200px; margin: 0 auto; background: var(--bg); 
      border-radius: 20px; padding: 30px; box-shadow: 0 20px 60px rgba(0,0,0,0.3);
      transition: all 0.3s ease;
    }
    
    .header { 
      display: flex; justify-content: space-between; align-items: center; 
      padding: 20px 0; border-bottom: 3px dashed var(--primary); margin-bottom: 30px;
      position: relative; flex-wrap: wrap; gap: 15px;
    }
    
    .header::after {
      content: "ğŸ›‹ï¸"; position: absolute; right: 20px; top: 15px; 
      font-size: 28px; animation: couch-bounce 3s ease-in-out infinite;
    }
    
    @keyframes couch-bounce {
      0%, 100% { transform: translateY(0) rotate(0deg); }
      50% { transform: translateY(-5px) rotate(-5deg); }
    }
    
    .title { 
      font-size: 2.5em; font-weight: bold; color: var(--primary); 
      margin: 0; cursor: pointer; flex-shrink: 0;
    }

    .subtitle {
      font-size: 1.1em; font-style: italic; color: #666; 
      margin-top: 5px; font-weight: normal;
    }
    
    .user-section {
      display: flex; align-items: center; gap: 15px; flex-wrap: wrap;
    }
    
    .name-container {
      display: flex; flex-direction: column; align-items: flex-end;
      transition: all 0.3s ease;
    }
    
    .name-instruction {
      font-size: 12px; color: var(--primary); font-weight: bold;
      margin-bottom: 5px;
    }
    
    .name-input {
      padding: 12px; border: 2px solid var(--primary); border-radius: 25px;
      background: var(--card); color: var(--text); font-weight: bold;
    }
    
    .name-container.hidden {
      opacity: 0; transform: scale(0.8); pointer-events: none;
    }
    
    .tab-container { 
      display: flex; background: var(--card); border-radius: 15px; 
      padding: 8px; margin: 30px 0; gap: 5px;
    }
    
    .tab { 
      flex: 1; padding: 18px 30px; border: none; background: transparent; 
      color: var(--text); cursor: pointer; border-radius: 10px; font-weight: bold;
      transition: all 0.3s ease; font-size: 16px; text-align: center;
      display: flex; align-items: center; justify-content: center; gap: 8px;
    }
    
    .tab.active { 
      background: linear-gradient(45deg, var(--primary), var(--purple)); 
      color: white; transform: scale(1.05);
    }
    
    .tab-badge {
      background: rgba(255,255,255,0.9); color: var(--primary);
      padding: 4px 10px; border-radius: 12px; font-size: 12px;
      font-weight: bold; min-width: 20px;
    }
    
    .tab.active .tab-badge {
      background: rgba(255,255,255,1); color: var(--primary);
    }
    
    button { 
      margin: 8px; padding: 12px 20px; border: none; border-radius: 25px; 
      background: linear-gradient(45deg, var(--primary), var(--purple)); 
      color: white; cursor: pointer; font-weight: bold; font-size: 14px;
      transition: all 0.3s ease;
    }
    
    button:hover { 
      transform: translateY(-3px) scale(1.05); 
    }
    
    button:disabled { 
      background: #666; cursor: not-allowed; transform: none; opacity: 0.6;
    }
    
    button.danger { background: linear-gradient(45deg, #ff4757, #ff3742); }
    button.success { background: linear-gradient(45deg, #2ed573, #1dd1a1); }
    button.secondary { background: linear-gradient(45deg, #747d8c, #57606f); }
    
    .search-container { 
      background: var(--card); padding: 25px; border-radius: 20px; 
      margin: 30px 0; border: 2px solid var(--primary);
    }
    
    .search-row {
      display: flex; gap: 15px; margin-bottom: 15px; flex-wrap: wrap;
    }
    
    .search-input {
      flex: 1; min-width: 250px; padding: 12px 15px;
      border: 2px solid var(--border); border-radius: 15px;
      background: var(--bg); color: var(--text); font-size: 16px;
    }
    
    .search-help {
      font-size: 12px; color: #666; margin-top: 5px; font-style: italic;
    }
    
    .tooltip {
      position: relative; display: inline-block; cursor: help;
      color: var(--primary); font-weight: bold; text-decoration: underline;
    }
    
    .tooltip .tooltiptext {
      visibility: hidden; width: 300px; background-color: var(--purple);
      color: white; text-align: left; border-radius: 10px;
      padding: 15px; position: absolute; z-index: 1000;
      bottom: 125%; left: 50%; margin-left: -150px;
      opacity: 0; transition: opacity 0.3s; font-style: normal;
      box-shadow: 0 5px 20px rgba(0,0,0,0.3);
    }
    
    .tooltip .tooltiptext::after {
      content: ""; position: absolute; top: 100%; left: 50%;
      margin-left: -5px; border-width: 5px;
      border-style: solid; border-color: var(--purple) transparent transparent transparent;
    }
    
    .tooltip:hover .tooltiptext {
      visibility: visible; opacity: 1;
    }

    .notification-test {
      background: #fef5e7; border: 2px solid #f6ad55; color: #c05621;
      margin-bottom: 20px; text-align: center; border-radius: 15px;
      padding: 12px 20px; font-weight: bold;
    }
    
    input, select { 
      padding: 12px 15px; margin: 5px; border: 2px solid var(--border); 
      border-radius: 15px; background: var(--bg); color: var(--text);
    }
    
    .section { margin: 40px 0; }
    
    .section-header {
      display: flex; justify-content: space-between; align-items: center;
      margin-bottom: 20px; cursor: pointer; padding: 10px 0;
    }
    
    .section h3 { 
      color: var(--primary); margin: 0; font-size: 1.8em;
    }
    
    .section-subtitle {
      font-size: 14px; color: #666; font-style: italic;
      margin-top: 5px; font-weight: normal;
    }
    
    .count { 
      background: linear-gradient(45deg, var(--primary), var(--purple)); 
      color: white; padding: 8px 15px; border-radius: 20px; 
      font-size: 16px; font-weight: bold; cursor: pointer;
    }
    
    .list-container { 
      background: var(--card); border-radius: 15px; padding: 20px; 
      min-height: 80px; border: 3px dashed var(--border);
    }
    
    .show-card { 
      display: flex; border: 2px solid var(--border); 
      border-radius: 15px; padding: 20px; margin: 15px 0; 
      background: var(--bg);
    }
    
    .show-poster { 
      width: 90px; height: 135px; border-radius: 10px; 
      object-fit: cover; margin-right: 20px; flex-shrink: 0;
      cursor: pointer;
    }
    
    .poster-placeholder { 
      width: 90px; height: 135px; background: #f0f0f0; 
      border-radius: 10px; display: flex; align-items: center; justify-content: center; 
      margin-right: 20px; color: #999; font-size: 12px; font-weight: bold; flex-shrink: 0;
      cursor: pointer;
    }
    
    .show-details { flex: 1; display: flex; flex-direction: column; }
    
    .show-title { 
      font-size: 20px; font-weight: bold; margin: 0 0 10px 0; 
      cursor: pointer; color: var(--primary);
      display: flex; align-items: center; gap: 10px;
    }
    
    .external-link {
      font-size: 14px; opacity: 0.7; transition: opacity 0.3s ease;
    }
    
    .external-link:hover { opacity: 1; }
    
    .show-meta { 
      color: #666; font-size: 14px; margin-bottom: 12px;
    }
    
    .show-overview { 
      font-size: 14px; line-height: 1.6; margin-bottom: 15px; 
      max-height: 60px; overflow: hidden; cursor: pointer;
    }
    
    .show-overview.expanded { max-height: none; }
    
    .rating-container {
      display: flex; align-items: center; gap: 10px; margin: 10px 0;
      flex-wrap: wrap;
    }
    
    .star-rating {
      display: flex; gap: 2px;
    }
    
    .star {
      font-size: 18px; cursor: pointer; transition: all 0.2s ease;
      color: #ddd;
    }
    
    .star:hover, .star.active { 
      color: #ffd700; transform: scale(1.1);
    }
    
    .like-dislike {
      display: flex; gap: 8px; align-items: center;
    }
    
    .like-btn, .dislike-btn {
      padding: 6px 12px; font-size: 12px; border-radius: 15px;
      border: none; cursor: pointer; transition: all 0.3s ease;
    }
    
    .like-btn {
      background: #ddd; color: #666;
    }
    
    .like-btn.active {
      background: linear-gradient(45deg, #2ed573, #1dd1a1);
      color: white;
    }
    
    .dislike-btn {
      background: #ddd; color: #666;
    }
    
    .dislike-btn.active {
      background: linear-gradient(45deg, #ff4757, #ff3742);
      color: white;
    }
    
    .notes-container {
      margin: 10px 0;
    }
    
    .notes-field {
      width: 100%; min-height: 50px; padding: 10px;
      border: 2px dashed var(--border); border-radius: 10px;
      background: var(--card); color: var(--text); resize: vertical;
      font-family: inherit; font-size: 13px;
    }
    
    .char-count {
      font-size: 11px; color: #999; text-align: right; margin-top: 5px;
    }
    
    .char-count.warning { color: var(--warning); }
    .char-count.danger { color: var(--danger); }
    
    .tags-container {
      margin: 10px 0;
    }
    
    .tag-input {
      width: 100%; padding: 8px; font-size: 12px;
      margin-bottom: 8px; border: 2px solid var(--border);
      border-radius: 10px; background: var(--bg); color: var(--text);
    }
    
    .tags-display {
      display: flex; flex-wrap: wrap; gap: 6px;
    }
    
    .tag {
      background: var(--purple); color: white; padding: 4px 8px;
      border-radius: 15px; font-size: 11px; font-weight: bold;
      display: flex; align-items: center; gap: 5px;
    }
    
    .tag-remove {
      cursor: pointer; font-weight: bold;
    }
    
    .episode-tracker {
      background: var(--card); padding: 12px; border-radius: 10px;
      border: 2px dashed var(--border); margin: 10px 0;
    }
    
    .episode-inputs {
      display: grid; grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
      gap: 8px; margin-top: 8px;
    }
    
    .episode-inputs input {
      padding: 8px; font-size: 12px; text-align: center;
      border: 2px solid var(--border); border-radius: 8px;
      background: var(--bg); color: var(--text);
    }
    
    .series-status {
      background: var(--card); padding: 10px; border-radius: 8px;
      margin: 8px 0; font-size: 12px; border-left: 4px solid var(--primary);
    }
    
    .status-ongoing { border-left-color: var(--success); }
    .status-ended { border-left-color: var(--danger); }
    .status-upcoming { border-left-color: var(--warning); }
    
    .episode-info {
      font-weight: bold; color: var(--primary);
    }
    
    .air-date {
      color: #666; font-style: italic;
    }
    
    .show-actions { 
      display: flex; gap: 12px; flex-wrap: wrap; align-items: center; 
      margin-top: 15px;
    }
    
    .show-actions button { padding: 8px 15px; font-size: 12px; margin: 2px; }
    
    .empty-state { 
      text-align: center; color: #666; padding: 40px 20px; 
      font-style: italic; font-size: 18px;
    }
    
    .sassy-empty { 
      font-weight: bold; color: var(--primary);
    }
    
    .stats { 
      display: flex; gap: 20px; margin: 30px 0; flex-wrap: wrap;
    }
    
    .stat { 
      background: var(--card); padding: 25px; border-radius: 15px; 
      text-align: center; flex: 1; min-width: 140px; 
      border: 2px solid var(--primary); cursor: pointer;
    }
    
    .stat:hover { 
      transform: translateY(-5px); 
    }
    
    .stat-num { 
      font-size: 2.5em; font-weight: bold; color: var(--primary); 
    }
    
    .stat-label { 
      font-size: 12px; color: #666; font-weight: bold; 
      text-transform: uppercase;
    }
    
    .notification {
      position: fixed; top: 20px; right: 20px; z-index: 1000;
      padding: 15px 25px; border-radius: 10px; color: white;
      font-weight: bold; animation: slide-in 0.5s ease, slide-out 0.5s ease 2.5s forwards;
    }
    
    @keyframes slide-in {
      from { transform: translateX(100%); opacity: 0; }
      to { transform: translateX(0); opacity: 1; }
    }
    
    @keyframes slide-out {
      from { transform: translateX(0); opacity: 1; }
      to { transform: translateX(100%); opacity: 0; }
    }
    
    .notification.success { background: var(--success); }
    .notification.error { background: var(--danger); }
    .notification.warning { background: var(--warning); color: #000; }
    .notification.info { background: var(--purple); }
    
    .loading-container {
      text-align: center; padding: 40px;
    }
    
    .loading-spinner {
      width: 50px; height: 50px; border: 5px solid var(--border);
      border-top: 5px solid var(--primary); border-radius: 50%;
      animation: spin 1s linear infinite; margin: 0 auto 20px;
    }
    
    @keyframes spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }
    
    .loading-text {
      font-weight: bold; color: var(--primary); font-size: 16px;
    }
    
    .easter-egg {
      position: fixed; bottom: 20px; right: 20px; 
      background: var(--purple); color: white; padding: 12px; 
      border-radius: 50%; cursor: pointer; z-index: 1000;
      font-size: 18px; width: 50px; height: 50px;
      display: flex; align-items: center; justify-content: center;
    }
    
    .feedback-button {
      position: fixed; bottom: 90px; right: 20px; 
      background: var(--primary); color: white; padding: 15px; 
      border-radius: 50%; cursor: pointer; z-index: 1001;
      font-size: 20px; width: 60px; height: 60px;
      display: flex; align-items: center; justify-content: center;
    }
    
    /* Responsive Design */
    @media (max-width: 768px) {
      .main-container { 
        padding: 15px; margin: 10px; border-radius: 15px;
      }
      
      .header { 
        flex-direction: column; text-align: center; gap: 10px;
      }
      
      .header::after { display: none; }
      
      .title { font-size: 2em; }
      
      .tab-container {
        flex-direction: column;
      }
      
      .tab {
        padding: 15px 20px;
      }
      
      .search-row {
        flex-direction: column;
      }
      
      .search-input {
        min-width: auto;
      }
      
      .show-card { 
        flex-direction: column; padding: 15px; text-align: center;
      }
      
      .show-poster, .poster-placeholder { 
        width: 70px; height: 105px; margin: 0 auto 15px auto; 
      }
      
      .stats { 
        flex-direction: column; gap: 10px;
      }
      
      .stat { 
        min-width: auto; padding: 15px;
      }
    }

    @keyframes bubble-bounce {
      0% { transform: scale(0) translateY(20px); opacity: 0; }
      100% { transform: scale(1) translateY(0); opacity: 1; }
    }

    /* ---------- ONLY FOR THE EPISODE PILL ALIGNMENT ---------- */
    .ep-compact{
      display:inline-flex !important; align-items:center; gap:6px;
      padding:6px 10px !important; margin:0 !important;
      border:1px dashed var(--border) !important; border-radius:8px !important;
      background:var(--card) !important; width:auto !important;
      justify-self:end; /* when placed in grid, hug right */
    }
    /* hide the big label + inputs, keep series status */
    .ep-compact > strong { display:none !important; }
    .ep-compact .episode-inputs { display:none !important; }

    /* grid layout for the tags row: left = input+button, right = pill */
    .tags-row-grid{display:grid; grid-template-columns:1fr auto; align-items:center; column-gap:12px;}
    .tags-row-grid input{width:100%;}
    /* make the tag list span the full width below the first row */
    .tags-row-grid .tags-display{grid-column:1 / -1;}
    /* --------------------------------------------------------- */
  </style>
</head>
<body>
  <div class="main-container">
    <div class="header">
      <div>
        <h1 class="title" id="welcomeText" data-testid="app-title">Flicklet</h1>
        <div class="subtitle">TV & Movie Tracker</div>
      </div>
      <div class="user-section">
        <div class="name-container" id="nameContainer">
          <div class="name-instruction">ğŸ‘† Add your name for a personal touch!</div>
          <input type="text" id="displayNameInput" class="name-input" placeholder="Your name here...">
        </div>
        <button id="darkModeToggle">ğŸŒ™ Go Dark</button>
      </div>
    </div>

    <div class="tab-container">
      <button id="homeTab" class="tab active" data-testid="home-tab">
        ğŸ  Home
        <span class="tab-badge">Overview</span>
      </button>
      <button id="watchingTab" class="tab"data-testid="watching-tab">
        â–¶ï¸ Currently Watching
        <span class="tab-badge" id="watchingBadge">0</span>
      </button>
      <button id="wishlistTab" class="tab"data-testid="wishlist-tab">
        ğŸ“– Want to Watch
        <span class="tab-badge" id="wishlistBadge">0</span>
      </button>
      <button id="watchedTab" class="tab" data-testid="watched-tab">
        âœ… Already Watched
        <span class="tab-badge" id="watchedBadge">0</span>
      </button>
    </div>

    <!-- HOME TAB -->
    <div id="homeSection" class="tab-section">
      <!-- Firebase Auth Section -->
      <div id="authSection" class="search-container" style="display: none;">
        <h3 style="color: var(--primary); margin: 0 0 15px 0;">ğŸ” Sign In to Sync Your Data</h3>
        <div style="display: flex; gap: 10px; flex-wrap: wrap; align-items: center;">
          <button id="googleSignIn" data-testid="google-signin-button" style="background: #4285f4;">ğŸ“± Sign in with Google</button>
          <button id="emailSignIn" data-testid="email-signin-button" style="background: var(--purple);">ğŸ“§ Sign in with Email</button>
          <button id="signOut" data-testid="signout-button" style="background: var(--danger); display: none;">ğŸšª Sign Out</button>
        </div>
        <div id="authStatus" style="margin-top: 10px; font-weight: bold;"></div>
      </div>

      <div class="search-container">
        <button id="testNotification" class="notification-test">ğŸ”” Test Push Notifications</button>
        
        <div class="search-row">
          <input type="text" id="searchInput" class="search-input" data-testid="search-input" placeholder="Search for shows or movies...">
          <select id="genreFilter"><option value="">All Genres</option></select>
          <<button id="searchBtn" data-testid="search-button">ğŸ” Search</button>
          <button id="clearSearchBtn" class="secondary" style="display: none;">âœ–ï¸ Clear</button>
        </div>
        
        <div class="search-help">
          ğŸ’¡ <strong><span class="tooltip">Wildcards:<span class="tooltiptext">
            <strong>Wildcard = when your brain is mush and you only remember part of the title.</strong><br><br>
            <strong>Examples:</strong><br>
            â€¢ Type "star*" = shows starting with "star"<br>
            â€¢ Type "*wars" = shows ending with "wars"<br>
            â€¢ Type "*trek*" = shows containing "trek"<br><br>
            Basically, it's search for dummies when you can't remember the full title! ğŸ§ 
          </span></span></strong> "star*" = starts with "star" | "*wars" = ends with "wars" | "*trek*" = contains "trek"
        </div>
        
        <div style="display: flex; gap: 10px; align-items: center; margin-top: 10px;">
          <button id="prevPageBtn" disabled>â† Previous</button>
          <span id="pageInfo" style="font-weight: bold; color: var(--primary);">Page 1</span>
          <button id="nextPageBtn" disabled>Next â†’</button>
        </div>
      </div>

      <div id="searchResults" class="section" style="display: none;">
        <h3>ğŸ¯ Search Results <span class="count" id="resultsCount">0</span></h3>
        <div id="searchResultsList" class="list-container"></div>
      </div>

      <div class="stats">
        <div class="stat" onclick="switchToTab('watching')">
          <div class="stat-num" id="totalWatchingCount">0</div>
          <div class="stat-label">Currently Watching</div>
        </div>
        <div class="stat" onclick="switchToTab('wishlist')">
          <div class="stat-num" id="totalWishlistCount">0</div>
          <div class="stat-label">Want to Watch</div>
        </div>
        <div class="stat" onclick="switchToTab('watched')">
          <div class="stat-num" id="totalWatchedCount">0</div>
          <div class="stat-label">Already Watched</div>
        </div>
        <div class="stat">
          <div class="stat-num" id="totalCount">0</div>
          <div class="stat-label">Total Collection</div>
        </div>
      </div>

      <div style="background: var(--card); padding: 25px; border-radius: 20px; margin: 30px 0; border: 2px solid var(--primary);">
        <h3 style="color: var(--primary); margin-top: 0;">ğŸ’¾ Backup Your Questionable Taste</h3>
        <div style="display: flex; gap: 10px; flex-wrap: wrap; align-items: center; margin-bottom: 15px;">
          <input type="file" id="importFile" accept=".json" style="max-width: 200px;">
          <button id="exportBtn" class="success" data-testid="export-button">ğŸ“¤ Export My Shame</button>
          <button id="clearAllBtn" class="danger" data-testid="clear-all-button">ğŸ—‘ï¸ Nuclear Option</button>
        </div>
        <div style="display: flex; gap: 10px; flex-wrap: wrap; align-items: center;">
          <button id="aboutBtn" class="secondary" data-testid="about-button">â„¹ï¸ About Flicklet</button>
          <button id="usageStatsBtn" class="secondary" data-testid="stats-button">ğŸ“Š Usage Stats</button>
          <button onclick="toggleContentFilter()" class="secondary" id="filterBtn">ğŸ­ Show All Content</button>
        </div>
      </div>
    </div>

    <!-- CURRENTLY WATCHING TAB -->
    <div id="watchingSection" class="tab-section" style="display: none;">
      <div class="section">
        <div class="section-header">
          <div>
            <h3>â–¶ï¸ Currently Watching <span class="count" id="watchingCount">0</span></h3>
            <div class="section-subtitle">Shows and movies you're actually committed to... for now</div>
          </div>
        </div>
        <div id="watchingList" class="list-container">
          <div class="empty-state sassy-empty">No shows yet? What are you, productive or something? ğŸ™„</div>
        </div>
      </div>
    </div>

    <!-- WANT TO WATCH TAB -->
    <div id="wishlistSection" class="tab-section" style="display: none;">
      <div class="section">
        <div class="section-header">
          <div>
            <h3>ğŸ“– Want to Watch <span class="count" id="wishlistCount">0</span></h3>
            <div class="section-subtitle">Your digital hoarding collection of "I'll definitely watch this someday"</div>
          </div>
        </div>
        <div id="wishlistList" class="list-container">
          <div class="empty-state sassy-empty">Your wishlist is emptier than a Netflix comedy special ğŸ’€</div>
        </div>
      </div>
    </div>

    <!-- ALREADY WATCHED TAB -->
    <div id="watchedSection" class="tab-section" style="display: none;">
      <div class="section">
        <div class="section-header">
          <div>
            <h3>âœ… Already Watched <span class="count" id="watchedCount">0</span></h3>
            <div class="section-subtitle">Your bragging rights collection and relationship argument ammunition</div>
          </div>
        </div>
        <div id="watchedList" class="list-container">
          <div class="empty-state sassy-empty">Nothing completed yet? Commitment issues much? ğŸ˜</div>
        </div>
      </div>
    </div>

    <div class="easter-egg" id="easterEgg">ğŸ­</div>
    <div class="feedback-button" id="feedbackBtn">ğŸ’¬</div>
  </div>

  <script>
    // Core Application Logic
    const TMDB_IMG_BASE = 'https://image.tmdb.org/t/p/w200';
    const API_BASE = '/.netlify/functions/tmdb';
    
    let currentPage = 1, searchCache = [], currentActiveTab = 'home';
    
    const appData = {
      tv: { watching: [], wishlist: [], watched: [] },
      movies: { watching: [], wishlist: [], watched: [] },
      settings: { theme: 'light', displayName: '' }
    };

    // Content filtering
    let showMoviesOnly = false;
    let showTVOnly = false;

    // Push Notifications Implementation
    function initPushNotifications() {
      if ('Capacitor' in window && window.Capacitor.Plugins) {
        const { PushNotifications } = window.Capacitor.Plugins;

        PushNotifications.requestPermissions().then(result => {
          if (result.receive === 'granted') {
            console.log('Push notification permission granted');
            PushNotifications.register();
          } else {
            console.log('Push notification permission denied');
          }
        });

        PushNotifications.addListener('registration', (token) => {
          console.log('Push registration success, token: ' + token.value);
        });

        PushNotifications.addListener('registrationError', (error) => {
          console.log('Error on registration: ' + JSON.stringify(error));
        });

        PushNotifications.addListener('pushNotificationReceived', (notification) => {
          console.log('Push received: ' + JSON.stringify(notification));
          showNotification('New notification: ' + notification.body, 'info');
        });

        PushNotifications.addListener('pushNotificationActionPerformed', (notification) => {
          console.log('Push action performed: ' + JSON.stringify(notification));
        });
      } else {
        console.log('Push notifications not available - running in browser');
      }
    }

    // Test notification function
    function testNotification() {
  // Check if notifications are supported
  if (!('Notification' in window)) {
    showNotification('This browser does not support notifications.', 'warning');
    return;
  }
  
  // Check current permission
  if (Notification.permission === 'granted') {
    // Show test notification
    try {
      const notification = new Notification('Flicklet Test! ğŸ“º', {
        body: 'Your notifications are working perfectly! ğŸ‰',
        icon: '/icons/icon-192.png',
        badge: '/icons/icon-72.png',
        tag: 'flicklet-test',
        requireInteraction: false
      });
      
      // Auto-close after 4 seconds
      setTimeout(() => notification.close(), 4000);
      
      showNotification('Test notification sent! Check your system notifications.', 'success');
    } catch (error) {
      console.error('Notification error:', error);
      showNotification('Notification failed to display.', 'error');
    }
  } else if (Notification.permission === 'denied') {
    showNotification('Notifications are blocked. Please enable them in your browser settings.', 'warning');
    showNotificationInstructions();
  } else {
    // Request permission
    Notification.requestPermission().then(permission => {
      if (permission === 'granted') {
        testNotification(); // Retry now that we have permission
      } else {
        showNotification('Notification permission denied.', 'warning');
      }
    });
  }
}
function showNotificationInstructions() {
  const instructions = {
    'Chrome': 'Click the ğŸ”’ icon in the address bar â†’ Notifications â†’ Allow',
    'Firefox': 'Click the shield icon â†’ Permissions â†’ Notifications â†’ Allow',
    'Safari': 'Safari â†’ Preferences â†’ Websites â†’ Notifications â†’ Allow',
    'Edge': 'Click the ğŸ”’ icon in the address bar â†’ Notifications â†’ Allow'
  };
  
  const browser = getBrowserName();
  const instruction = instructions[browser] || 'Check your browser settings for notification permissions';
  
  showNotification(`Enable notifications: ${instruction}`, 'info');
}

function getBrowserName() {
  const userAgent = navigator.userAgent;
  if (userAgent.includes('Chrome') && !userAgent.includes('Edge')) return 'Chrome';
  if (userAgent.includes('Firefox')) return 'Firefox';
  if (userAgent.includes('Safari') && !userAgent.includes('Chrome')) return 'Safari';
  if (userAgent.includes('Edge')) return 'Edge';
  return 'Unknown';
}

    // Simple modal functions - NO closeModal references
    function showAboutModal() {
      const backdrop = document.createElement('div');
      backdrop.style.position = 'fixed';
      backdrop.style.top = '0';
      backdrop.style.left = '0';
      backdrop.style.width = '100%';
      backdrop.style.height = '100%';
      backdrop.style.backgroundColor = 'rgba(0,0,0,0.8)';
      backdrop.style.zIndex = '2000';
      backdrop.style.display = 'flex';
      backdrop.style.alignItems = 'center';
      backdrop.style.justifyContent = 'center';
      backdrop.style.padding = '20px';
      
      const modal = document.createElement('div');
      modal.style.backgroundColor = 'var(--bg)';
      modal.style.padding = '30px';
      modal.style.borderRadius = '20px';
      modal.style.maxWidth = '500px';
      modal.style.width = '100%';
      modal.style.color = 'var(--text)';
      modal.style.boxShadow = '0 20px 60px rgba(0,0,0,0.3)';
      modal.style.border = '2px solid var(--primary)';
      
      modal.innerHTML = '<h2 style="color: var(--primary); margin: 0 0 20px 0; font-size: 24px; text-align: center;">About Flicklet ğŸ“º</h2><div style="line-height: 1.6; font-size: 14px;"><div style="margin-bottom: 20px;"><strong style="color: var(--primary);">Why Flicklet exists:</strong><br>Because tracking your TV shows and movies shouldn\'t be harder than actually watching them! Created for people who start 20 shows and finish... maybe 3.</div><div style="margin-bottom: 20px;"><strong style="color: var(--primary);">ğŸ’¾ Your Data:</strong><br>Flicklet is browser-based, so your data stays on your device. If you use it on your phone, that data won\'t magically appear on your computer (and vice versa). Use the Export/Import feature to transfer your collection between devices!</div><div style="margin-bottom: 20px;"><strong style="color: var(--primary);">ğŸš€ Coming Soon:</strong><br>Native mobile app with cloud sync, so your questionable taste follows you everywhere!</div><div style="margin-bottom: 25px;"><strong style="color: var(--primary);">ğŸ› Found a bug or have feedback?</strong><br>We\'re constantly improving Flicklet based on user feedback. Your input helps make this the best TV/movie tracker out there!</div></div><div style="text-align: center;"><button style="background: linear-gradient(45deg, var(--primary), var(--purple)); color: white; border: none; padding: 12px 25px; border-radius: 25px; cursor: pointer; font-weight: bold; font-size: 14px;" onclick="this.closest(\'.backdrop\').remove()">Got it! ğŸ‘</button></div>';
      
      backdrop.className = 'backdrop';
      backdrop.appendChild(modal);
      document.body.appendChild(backdrop);
      
      backdrop.onclick = function(e) {
        if (e.target === backdrop) {
          backdrop.remove();
        }
      };
    }

    function showStatsModal() {
      const stats = getUsageStats();
      const totalShows = (appData.tv.watching.length + appData.tv.wishlist.length + appData.tv.watched.length + appData.movies.watching.length + appData.movies.wishlist.length + appData.movies.watched.length);
      
      const backdrop = document.createElement('div');
      backdrop.style.position = 'fixed';
      backdrop.style.top = '0';
      backdrop.style.left = '0';
      backdrop.style.width = '100%';
      backdrop.style.height = '100%';
      backdrop.style.backgroundColor = 'rgba(0,0,0,0.8)';
      backdrop.style.zIndex = '2000';
      backdrop.style.display = 'flex';
      backdrop.style.alignItems = 'center';
      backdrop.style.justifyContent = 'center';
      backdrop.style.padding = '20px';
      
      const modal = document.createElement('div');
      modal.style.backgroundColor = 'var(--bg)';
      modal.style.padding = '30px';
      modal.style.borderRadius = '20px';
      modal.style.maxWidth = '500px';
      modal.style.width = '100%';
      modal.style.color = 'var(--text)';
      modal.style.boxShadow = '0 20px 60px rgba(0,0,0,0.3)';
      modal.style.border = '2px solid var(--primary)';
      
      modal.innerHTML = '<h2 style="color: var(--primary); margin: 0 0 20px 0; font-size: 24px; text-align: center;">ğŸ“Š Your Flicklet Stats</h2><div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 15px; margin: 20px 0;"><div style="text-align: center; padding: 15px; background: var(--card); border-radius: 10px; border: 1px solid var(--border);"><div style="font-size: 24px; font-weight: bold; color: var(--primary);">' + totalShows + '</div><div style="font-size: 12px; color: #666;">Total Shows</div></div><div style="text-align: center; padding: 15px; background: var(--card); border-radius: 10px; border: 1px solid var(--border);"><div style="font-size: 24px; font-weight: bold; color: var(--primary);">' + (stats.rating || 0) + '</div><div style="font-size: 12px; color: #666;">Ratings Given</div></div><div style="text-align: center; padding: 15px; background: var(--card); border-radius: 10px; border: 1px solid var(--border);"><div style="font-size: 24px; font-weight: bold; color: var(--primary);">' + (stats.share || 0) + '</div><div style="font-size: 12px; color: #666;">Shows Shared</div></div></div><h3 style="color: var(--primary); font-size: 16px; margin: 20px 0 10px 0;">Feature Usage:</h3><div style="background: var(--card); padding: 15px; border-radius: 10px; font-size: 14px; border: 1px solid var(--border);">No usage data yet. Start using features to see stats!</div><div style="text-align: center; margin-top: 25px;"><button style="background: linear-gradient(45deg, var(--primary), var(--purple)); color: white; border: none; padding: 12px 25px; border-radius: 25px; cursor: pointer; font-weight: bold; font-size: 14px;" onclick="this.closest(\'.backdrop\').remove()">Close</button></div>';
      
      backdrop.className = 'backdrop';
      backdrop.appendChild(modal);
      document.body.appendChild(backdrop);
      
      backdrop.onclick = function(e) {
        if (e.target === backdrop) {
          backdrop.remove();
        }
      };
    }

    // Sassy messages for different actions
    const homeMessages = [
      "Back to the beginning.",
      "Here we go again.", 
      "Didn't we just leave here?",
      "Home sweet home (but with more streaming debt).",
      "Welcome back to your digital shame spiral.",
      "Ready for more questionable life choices?",
      "The mothership awaits your return."
    ];

    const loadingMessages = [
      "Finding shows you'll probably abandon after 2 episodes...",
      "Searching the depths of entertainment mediocrity...",
      "Loading... (This is taking longer than your last relationship)",
      "Fetching content that'll judge your life choices...",
      "Retrieving shows you'll add but never watch...",
      "Consulting the algorithm gods...",
      "Preparing your next binge-watching obsession..."
    ];

    const sassyTitles = [
      "Chaos", "Digital Hoarding", "Commitment Issues", "Questionable Taste", 
      "Binge Empire", "Streaming Madness", "Watch List Anarchy", "Media Obsession",
      "Entertainment Addiction", "Viewing Disorder", "Screen Time Shame"
    ];

    function showNotification(message, type = 'success') {
      const notification = document.createElement('div');
      notification.className = `notification ${type}`;
      notification.textContent = message;
      document.body.appendChild(notification);
      
      setTimeout(() => {
        if (notification.parentNode) {
          notification.parentNode.removeChild(notification);
        }
      }, 3000);
    }

    function getRandomMessage(array) {
      return array[Math.floor(Math.random() * array.length)];
    }

    function createLoadingElement() {
      return `<div class="loading-container"><div class="loading-spinner"></div><div class="loading-text">${getRandomMessage(loadingMessages)}</div></div>`;
    }

    function loadAppData() {
      const saved = localStorage.getItem('tvMovieTrackerData');
      if (saved) {
        try {
          const parsedData = JSON.parse(saved);
          if (!parsedData.tv) parsedData.tv = { watching: [], wishlist: [], watched: [] };
          if (!parsedData.movies) parsedData.movies = { watching: [], wishlist: [], watched: [] };
          if (!parsedData.tv.watched) parsedData.tv.watched = [];
          if (!parsedData.movies.watched) parsedData.movies.watched = [];
          if (!parsedData.settings) parsedData.settings = { theme: 'light', displayName: '' };
          
          Object.assign(appData, parsedData);
        } catch (e) {
          console.error('Error loading data:', e);
          showNotification("Failed to load your data. Starting fresh! ğŸ”¥", 'warning');
        }
      }
      
      if (appData.settings.theme === 'dark') {
        document.body.classList.add('dark-mode');
      }
      
      if (appData.settings.displayName) {
        document.getElementById('displayNameInput').value = appData.settings.displayName;
        updateWelcomeText();
        hideNameContainer();
      }
    }

    function updateWelcomeText() {
      const name = appData.settings.displayName;
      if (name) {
        const randomSass = getRandomMessage(sassyTitles);
        document.getElementById('welcomeText').textContent = `${name}'s ${randomSass}`;
      } else {
        document.getElementById('welcomeText').textContent = 'Flicklet';
      }
    }

    function hideNameContainer() {
      const container = document.getElementById('nameContainer');
      if (appData.settings.displayName && container) {
        container.classList.add('hidden');
      }
    }

    function updateDarkModeButton() {
      const isDark = document.body.classList.contains('dark-mode');
      document.getElementById('darkModeToggle').textContent = isDark ? 'â˜€ï¸ Go Light' : 'ğŸŒ™ Go Dark';
    }

    async function saveAppData() {
  // Always save locally as backup
  localStorage.setItem('tvMovieTrackerData', JSON.stringify(appData));
  
  // If user is signed in, also save to Firestore
  if (currentUser) {
    try {
      const userRef = db.collection('users').doc(currentUser.uid);
      
      await userRef.set({
        watchlists: {
          tv: appData.tv,
          movies: appData.movies
        },
        settings: appData.settings,
        lastUpdated: firebase.firestore.FieldValue.serverTimestamp()
      }, { merge: true });
      
      console.log('âœ… Data synced to cloud');
    } catch (error) {
      console.error('âŒ Failed to sync to cloud:', error);
      showNotification('Failed to sync to cloud. Data saved locally.', 'warning');
    }
  }
}
async function loadUserDataFromCloud(userId) {
  try {
    const userRef = db.collection('users').doc(userId);
    const doc = await userRef.get();
    
    if (doc.exists) {
      const cloudData = doc.data();
      if (cloudData.watchlists) {
        // Merge cloud data with local data
        if (cloudData.watchlists.tv) appData.tv = cloudData.watchlists.tv;
        if (cloudData.watchlists.movies) appData.movies = cloudData.watchlists.movies;
        if (cloudData.settings) appData.settings = { ...appData.settings, ...cloudData.settings };
        
        console.log('âœ… Loaded data from cloud');
        updateUI();
        
        // Save merged data locally
        localStorage.setItem('tvMovieTrackerData', JSON.stringify(appData));
        showNotification('Data synced from cloud! ğŸ“', 'success');
      }
    } else {
      console.log('No cloud data found, using local data');
    }
  } catch (error) {
    console.error('âŒ Failed to load from cloud:', error);
    showNotification('Failed to load cloud data. Using local data.', 'warning');
  }
}

    function setupEventListeners() {
      document.getElementById('darkModeToggle').onclick = () => {
        document.body.classList.toggle('dark-mode');
        appData.settings.theme = document.body.classList.contains('dark-mode') ? 'dark' : 'light';
        updateDarkModeButton();
        saveAppData();
        
        const isDark = document.body.classList.contains('dark-mode');
        showNotification(isDark ? "Welcome to the dark side ğŸ˜ˆ" : "Returning to the light! â˜€ï¸", 'success');
      };
      
      document.getElementById('displayNameInput').oninput = (e) => {
        appData.settings.displayName = e.target.value;
        updateWelcomeText();
        saveAppData();
        
        if (e.target.value.trim()) {
          setTimeout(() => hideNameContainer(), 1000);
        }
      };
      
      document.getElementById('homeTab').onclick = () => switchToTab('home');
      document.getElementById('watchingTab').onclick = () => switchToTab('watching');
      document.getElementById('wishlistTab').onclick = () => switchToTab('wishlist');
      document.getElementById('watchedTab').onclick = () => switchToTab('watched');
      
      document.getElementById('searchBtn').onclick = performSearch;
      document.getElementById('searchInput').onkeydown = (e) => {
        if (e.key === 'Enter') performSearch();
      };
      
      document.getElementById('testNotification').onclick = testNotification;
      
      document.getElementById('clearSearchBtn').onclick = clearSearch;
      document.getElementById('searchInput').oninput = updateClearButton;
      document.getElementById('genreFilter').onchange = updateClearButton;
      
      document.getElementById('prevPageBtn').onclick = () => {
        if (currentPage > 1) {
          currentPage--;
          performSearch();
        }
      };
      
      document.getElementById('nextPageBtn').onclick = () => {
        currentPage++;
        performSearch();
      };
      
      document.getElementById('exportBtn').onclick = exportData;
      document.getElementById('importFile').onchange = importData;
      document.getElementById('clearAllBtn').onclick = () => {
        if (confirm('Are you SURE you want to delete everything? This nuclear option cannot be undone! ğŸ’¥')) {
          appData.tv = { watching: [], wishlist: [], watched: [] };
          appData.movies = { watching: [], wishlist: [], watched: [] };
          saveAppData();
          updateUI();
          showNotification("Boom! Everything deleted. Hope you're happy! ğŸ’€", 'error');
        }
      };
      
      document.getElementById('aboutBtn').onclick = showAboutModal;
      document.getElementById('usageStatsBtn').onclick = showStatsModal;
      
      setupEasterEgg();
    }

    function updateClearButton() {
      const hasContent = document.getElementById('searchInput').value.trim() || 
                        document.getElementById('genreFilter').value;
      document.getElementById('clearSearchBtn').style.display = hasContent ? 'inline-block' : 'none';
    }

    function switchToTab(tab) {
      currentActiveTab = tab;
      
      document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
      document.getElementById(tab + 'Tab').classList.add('active');
      
      document.querySelectorAll('.tab-section').forEach(s => s.style.display = 'none');
      document.getElementById(tab + 'Section').style.display = 'block';
      
      if (tab !== 'home') {
        document.getElementById('searchResults').style.display = 'none';
      }
      
      const messages = {
        home: getRandomMessage(homeMessages),
        watching: 'Time to face your current commitments! ğŸ“º',
        wishlist: 'Welcome to your digital hoarding paradise! ğŸ“š',
        watched: 'Behold your completed conquests! ğŸ†'
      };
      
      showNotification(messages[tab], 'success');
    }

    async function performSearch() {
      const query = document.getElementById('searchInput').value.trim();
      const genre = document.getElementById('genreFilter').value;
      
      if (!query && !genre) {
        showNotification('Please enter a search term or select a genre, genius! ğŸ¤”', 'warning');
        return;
      }
      
      const container = document.getElementById('searchResultsList');
      container.innerHTML = createLoadingElement();
      document.getElementById('searchResults').style.display = 'block';
      
      try {
        let processedQuery = query;
        let isWildcardSearch = false;
        let wildcardType = 'none';
        
        if (query.includes('*')) {
          isWildcardSearch = true;
          
          if (query.startsWith('*') && query.endsWith('*')) {
            wildcardType = 'contains';
            processedQuery = query.slice(1, -1);
          } else if (query.startsWith('*')) {
            wildcardType = 'endsWith';
            processedQuery = query.slice(1);
          } else if (query.endsWith('*')) {
            wildcardType = 'startsWith';
            processedQuery = query.slice(0, -1);
          }
          
          if (processedQuery.length === 0) {
            showNotification('Wildcard search needs some text! Try "star*" or "*wars" ğŸ¤”', 'warning');
            return;
          }
          
          showNotification(`ğŸ” Wildcard search: ${wildcardType} "${processedQuery}"`, 'info');
        }
        
        const searchTerm = isWildcardSearch ? processedQuery : query;
        const results = await fetchShowData(searchTerm, currentPage, genre);
        
        let filteredResults = results;
        if (isWildcardSearch && results.length > 0) {
          const searchPattern = processedQuery.toLowerCase();
          filteredResults = results.filter(item => {
            const title = (item.name || item.title || '').toLowerCase();
            
            switch(wildcardType) {
              case 'contains':
                return title.includes(searchPattern);
              case 'endsWith':
                return title.endsWith(searchPattern);
              case 'startsWith':
                return title.startsWith(searchPattern);
              default:
                return title.includes(searchPattern);
            }
          });
          
          if (filteredResults.length !== results.length) {
            showNotification(`Filtered to ${filteredResults.length} shows matching "${query}" ğŸ¯`, 'success');
          }
        }
        
        searchCache = filteredResults;
        displaySearchResults(filteredResults);
        updatePagination();
        
        if (filteredResults.length === 0) {
          if (isWildcardSearch) {
            showNotification(`No shows found matching "${query}". Try a different pattern! ğŸ”`, 'warning');
          } else {
            showNotification('No results found. Try lowering your standards! ğŸ“‰', 'warning');
          }
        } else if (!isWildcardSearch) {
          showNotification(`Found ${filteredResults.length} options for your viewing pleasure! ğŸ¯`, 'success');
        }
      } catch (error) {
        container.innerHTML = `<div style="color: red; text-align: center; padding: 40px; font-weight: bold;">Search failed: ${error.message}<br><br>Maybe try turning it off and on again? ğŸ¤·â€â™‚ï¸</div>`;
        showNotification('Search failed. The internet is judging you! ğŸŒ', 'error');
      }
    }

    async function fetchShowData(query, page = 1, genreFilter = '') {
      let endpoint, params;
  
      if (genreFilter && !query) {
         // Genre browsing
         endpoint = 'discover/tv';
         params = `endpoint=${endpoint}&page=${page}&with_genres=${genreFilter}`;
      } else {
        // Search
        endpoint = 'search/multi';
        params = `endpoint=${endpoint}&page=${page}`;
        if (query) params += `&query=${encodeURIComponent(query)}`;
      }
         
      try {
        const response = await fetch(`${API_BASE}?${params}`);
        
        if (!response.ok) {
          throw new Error(`Search service unavailable (${response.status}). Please try again later.`);
        }
        
        const data = await response.json();
        
        const enhancedResults = await Promise.all(
          (data.results || []).map(async (item) => {
            try {
              if (item.media_type === 'tv' || item.first_air_date) {
                const detailResponse = await fetch(`${API_BASE}?endpoint=tv/${item.id}`);
                if (detailResponse.ok) {
                  const details = await detailResponse.json();
                  return {
                    ...item,
                    status: details.status,
                    number_of_seasons: details.number_of_seasons,
                    number_of_episodes: details.number_of_episodes,
                    last_air_date: details.last_air_date,
                    first_air_date: details.first_air_date,
                    next_episode_to_air: details.next_episode_to_air,
                    last_episode_to_air: details.last_episode_to_air,
                    in_production: details.in_production,
                    genres: details.genres,
                    networks: details.networks
                  };
                }
              } else if (item.media_type === 'movie' || item.release_date) {
                const detailResponse = await fetch(`${API_BASE}?endpoint=movie/${item.id}`);
                if (detailResponse.ok) {
                  const details = await detailResponse.json();
                  return {
                    ...item,
                    status: details.status,
                    release_date: details.release_date,
                    genres: details.genres
                  };
                }
              }
            } catch (e) {
              console.log('Failed to fetch details for:', item.name || item.title);
            }
            return item;
          })
        );
        
        return enhancedResults;
      } catch (error) {
        console.error('Fetch error:', error);
        throw new Error('Search temporarily unavailable. Our servers are probably binge-watching something! ğŸ“º');
      }
    }

    async function loadGenres() {
      try {
        const response = await fetch(`${API_BASE}?endpoint=genre/tv/list`);
        
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const data = await response.json();
        const select = document.getElementById('genreFilter');
        select.innerHTML = '<option value="">All Genres</option>';
        
        if (data.genres && data.genres.length > 0) {
          data.genres.forEach(genre => {
            select.innerHTML += `<option value="${genre.id}">${genre.name}</option>`;
          });
        }
      } catch (error) {
        console.error('Error loading genres:', error);
        const select = document.getElementById('genreFilter');
        const fallbackGenres = [
          {id: 10759, name: 'Action & Adventure'}, {id: 16, name: 'Animation'}, 
          {id: 35, name: 'Comedy'}, {id: 80, name: 'Crime'}, 
          {id: 99, name: 'Documentary'}, {id: 18, name: 'Drama'}, 
          {id: 10765, name: 'Sci-Fi & Fantasy'}
        ];
        
        select.innerHTML = '<option value="">All Genres</option>';
        fallbackGenres.forEach(genre => {
          select.innerHTML += `<option value="${genre.id}">${genre.name}</option>`;
        });
      }
    }

    function displaySearchResults(results) {
      const container = document.getElementById('searchResultsList');
      document.getElementById('resultsCount').textContent = results.length;
      
      if (results.length === 0) {
        container.innerHTML = '<div class="empty-state sassy-empty">No results found. Maybe try something that actually exists? ğŸ¤¨</div>';
        return;
      }
      
      container.innerHTML = '';
      results.forEach(item => {
        const card = createShowCard(item, true);
        container.appendChild(card);
      });
    }

    function createShowCard(item, isSearchResult = false) {
      const card = document.createElement('div');
      card.className = 'show-card';
      
      const title = item.name || item.title || 'Unknown Title';
      const date = item.first_air_date || item.release_date || '';
      const rating = item.vote_average ? item.vote_average.toFixed(1) : 'N/A';
      const overview = item.overview || 'No description available.';
      const mediaType = item.media_type || (item.first_air_date ? 'tv' : 'movie');
      card.setAttribute('data-testid', `show-card-${item.id}`);
      card.setAttribute('data-show-title', title);
      card.setAttribute('data-media-type', mediaType);
      const category = mediaType === 'tv' ? 'tv' : 'movies';
      const isInWatching = appData[category] && appData[category].watching && appData[category].watching.some(show => show.id === item.id);
      const isInWishlist = appData[category] && appData[category].wishlist && appData[category].wishlist.some(show => show.id === item.id);
      const isInWatched = appData[category] && appData[category].watched && appData[category].watched.some(show => show.id === item.id);
      
      const posterHtml = item.poster_path ? 
        `<img src="${TMDB_IMG_BASE}${item.poster_path}" alt="${title}" class="show-poster" onclick="openTMDBLink(${item.id}, '${mediaType}')">` : 
        `<div class="poster-placeholder" onclick="openTMDBLink(${item.id}, '${mediaType}')">No Image<br>Available ğŸ“·</div>`;
      
      let actionsHtml = '';
      
      if (isSearchResult) {
        actionsHtml = `
          <div class="show-actions">
            <button onclick="addToList(${JSON.stringify(item).replace(/"/g, '&quot;')}, 'watching')" ${isInWatching ? 'disabled' : ''}>
              ${isInWatching ? 'âœ“ Currently Watching' : 'â–¶ï¸ Currently Watching'}
            </button>
            <button onclick="addToList(${JSON.stringify(item).replace(/"/g, '&quot;')}, 'wishlist')" ${isInWishlist ? 'disabled' : ''}>
              ${isInWishlist ? 'âœ“ In Want to Watch' : 'ğŸ“– Want to Watch'}
            </button>
            <button onclick="addToList(${JSON.stringify(item).replace(/"/g, '&quot;')}, 'watched')" ${isInWatched ? 'disabled' : ''}>
              ${isInWatched ? 'âœ“ Already Watched' : 'âœ… Mark as Watched'}
            </button>
            <button onclick="shareShow(null, ${JSON.stringify(item).replace(/"/g, '&quot;')})" class="secondary">ğŸ“¤ Share</button>
            <button onclick="openTMDBLink(${item.id}, '${mediaType}')" class="secondary">ğŸ”— TMDB Info</button>
          </div>
        `;
      } else {
        const userRating = item.userRating || 0;
        const notes = item.notes || '';
        const tags = item.tags || [];
        const likeStatus = item.likeStatus || 'none';
        const currentSeason = item.currentSeason || '';
        const currentEpisode = item.currentEpisode || '';
        
        actionsHtml = `
          <div class="rating-container">
            <span>Your Rating:</span>
            <div class="star-rating">
              ${[1,2,3,4,5].map(star => 
                `<span class="star ${star <= userRating ? 'active' : ''}" onclick="setRating(${item.id}, ${star})" data-rating="${star}">â­</span>`
              ).join('')}
            </div>
            <div class="like-dislike">
              <button class="like-btn ${likeStatus === 'like' ? 'active' : ''}" onclick="setLikeStatus(${item.id}, 'like')">ğŸ‘</button>
              <button class="dislike-btn ${likeStatus === 'dislike' ? 'active' : ''}" onclick="setLikeStatus(${item.id}, 'dislike')">ğŸ‘</button>
            </div>
          </div>
          
          ${mediaType === 'tv' ? `
            <div class="episode-tracker">
              <strong>Episode Progress:</strong>
              <div class="episode-inputs">
                <input type="number" placeholder="Season" min="1" value="${currentSeason}" onchange="updateEpisodeProgress(${item.id}, 'season', this.value)">
                <input type="number" placeholder="Episode" min="1" value="${currentEpisode}" onchange="updateEpisodeProgress(${item.id}, 'episode', this.value)">
              </div>
              ${getSeriesStatusInfo(item)}
            </div>
          ` : ''}
          
          <div class="tags-container">
            <div style="display: flex; gap: 8px; margin-bottom: 8px;">
              <input type="text" class="tag-input" placeholder="Add tags (horror, comedy, etc.)" id="tagInput-${item.id}" style="flex: 1;">
              <button onclick="addTagFromInput(${item.id})" style="padding: 6px 12px; font-size: 12px; margin: 0;">Add Tag</button>
            </div>
            <div class="tags-display" id="tags-${item.id}">
              ${tags.map(tag => `<span class="tag">${tag} <span class="tag-remove" onclick="removeTag(${item.id}, '${tag}')">Ã—</span></span>`).join('')}
            </div>
          </div>
          
          <div class="notes-container">
            <textarea class="notes-field" placeholder="Your thoughts on this (250 chars)..." maxlength="250" onchange="updateNotes(${item.id}, this.value)" spellcheck="true">${notes}</textarea>
            <div class="char-count ${notes.length > 200 ? 'warning' : ''} ${notes.length > 240 ? 'danger' : ''}">${notes.length}/250</div>
          </div>
          
          <div class="show-actions">
            <button onclick="moveItem(${item.id}, 'watching')" ${isInWatching ? 'disabled' : ''}>â†’ Currently Watching</button>
            <button onclick="moveItem(${item.id}, 'wishlist')" ${isInWishlist ? 'disabled' : ''}>â†’ Want to Watch</button>
            <button onclick="moveItem(${item.id}, 'watched')" ${isInWatched ? 'disabled' : ''}>â†’ Already Watched</button>
            <button class="danger" onclick="removeItemFromCurrentList(${item.id})" title="Remove from current list only">ğŸ—‘ï¸ Remove</button>
            <button onclick="shareShow(${item.id})" class="secondary" title="Share this show">ğŸ“¤ Share</button>
          </div>
        `;
      }
      
      card.innerHTML = `
        ${posterHtml}
        <div class="show-details">
          <h4 class="show-title" onclick="openTMDBLink(${item.id}, '${mediaType}')">
            ${title}
            <span class="external-link">ğŸ”—</span>
          </h4>
          <div class="show-meta">â­ ${rating} ${date ? `â€¢ ${date.split('-')[0]}` : ''} â€¢ ${mediaType.toUpperCase()}</div>
          <div class="show-overview" onclick="this.classList.toggle('expanded')">${overview}</div>
          ${actionsHtml}
        </div>
      `;
      
      return card;
    }

    function openTMDBLink(id, mediaType) {
      const url = `https://www.themoviedb.org/${mediaType}/${id}`;
      window.open(url, '_blank');
      showNotification('Opening TMDB details! ğŸ”—', 'info');
    }

    function setRating(itemId, rating) {
      let item = findItem(itemId);
      if (item) {
        item.userRating = rating;
        saveAppData();
        
        const stars = document.querySelectorAll(`[onclick*="setRating(${itemId}"]`);
        stars.forEach((star, index) => {
          const starRating = parseInt(star.getAttribute('data-rating'));
          if (starRating <= rating) {
            star.classList.add('active');
          } else {
            star.classList.remove('active');
          }
        });
        
        showNotification(`Rated "${item.title}" ${rating} stars! â­`, 'success');
        trackFeatureUsage('rating');
      }
    }

    function addTagFromInput(itemId) {
      const input = document.getElementById(`tagInput-${itemId}`);
      if (input) {
        const tagValue = input.value.trim();
        if (tagValue) {
          addTag(itemId, tagValue);
          input.value = '';
        }
      }
    }

    function handleTagInput(event, itemId) {
      if (event.key === 'Enter') {
        event.preventDefault();
        const tagValue = event.target.value.trim();
        if (tagValue) {
          addTag(itemId, tagValue);
          event.target.value = '';
        }
      }
    }

    function removeItemFromCurrentList(itemId) {
      let item = findItem(itemId);
      if (!item) return;
      
      if (confirm(`Remove "${item.title}" from your current list? ğŸ—‘ï¸`)) {
        let removed = false;
        
        const currentTab = currentActiveTab;
        if (currentTab === 'watching') {
          ['tv', 'movies'].forEach(category => {
            const index = appData[category].watching.findIndex(s => s.id === itemId);
            if (index !== -1) {
              appData[category].watching.splice(index, 1);
              removed = true;
            }
          });
        } else if (currentTab === 'wishlist') {
          ['tv', 'movies'].forEach(category => {
            const index = appData[category].wishlist.findIndex(s => s.id === itemId);
            if (index !== -1) {
              appData[category].wishlist.splice(index, 1);
              removed = true;
            }
          });
        } else if (currentTab === 'watched') {
          ['tv', 'movies'].forEach(category => {
            const index = appData[category].watched.findIndex(s => s.id === itemId);
            if (index !== -1) {
              appData[category].watched.splice(index, 1);
              removed = true;
            }
          });
        }
        
        if (removed) {
          saveAppData();
          updateUI();
          showNotification(`"${item.title}" removed from current list! ğŸš€`, 'success');
          trackFeatureUsage('remove');
        }
      }
    }

    function removeItem(itemId) {
      if (confirm('Remove this item from ALL lists? It\'s probably for the best... ğŸ—‘ï¸')) {
        let item = null;
        
        ['tv', 'movies'].forEach(category => {
          ['watching', 'wishlist', 'watched'].forEach(list => {
            const found = appData[category][list].find(s => s.id === itemId);
            if (found) item = found;
            appData[category][list] = appData[category][list].filter(s => s.id !== itemId);
          });
        });
        
        saveAppData();
        updateUI();
        
        showNotification(`"${item?.title || 'Item'}" has been yeeted into the void! ğŸš€`, 'success');
        trackFeatureUsage('removeAll');
      }
    }

    function shareShow(itemId, itemData = null) {
      let item = itemId ? findItem(itemId) : itemData;
      if (!item) return;
      
      const title = item.title || item.name;
      const shareText = `Check out "${title}" on Flicklet! ğŸ¬\n\nI'm tracking this ${item.media_type === 'tv' ? 'TV show' : 'movie'} and thought you might like it too!`;
      
      if (navigator.share) {
        navigator.share({
          title: `${title} - Flicklet`,
          text: shareText,
          url: window.location.href
        }).then(() => {
          showNotification('Shared successfully! ğŸ“¤', 'success');
          trackFeatureUsage('share');
        }).catch(() => {
          fallbackShare(shareText);
        });
      } else {
        fallbackShare(shareText);
      }
    }

    function fallbackShare(text) {
      if (navigator.clipboard) {
        navigator.clipboard.writeText(text).then(() => {
          showNotification('Share text copied to clipboard! ğŸ“‹', 'success');
          trackFeatureUsage('share');
        });
      } else {
        const textArea = document.createElement('textarea');
        textArea.value = text;
        document.body.appendChild(textArea);
        textArea.select();
        document.execCommand('copy');
        document.body.removeChild(textArea);
        showNotification('Share text copied to clipboard! ğŸ“‹', 'success');
        trackFeatureUsage('share');
      }
    }

    function trackFeatureUsage(feature) {
      const usage = JSON.parse(localStorage.getItem('showlyUsageStats') || '{}');
      usage[feature] = (usage[feature] || 0) + 1;
      usage.lastUsed = new Date().toISOString();
      localStorage.setItem('showlyUsageStats', JSON.stringify(usage));
    }

    function getUsageStats() {
      return JSON.parse(localStorage.getItem('showlyUsageStats') || '{}');
    }

    function setLikeStatus(itemId, status) {
      let item = findItem(itemId);
      if (item) {
        item.likeStatus = item.likeStatus === status ? 'none' : status;
        saveAppData();
        updateUI();
        
        const messages = {
          like: 'You liked this! ğŸ‘',
          dislike: 'You disliked this! ğŸ‘',
          none: 'Rating cleared! ğŸ¤·â€â™‚ï¸'
        };
        showNotification(`${item.title}: ${messages[item.likeStatus]}`, 'success');
      }
    }

    function updateNotes(itemId, notes) {
      let item = findItem(itemId);
      if (item) {
        item.notes = notes;
        saveAppData();
      }
    }

    function updateEpisodeProgress(itemId, type, value) {
      let item = findItem(itemId);
      if (item) {
        if (type === 'season') {
          item.currentSeason = value;
        } else if (type === 'episode') {
          item.currentEpisode = value;
        }
        saveAppData();
        showNotification(`Updated ${type} progress! ğŸ“º`, 'success');
      }
    }

    function addTag(itemId, tagValue) {
      let item = findItem(itemId);
      if (item && !item.tags.includes(tagValue)) {
        item.tags.push(tagValue);
        saveAppData();
        updateUI();
        showNotification(`Added tag "${tagValue}" to ${item.title}! ğŸ·ï¸`, 'success');
      }
    }

    function removeTag(itemId, tagValue) {
      let item = findItem(itemId);
      if (item) {
        item.tags = item.tags.filter(tag => tag !== tagValue);
        saveAppData();
        updateUI();
        showNotification(`Removed tag "${tagValue}" from ${item.title}! ğŸ—‘ï¸`, 'success');
      }
    }

    function findItem(itemId) {
      let found = null;
      ['tv', 'movies'].forEach(category => {
        ['watching', 'wishlist', 'watched'].forEach(list => {
          const item = appData[category][list].find(s => s.id === itemId);
          if (item) found = item;
        });
      });
      return found;
    }

    function getSeriesStatusInfo(item) {
      if (!item || item.media_type !== 'tv') return '';
      
      const status = item.status;
      const lastAirDate = item.last_air_date;
      const nextEpisode = item.next_episode_to_air;
      const lastEpisode = item.last_episode_to_air;
      const seasons = item.number_of_seasons;
      const inProduction = item.in_production;
      
      let statusClass = 'status-ongoing';
      let statusText = '';
      
      if (status === 'Ended' || status === 'Canceled') {
        statusClass = 'status-ended';
        if (lastEpisode) {
          const lastEp = lastEpisode;
          statusText = `<div class="episode-info">Series Complete</div>
                       <div class="air-date">Final: S${lastEp.season_number}E${lastEp.episode_number} - ${formatDate(lastEp.air_date)}</div>`;
        } else if (lastAirDate) {
          statusText = `<div class="episode-info">Series Complete</div>
                       <div class="air-date">Last aired: ${formatDate(lastAirDate)}</div>`;
        } else {
          statusText = `<div class="episode-info">Series Complete</div>
                       <div class="air-date">${seasons ? `${seasons} seasons total` : 'Status: Ended'}</div>`;
        }
      } else if (status === 'Returning Series' || inProduction) {
        statusClass = 'status-ongoing';
        if (nextEpisode) {
          const nextEp = nextEpisode;
          statusText = `<div class="episode-info">Currently Airing</div>
                       <div class="air-date">Next: S${nextEp.season_number}E${nextEp.episode_number} - ${formatDate(nextEp.air_date)}</div>`;
        } else if (lastEpisode) {
          const lastEp = lastEpisode;
          statusText = `<div class="episode-info">Season ${lastEp.season_number} Ongoing</div>
                       <div class="air-date">Latest: S${lastEp.season_number}E${lastEp.episode_number} - ${formatDate(lastEp.air_date)}</div>`;
        } else if (lastAirDate) {
          statusText = `<div class="episode-info">Currently Airing</div>
                       <div class="air-date">Last episode: ${formatDate(lastAirDate)}</div>`;
        } else {
          statusText = `<div class="episode-info">Returning Series</div>
                       <div class="air-date">${seasons ? `${seasons} seasons so far` : 'Status: Ongoing'}</div>`;
        }
      } else if (status === 'In Production') {
        statusClass = 'status-upcoming';
        const firstAir = item.first_air_date;
        if (firstAir && new Date(firstAir) > new Date()) {
          statusText = `<div class="episode-info">Coming Soon</div>
                       <div class="air-date">Premieres: ${formatDate(firstAir)}</div>`;
        } else {
          statusText = `<div class="episode-info">In Production</div>
                       <div class="air-date">Release date TBA</div>`;
        }
      } else {
        if (lastAirDate) {
          statusText = `<div class="episode-info">${status || 'Status Unknown'}</div>
                       <div class="air-date">Last aired: ${formatDate(lastAirDate)}</div>`;
        } else {
          statusText = `<div class="episode-info">${status || 'Status Unknown'}</div>
                       <div class="air-date">${seasons ? `${seasons} seasons` : 'Air dates unknown'}</div>`;
        }
      }
      
      return `<div class="series-status ${statusClass}">${statusText}</div>`;
    }

    function formatDate(dateString) {
      if (!dateString) return 'Date unknown';
      try {
        const date = new Date(dateString);
        return date.toLocaleDateString('en-US', { 
          year: 'numeric', 
          month: 'short', 
          day: 'numeric' 
        });
      } catch (e) {
        return dateString;
      }
    }

    function addToList(item, listType) {
      const mediaType = item.media_type || (item.first_air_date ? 'tv' : 'movie');
      const category = mediaType === 'tv' ? 'tv' : 'movies';
      
      const newItem = {
        id: item.id,
        title: item.name || item.title,
        overview: item.overview,
        poster_path: item.poster_path,
        date: item.first_air_date || item.release_date,
        rating: item.vote_average,
        media_type: mediaType,
        date_added: new Date().toISOString(),
        userRating: 0,
        likeStatus: 'none',
        notes: '',
        tags: [],
        currentSeason: '',
        currentEpisode: '',
        status: item.status,
        number_of_seasons: item.number_of_seasons,
        number_of_episodes: item.number_of_episodes,
        last_air_date: item.last_air_date,
        first_air_date: item.first_air_date,
        next_episode_to_air: item.next_episode_to_air,
        last_episode_to_air: item.last_episode_to_air,
        in_production: item.in_production
      };
      
      if (!appData[category][listType].some(show => show.id === item.id)) {
        appData[category][listType].push(newItem);
        saveAppData();
        updateUI();
        performSearch();
        
        const listNames = { 
          watching: 'Currently Watching', 
          wishlist: 'Want to Watch',
          watched: 'Already Watched'
        };
        showNotification(`Added "${newItem.title}" to ${listNames[listType]}! ğŸ‰`, 'success');
        
        if ('Notification' in window && Notification.permission === 'granted') {
          setTimeout(() => {
            new Notification('Flicklet', {
              body: `"${newItem.title}" added to your ${listNames[listType]} list! ğŸ¬`,
              icon: 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><rect width="100" height="100" fill="%23ff6b6b"/><text x="50" y="55" font-size="40" text-anchor="middle" fill="white">ğŸ“º</text></svg>'
            });
          }, 1000);
        }
      } else {
        showNotification('Already on your list, genius! ğŸ™„', 'warning');
      }
    }

    function moveItem(itemId, newListType) {
      let item = null;
      let fromList = null;
      let category = null;
      
      ['tv', 'movies'].forEach(cat => {
        ['watching', 'wishlist', 'watched'].forEach(list => {
          const found = appData[cat][list].find(s => s.id === itemId);
          if (found) {
            item = found;
            fromList = list;
            category = cat;
          }
        });
      });
      
      if (item && fromList !== newListType) {
        appData[category][fromList] = appData[category][fromList].filter(s => s.id !== itemId);
        
        if (!appData[category][newListType].some(s => s.id === itemId)) {
          appData[category][newListType].push(item);
        }
        
        saveAppData();
        updateUI();
        
        const listNames = { 
          watching: 'Currently Watching', 
          wishlist: 'Want to Watch',
          watched: 'Already Watched'
        };
        showNotification(`Moved "${item.title}" from ${listNames[fromList]} to ${listNames[newListType]}! ğŸ“¦`, 'success');
      } else if (fromList === newListType) {
        showNotification(`"${item?.title}" is already in that list! ğŸ¤·â€â™‚ï¸`, 'warning');
      }
    }

    function updateUI() {
      try {
        const totalWatching = appData.tv.watching.length + appData.movies.watching.length;
        const totalWishlist = appData.tv.wishlist.length + appData.movies.wishlist.length;
        const totalWatched = appData.tv.watched.length + appData.movies.watched.length;
        
        const watchingBadge = document.getElementById('watchingBadge');
        const wishlistBadge = document.getElementById('wishlistBadge');
        const watchedBadge = document.getElementById('watchedBadge');
        
        if (watchingBadge) watchingBadge.textContent = totalWatching;
        if (wishlistBadge) wishlistBadge.textContent = totalWishlist;
        if (watchedBadge) watchedBadge.textContent = totalWatched;
        
        const totalWatchingCount = document.getElementById('totalWatchingCount');
        const totalWishlistCount = document.getElementById('totalWishlistCount');
        const totalWatchedCount = document.getElementById('totalWatchedCount');
        const totalCount = document.getElementById('totalCount');
        
        if (totalWatchingCount) totalWatchingCount.textContent = totalWatching;
        if (totalWishlistCount) totalWishlistCount.textContent = totalWishlist;
        if (totalWatchedCount) totalWatchedCount.textContent = totalWatched;
        if (totalCount) totalCount.textContent = totalWatching + totalWishlist + totalWatched;
        
        const watchingCount = document.getElementById('watchingCount');
        const wishlistCount = document.getElementById('wishlistCount');
        const watchedCount = document.getElementById('watchedCount');
        
        if (watchingCount) watchingCount.textContent = totalWatching;
        if (wishlistCount) wishlistCount.textContent = totalWishlist;
        if (watchedCount) watchedCount.textContent = totalWatched;
        
        updateList('watchingList', [...appData.tv.watching, ...appData.movies.watching]);
        updateList('wishlistList', [...appData.tv.wishlist, ...appData.movies.wishlist]);
        updateList('watchedList', [...appData.tv.watched, ...appData.movies.watched]);
      } catch (error) {
        console.error('Error updating UI:', error);
      }
    }

    function updateList(containerId, items) {
      const container = document.getElementById(containerId);
      
      if (!container) {
        console.error('Container not found:', containerId);
        return;
      }
      
      let filteredItems = items;
      if (showTVOnly) {
        filteredItems = items.filter(item => item.media_type === 'tv');
      } else if (showMoviesOnly) {
        filteredItems = items.filter(item => item.media_type === 'movie');
      }
      
      if (filteredItems.length === 0) {
        const emptyMessages = {
          watchingList: 'No shows yet? What are you, productive or something? ğŸ™„',
          wishlistList: 'Your wishlist is emptier than a Netflix comedy special ğŸ’€',
          watchedList: 'Nothing completed yet? Commitment issues much? ğŸ˜'
        };
        
        let message = emptyMessages[containerId];
        if (items.length > 0 && filteredItems.length === 0) {
          message = showTVOnly ? 'No TV shows in this category! ğŸ“º' : 'No movies in this category! ğŸ¬';
        }
        
        container.innerHTML = `<div class="empty-state sassy-empty">${message}</div>`;
      } else {
        container.innerHTML = '';
        filteredItems.forEach(item => {
          try {
            const card = createShowCard(item, false);
            container.appendChild(card);
          } catch (error) {
            console.error('Error creating card for item:', item, error);
          }
        });
      }
    }

    function clearSearch() {
      document.getElementById('searchInput').value = '';
      document.getElementById('genreFilter').value = '';
      document.getElementById('clearSearchBtn').style.display = 'none';
      document.getElementById('searchResults').style.display = 'none';
      currentPage = 1;
      document.getElementById('pageInfo').textContent = 'Page 1';
      document.getElementById('prevPageBtn').disabled = true;
      document.getElementById('nextPageBtn').disabled = true;
      searchCache = [];
      showNotification('Search cleared! Back to square one! ğŸ”„', 'success');
    }

    function updatePagination() {
      document.getElementById('pageInfo').textContent = `Page ${currentPage}`;
      document.getElementById('prevPageBtn').disabled = currentPage === 1;
      document.getElementById('nextPageBtn').disabled = searchCache.length < 20;
    }

    function exportData() {
      const blob = new Blob([JSON.stringify(appData, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `showly-backup-${new Date().toISOString().split('T')[0]}.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      showNotification('Your questionable taste has been exported! ğŸ“¤', 'success');
    }

    function importData(e) {
      const file = e.target.files[0];
      if (!file) return;
      
      const reader = new FileReader();
      reader.onload = function(event) {
        try {
          const imported = JSON.parse(event.target.result);
          if (confirm('Import data? This will overwrite your current collection of digital hoarding! ğŸ’¾')) {
            if (!imported.tv.watched) imported.tv.watched = [];
            if (!imported.movies.watched) imported.movies.watched = [];
            
            Object.assign(appData, imported);
            saveAppData();
            updateUI();
            showNotification('Data imported! Your taste is still questionable! ğŸ‰', 'success');
          }
        } catch (error) {
          showNotification('Invalid file format. Even your backups are broken! ğŸ’¥', 'error');
        }
      };
      reader.readAsText(file);
    }

    function setupEasterEgg() {
      const tips = [
        "Pro tip: Having 500 items in your wishlist doesn't count as productivity! ğŸ¯",
        "Fun fact: 'I'll watch it later' is the most common lie in streaming! ğŸ¤¥",
        "Reality check: You have more shows bookmarked than days in the year! ğŸ“…",
        "Hot take: Your 'Currently Watching' list is more fiction than fantasy movies! ğŸ“š",
        "Reminder: Netflix doesn't pay you to collect shows like PokÃ©mon cards! ğŸƒ",
        "News flash: Starting 20 shows doesn't make you a 'multimedia enthusiast'! ğŸ“º"
      ];

      let clickCount = 0;
      
      setTimeout(() => {
        const easterEgg = document.getElementById('easterEgg');
        const feedbackBtn = document.getElementById('feedbackBtn');
        
        if (easterEgg) {
          easterEgg.onclick = () => {
            clickCount++;
            if (clickCount % 3 === 0) {
              showRandomTip(tips);
            }
          };
        }
        
        if (feedbackBtn) {
          feedbackBtn.onclick = () => {
            showNotification('Feedback feature coming soon! For now, enjoy the sassy tips! ğŸ’¬', 'info');
          };
        }
      }, 500);
    }

    function showRandomTip(tips) {
      const tip = tips[Math.floor(Math.random() * tips.length)];
      const bubble = document.createElement('div');
      bubble.style.position = 'fixed';
      bubble.style.bottom = '80px';
      bubble.style.right = '20px';
      bubble.style.zIndex = '1500';
      bubble.style.background = 'var(--purple)';
      bubble.style.color = 'white';
      bubble.style.padding = '15px 20px';
      bubble.style.borderRadius = '20px';
      bubble.style.maxWidth = '300px';
      bubble.style.fontSize = '13px';
      bubble.style.boxShadow = '0 5px 20px rgba(0,0,0,0.3)';
      bubble.style.animation = 'bubble-bounce 0.5s ease';
      
      bubble.textContent = tip;
      document.body.appendChild(bubble);
      
      setTimeout(() => {
        if (bubble.parentNode) bubble.parentNode.removeChild(bubble);
      }, 7000);
    }

    function toggleContentFilter() {
      const btn = document.getElementById('filterBtn');
      
      if (!showMoviesOnly && !showTVOnly) {
        showTVOnly = true;
        btn.textContent = 'ğŸ“º TV Shows Only';
        showNotification('Filtering to TV shows only! ğŸ“º', 'info');
      } else if (showTVOnly) {
        showTVOnly = false;
        showMoviesOnly = true;
        btn.textContent = 'ğŸ¬ Movies Only';
        showNotification('Filtering to movies only! ğŸ¬', 'info');
      } else {
        showMoviesOnly = false;
        btn.textContent = 'ğŸ­ Show All Content';
        showNotification('Showing all content! ğŸ­', 'info');
      }
      
      updateUI();
      trackFeatureUsage('filter');
    }

    // Initialize app
    document.addEventListener('DOMContentLoaded', () => {
      loadAppData();
      setupEventListeners();
      // Firebase Auth Event Listeners
      document.getElementById('googleSignIn').onclick = signInWithGoogle;
      document.getElementById('emailSignIn').onclick = signInWithEmail;  
      document.getElementById('signOut').onclick = signOut;
      loadGenres();
      updateUI();
      updateDarkModeButton();
      initPushNotifications();
      // Show auth section on load
      document.getElementById('authSection').style.display = 'block';
      
      if ('Notification' in window && Notification.permission === 'default') {
        Notification.requestPermission();
      }
    });

    /* === EPISODE PILL: place to the right of the tags row === */
    (function placeEpisodePill() {
      function move() {
        document.querySelectorAll('.show-card, .movie-card, .card').forEach(card => {
          const ep = card.querySelector('.episode-tracker');
          if (!ep) return;

          const tags = card.querySelector('.tags-container');
          if (!tags) return;

          // Make the row a 2-col grid (input+button | pill)
          tags.classList.add('tags-row-grid');

          // Compact view for the pill
          ep.classList.add('ep-compact');

          // Ensure the tags list spans full width below
          const tagsDisplay = tags.querySelector('.tags-display');

          // Insert the pill BEFORE the tags display so it sits in the first row, right column
          if (tagsDisplay && ep.nextSibling !== tagsDisplay) {
            tags.insertBefore(ep, tagsDisplay);
          } else if (!tagsDisplay && !tags.contains(ep)) {
            tags.appendChild(ep);
          }
        });
      }
      document.addEventListener('DOMContentLoaded', move);
      window.addEventListener('load', move);
      setTimeout(move, 300);
      setTimeout(move, 1200);
    })();
  </script>

  <!-- Firebase v9 SDK -->
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>

  <script>
  // Firebase Configuration
  const firebaseConfig = {
    apiKey: "AIzaSyDEiqf8cxQJ11URcQeE8jqq5EMa5M6zAXM",
    authDomain: "flicklet-71dff.firebaseapp.com",
    projectId: "flicklet-71dff",
    storageBucket: "flicklet-71dff.firebasestorage.app",
    messagingSenderId: "1034923556763",
    appId: "1:1034923556763:web:bba5489cd1d9412c9c2b3e"
  };

  // Initialize Firebase
  firebase.initializeApp(firebaseConfig);

  // Initialize services
  const auth = firebase.auth();
  // Ensure profile exists + bump lastLoginAt on every session
  firebase.auth().onAuthStateChanged(async (user) => {
    if (!user) return;
    try {
      const ref = firebase.firestore().collection('users').doc(user.uid);
      const snap = await ref.get();

      const payload = {
        uid: user.uid,
        email: user.email || null,
        displayName: user.displayName || null,
        photoURL: user.photoURL || null,
        provider: (user.providerData && user.providerData[0])
          ? user.providerData[0].providerId
          : null,
        lastLoginAt: firebase.firestore.FieldValue.serverTimestamp(),
      };

      if (!snap.exists) {
        payload.createdAt = firebase.firestore.FieldValue.serverTimestamp();
      }

      await ref.set(payload, { merge: true });
    } catch (e) {
      console.error('profile upsert on auth state:', e);
    }
  });

  const db = firebase.firestore();

  console.log('ğŸ”¥ Firebase initialized successfully!');

  // Firebase Authentication Functions
  let currentUser = null;

  // Monitor auth state changes
  auth.onAuthStateChanged(async (user) => {
    currentUser = user;
    updateAuthUI(user);
    
    if (user) {
      console.log('âœ… User signed in:', user.email);
      await loadUserDataFromCloud(user.uid);
    } else {
      console.log('âŒ User signed out');
    }
  });

  function updateAuthUI(user) {
    const authSection = document.getElementById('authSection');
    const authStatus = document.getElementById('authStatus');
    const signOut = document.getElementById('signOut');
    const googleSignIn = document.getElementById('googleSignIn');
    const emailSignIn = document.getElementById('emailSignIn');
    
    if (authSection) {
      if (user) {
        authStatus.textContent = `âœ… Signed in as: ${user.email}`;
        authStatus.style.color = 'var(--success)';
        signOut.style.display = 'inline-block';
        googleSignIn.style.display = 'none';
        emailSignIn.style.display = 'none';
      } else {
        authStatus.textContent = 'âŒ Not signed in - data stays local only';
        authStatus.style.color = 'var(--danger)';
        signOut.style.display = 'none';
        googleSignIn.style.display = 'inline-block';
        emailSignIn.style.display = 'inline-block';
      }
    }
  }

  // Google Sign In
  async function signInWithGoogle() {
    try {
      const provider = new firebase.auth.GoogleAuthProvider();
      const result = await auth.signInWithPopup(provider);

      // upsert /users/{uid}
      await firebase.firestore().collection('users').doc(result.user.uid).set({
        uid: result.user.uid,
        email: result.user.email || null,
        displayName: result.user.displayName || null,
        photoURL: result.user.photoURL || null,
        provider: (result.user.providerData && result.user.providerData[0])
          ? result.user.providerData[0].providerId
          : null,
        lastLoginAt: firebase.firestore.FieldValue.serverTimestamp(),
        createdAt: firebase.firestore.FieldValue.serverTimestamp(),
      }, { merge: true });

      showNotification(`Welcome ${result.user.displayName || 'there'}! ğŸ‰`, 'success');
    } catch (error) {
      console.error('Google sign in error:', error);
      showNotification('Google sign in failed. Try again! ğŸ¤·', 'error');
    }
  }

  // Email Sign In
  async function signInWithEmail() {
    const email = prompt('Enter your email:');
    const password = prompt('Enter your password:');
    
    if (email && password) {
      try {
        await auth.signInWithEmailAndPassword(email, password);
        showNotification('Welcome back! ğŸ‰', 'success');
      } catch (error) {
        if (error.code === 'auth/user-not-found') {
          try {
            await auth.createUserWithEmailAndPassword(email, password);
            showNotification('Account created! Welcome! ğŸ‰', 'success');
          } catch (createError) {
            showNotification('Failed to create account. Try again! ğŸ˜…', 'error');
          }
        } else {
          showNotification('Sign in failed. Check your credentials! ğŸ”‘', 'error');
        }
      }
    }
  }

  // Sign Out
  async function signOut() {
    try {
      await auth.signOut();
      showNotification('Signed out successfully! ğŸ‘‹', 'success');
    } catch (error) {
      showNotification('Sign out failed! ğŸ¤”', 'error');
    }
  }
  </script>
</body>
</html>
