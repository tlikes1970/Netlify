<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <!-- Primary Meta Tags -->
  <title>TV Tracker V2 - Your Brutally Honest Entertainment Companion</title>
  <meta name="title" content="TV Tracker V2 - Your Brutally Honest Entertainment Companion">
  <meta name="description" content="Track your TV shows and movies with sassy commentary, custom tags, episode tracking, and more. Never lose track of your binge-watching again!">
  <meta name="keywords" content="tv tracker, movie tracker, streaming, watchlist, tv shows, movies, entertainment, episode tracker">
  <meta name="author" content="TV Tracker">
  
  <!-- Open Graph / Facebook -->
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://tv-movie-tracker.netlify.app/">
  <meta property="og:title" content="TV Tracker V2 - Your Brutally Honest Entertainment Companion">
  <meta property="og:description" content="Track your TV shows and movies with sassy commentary, custom tags, episode tracking, and more. Never lose track of your binge-watching again!">
  <meta property="og:image" content="https://tv-movie-tracker.netlify.app/icons/og-image.png">
  
  <!-- PWA Meta Tags -->
  <meta name="application-name" content="TV Tracker">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="TV Tracker">
  <meta name="theme-color" content="#ff6b6b">
  
  <!-- Favicons -->
  <link rel="icon" type="image/x-icon" href="/icons/favicon.ico">
  <link rel="manifest" href="/manifest.json">
  
  <style>
    :root {
      --bg: #fff; --text: #000; --primary: #ff6b6b; --card: #f9f9f9; --border: #ddd;
      --success: #51cf66; --warning: #ffd43b; --danger: #ff6b6b; --purple: #845ec2;
      --blue: #4dabf7; --orange: #ff8c42; --green: #51cf66;
    }
    
    * { box-sizing: border-box; }
    
    body { 
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; 
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: var(--text); margin: 0; padding: 15px; min-height: 100vh;
      transition: all 0.3s ease;
    }
    
    .dark-mode { 
      --bg: #1a1a1a; --text: #f5f5f5; --card: #2d2d2d; --border: #444;
      background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%) !important;
    }
    
    .main-container {
      max-width: 1400px; margin: 0 auto; background: var(--bg); 
      border-radius: 20px; padding: 25px; box-shadow: 0 20px 60px rgba(0,0,0,0.3);
      transition: all 0.3s ease;
    }
    
    .header { 
      display: flex; justify-content: space-between; align-items: center; 
      padding: 15px 0; border-bottom: 3px dashed var(--primary); margin-bottom: 25px;
      position: relative; flex-wrap: wrap; gap: 15px;
    }
    
    .header::after {
      content: "üõãÔ∏è"; position: absolute; right: 20px; top: 10px; 
      font-size: 24px; animation: couch-bounce 3s ease-in-out infinite;
    }
    
    @keyframes couch-bounce {
      0%, 100% { transform: translateY(0) rotate(0deg); }
      50% { transform: translateY(-5px) rotate(-5deg); }
    }
    
    .title { 
      font-size: clamp(1.8em, 4vw, 2.5em); font-weight: bold; color: var(--primary); 
      margin: 0; cursor: pointer; flex-shrink: 0;
    }
    
    .user-section {
      display: flex; align-items: center; gap: 12px; flex-wrap: wrap;
    }
    
    .name-container {
      display: flex; flex-direction: column; align-items: flex-end;
      transition: all 0.3s ease;
    }
    
    .name-instruction {
      font-size: 11px; color: var(--primary); font-weight: bold;
      margin-bottom: 5px;
    }
    
    .name-input {
      padding: 10px 15px; border: 2px solid var(--primary); border-radius: 25px;
      background: var(--card); color: var(--text); font-weight: bold; font-size: 14px;
    }
    
    .name-container.hidden {
      opacity: 0; transform: scale(0.8); pointer-events: none;
    }
    
    .tab-container { 
      display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      background: var(--card); border-radius: 15px; 
      padding: 8px; margin: 25px 0; gap: 5px;
    }
    
    .tab { 
      padding: 15px 20px; border: none; background: transparent; 
      color: var(--text); cursor: pointer; border-radius: 10px; font-weight: bold;
      transition: all 0.3s ease; font-size: 14px; text-align: center;
      display: flex; align-items: center; justify-content: center; gap: 8px;
    }
    
    .tab.active { 
      background: linear-gradient(45deg, var(--primary), var(--purple)); 
      color: white; transform: scale(1.02);
    }
    
    .tab-badge {
      background: rgba(255,255,255,0.9); color: var(--primary);
      padding: 3px 8px; border-radius: 12px; font-size: 11px;
      font-weight: bold; min-width: 20px;
    }
    
    .tab.active .tab-badge {
      background: rgba(255,255,255,1); color: var(--primary);
    }
    
    button { 
      margin: 4px; padding: 10px 16px; border: none; border-radius: 20px; 
      background: linear-gradient(45deg, var(--primary), var(--purple)); 
      color: white; cursor: pointer; font-weight: bold; font-size: 13px;
      transition: all 0.3s ease; border: 2px solid transparent;
    }
    
    button:hover { 
      transform: translateY(-2px) scale(1.02); 
      box-shadow: 0 5px 15px rgba(0,0,0,0.2);
    }
    
    button:disabled { 
      background: #666; cursor: not-allowed; transform: none; opacity: 0.6;
    }
    
    button.danger { background: linear-gradient(45deg, #ff4757, #ff3742); }
    button.success { background: linear-gradient(45deg, #2ed573, #1dd1a1); }
    button.secondary { background: linear-gradient(45deg, #747d8c, #57606f); }
    button.like { background: linear-gradient(45deg, #2ed573, #1dd1a1); }
    button.dislike { background: linear-gradient(45deg, #ff4757, #ff3742); }
    
    .search-container { 
      background: var(--card); padding: 20px; border-radius: 20px; 
      margin: 25px 0; border: 2px solid var(--primary);
    }
    
    .search-row {
      display: grid; grid-template-columns: 1fr auto auto auto; gap: 12px; margin-bottom: 15px;
      align-items: center;
    }
    
    .search-input {
      padding: 12px 15px; border: 2px solid var(--border); border-radius: 15px;
      background: var(--bg); color: var(--text); font-size: 15px;
      transition: border-color 0.3s ease;
    }
    
    .search-input:focus {
      outline: none; border-color: var(--primary);
    }
    
    .search-help {
      font-size: 12px; color: #666; font-style: italic; margin-bottom: 10px;
      position: relative;
    }
    
    .tooltip {
      position: relative; display: inline-block; cursor: help;
      color: var(--primary); font-weight: bold; text-decoration: underline;
    }
    
    .tooltip .tooltiptext {
      visibility: hidden; width: 300px; background-color: var(--purple);
      color: white; text-align: left; border-radius: 10px;
      padding: 15px; position: absolute; z-index: 1000;
      bottom: 125%; left: 50%; margin-left: -150px;
      opacity: 0; transition: opacity 0.3s; font-style: normal;
      box-shadow: 0 5px 20px rgba(0,0,0,0.3);
    }
    
    .tooltip .tooltiptext::after {
      content: ""; position: absolute; top: 100%; left: 50%;
      margin-left: -5px; border-width: 5px;
      border-style: solid; border-color: var(--purple) transparent transparent transparent;
    }
    
    .tooltip:hover .tooltiptext {
      visibility: visible; opacity: 1;
    }
    
    .pagination {
      display: flex; gap: 10px; align-items: center; justify-content: center;
      margin-top: 15px; flex-wrap: wrap;
    }
    
    input, select { 
      padding: 10px 12px; margin: 4px; border: 2px solid var(--border); 
      border-radius: 12px; background: var(--bg); color: var(--text);
      font-size: 14px; transition: border-color 0.3s ease;
    }
    
    input:focus, select:focus {
      outline: none; border-color: var(--primary);
    }
    
    .section { margin: 30px 0; }
    
    .section-header {
      display: flex; justify-content: space-between; align-items: center;
      margin-bottom: 20px; padding: 10px 0; flex-wrap: wrap; gap: 10px;
    }
    
    .section h3 { 
      color: var(--primary); margin: 0; font-size: clamp(1.3em, 3vw, 1.8em);
      display: flex; align-items: center; gap: 10px;
    }
    
    .section-subtitle {
      font-size: 13px; color: #666; font-style: italic;
      margin-top: 5px; font-weight: normal;
    }
    
    .count { 
      background: linear-gradient(45deg, var(--primary), var(--purple)); 
      color: white; padding: 6px 12px; border-radius: 15px; 
      font-size: 14px; font-weight: bold; cursor: pointer;
    }
    
    .list-container { 
      background: var(--card); border-radius: 15px; padding: 20px; 
      min-height: 80px; border: 2px dashed var(--border);
    }
    
    .show-card { 
      display: grid; grid-template-columns: auto 1fr auto;
      gap: 20px; border: 2px solid var(--border); 
      border-radius: 15px; padding: 20px; margin: 15px 0; 
      background: var(--bg); align-items: start;
      transition: all 0.3s ease;
    }
    
    .show-card:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 20px rgba(0,0,0,0.1);
    }
    
    .show-poster { 
      width: 80px; height: 120px; border-radius: 10px; 
      object-fit: cover; cursor: pointer;
    }
    
    .poster-placeholder { 
      width: 80px; height: 120px; background: #f0f0f0; 
      border-radius: 10px; display: flex; align-items: center; justify-content: center; 
      color: #999; font-size: 11px; font-weight: bold; text-align: center;
    }
    
    .show-details { 
      display: flex; flex-direction: column; gap: 10px; min-width: 0;
    }
    
    .show-title { 
      font-size: 18px; font-weight: bold; margin: 0; 
      cursor: pointer; color: var(--primary);
      display: flex; align-items: center; gap: 10px;
    }
    
    .external-link {
      font-size: 14px; opacity: 0.7; transition: opacity 0.3s ease;
    }
    
    .external-link:hover { opacity: 1; }
    
    .show-meta { 
      color: #666; font-size: 13px; display: flex; flex-wrap: wrap; gap: 10px;
    }
    
    .show-overview { 
      font-size: 13px; line-height: 1.5; max-height: 60px; overflow: hidden; 
      cursor: pointer; transition: max-height 0.3s ease;
    }
    
    .show-overview.expanded { max-height: none; }
    
    .show-status {
      display: flex; flex-wrap: wrap; gap: 8px; margin: 10px 0;
    }
    
    .status-badge {
      padding: 4px 10px; border-radius: 12px; font-size: 11px;
      font-weight: bold; color: white;
    }
    
    .status-ongoing { background: var(--success); }
    .status-ended { background: var(--danger); }
    .status-unknown { background: #666; }
    
    .episode-tracker {
      background: var(--card); padding: 12px; border-radius: 10px;
      border: 2px dashed var(--border); margin: 10px 0;
    }
    
    .episode-inputs {
      display: grid; grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
      gap: 8px; margin-bottom: 10px;
    }
    
    .episode-inputs input {
      margin: 0; padding: 8px; font-size: 12px;
      text-align: center;
    }
    
    .rating-container {
      display: flex; align-items: center; gap: 10px; margin: 10px 0;
      flex-wrap: wrap;
    }
    
    .star-rating {
      display: flex; gap: 2px;
    }
    
    .star {
      font-size: 18px; cursor: pointer; transition: all 0.2s ease;
      color: #ddd;
    }
    
    .star:hover, .star.active { 
      color: #ffd700; transform: scale(1.1);
    }
    
    .like-dislike {
      display: flex; gap: 8px; align-items: center;
    }
    
    .notes-container {
      margin: 10px 0;
    }
    
    .notes-field {
      width: 100%; min-height: 50px; padding: 10px;
      border: 2px dashed var(--border); border-radius: 10px;
      background: var(--card); color: var(--text); resize: vertical;
      font-family: inherit; font-size: 13px;
    }
    
    .char-count {
      font-size: 11px; color: #999; text-align: right; margin-top: 5px;
    }
    
    .char-count.warning { color: var(--warning); }
    .char-count.danger { color: var(--danger); }
    
    .tags-container {
      margin: 10px 0;
    }
    
    .tag-input {
      width: 100%; padding: 8px; font-size: 12px;
      margin-bottom: 8px;
    }
    
    .tags-display {
      display: flex; flex-wrap: wrap; gap: 6px;
    }
    
    .tag {
      background: var(--purple); color: white; padding: 4px 8px;
      border-radius: 15px; font-size: 11px; font-weight: bold;
      display: flex; align-items: center; gap: 5px;
    }
    
    .tag-remove {
      cursor: pointer; font-weight: bold;
    }
    
    .show-actions { 
      display: flex; flex-direction: column; gap: 10px; min-width: 200px;
    }
    
    .action-row {
      display: flex; gap: 8px; flex-wrap: wrap;
    }
    
    .show-actions button { 
      flex: 1; min-width: 80px; padding: 8px 12px; font-size: 11px; 
      margin: 2px; white-space: nowrap;
    }
    
    .show-actions input { 
      flex: 1; min-width: 120px; padding: 6px 10px; font-size: 11px; 
      margin: 2px;
    }
    
    .favorite.active { 
      background: linear-gradient(45deg, #ffd700, #ffed4e); 
      color: #000;
    }
    
    .empty-state { 
      text-align: center; color: #666; padding: 40px 20px; 
      font-style: italic; font-size: 16px;
    }
    
    .sassy-empty { 
      font-weight: bold; color: var(--primary);
    }
    
    .stats { 
      display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 15px; margin: 25px 0;
    }
    
    .stat { 
      background: var(--card); padding: 20px; border-radius: 15px; 
      text-align: center; border: 2px solid var(--primary); cursor: pointer;
      transition: all 0.3s ease;
    }
    
    .stat:hover { 
      transform: translateY(-3px); 
      box-shadow: 0 8px 25px rgba(0,0,0,0.15);
    }
    
    .stat-num { 
      font-size: 2.2em; font-weight: bold; color: var(--primary); 
      margin-bottom: 5px;
    }
    
    .stat-label { 
      font-size: 11px; color: #666; font-weight: bold; 
      text-transform: uppercase; letter-spacing: 0.5px;
    }
    
    .notification {
      position: fixed; top: 20px; right: 20px; z-index: 2000;
      padding: 15px 25px; border-radius: 10px; color: white;
      font-weight: bold; max-width: 350px;
      animation: slide-in 0.5s ease, slide-out 0.5s ease 4s forwards;
      box-shadow: 0 5px 20px rgba(0,0,0,0.3);
    }
    
    @keyframes slide-in {
      from { transform: translateX(100%); opacity: 0; }
      to { transform: translateX(0); opacity: 1; }
    }
    
    @keyframes slide-out {
      from { transform: translateX(0); opacity: 1; }
      to { transform: translateX(100%); opacity: 0; }
    }
    
    .notification.success { background: var(--success); }
    .notification.error { background: var(--danger); }
    .notification.warning { background: var(--warning); color: #000; }
    .notification.info { background: var(--purple); }
    
    .loading-container {
      text-align: center; padding: 40px;
    }
    
    .loading-spinner {
      width: 40px; height: 40px; border: 4px solid var(--border);
      border-top: 4px solid var(--primary); border-radius: 50%;
      animation: spin 1s linear infinite; margin: 0 auto 15px;
    }
    
    @keyframes spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }
    
    .loading-text {
      font-weight: bold; color: var(--primary); font-size: 14px;
    }
    
    .easter-egg {
      position: fixed; bottom: 20px; right: 20px; 
      background: var(--purple); color: white; padding: 12px; 
      border-radius: 50%; cursor: pointer; z-index: 1000;
      font-size: 18px; width: 50px; height: 50px;
      display: flex; align-items: center; justify-content: center;
      transition: all 0.3s ease;
    }
    
    .easter-egg:hover {
      transform: scale(1.1);
    }
    
    .feedback-button {
      position: fixed; bottom: 90px; right: 20px; 
      background: var(--primary); color: white; padding: 12px; 
      border-radius: 50%; cursor: pointer; z-index: 1001;
      font-size: 16px; width: 50px; height: 50px;
      display: flex; align-items: center; justify-content: center;
      transition: all 0.3s ease;
    }
    
    .feedback-button:hover {
      transform: scale(1.1);
    }
    
    .modal {
      position: fixed; top: 0; left: 0; right: 0; bottom: 0; 
      background: rgba(0,0,0,0.8); z-index: 3000; 
      display: flex; align-items: center; justify-content: center;
      padding: 20px;
    }
    
    .modal-content {
      background: var(--bg); border-radius: 20px; 
      max-width: 600px; width: 100%; max-height: 90vh; overflow-y: auto;
      border: 2px solid var(--primary);
    }
    
    .modal-header {
      padding: 20px 25px 0; display: flex; justify-content: space-between; 
      align-items: center; border-bottom: 2px dashed var(--primary); margin-bottom: 20px;
    }
    
    .modal-header h3 {
      margin: 0; color: var(--primary); font-size: 1.4em;
    }
    
    .close-btn {
      background: none; border: none; font-size: 20px; 
      cursor: pointer; color: var(--text); padding: 5px; margin: 0;
    }
    
    .modal-body {
      padding: 0 25px 25px;
    }
    
    .tip-bubble {
      position: fixed; bottom: 80px; right: 20px; z-index: 1500;
      background: var(--purple); color: white; padding: 15px 20px;
      border-radius: 20px; max-width: 300px; font-size: 13px;
      box-shadow: 0 5px 20px rgba(0,0,0,0.3);
      animation: bubble-bounce 0.5s ease;
    }
    
    @keyframes bubble-bounce {
      0% { transform: scale(0) translateY(20px); opacity: 0; }
      100% { transform: scale(1) translateY(0); opacity: 1; }
    }
    
    .filter-container {
      background: var(--card); padding: 15px; border-radius: 15px;
      margin: 15px 0; border: 2px solid var(--border);
    }
    
    .filter-row {
      display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 10px; align-items: center;
    }
    
    .share-buttons {
      display: flex; gap: 8px; flex-wrap: wrap; margin: 10px 0;
    }
    
    .share-btn {
      padding: 6px 12px; font-size: 11px; border-radius: 15px;
      background: var(--blue); color: white; border: none;
      cursor: pointer; transition: all 0.3s ease;
    }
    
    .share-btn:hover {
      transform: translateY(-2px);
    }
    
    /* Responsive Design */
    @media (max-width: 768px) {
      .main-container { 
        padding: 15px; margin: 10px; border-radius: 15px;
      }
      
      .header { 
        flex-direction: column; text-align: center; gap: 10px;
      }
      
      .header::after { display: none; }
      
      .title { font-size: 2em; }
      
      .tab-container {
        grid-template-columns: 1fr 1fr;
        gap: 8px;
      }
      
      .tab {
        padding: 12px 15px; font-size: 12px;
      }
      
      .search-row {
        grid-template-columns: 1fr;
      }
      
      .show-card { 
        grid-template-columns: 1fr;
        gap: 15px; padding: 15px; text-align: center;
      }
      
      .show-poster, .poster-placeholder { 
        width: 60px; height: 90px; margin: 0 auto;
      }
      
      .show-actions {
        min-width: auto;
      }
      
      .stats { 
        grid-template-columns: repeat(2, 1fr);
        gap: 10px;
      }
      
      .stat { padding: 15px; }
      
      .stat-num { font-size: 1.8em; }
    }
    
    @media (orientation: landscape) and (max-height: 500px) {
      .main-container {
        padding: 10px;
      }
      
      .header {
        padding: 10px 0;
        margin-bottom: 15px;
      }
      
      .tab-container {
        margin: 15px 0;
      }
      
      .section {
        margin: 20px 0;
      }
    }
  </style>
</head>
<body>
  <div class="main-container">
    <div class="header">
      <h1 class="title" id="welcomeText">TV Tracker V2</h1>
      <div class="user-section">
        <div class="name-container" id="nameContainer">
          <div class="name-instruction">üëÜ Add your name for a personal touch!</div>
          <input type="text" id="displayNameInput" class="name-input" placeholder="Your name here...">
        </div>
        <button id="darkModeToggle">üåô Go Dark</button>
      </div>
    </div>

    <div class="tab-container">
      <button id="homeTab" class="tab active">
        üè† Home
        <span class="tab-badge">Overview</span>
      </button>
      <button id="watchingTab" class="tab">
        ‚ñ∂Ô∏è Currently Watching
        <span class="tab-badge" id="watchingBadge">0</span>
      </button>
      <button id="wishlistTab" class="tab">
        üìñ Want to Watch
        <span class="tab-badge" id="wishlistBadge">0</span>
      </button>
      <button id="watchedTab" class="tab">
        ‚úÖ Already Watched
        <span class="tab-badge" id="watchedBadge">0</span>
      </button>
    </div>

    <!-- HOME TAB -->
    <div id="homeSection" class="tab-section">
      <div class="search-container">
        <div class="search-row">
          <input type="text" id="searchInput" class="search-input" placeholder="Search for shows or movies...">
          <select id="genreFilter"><option value="">All Genres</option></select>
          <button id="searchBtn">üîç Search</button>
          <button id="clearSearchBtn" class="secondary" style="display: none;">‚úñÔ∏è Clear</button>
        </div>
        
        <div class="search-help">
          üí° <strong><span class="tooltip">Wildcards:<span class="tooltiptext">
            <strong>Wildcard = when your brain is mush and you only remember part of the title.</strong><br><br>
            <strong>Examples:</strong><br>
            ‚Ä¢ Type "star*" = shows starting with "star"<br>
            ‚Ä¢ Type "*wars" = shows ending with "wars"<br>
            ‚Ä¢ Type "*trek*" = shows containing "trek"<br><br>
            Basically, it's search for dummies when you can't remember the full title! üß†
          </span></span></strong> "star*" = starts with "star" | "*wars" = ends with "wars" | "*trek*" = contains "trek"
        </div>
        
        <div class="pagination">
          <button id="prevPageBtn" disabled>‚Üê Previous</button>
          <span id="pageInfo" style="font-weight: bold; color: var(--primary);">Page 1</span>
          <button id="nextPageBtn" disabled>Next ‚Üí</button>
        </div>
      </div>

      <div class="filter-container">
        <div class="filter-row">
          <select id="statusFilter">
            <option value="">All Status</option>
            <option value="ongoing">Currently Airing</option>
            <option value="ended">Completed Series</option>
            <option value="unknown">Status Unknown</option>
          </select>
          <select id="tagFilter">
            <option value="">All Tags</option>
          </select>
          <select id="ratingFilter">
            <option value="">All Ratings</option>
            <option value="5">5 Stars</option>
            <option value="4">4+ Stars</option>
            <option value="3">3+ Stars</option>
            <option value="unrated">Unrated</option>
          </select>
          <button id="clearFiltersBtn" class="secondary">Clear Filters</button>
        </div>
      </div>

      <div id="searchResults" class="section" style="display: none;">
        <h3>üéØ Search Results <span class="count" id="resultsCount">0</span></h3>
        <div id="searchResultsList" class="list-container"></div>
      </div>

      <div class="stats">
        <div class="stat" onclick="switchToTab('watching')">
          <div class="stat-num" id="totalWatchingCount">0</div>
          <div class="stat-label">Currently Watching</div>
        </div>
        <div class="stat" onclick="switchToTab('wishlist')">
          <div class="stat-num" id="totalWishlistCount">0</div>
          <div class="stat-label">Want to Watch</div>
        </div>
        <div class="stat" onclick="switchToTab('watched')">
          <div class="stat-num" id="totalWatchedCount">0</div>
          <div class="stat-label">Already Watched</div>
        </div>
        <div class="stat">
          <div class="stat-num" id="totalCount">0</div>
          <div class="stat-label">Total Collection</div>
        </div>
      </div>

      <div style="background: var(--card); padding: 20px; border-radius: 20px; margin: 25px 0; border: 2px solid var(--primary);">
        <h3 style="color: var(--primary); margin-top: 0;">üíæ Backup Your Questionable Taste</h3>
        <div style="display: flex; gap: 10px; flex-wrap: wrap; align-items: center;">
          <input type="file" id="importFile" accept=".json" style="max-width: 200px;">
          <button id="exportBtn" class="success">üì§ Export My Shame</button>
          <button id="clearAllBtn" class="danger">üóëÔ∏è Nuclear Option</button>
        </div>
      </div>
    </div>

    <!-- CURRENTLY WATCHING TAB -->
    <div id="watchingSection" class="tab-section" style="display: none;">
      <div class="section">
        <div class="section-header">
          <div>
            <h3>‚ñ∂Ô∏è Currently Watching <span class="count" id="watchingCount">0</span></h3>
            <div class="section-subtitle">Shows and movies you're actually committed to... for now</div>
          </div>
        </div>
        <div id="watchingList" class="list-container">
          <div class="empty-state sassy-empty">No shows yet? What are you, productive or something? üôÑ</div>
        </div>
      </div>
    </div>

    <!-- WANT TO WATCH TAB -->
    <div id="wishlistSection" class="tab-section" style="display: none;">
      <div class="section">
        <div class="section-header">
          <div>
            <h3>üìñ Want to Watch <span class="count" id="wishlistCount">0</span></h3>
            <div class="section-subtitle">Your digital hoarding collection of "I'll definitely watch this someday"</div>
          </div>
        </div>
        <div id="wishlistList" class="list-container">
          <div class="empty-state sassy-empty">Your wishlist is emptier than a Netflix comedy special üíÄ</div>
        </div>
      </div>
    </div>

    <!-- ALREADY WATCHED TAB -->
    <div id="watchedSection" class="tab-section" style="display: none;">
      <div class="section">
        <div class="section-header">
          <div>
            <h3>‚úÖ Already Watched <span class="count" id="watchedCount">0</span></h3>
            <div class="section-subtitle">Your bragging rights collection and relationship argument ammunition</div>
          </div>
        </div>
        <div id="watchedList" class="list-container">
          <div class="empty-state sassy-empty">Nothing completed yet? Commitment issues much? üòè</div>
        </div>
      </div>
    </div>
  </div>

  <div class="easter-egg" id="easterEgg">üé≠</div>
  <div class="feedback-button" id="feedbackBtn">üí¨</div>

  <!-- Feedback Modal -->
  <div class="modal" id="feedbackModal" style="display: none;">
    <div class="modal-content">
      <div class="modal-header">
        <h3>üéØ Your Brutally Honest Feedback</h3>
        <button class="close-btn" id="closeFeedback">‚úï</button>
      </div>
      <div class="modal-body">
        <p><strong>Help make this app less terrible!</strong> üòà</p>
        <textarea id="feedbackText" placeholder="What confused you? What's missing? Be brutally honest..." style="width: 100%; height: 120px; padding: 15px; border: 2px solid var(--border); border-radius: 10px; background: var(--card); color: var(--text); resize: vertical; font-family: inherit; font-size: 14px;"></textarea>
        <div style="margin: 20px 0;">
          <p><strong>Overall experience:</strong></p>
          <div style="display: flex; gap: 8px; flex-wrap: wrap; margin-top: 10px;" id="ratingButtons">
            <button class="rating-btn" data-rating="1">üò§ Terrible</button>
            <button class="rating-btn" data-rating="2">üòï Meh</button>
            <button class="rating-btn" data-rating="3">üôÇ Decent</button>
            <button class="rating-btn" data-rating="4">üòç Love it</button>
            <button class="rating-btn" data-rating="5">ü§Ø Mind blown</button>
          </div>
        </div>
        <button id="submitFeedback" style="width: 100%; margin: 15px 0; padding: 15px; font-size: 16px; font-weight: bold;">üì§ Submit Feedback</button>
      </div>
    </div>
  </div>

  <script>
    // Core Application Logic
    const TMDB_IMG_BASE = 'https://image.tmdb.org/t/p/w200';
    const API_BASE = '/.netlify/functions/tmdb';
    
    let currentPage = 1, searchCache = [], currentActiveTab = 'home';
    
    const appData = {
      tv: { watching: [], wishlist: [], watched: [] },
      movies: { watching: [], wishlist: [], watched: [] },
      settings: { theme: 'light', displayName: '' }
    };

    // Sassy messages for different actions
    const homeMessages = [
      "Back to the beginning.",
      "Here we go again.", 
      "Didn't we just leave here?",
      "Home sweet home (but with more streaming debt).",
      "Welcome back to your digital shame spiral.",
      "Ready for more questionable life choices?",
      "The mothership awaits your return."
    ];

    const loadingMessages = [
      "Finding shows you'll probably abandon after 2 episodes...",
      "Searching the depths of entertainment mediocrity...",
      "Loading... (This is taking longer than your last relationship)",
      "Fetching content that'll judge your life choices...",
      "Retrieving shows you'll add but never watch...",
      "Consulting the algorithm gods...",
      "Preparing your next binge-watching obsession..."
    ];

    const sassyTitles = [
      "Chaos", "Digital Hoarding", "Commitment Issues", "Questionable Taste", 
      "Binge Empire", "Streaming Madness", "Watch List Anarchy", "Media Obsession",
      "Entertainment Addiction", "Viewing Disorder", "Screen Time Shame"
    ];

    const tips = [
      "Pro tip: Having 500 items in your wishlist doesn't count as productivity! üéØ",
      "Fun fact: 'I'll watch it later' is the most common lie in streaming! ü§•",
      "Reality check: You have more shows bookmarked than days in the year! üìÖ",
      "Hot take: Your 'Currently Watching' list is more fiction than fantasy movies! üìö",
      "Reminder: Netflix doesn't pay you to collect shows like Pok√©mon cards! üÉè",
      "News flash: Starting 20 shows doesn't make you a 'multimedia enthusiast'! üì∫",
      "Breaking: Local person discovers tags feature, organizes entire life! üè∑Ô∏è"
    ];

    // Initialize app
    document.addEventListener('DOMContentLoaded', () => {
      loadAppData();
      setupEventListeners();
      loadGenres();
      updateUI();
      setupEasterEgg();
      updateDarkModeButton();
    });

    function showNotification(message, type = 'success') {
      const notification = document.createElement('div');
      notification.className = `notification ${type}`;
      notification.textContent = message;
      document.body.appendChild(notification);
      
      setTimeout(() => {
        if (notification.parentNode) {
          notification.parentNode.removeChild(notification);
        }
      }, 4500);
    }

    function getRandomMessage(array) {
      return array[Math.floor(Math.random() * array.length)];
    }

    function createLoadingElement() {
      return `<div class="loading-container"><div class="loading-spinner"></div><div class="loading-text">${getRandomMessage(loadingMessages)}</div></div>`;
    }

    function loadAppData() {
      const saved = localStorage.getItem('tvMovieTrackerData');
      if (saved) {
        try {
          const parsedData = JSON.parse(saved);
          // Ensure watched arrays exist (backwards compatibility)
          if (!parsedData.tv.watched) parsedData.tv.watched = [];
          if (!parsedData.movies.watched) parsedData.movies.watched = [];
          Object.assign(appData, parsedData);
        } catch (e) {
          console.error('Error loading data:', e);
          showNotification("Failed to load your data. Starting fresh! üî•", 'warning');
        }
      }
      
      if (appData.settings.theme === 'dark') {
        document.body.classList.add('dark-mode');
      }
      
      if (appData.settings.displayName) {
        document.getElementById('displayNameInput').value = appData.settings.displayName;
        updateWelcomeText();
        hideNameContainer();
      }
    }

    function updateWelcomeText() {
      const name = appData.settings.displayName;
      if (name) {
        const randomSass = getRandomMessage(sassyTitles);
        document.getElementById('welcomeText').textContent = `${name}'s ${randomSass}`;
      } else {
        document.getElementById('welcomeText').textContent = 'TV Tracker V2';
      }
    }

    function hideNameContainer() {
      const container = document.getElementById('nameContainer');
      if (appData.settings.displayName && container) {
        container.classList.add('hidden');
      }
    }

    function updateDarkModeButton() {
      const isDark = document.body.classList.contains('dark-mode');
      document.getElementById('darkModeToggle').textContent = isDark ? '‚òÄÔ∏è Go Light' : 'üåô Go Dark';
    }

    function saveAppData() {
      localStorage.setItem('tvMovieTrackerData', JSON.stringify(appData));
    }

    function setupEventListeners() {
      // Dark mode toggle
      document.getElementById('darkModeToggle').onclick = () => {
        document.body.classList.toggle('dark-mode');
        appData.settings.theme = document.body.classList.contains('dark-mode') ? 'dark' : 'light';
        updateDarkModeButton();
        saveAppData();
        
        const isDark = document.body.classList.contains('dark-mode');
        showNotification(isDark ? "Welcome to the dark side üòà" : "Returning to the light! ‚òÄÔ∏è", 'success');
      };
      
      // Name input
      document.getElementById('displayNameInput').oninput = (e) => {
        appData.settings.displayName = e.target.value;
        updateWelcomeText();
        saveAppData();
        
        if (e.target.value.trim()) {
          setTimeout(() => hideNameContainer(), 1000);
        }
      };
      
      // Tab navigation
      document.getElementById('homeTab').onclick = () => switchToTab('home');
      document.getElementById('watchingTab').onclick = () => switchToTab('watching');
      document.getElementById('wishlistTab').onclick = () => switchToTab('wishlist');
      document.getElementById('watchedTab').onclick = () => switchToTab('watched');
      
      // Search functionality
      document.getElementById('searchBtn').onclick = performSearch;
      document.getElementById('searchInput').onkeydown = (e) => {
        if (e.key === 'Enter') performSearch();
      };
      
      // Clear search
      document.getElementById('clearSearchBtn').onclick = clearSearch;
      document.getElementById('searchInput').oninput = updateClearButton;
      document.getElementById('genreFilter').onchange = updateClearButton;
      
      // Pagination
      document.getElementById('prevPageBtn').onclick = () => {
        if (currentPage > 1) {
          currentPage--;
          performSearch();
        }
      };
      
      document.getElementById('nextPageBtn').onclick = () => {
        currentPage++;
        performSearch();
      };
      
      // Filter functionality
      document.getElementById('statusFilter').onchange = applyFilters;
      document.getElementById('tagFilter').onchange = applyFilters;
      document.getElementById('ratingFilter').onchange = applyFilters;
      document.getElementById('clearFiltersBtn').onclick = clearFilters;
      
      // Data management
      document.getElementById('exportBtn').onclick = exportData;
      document.getElementById('importFile').onchange = importData;
      document.getElementById('clearAllBtn').onclick = () => {
        if (confirm('Are you SURE you want to delete everything? This nuclear option cannot be undone! üí•')) {
          appData.tv = { watching: [], wishlist: [], watched: [] };
          appData.movies = { watching: [], wishlist: [], watched: [] };
          saveAppData();
          updateUI();
          showNotification("Boom! Everything deleted. Hope you're happy! üíÄ", 'error');
        }
      };
    }

    function updateClearButton() {
      const hasContent = document.getElementById('searchInput').value.trim() || 
                        document.getElementById('genreFilter').value;
      document.getElementById('clearSearchBtn').style.display = hasContent ? 'inline-block' : 'none';
    }

    function switchToTab(tab) {
      currentActiveTab = tab;
      
      // Update tab buttons
      document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
      document.getElementById(tab + 'Tab').classList.add('active');
      
      // Show/hide sections
      document.querySelectorAll('.tab-section').forEach(s => s.style.display = 'none');
      document.getElementById(tab + 'Section').style.display = 'block';
      
      // Clear search when switching tabs
      if (tab !== 'home') {
        document.getElementById('searchResults').style.display = 'none';
      }
      
      const messages = {
        home: getRandomMessage(homeMessages),
        watching: 'Time to face your current commitments! üì∫',
        wishlist: 'Welcome to your digital hoarding paradise! üìö',
        watched: 'Behold your completed conquests! üèÜ'
      };
      
      showNotification(messages[tab], 'success');
    }

    async function performSearch() {
      const query = document.getElementById('searchInput').value.trim();
      const genre = document.getElementById('genreFilter').value;
      
      if (!query && !genre) {
        showNotification('Please enter a search term or select a genre, genius! ü§î', 'warning');
        return;
      }
      
      const container = document.getElementById('searchResultsList');
      container.innerHTML = createLoadingElement();
      document.getElementById('searchResults').style.display = 'block';
      
      try {
        // Wildcard search logic
        let processedQuery = query;
        let isWildcardSearch = false;
        
        if (query.includes('*')) {
          isWildcardSearch = true;
          processedQuery = query.replace(/\*/g, '');
          showNotification(`üîç Wildcard search: Finding shows with "${processedQuery}"`, 'info');
        }
        
        const results = await fetchShowData(processedQuery, currentPage, genre);
        
        // Filter results for wildcard searches
        let filteredResults = results;
        if (isWildcardSearch) {
          const searchTerm = processedQuery.toLowerCase();
          filteredResults = results.filter(item => {
            const title = (item.name || item.title || '').toLowerCase();
            
            if (query.startsWith('*') && query.endsWith('*')) {
              return title.includes(searchTerm);
            } else if (query.startsWith('*')) {
              return title.endsWith(searchTerm);
            } else if (query.endsWith('*')) {
              return title.startsWith(searchTerm);
            }
            
            return title.includes(searchTerm);
          });
          
          if (filteredResults.length !== results.length) {
            showNotification(`Filtered to ${filteredResults.length} shows matching "${query}" üéØ`, 'success');
          }
        }
        
        searchCache = filteredResults;
        displaySearchResults(filteredResults);
        updatePagination();
        
        if (filteredResults.length === 0) {
          showNotification('No results found. Try lowering your standards! üìâ', 'warning');
        } else if (!isWildcardSearch) {
          showNotification(`Found ${filteredResults.length} options for your viewing pleasure! üéØ`, 'success');
        }
      } catch (error) {
        container.innerHTML = `<div style="color: red; text-align: center; padding: 40px; font-weight: bold;">Search failed: ${error.message}<br><br>Maybe try turning it off and on again? ü§∑‚Äç‚ôÇÔ∏è</div>`;
        showNotification('Search failed. The internet is judging you! üåê', 'error');
      }
    }

    async function fetchShowData(query, page = 1, genreFilter = '') {
      const type = 'multi';
      let endpoint = `search/${type}`;
      let params = `endpoint=${endpoint}&page=${page}`;
      
      if (query) params += `&query=${encodeURIComponent(query)}`;
      if (genreFilter && !query) {
        endpoint = `discover/tv`;
        params = `endpoint=${endpoint}&page=${page}&genre=${genreFilter}`;
      }
      
      try {
        const response = await fetch(`${API_BASE}?${params}`);
        
        if (!response.ok) {
          throw new Error(`Search service unavailable (${response.status}). Please try again later.`);
        }
        
        const data = await response.json();
        
        // Enhance results with additional TMDB data
        const enhancedResults = await Promise.all(
          (data.results || []).map(async (item) => {
            try {
              const detailEndpoint = item.media_type === 'tv' ? `tv/${item.id}` : `movie/${item.id}`;
              const detailResponse = await fetch(`${API_BASE}?endpoint=${detailEndpoint}`);
              
              if (detailResponse.ok) {
                const details = await detailResponse.json();
                return {
                  ...item,
                  status: details.status,
                  number_of_seasons: details.number_of_seasons,
                  number_of_episodes: details.number_of_episodes,
                  last_air_date: details.last_air_date,
                  next_episode_to_air: details.next_episode_to_air,
                  genres: details.genres
                };
              }
            } catch (e) {
              console.log('Failed to fetch details for:', item.name || item.title);
            }
            return item;
          })
        );
        
        return enhancedResults;
      } catch (error) {
        console.error('Fetch error:', error);
        throw new Error('Search temporarily unavailable. Our servers are probably binge-watching something! üì∫');
      }
    }

    async function loadGenres() {
      try {
        const response = await fetch(`${API_BASE}?endpoint=genre/tv/list`);
        
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const data = await response.json();
        const select = document.getElementById('genreFilter');
        select.innerHTML = '<option value="">All Genres</option>';
        
        if (data.genres && data.genres.length > 0) {
          data.genres.forEach(genre => {
            select.innerHTML += `<option value="${genre.id}">${genre.name}</option>`;
          });
        }
      } catch (error) {
        console.error('Error loading genres:', error);
        const select = document.getElementById('genreFilter');
        const fallbackGenres = [
          {id: 10759, name: 'Action & Adventure'}, {id: 16, name: 'Animation'}, 
          {id: 35, name: 'Comedy'}, {id: 80, name: 'Crime'}, 
          {id: 99, name: 'Documentary'}, {id: 18, name: 'Drama'}, 
          {id: 10765, name: 'Sci-Fi & Fantasy'}
        ];
        
        select.innerHTML = '<option value="">All Genres</option>';
        fallbackGenres.forEach(genre => {
          select.innerHTML += `<option value="${genre.id}">${genre.name}</option>`;
        });
      }
    }

    function displaySearchResults(results) {
      const container = document.getElementById('searchResultsList');
      document.getElementById('resultsCount').textContent = results.length;
      
      if (results.length === 0) {
        container.innerHTML = '<div class="empty-state sassy-empty">No results found. Maybe try something that actually exists? ü§®</div>';
        return;
      }
      
      container.innerHTML = '';
      results.forEach(item => {
        const card = createShowCard(item, true);
        container.appendChild(card);
      });
    }

    function createShowCard(item, isSearchResult = false) {
      const card = document.createElement('div');
      card.className = 'show-card';
      
      const title = item.name || item.title || 'Unknown Title';
      const date = item.first_air_date || item.release_date || '';
      const rating = item.vote_average ? item.vote_average.toFixed(1) : 'N/A';
      const overview = item.overview || 'No description available.';
      const mediaType = item.media_type || (item.first_air_date ? 'tv' : 'movie');
      
      const category = mediaType === 'tv' ? 'tv' : 'movies';
      const isInWatching = appData[category].watching.some(show => show.id === item.id);
      const isInWishlist = appData[category].wishlist.some(show => show.id === item.id);
      const isInWatched = appData[category].watched.some(show => show.id === item.id);
      
      const posterHtml = item.poster_path ? 
        `<img src="${TMDB_IMG_BASE}${item.poster_path}" alt="${title}" class="show-poster" onclick="openTMDBLink(${item.id}, '${mediaType}')">` : 
        `<div class="poster-placeholder" onclick="openTMDBLink(${item.id}, '${mediaType}')">No Image<br>Available üì∑</div>`;
      
      let actionsHtml = '';
      
      if (isSearchResult) {
        actionsHtml = `
          <div class="show-actions">
            <div class="action-row">
              <button onclick="addToList(${JSON.stringify(item).replace(/"/g, '&quot;')}, 'watching')" ${isInWatching ? 'disabled' : ''}>
                ${isInWatching ? '‚úì Watching' : '‚ñ∂Ô∏è Watching'}
              </button>
              <button onclick="addToList(${JSON.stringify(item).replace(/"/g, '&quot;')}, 'wishlist')" ${isInWishlist ? 'disabled' : ''}>
                ${isInWishlist ? '‚úì In Wishlist' : 'üìñ Want to Watch'}
              </button>
            </div>
            <div class="action-row">
              <button onclick="addToList(${JSON.stringify(item).replace(/"/g, '&quot;')}, 'watched')" ${isInWatched ? 'disabled' : ''}>
                ${isInWatched ? '‚úì Watched' : '‚úÖ Mark Watched'}
              </button>
              <button onclick="openTMDBLink(${item.id}, '${mediaType}')" class="secondary">
                üîó TMDB Info
              </button>
            </div>
            <div class="share-buttons">
              <button class="share-btn" onclick="shareShow('${title}', ${item.id}, '${mediaType}')">üì§ Share</button>
            </div>
          </div>
        `;
      } else {
        // Full card for list sections
        const userRating = item.userRating || 0;
        const notes = item.notes || '';
        const tags = item.tags || [];
        const progress = item.progress || '';
        const currentSeason = item.currentSeason || '';
        const currentEpisode = item.currentEpisode || '';
        const likeStatus = item.likeStatus || 'none'; // 'like', 'dislike', 'none'
        
        // Status badge
        let statusBadge = '';
        if (item.status) {
          const statusClass = item.status === 'Ended' ? 'ended' : 
                            item.status === 'Returning Series' ? 'ongoing' : 'unknown';
          statusBadge = `<span class="status-badge status-${statusClass}">${item.status}</span>`;
        }
        
        // Series info
        let seriesInfo = '';
        if (mediaType === 'tv' && item.number_of_seasons) {
          seriesInfo = `<span>üì∫ ${item.number_of_seasons} Season${item.number_of_seasons > 1 ? 's' : ''}</span>`;
          if (item.last_air_date) {
            seriesInfo += `<span>üìÖ Last: ${item.last_air_date}</span>`;
          }
        }
        
        actionsHtml = `
          <div class="show-actions">
            ${mediaType === 'tv' ? `
              <div class="episode-tracker">
                <strong>Episode Progress:</strong>
                <div class="episode-inputs">
                  <input type="number" placeholder="Season" min="1" value="${currentSeason}" onchange="updateEpisodeProgress(${item.id}, 'season', this.value)">
                  <input type="number" placeholder="Episode" min="1" value="${currentEpisode}" onchange="updateEpisodeProgress(${item.id}, 'episode', this.value)">
                </div>
              </div>
            ` : ''}
            
            <div class="rating-container">
              <span>Your Rating:</span>
              <div class="star-rating">
                ${[1,2,3,4,5].map(star => 
                  `<span class="star ${star <= userRating ? 'active' : ''}" onclick="setRating(${item.id}, ${star})">‚≠ê</span>`
                ).join('')}
              </div>
              <div class="like-dislike">
                <button class="like ${likeStatus === 'like' ? 'active' : ''}" onclick="setLikeStatus(${item.id}, 'like')">üëç</button>
                <button class="dislike ${likeStatus === 'dislike' ? 'active' : ''}" onclick="setLikeStatus(${item.id}, 'dislike')">üëé</button>
              </div>
            </div>
            
            <div class="tags-container">
              <input type="text" class="tag-input" placeholder="Add tags (horror, comedy, etc.)" onkeydown="handleTagInput(event, ${item.id})">
              <div class="tags-display" id="tags-${item.id}">
                ${tags.map(tag => `<span class="tag">${tag} <span class="tag-remove" onclick="removeTag(${item.id}, '${tag}')">√ó</span></span>`).join('')}
              </div>
            </div>
            
            <div class="notes-container">
              <textarea class="notes-field" placeholder="What I loved about this (250 chars)..." maxlength="250" onchange="updateNotes(${item.id}, this.value)">${notes}</textarea>
              <div class="char-count ${notes.length > 200 ? 'warning' : ''} ${notes.length > 240 ? 'danger' : ''}">${notes.length}/250</div>
            </div>
            
            <div class="action-row">
              <button onclick="moveItem(${item.id}, 'watching')" ${isInWatching ? 'disabled' : ''}>‚Üí Watching</button>
              <button onclick="moveItem(${item.id}, 'wishlist')" ${isInWishlist ? 'disabled' : ''}>‚Üí Wishlist</button>
              <button onclick="moveItem(${item.id}, 'watched')" ${isInWatched ? 'disabled' : ''}>‚Üí Watched</button>
            </div>
            
            <div class="action-row">
              <button class="favorite ${item.favorite ? 'active' : ''}" onclick="toggleFavorite(${item.id})">‚≠ê ${item.favorite ? 'Favorited' : 'Favorite'}</button>
              <button class="danger" onclick="removeItem(${item.id})">üóëÔ∏è Remove</button>
              <button onclick="openTMDBLink(${item.id}, '${mediaType}')" class="secondary">üîó TMDB</button>
            </div>
            
            <div class="action-row">
              <input type="text" placeholder="Progress notes..." value="${progress}" onchange="updateProgress(${item.id}, this.value)">
            </div>
            
            <div class="share-buttons">
              <button class="share-btn" onclick="shareShow('${title}', ${item.id}, '${mediaType}')">üì§ Share</button>
            </div>
          </div>
        `;
      }
      
      card.innerHTML = `
        ${posterHtml}
        <div class="show-details">
          <h4 class="show-title" onclick="openTMDBLink(${item.id}, '${mediaType}')">
            ${title}
            <span class="external-link">üîó</span>
          </h4>
          <div class="show-meta">
            <span>‚≠ê ${rating}</span>
            ${date ? `<span>üìÖ ${date.split('-')[0]}</span>` : ''}
            <span>${mediaType.toUpperCase()}</span>
            ${seriesInfo}
          </div>
          ${statusBadge ? `<div class="show-status">${statusBadge}</div>` : ''}
          <div class="show-overview" onclick="this.classList.toggle('expanded')">${overview}</div>
        </div>
        ${actionsHtml}
      `;
      
      return card;
    }

    function openTMDBLink(id, mediaType) {
      const url = `https://www.themoviedb.org/${mediaType}/${id}`;
      window.open(url, '_blank');
      showNotification('Opening TMDB details! üîó', 'info');
    }

    function shareShow(title, id, mediaType) {
      const url = `https://www.themoviedb.org/${mediaType}/${id}`;
      const text = `Check out "${title}" - I'm tracking it on TV Tracker! ${url}`;
      
      if (navigator.share) {
        navigator.share({
          title: `Check out "${title}"`,
          text: text,
          url: url
        }).catch(() => {
          copyToClipboard(text);
        });
      } else {
        copyToClipboard(text);
      }
    }

    function copyToClipboard(text) {
      navigator.clipboard.writeText(text).then(() => {
        showNotification('Share link copied to clipboard! üìã', 'success');
      }).catch(() => {
        showNotification('Could not copy to clipboard üòÖ', 'warning');
      });
    }

    function addToList(item, listType) {
      const mediaType = item.media_type || (item.first_air_date ? 'tv' : 'movie');
      const category = mediaType === 'tv' ? 'tv' : 'movies';
      
      const newItem = {
        id: item.id,
        title: item.name || item.title,
        overview: item.overview,
        poster_path: item.poster_path,
        date: item.first_air_date || item.release_date,
        rating: item.vote_average,
        media_type: mediaType,
        date_added: new Date().toISOString(),
        progress: '',
        favorite: false,
        userRating: 0,
        notes: '',
        tags: [],
        likeStatus: 'none',
        currentSeason: '',
        currentEpisode: '',
        status: item.status || '',
        number_of_seasons: item.number_of_seasons || 0,
        last_air_date: item.last_air_date || ''
      };
      
      if (!appData[category][listType].some(show => show.id === item.id)) {
        appData[category][listType].push(newItem);
        saveAppData();
        updateUI();
        performSearch(); // Refresh search to update button states
        
        const listNames = { 
          watching: 'Currently Watching', 
          wishlist: 'Want to Watch',
          watched: 'Already Watched'
        };
        showNotification(`Added "${newItem.title}" to ${listNames[listType]}! üéâ`, 'success');
      } else {
        showNotification('Already on your list, genius! üôÑ', 'warning');
      }
    }

    function moveItem(itemId, newListType) {
      let item = null;
      let fromList = null;
      let category = null;
      
      // Find the item in all categories and lists
      ['tv', 'movies'].forEach(cat => {
        ['watching', 'wishlist', 'watched'].forEach(list => {
          const found = appData[cat][list].find(s => s.id === itemId);
          if (found) {
            item = found;
            fromList = list;
            category = cat;
          }
        });
      });
      
      if (item && fromList !== newListType) {
        appData[category][fromList] = appData[category][fromList].filter(s => s.id !== itemId);
        appData[category][newListType].push(item);
        saveAppData();
        updateUI();
        
        const listNames = { 
          watching: 'Currently Watching', 
          wishlist: 'Want to Watch',
          watched: 'Already Watched'
        };
        showNotification(`Moved "${item.title}" to ${listNames[newListType]}! üì¶`, 'success');
      }
    }

    function removeItem(itemId) {
      if (confirm('Remove this item? It\'s probably for the best... üóëÔ∏è')) {
        let item = null;
        
        ['tv', 'movies'].forEach(category => {
          ['watching', 'wishlist', 'watched'].forEach(list => {
            const found = appData[category][list].find(s => s.id === itemId);
            if (found) item = found;
            appData[category][list] = appData[category][list].filter(s => s.id !== itemId);
          });
        });
        
        saveAppData();
        updateUI();
        
        showNotification(`"${item?.title || 'Item'}" has been yeeted into the void! üöÄ`, 'success');
      }
    }

    function toggleFavorite(itemId) {
      let item = null;
      
      ['tv', 'movies'].forEach(category => {
        ['watching', 'wishlist', 'watched'].forEach(list => {
          const found = appData[category][list].find(s => s.id === itemId);
          if (found) item = found;
        });
      });
      
      if (item) {
        item.favorite = !item.favorite;
        saveAppData();
        updateUI();
        
        const action = item.favorite ? 'favorited' : 'unfavorited';
        showNotification(`${item.title} ${action}! ${item.favorite ? '‚≠ê' : 'üíî'}`, 'success');
      }
    }

    function setRating(itemId, rating) {
      let item = null;
      
      ['tv', 'movies'].forEach(category => {
        ['watching', 'wishlist', 'watched'].forEach(list => {
          const found = appData[category][list].find(s => s.id === itemId);
          if (found) item = found;
        });
      });
      
      if (item) {
        item.userRating = rating;
        saveAppData();
        updateUI();
        showNotification(`Rated "${item.title}" ${rating} stars! ‚≠ê`, 'success');
      }
    }

    function setLikeStatus(itemId, status) {
      let item = null;
      
      ['tv', 'movies'].forEach(category => {
        ['watching', 'wishlist', 'watched'].forEach(list => {
          const found = appData[category][list].find(s => s.id === itemId);
          if (found) item = found;
        });
      });
      
      if (item) {
        item.likeStatus = item.likeStatus === status ? 'none' : status;
        saveAppData();
        updateUI();
        
        const messages = {
          like: 'You liked this! üëç',
          dislike: 'You disliked this! üëé',
          none: 'Rating cleared! ü§∑‚Äç‚ôÇÔ∏è'
        };
        showNotification(`${item.title}: ${messages[item.likeStatus]}`, 'success');
      }
    }

    function updateNotes(itemId, notes) {
      let item = null;
      
      ['tv', 'movies'].forEach(category => {
        ['watching', 'wishlist', 'watched'].forEach(list => {
          const found = appData[category][list].find(s => s.id === itemId);
          if (found) item = found;
        });
      });
      
      if (item) {
        item.notes = notes;
        saveAppData();
      }
    }

    function updateProgress(itemId, progress) {
      let item = null;
      
      ['tv', 'movies'].forEach(category => {
        ['watching', 'wishlist', 'watched'].forEach(list => {
          const found = appData[category][list].find(s => s.id === itemId);
          if (found) item = found;
        });
      });
      
      if (item) {
        item.progress = progress;
        saveAppData();
      }
    }

    function updateEpisodeProgress(itemId, type, value) {
      let item = null;
      
      ['tv', 'movies'].forEach(category => {
        ['watching', 'wishlist', 'watched'].forEach(list => {
          const found = appData[category][list].find(s => s.id === itemId);
          if (found) item = found;
        });
      });
      
      if (item) {
        if (type === 'season') {
          item.currentSeason = value;
        } else if (type === 'episode') {
          item.currentEpisode = value;
        }
        saveAppData();
      }
    }

    function handleTagInput(event, itemId) {
      if (event.key === 'Enter') {
        const tagValue = event.target.value.trim();
        if (tagValue) {
          addTag(itemId, tagValue);
          event.target.value = '';
        }
      }
    }

    function addTag(itemId, tagValue) {
      let item = null;
      
      ['tv', 'movies'].forEach(category => {
        ['watching', 'wishlist', 'watched'].forEach(list => {
          const found = appData[category][list].find(s => s.id === itemId);
          if (found) item = found;
        });
      });
      
      if (item && !item.tags.includes(tagValue)) {
        item.tags.push(tagValue);
        saveAppData();
        updateUI();
        updateTagFilter();
        showNotification(`Added tag "${tagValue}" to ${item.title}! üè∑Ô∏è`, 'success');
      }
    }

    function removeTag(itemId, tagValue) {
      let item = null;
      
      ['tv', 'movies'].forEach(category => {
        ['watching', 'wishlist', 'watched'].forEach(list => {
          const found = appData[category][list].find(s => s.id === itemId);
          if (found) item = found;
        });
      });
      
      if (item) {
        item.tags = item.tags.filter(tag => tag !== tagValue);
        saveAppData();
        updateUI();
        updateTagFilter();
        showNotification(`Removed tag "${tagValue}" from ${item.title}! üóëÔ∏è`, 'success');
      }
    }

    function updateTagFilter() {
      const allTags = new Set();
      
      ['tv', 'movies'].forEach(category => {
        ['watching', 'wishlist', 'watched'].forEach(list => {
          appData[category][list].forEach(item => {
            if (item.tags) {
              item.tags.forEach(tag => allTags.add(tag));
            }
          });
        });
      });
      
      const tagFilter = document.getElementById('tagFilter');
      const currentValue = tagFilter.value;
      tagFilter.innerHTML = '<option value="">All Tags</option>';
      
      Array.from(allTags).sort().forEach(tag => {
        tagFilter.innerHTML += `<option value="${tag}">${tag}</option>`;
      });
      
      tagFilter.value = currentValue;
    }

    function applyFilters() {
      if (currentActiveTab === 'home') return;
      
      const statusFilter = document.getElementById('statusFilter').value;
      const tagFilter = document.getElementById('tagFilter').value;
      const ratingFilter = document.getElementById('ratingFilter').value;
      
      const allItems = [...appData.tv[currentActiveTab], ...appData.movies[currentActiveTab]];
      
      let filteredItems = allItems.filter(item => {
        // Status filter
        if (statusFilter && item.status) {
          const itemStatus = item.status.toLowerCase();
          if (statusFilter === 'ongoing' && !itemStatus.includes('returning')) return false;
          if (statusFilter === 'ended' && !itemStatus.includes('ended')) return false;
          if (statusFilter === 'unknown' && itemStatus !== '') return false;
        }
        
        // Tag filter
        if (tagFilter && (!item.tags || !item.tags.includes(tagFilter))) return false;
        
        // Rating filter
        if (ratingFilter) {
          const userRating = item.userRating || 0;
          if (ratingFilter === 'unrated' && userRating > 0) return false;
          if (ratingFilter !== 'unrated' && userRating < parseInt(ratingFilter)) return false;
        }
        
        return true;
      });
      
      updateFilteredList(currentActiveTab + 'List', filteredItems);
      
      if (filteredItems.length !== allItems.length) {
        showNotification(`Filtered to ${filteredItems.length} items! üîç`, 'info');
      }
    }

    function clearFilters() {
      document.getElementById('statusFilter').value = '';
      document.getElementById('tagFilter').value = '';
      document.getElementById('ratingFilter').value = '';
      updateUI();
      showNotification('Filters cleared! üßπ', 'success');
    }

    function updateFilteredList(containerId, items) {
      const container = document.getElementById(containerId);
      
      if (items.length === 0) {
        const emptyMessages = {
          watchingList: 'No items match your filters! Try lowering your standards! ü§∑‚Äç‚ôÇÔ∏è',
          wishlistList: 'No items match your filters! Time to be less picky! üòè',
          watchedList: 'No items match your filters! Your achievements are hiding! üïµÔ∏è‚Äç‚ôÇÔ∏è'
        };
        container.innerHTML = `<div class="empty-state sassy-empty">${emptyMessages[containerId] || 'No matches found!'}</div>`;
      } else {
        container.innerHTML = '';
        items.forEach(item => {
          container.appendChild(createShowCard(item, false));
        });
      }
    }

    function updateUI() {
      const totalWatching = appData.tv.watching.length + appData.movies.watching.length;
      const totalWishlist = appData.tv.wishlist.length + appData.movies.wishlist.length;
      const totalWatched = appData.tv.watched.length + appData.movies.watched.length;
      
      // Update tab badges
      document.getElementById('watchingBadge').textContent = totalWatching;
      document.getElementById('wishlistBadge').textContent = totalWishlist;
      document.getElementById('watchedBadge').textContent = totalWatched;
      
      // Update stats
      document.getElementById('totalWatchingCount').textContent = totalWatching;
      document.getElementById('totalWishlistCount').textContent = totalWishlist;
      document.getElementById('totalWatchedCount').textContent = totalWatched;
      document.getElementById('totalCount').textContent = totalWatching + totalWishlist + totalWatched;
      
      // Update section counts
      document.getElementById('watchingCount').textContent = totalWatching;
      document.getElementById('wishlistCount').textContent = totalWishlist;
      document.getElementById('watchedCount').textContent = totalWatched;
      
      // Update lists
      updateList('watchingList', [...appData.tv.watching, ...appData.movies.watching]);
      updateList('wishlistList', [...appData.tv.wishlist, ...appData.movies.wishlist]);
      updateList('watchedList', [...appData.tv.watched, ...appData.movies.watched]);
      
      updateTagFilter();
    }

    function updateList(containerId, items) {
      const container = document.getElementById(containerId);
      
      if (items.length === 0) {
        const emptyMessages = {
          watchingList: 'No shows yet? What are you, productive or something? üôÑ',
          wishlistList: 'Your wishlist is emptier than a Netflix comedy special üíÄ',
          watchedList: 'Nothing completed yet? Commitment issues much? üòè'
        };
        container.innerHTML = `<div class="empty-state sassy-empty">${emptyMessages[containerId]}</div>`;
      } else {
        container.innerHTML = '';
        items.forEach(item => {
          container.appendChild(createShowCard(item, false));
        });
      }
    }

    function clearSearch() {
      document.getElementById('searchInput').value = '';
      document.getElementById('genreFilter').value = '';
      document.getElementById('clearSearchBtn').style.display = 'none';
      document.getElementById('searchResults').style.display = 'none';
      currentPage = 1;
      document.getElementById('pageInfo').textContent = 'Page 1';
      document.getElementById('prevPageBtn').disabled = true;
      document.getElementById('nextPageBtn').disabled = true;
      searchCache = [];
      showNotification('Search cleared! Back to square one! üîÑ', 'success');
    }

    function updatePagination() {
      document.getElementById('pageInfo').textContent = `Page ${currentPage}`;
      document.getElementById('prevPageBtn').disabled = currentPage === 1;
      document.getElementById('nextPageBtn').disabled = searchCache.length < 20;
    }

    function exportData() {
      const blob = new Blob([JSON.stringify(appData, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `tv-tracker-v2-backup-${new Date().toISOString().split('T')[0]}.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      showNotification('Your questionable taste has been exported! üì§', 'success');
    }

    function importData(e) {
      const file = e.target.files[0];
      if (!file) return;
      
      const reader = new FileReader();
      reader.onload = function(event) {
        try {
          const imported = JSON.parse(event.target.result);
          if (confirm('Import data? This will overwrite your current collection of digital hoarding! üíæ')) {
            // Ensure backwards compatibility
            if (!imported.tv.watched) imported.tv.watched = [];
            if (!imported.movies.watched) imported.movies.watched = [];
            
            Object.assign(appData, imported);
            saveAppData();
            updateUI();
            showNotification('Data imported! Your taste is still questionable! üéâ', 'success');
          }
        } catch (error) {
          showNotification('Invalid file format. Even your backups are broken! üí•', 'error');
        }
      };
      reader.readAsText(file);
    }

    function setupEasterEgg() {
      let clickCount = 0;
      let tipTimeout = null;
      
      document.getElementById('easterEgg').onclick = () => {
        clickCount++;
        if (clickCount % 3 === 0) {
          showRandomTip();
        }
      };
      
      // Feedback modal functionality
      const feedbackBtn = document.getElementById('feedbackBtn');
      const feedbackModal = document.getElementById('feedbackModal');
      const closeFeedback = document.getElementById('closeFeedback');
      const submitFeedback = document.getElementById('submitFeedback');
      const ratingBtns = document.querySelectorAll('.rating-btn');
      
      let selectedRating = 0;
      
      feedbackBtn.onclick = () => {
        feedbackModal.style.display = 'flex';
        document.body.style.overflow = 'hidden';
      };
      
      closeFeedback.onclick = () => {
        feedbackModal.style.display = 'none';
        document.body.style.overflow = 'auto';
      };
      
      // Close on background click
      feedbackModal.onclick = (e) => {
        if (e.target === feedbackModal) {
          feedbackModal.style.display = 'none';
          document.body.style.overflow = 'auto';
        }
      };
      
      // Rating selection
      ratingBtns.forEach(btn => {
        btn.onclick = () => {
          ratingBtns.forEach(b => b.classList.remove('selected'));
          btn.classList.add('selected');
          selectedRating = parseInt(btn.dataset.rating);
        };
      });
      
      // Submit feedback
      submitFeedback.onclick = async () => {
        const feedbackText = document.getElementById('feedbackText').value.trim();
        
        if (!feedbackText && selectedRating === 0) {
          showNotification('Come on, give us SOMETHING to work with! üôÑ', 'warning');
          return;
        }
        
        // Store feedback locally
        const feedback = {
          text: feedbackText,
          rating: selectedRating,
          timestamp: new Date().toISOString(),
          url: window.location.href,
          version: '2.0'
        };
        
        // Save to localStorage
        const existingFeedback = JSON.parse(localStorage.getItem('userFeedback') || '[]');
        existingFeedback.push(feedback);
        localStorage.setItem('userFeedback', JSON.stringify(existingFeedback));
        
        // Send to server
        try {
          console.log('üöÄ Sending V2 feedback to server:', feedback);
          const response = await fetch('https://tv-movie-tracker.netlify.app/.netlify/functions/feedback', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify(feedback)
          });
          
          if (response.ok) {
            console.log('‚úÖ V2 feedback sent successfully');
          }
        } catch (error) {
          console.error('‚ùå Failed to send V2 feedback:', error);
        }
        
        showNotification('Feedback submitted! We\'ll try not to disappoint you further! üéØ', 'success');
        feedbackModal.style.display = 'none';
        document.body.style.overflow = 'auto';
        
        // Clear form
        document.getElementById('feedbackText').value = '';
        ratingBtns.forEach(b => b.classList.remove('selected'));
        selectedRating = 0;
      };
    }

    function showRandomTip() {
      const tip = getRandomMessage(tips);
      const bubble = document.createElement('div');
      bubble.className = 'tip-bubble';
      bubble.textContent = tip;
      document.body.appendChild(bubble);
      
      // Make tip linger longer (was 4 seconds, now 7 seconds)
      setTimeout(() => {
        if (bubble.parentNode) bubble.parentNode.removeChild(bubble);
      }, 7000);
    }

    // Handle window resize for responsive design
    window.addEventListener('resize', () => {
      // Force a small delay to ensure proper layout recalculation
      setTimeout(() => {
        updateUI();
      }, 100);
    });

    // Handle orientation change
    window.addEventListener('orientationchange', () => {
      setTimeout(() => {
        updateUI();
      }, 500);
    });

    // Add CSS for selected rating buttons
    const style = document.createElement('style');
    style.textContent = `
      .rating-btn.selected {
        background: linear-gradient(45deg, #ffd700, #ffed4e) !important;
        color: #000 !important;
        transform: scale(1.05);
      }
      
      .like.active {
        background: linear-gradient(45deg, #2ed573, #1dd1a1) !important;
      }
      
      .dislike.active {
        background: linear-gradient(45deg, #ff4757, #ff3742) !important;
      }
    `;
    document.head.appendChild(style);
  </script>
</body>
</html>