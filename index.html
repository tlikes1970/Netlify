<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Flicklet - TV & Movie Tracker</title>
    <meta
      name="description"
      content="Search, track, and rate shows & films fast."
    />

    <style>
      :root {
        --bg: #ffffff;
        --text: #121212;
        --primary: #ff6b6b;
        --card: #f7f7f9;
        --border: #dedee3;
        --success: #51cf66;
        --warning: #ffd43b;
        --danger: #ff4d4f;
        --purple: #845ec2;
        --mardi1: #6a0dad;
        --mardi2: #28a745;
        --mardi3: #ffd43b;
        --focus: #1a73e8;
      }
      * {
        box-sizing: border-box;
      }
      html,
      body {
        height: 100%;
      }
      body {
        font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial,
          sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        margin: 0;
        padding: 20px;
        color: var(--text);
        line-height: 1.5;
        min-height: 100svh;
        overflow-x: hidden;
        /* Ensure sticky positioning works */
        overflow-y: visible;

      }
      .dark-mode {
        --bg: #1a1a1a;
        --text: #f5f5f5;
        --card: #232323;
        --border: #383838;
        background: linear-gradient(
          135deg,
          #2c3e50 0%,
          #34495e 100%
        ) !important;
      }
      .mardi .header {
        border-color: var(--mardi3) !important;
      }
      .mardi .btn {
        background: linear-gradient(
          45deg,
          var(--mardi1),
          var(--mardi3)
        ) !important;
      }
      body.mardi {
        background: linear-gradient(
          135deg,
          var(--mardi1),
          var(--mardi2)
        ) !important;
      }

      .main-container {
        max-width: 1100px;
        margin: 0 auto;
        background: var(--bg);
        border-radius: 20px;
        padding: 24px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.25);
      }

      .header {
        display: flex;
        justify-content: space-between;
        gap: 12px;
        flex-wrap: wrap;
        border-bottom: 3px solid var(--primary);
        padding-bottom: 16px;
        margin-bottom: 12px;
      }
      
      .header-left {
        flex: 1;
        max-width: 600px;
      }
      .title {
        margin: 0;
        font-size: 2.1rem;
        color: var(--primary);
        font-weight: 800;
        letter-spacing: 0.2px;
      }
      .subtitle {
        margin: 2px 0 8px;
        color: #8a8a98;
        font-weight: 600;
      }
      .user-section {
        display: flex;
        align-items: center;
        gap: 10px;
        flex-wrap: wrap;
      }
      #langToggle {
        padding: 8px 10px;
        border-radius: 14px;
        border: 2px solid var(--border);
        background: var(--card);
        color: var(--text);
        font-weight: 700;
      }

      .tab-container {
        display: flex;
        gap: 6px;
        background: var(--card);
        padding: 8px;
        border-radius: 12px;
        margin: 14px 0;
      }
      .tab {
        flex: 1;
        border: 0;
        background: transparent;
        padding: 12px 10px;
        border-radius: 10px;
        font-weight: 800;
        cursor: pointer;
      }
      .tab.active {
        background: linear-gradient(45deg, var(--primary), var(--purple));
        color: #fff;
      }
      .tab-badge {
        background: #fff;
        color: var(--primary);
        border-radius: 12px;
        padding: 2px 8px;
        font-size: 12px;
        margin-left: 6px;
      }

              .btn {
          border: 0;
          background: linear-gradient(45deg, var(--primary), var(--purple));
          color: #fff;
          border-radius: 18px;
          padding: 10px 14px;
          font-weight: 800;
          cursor: pointer;
          transition: all 0.2s ease;
          position: relative;
          overflow: hidden;
        }
        
        .btn:hover {
          transform: translateY(-2px);
          box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        
        .btn:active {
          transform: translateY(0);
          box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }
        
        .btn:focus {
          outline: 3px solid var(--focus, #1a73e8);
          outline-offset: 2px;
        }
      .btn.secondary {
        background: linear-gradient(45deg, #737d8c, #57606f);
      }
      .btn.success {
        background: linear-gradient(45deg, #2ed573, #1dd1a1);
      }
      .btn.danger {
        background: linear-gradient(45deg, #ff4d4f, #ff2d55);
      }

            /* Sticky top search */
      /* Sticky top search */
      .top-search {
        position: sticky;
        top: 0;
        z-index: 50;
        background: var(--bg);
        border: 2px solid var(--primary);
        border-radius: 14px;
        padding: 12px;
        margin: 12px 0;
        box-shadow: 0 6px 18px rgba(0, 0, 0, 0.06);
      }
      .search-row {
        display: grid;
        grid-template-columns: 1fr 180px auto auto;
        gap: 8px;
        align-items: center;
      }
      
      /* Responsive search row */
      @media (max-width: 768px) {
        .search-row {
          display: flex !important;
          flex-direction: column !important;
          gap: 8px !important;
        }
      }
      .tab-container {
        display: flex;
        gap: 6px;
        background: var(--card);
        padding: 8px;
        border-radius: 12px;
        margin: 14px 0;
      }
      .tab {
        flex: 1;
        border: 0;
        background: transparent;
        padding: 12px 10px;
        border-radius: 10px;
        font-weight: 800;
        cursor: pointer;
      }
      .tab.active {
        background: linear-gradient(45deg, var(--primary), var(--purple));
        color: #fff;
      }
      .tab-badge {
        background: #fff;
        color: var(--primary);
        border-radius: 12px;
        padding: 2px 8px;
        font-size: 12px;
        margin-left: 6px;
      }

      .search-input {
        padding: 10px 12px;
        border-radius: 12px;
        border: 2px solid var(--border);
        background: var(--bg);
        color: var(--text);
      }
      .tag-filters {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        margin-top: 8px;
      }
      .tag-pill {
        padding: 6px 10px;
        border-radius: 999px;
        border: 2px solid var(--border);
        background: var(--card);
        cursor: pointer;
        font-weight: 700;
      }
      .tag-pill.active {
        border-color: var(--primary);
        color: var(--primary);
      }

      .stats {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        margin: 14px 0;
      }
      /* Hide duplicate count cards; keep binge meter only */
      .stats .stat {
        display: none;
      }
      .stat-num {
        font-size: 1.8rem;
        color: var(--primary);
        font-weight: 900;
      }
      .stat-label {
        font-size: 0.72rem;
        color: #80808f;
        text-transform: uppercase;
        font-weight: 900;
        letter-spacing: 0.6px;
      }
      #bingeMeter {
        display: block !important;
        flex-basis: 100% !important;
        order: 0 !important;
      }

      .stat-num {
        font-size: 1.8rem;
        color: var(--primary);
        font-weight: 900;
      }
      .stat-label {
        font-size: 0.72rem;
        color: #80808f;
        text-transform: uppercase;
        font-weight: 900;
        letter-spacing: 0.6px;
      }



      .list-container {
        background: var(--card);
        border: 3px solid var(--border);
        border-radius: 12px;
        padding: 12px;
        min-height: 80px;
      }

      /* Cards */
      .show-card {
        display: grid;
        grid-template-columns: 92px 1fr;
        gap: 16px;
        border: 2px solid var(--border);
        border-radius: 12px;
        padding: 14px;
        margin: 12px 0;
        background: var(--bg);
      }
      .show-poster {
        width: 92px;
        height: 138px;
        border-radius: 8px;
        object-fit: cover;
        cursor: pointer;
      }
      .poster-placeholder {
        width: 92px;
        height: 138px;
        border-radius: 8px;
        display: flex;
        align-items: center;
        justify-content: center;
        background: #e9e9ee;
        color: #777;
        font-size: 12px;
      }
      .show-details {
        display: grid;
        grid-template-rows: auto auto auto 1fr;
        gap: 6px;
        min-width: 0;
      }
      .show-title {
        margin: 0;
        color: var(--primary);
        font-size: 1.05rem;
        font-weight: 900;
        display: flex;
        gap: 8px;
        align-items: center;
        cursor: pointer;
        line-height: 1.2;
      }
      .show-meta {
        color: #8a8a98;
        font-size: 0.88rem;
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
      }
      .show-overview {
        font-size: 0.95rem;
        line-height: 1.45;
        color: var(--text);
        display: -webkit-box;
        -webkit-line-clamp: 3;
        -webkit-box-orient: vertical;
        overflow: hidden;
      }
      .rating-container {
        display: flex;
        align-items: center;
        gap: 10px;
        flex-wrap: wrap;
        margin-top: 6px;
      }
      .star-rating .star {
        cursor: pointer;
        filter: grayscale(1);
      }
      .star-rating .star.active {
        filter: none;
      }
      
      .file-input-label {
        display: flex;
        flex-direction: column;
        gap: 4px;
        cursor: pointer;
      }
      
      .file-input-label input[type="file"] {
        cursor: pointer;
      }
      
      .file-label {
        font-size: 0.85rem;
        color: #666;
        font-style: italic;
      }
      .like-btn,
      .dislike-btn {
        padding: 6px 12px;
        border-radius: 14px;
        background: #dedee3;
        color: #444;
      }
      .like-btn.active {
        background: linear-gradient(45deg, #2ed573, #1dd1a1);
        color: #fff;
      }
      .dislike-btn.active {
        background: linear-gradient(45deg, #ff4757, #ff3742);
        color: #fff;
      }

      .series-pill {
        margin-left: auto;
        padding: 6px 10px;
        border-radius: 999px;
        font-size: 12px;
        font-weight: 900;
        white-space: nowrap;
        border: 1px solid transparent;
      }
      .series-pill.status-ongoing {
        background: rgba(81, 207, 102, 0.16);
        color: #2f9e44;
        border-color: #2f9e44;
      }
      .series-pill.status-ended {
        background: rgba(255, 77, 79, 0.16);
        color: #d63031;
        border-color: #d63031;
      }
      .series-pill.status-upcoming {
        background: rgba(255, 212, 59, 0.16);
        color: #b08900;
        border-color: #b08900;
      }

      /* Banners */
      #bingeBanner {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 4px 0;
      }
      #bingeBanner .binge-time {
        font-family: ui-monospace, Menlo, monospace;
        font-weight: 900;
        color: #ffd43b;
      }
      #bingeBanner .binge-label {
        color: #555;
      }
      #bingeBanner .binge-cta {
        padding: 8px 12px;
        font-size: 0.88rem;
        border-radius: 16px;
        color: #fff;
        background: linear-gradient(
          45deg,
          #ff6b6b,
          #4ecdc4,
          #45b7d1,
          #96ceb4,
          #feca57,
          #ff9ff3,
          #54a0ff
        );
        background-size: 400% 400%;
        animation: rainbow 3s ease-in-out infinite;
        border: 2px solid rgba(255, 255, 255, 0.85);
      }
      @keyframes rainbow {
        0%,
        100% {
          background-position: 0% 50%;
        }
        50% {
          background-position: 100% 50%;
        }
      }

      .notification {
        position: fixed;
        right: 20px;
        top: 20px;
        z-index: 1000;
        color: #fff;
        font-weight: 900;
        padding: 12px 16px;
        border-radius: 10px;
        background: var(--purple);
        animation: fadeout 0.4s ease 2.6s forwards;
      }
      .notification.success {
        background: var(--success);
      }
      .notification.warning {
        background: var(--warning);
        color: #000;
      }
      .notification.error {
        background: var(--danger);
      }
      @keyframes fadeout {
        to {
          opacity: 0;
          transform: translateX(120%);
        }
      }

      /* Modal */
      .modal-backdrop {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.55);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10000;
      }
      .modal {
        background: var(--bg);
        color: var(--text);
        max-width: 680px;
        width: 92%;
        border-radius: 14px;
        border: 2px solid var(--primary);
        padding: 18px;
      }
      .modal h3 {
        margin: 0 0 10px;
        color: var(--primary);
      }
      .modal .modal-actions {
        display: flex;
        justify-content: flex-end;
        gap: 8px;
        margin-top: 14px;
      }

      /* Mobile */
      @media (max-width: 768px) {
        body {
          padding: 16px;
        }
        .main-container {
          padding: 16px;
        }
        .search-row {
          display: flex !important;
          flex-direction: column !important;
          gap: 8px !important;
        }
        .search-input {
          width: 100% !important;
          font-size: 16px;
        }
        .search-filters {
          display: flex !important;
          gap: 8px !important;
        }
        #genreFilter {
          flex: 1 !important;
        }
        .search-container {
          background: var(--card);
          border: 2px solid var(--primary);
          border-radius: 14px;
          padding: 12px;
          margin: 14px 0;
        }
        .search-container .btn {
          flex: 1 !important;
          min-height: 44px;
        }

        .show-actions {
          display: flex !important;
          flex-direction: column !important;
          gap: 8px !important;
        }
        .show-actions .btn {
          display: block !important;
          width: 100% !important;
          margin: 0 !important;
          box-sizing: border-box !important;
          text-align: center !important;
          white-space: normal !important;
          overflow: hidden !important;
          text-overflow: ellipsis !important;
          min-height: 44px !important;
        }
        
        .show-card {
          grid-template-columns: 80px 1fr;
          gap: 12px;
          padding: 12px;
        }
        .show-poster {
          width: 80px;
          height: 120px;
        }
        .poster-placeholder {
          width: 80px;
          height: 120px;
        }
        .show-title {
          font-size: 1rem;
        }
        .show-meta {
          font-size: 0.85rem;
        }
        .show-overview {
          font-size: 0.9rem;
        }
        .rating-container {
          gap: 4px;
        }
        .star-btn {
          padding: 4px;
          min-width: 32px;
        }
      }

      /* iPhone specific */
      @media (max-width: 428px) {
        body {
          padding: 12px;
        }
        .main-container {
          padding: 12px;
        }
        .search-row {
          gap: 6px !important;
        }
        .search-input {
          padding: 8px 10px;
        }
        .btn {
          padding: 8px 12px;
          font-size: 14px;
        }
        .show-card {
          grid-template-columns: 70px 1fr;
          gap: 10px;
          padding: 10px;
        }
        .show-poster {
          width: 70px;
          height: 105px;
        }
        .poster-placeholder {
          width: 70px;
          height: 105px;
        }
        .show-title {
          font-size: 0.95rem;
        }
        .show-meta {
          font-size: 0.8rem;
        }
        .show-overview {
          font-size: 0.85rem;
        }
      }

      /* iPhone notch/safe area support */
      @supports (padding: max(0px)) {
        body {
          padding-left: max(12px, env(safe-area-inset-left));
          padding-right: max(12px, env(safe-area-inset-right));
          padding-top: max(12px, env(safe-area-inset-top));
          padding-bottom: max(12px, env(safe-area-inset-bottom));
        }
      }

      /* iOS-specific button styling */
      .btn {
        -webkit-appearance: none;
        touch-action: manipulation;
        user-select: none;
      }
      .btn:active {
        transform: scale(0.98);
      }

      /* Missing CSS classes */
      .section {
        margin: 20px 0;
      }
      .section-header {
        margin-bottom: 12px;
      }
      .section-header h3 {
        margin: 0;
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .tab-section {
        display: none;
      }
      .tab-section.active {
        display: block;
      }
      .count {
        background: var(--primary);
        color: white;
        border-radius: 12px;
        padding: 2px 8px;
        font-size: 12px;
        margin-left: 6px;
      }
      .binge-banner {
        background: linear-gradient(45deg, var(--mardi1), var(--mardi3));
        color: white;
        padding: 12px 16px;
        border-radius: 10px;
        margin: 14px 0;
        text-align: center;
        animation: fadeout 0.4s ease 2.6s forwards;
      }
      .modal {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.8);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1000;
        padding: 20px;
      }
      .modal-content {
        background: var(--bg);
        color: var(--text);
        max-width: 680px;
        width: 92%;
        border-radius: 14px;
        border: 2px solid var(--primary);
        padding: 18px;
        max-height: 90vh;
        overflow-y: auto;
      }
      .modal h3 {
        margin: 0 0 10px;
        color: var(--primary);
      }
      .empty-state {
        text-align: center;
        color: #666;
        padding: 20px;
        font-style: italic;
      }
      .notification {
        position: fixed;
        top: 20px;
        right: 20px;
        background: var(--purple);
        color: white;
        padding: 12px 16px;
        border-radius: 10px;
        z-index: 1000;
        animation: fadeout 0.4s ease 2.6s forwards;
      }
      .notification.success {
        background: var(--success);
      }
      .notification.warning {
        background: var(--warning);
        color: #000;
      }
      .notification.error {
        background: var(--danger);
      }
      @keyframes fadeout {
        to {
          opacity: 0;
          transform: translateY(-10px);
        }
      }

      /* Banners */
      #bingeBanner {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 4px 0;
      }
      #bingeBanner .binge-time {
        font-family: ui-monospace, Menlo, monospace;
        font-weight: 900;
        color: #ffd43b;
      }
      #bingeBanner .binge-label {
        color: #555;
      }
      #bingeBanner .binge-cta {
        padding: 8px 12px;
        font-size: 0.88rem;
        border-radius: 16px;
        color: #fff;
        background: linear-gradient(
          45deg,
          #ff6b6b,
          #4ecdc4,
          #45b7d1,
          #96ceb4,
          #feca57,
          #ff9ff3,
          #54a0ff
        );
        background-size: 400% 400%;
        animation: rainbow 3s ease-in-out infinite;
        border: 2px solid rgba(255, 255, 255, 0.85);
      }
      @keyframes rainbow {
        0%,
        100% {
          background-position: 0% 50%;
        }
        50% {
          background-position: 100% 50%;
        }
      }

      .feedback-card {
        background: var(--card);
        border: 2px solid var(--primary);
        border-radius: 14px;
        padding: 12px;
        margin: 14px 0;
      }
      
      .feedback-form {
        margin-top: 12px;
      }
      
      .feedback-form .hidden {
        display: none;
      }
      
      .feedback-form textarea {
        flex: 1;
        min-width: 200px;
      }
    
      .form-error {
        color: #b00020;
        margin-top: 6px;
        font-size: 0.9rem;
      }

      @media (prefers-reduced-motion: reduce) {
        #bingeBanner .binge-cta { animation: none !important; }
      }

      .btn-link {
        background: none;
        border: none;
        color: var(--primary);
        font-weight: 900;
        text-decoration: underline;
        padding: 0;
        cursor: pointer;
      }

      /* Accessibility helpers */
      .skip-link {
        position: absolute;
        left: -9999px;
        top: auto;
        width: 1px;
        height: 1px;
        overflow: hidden;
      }
      .skip-link:focus {
        position: fixed;
        left: 8px;
        top: 8px;
        width: auto;
        height: auto;
        padding: 8px 12px;
        background: #000;
        color: #fff;
        z-index: 1000;
        border-radius: 6px;
        outline: 3px solid #fff;
      }
      .sr-only {
        position: absolute !important;
        width: 1px !important;
        height: 1px !important;
        padding: 0 !important;
        margin: -1px !important;
        overflow: hidden !important;
        clip: rect(0, 0, 0, 0) !important;
        white-space: normal !important;
        border: 0 !important;
      }
      /* High-contrast focus ring */
      :focus-visible {
        outline: 3px solid var(--focus, #1a73e8);
        outline-offset: 2px;
      }
      body.dark-mode :focus-visible {
        outline-color: #fff;
      }
      /* Card overflow & wrapping */
      .show-card { overflow: hidden; }
      .show-title, .show-meta, .rating-container, .show-actions { min-width: 0; overflow-wrap: anywhere; }
      .show-actions { display: flex; flex-wrap: wrap; gap: 8px; }
      .show-actions .btn { white-space: normal; }
      /* Poster button reset */
      .poster-button {
        border: none;
        background: none;
        padding: 0;
        margin: 0;
        cursor: pointer;
        display: block;
      }
      .star-rating { display: inline-flex; gap: 2px; }
      .star-btn {
        border: none;
        background: none;
        padding: 2px;
        line-height: 1;
        cursor: pointer;
        font-size: 1.1rem;
      }
      .star-btn.active { 
        filter: saturate(1.2) brightness(1.1); 
        color: #0066cc; 
        transform: scale(1.1); 
        text-shadow: 0 0 6px rgba(0, 102, 204, 0.6);
        font-weight: bold;
        font-size: 1.3rem;
      }
      
      .star-btn {
        border: none;
        background: none;
        padding: 2px;
        line-height: 1;
        cursor: pointer;
        font-size: 1.1rem;
        color: #333;
      }
      </style>
  
<style id="tabs-only-fix">
/* ===== Tabs-only fix (does not touch sticky search) ===== */

/* Guard: never create a scroll container on sticky */
.top-search, header.header { overflow: visible !important; }

/* Reset tab flex growth from earlier styles */
.tab-container .tab { 
  flex: 0 0 auto !important; 
  white-space: nowrap !important;
}

/* Desktop / wide: single-row horizontal scroll */
@media (min-width: 769px) {
  .tab-container {
    display: block !important;
    overflow-x: auto !important;   /* horizontal scroll lives only here */
    overflow-y: visible !important;
    -webkit-overflow-scrolling: touch;
    white-space: nowrap !important;
    padding-bottom: 4px;           /* space for thin scrollbar */
    mask-image: linear-gradient(to right, transparent 0, #000 16px, #000 calc(100% - 16px), transparent 100%);
  }
  .tab-container .tab {
    display: inline-flex !important;
    align-items: center;
    justify-content: center;
    margin-right: 6px;
  }
  /* Optional: subtle end fade (non-critical) */
  .tab-container::-webkit-scrollbar { height: 6px; }
}

/* Mobile: stack neatly in two columns */
@media (max-width: 768px) {
  .tab-container {
    overflow: visible !important;  /* remove horizontal scroll on mobile */
    display: grid !important;
    grid-template-columns: 1fr 1fr !important;
    gap: 8px !important;
    white-space: normal !important;
  }
  .tab-container .tab {
    width: 100% !important;
    justify-content: center;
    min-height: 44px;
  }
}
</style>

</head>

  <body>
    <a href="#main" class="skip-link">Skip to main content</a>
    <div id="liveRegion" class="sr-only" role="status" aria-live="polite"></div>


    <div class="main-container" id="appRoot">
      <header class="header" role="banner">
        <div>
          <h1 id="welcomeText" class="title" data-i18n="app_title">Flicklet</h1>
          <div class="subtitle" data-i18n="subtitle">TV & Movie Tracker</div>
          <div id="bingeBanner" class="binge-banner" aria-live="polite"></div>
        </div>
        <div class="user-section">
          <button id="darkModeToggle" class="btn" title="Theme">
            🌙 <span data-i18n="go_dark">Go Dark</span>
          </button>
          <button
            id="mardiToggle"
            class="btn secondary"
            title="Mardi Gras mode"
          >
            🎭 <span data-i18n="mardi_gras_mode">Mardi</span>
          </button>
          <button
            id="accountBtn"
            class="btn secondary"
            title="Sign in / Account"
          >
            👤 <span data-i18n="sign_in_account">Sign In</span>
          </button>
                  <select id="langToggle" aria-label="Language" title="Language" onchange="changeLanguage(this.value).catch(console.error)">
          <option value="en">EN</option>
          <option value="es">ES</option>
        </select>
        </div>
      </header>

      <!-- Sticky Top Search -->
      <div class="top-search">
        <div class="search-row">
          <input
            id="searchInput"
            class="search-input"
            placeholder=""
            data-i18n-placeholder="search_placeholder"
          />
          <select id="genreFilter">
            <option value="" data-i18n="all_genres">All Genres</option>
          </select>
          <button id="searchBtn" class="btn">🔍 <span data-i18n="search">Search</span></button>
          <button id="clearSearchBtn" class="btn secondary">
            ✖️ <span data-i18n="clear">Clear</span>
          </button>
        </div>
        <div
          id="tagFilterRow"
          class="tag-filters"
          aria-label="Tag filters"
        ></div>
      </div>

      <div class="tab-container">
        <button id="homeTab" class="tab active">🏠 <span data-i18n="home">Home</span></button>
        <button id="watchingTab" class="tab">
          ▶️ <span data-i18n="currently_watching">Currently Watching</span>
          <span class="tab-badge" id="watchingBadge">0</span>
        </button>
        <button id="wishlistTab" class="tab">
          📖 <span data-i18n="want_to_watch">Want to Watch</span>
          <span class="tab-badge" id="wishlistBadge">0</span>
        </button>
        <button id="watchedTab" class="tab">
          ✅ <span data-i18n="already_watched">Already Watched</span>
          <span class="tab-badge" id="watchedBadge">0</span>
        </button>
        <button id="discoverTab" class="tab">✨ <span data-i18n="discover">Discover</span></button>
        <button id="settingsTab" class="tab">⚙️ <span data-i18n="settings">Settings</span></button>
      </div>

      <!-- Results -->
      <div id="searchResults" class="section" style="display: none">
                  <h3>
            🎯 <span data-i18n="search_results">Search Results</span> <span class="count" id="resultsCount">0</span>
          </h3>
        <div id="searchResultsList" class="list-container"></div>
      </div>

      <!-- Home -->
      <div id="homeSection" class="tab-section">
        <div class="stats">
          <div class="stat" id="bingeMeter"></div>
        </div>

        <!-- Mardi Gras Toggle -->
        <div class="feedback-card">
          <h3>🎭 <span data-i18n="theme">Theme</span> Toggle</h3>
          <p data-i18n="theme_description">Switch between different visual themes for the app.</p>
          <div style="display: flex; gap: 8px; flex-wrap: wrap">
            <button
              id="mardiOnBtn"
              class="btn secondary"
              title="Toggle Mardi Gras theme"
            >
              🎭 <span data-i18n="mardi_gras_mode">Mardi Gras</span>
            </button>
          </div>
        </div>
      </div>

      <main id="main" role="main">

      <!-- Watching -->
      <div id="watchingSection" class="tab-section" style="display: none">
        <div class="section">
          <div class="section-header">
            <h3>
              ▶️ <span data-i18n="currently_watching">Currently Watching</span>
              <span class="count" id="watchingCount">0</span>
            </h3>
          </div>
          <div id="watchingList" class="list-container"></div>
        </div>
      </div>

      <!-- Wishlist -->
      <div id="wishlistSection" class="tab-section" style="display: none">
        <div class="section">
          <div class="section-header">
            <h3>
              📖 <span data-i18n="want_to_watch">Want to Watch</span>
              <span class="count" id="wishlistCount">0</span>
            </h3>
          </div>
          <div id="wishlistList" class="list-container"></div>
        </div>
      </div>

      <!-- Watched -->
      <div id="watchedSection" class="tab-section" style="display: none">
        <div class="section">
          <div class="section-header">
            <h3>
              ✅ <span data-i18n="already_watched">Already Watched</span>
              <span class="count" id="watchedCount">0</span>
            </h3>
          </div>
          <div id="watchedList" class="list-container"></div>
        </div>
      </div>

      <!-- Discover -->
              <div id="discoverSection" class="tab-section" style="display: none">
          <div class="section">
            <h3>✨ <span data-i18n="discover">Discover</span></h3>
            <p data-i18n="discover_description">Recommendations based on your likes and ratings.</p>
            <div id="discoverList" class="list-container"></div>
          </div>
        </div>

      <!-- Settings / Profile -->
              <div id="settingsSection" class="tab-section" style="display: none">
          <div class="section">
            <h3>⚙️ <span data-i18n="settings">Settings</span></h3>

          <div
            style="
              display: flex;
              gap: 10px;
              flex-wrap: wrap;
              align-items: center;
              margin-bottom: 8px;
            "
          >
            <input
              id="displayNameInput"
              class="search-input"
              placeholder=""
              data-i18n-placeholder="display_name_placeholder"
            />
            <button id="saveNameBtn" class="btn secondary" data-i18n="save_name">Save</button>
            <label style="display: flex; gap: 6px; align-items: center">
              <input type="checkbox" id="proToggle" /> <span data-i18n="pro_simulate">Pro (simulate)</span>
            </label>
            <div id="proFeatures" style="display: none; margin-top: 8px; padding: 8px; background: var(--card); border-radius: 8px; font-size: 0.9rem;">
              <strong data-i18n="pro_features">Pro Features:</strong>
              <ul style="margin: 4px 0; padding-left: 20px;">
                <li data-i18n="pro_feature_analytics">Advanced analytics & insights</li>
                <li data-i18n="pro_feature_categories">Custom watchlist categories</li>
                <li data-i18n="pro_feature_export">Export to multiple formats</li>
                <li data-i18n="pro_feature_support">Priority customer support</li>
                <li data-i18n="pro_feature_early_access">Early access to new features</li>
              </ul>
            </div>
          </div>

          <h4 data-i18n="backup_import">Backup & Import</h4>
          <div
            style="
              display: flex;
              gap: 10px;
              flex-wrap: wrap;
              align-items: center;
              margin-bottom: 8px;
            "
          >
            <label for="importFile" class="file-input-label">
              <span data-i18n="choose_file">Choose File</span>
              <input
                id="importFile"
                type="file"
                accept=".json"
                style="max-width: 220px"
                onchange="updateFileLabel(this)"
              />
              <span id="fileLabel" class="file-label" data-i18n="no_file_chosen">No file chosen</span>
            </label>
            <button id="exportBtn" class="btn success">📤 <span data-i18n="export">Export</span></button>
            <button id="clearAllBtn" class="btn danger">
              🗑️ <span data-i18n="nuclear_option">Nuclear Option</span>
            </button>
            <button
              id="shareListBtn"
              class="btn"
              title="Generate share link for current tab"
            >
              🔗 <span data-i18n="share_this_list">Share This List</span>
            </button>
            <input
              id="shareLinkOut" aria-label="Share link output"
              class="search-input"
              placeholder=""
              data-i18n-placeholder="share_link"
              readonly
            />
          </div>

          <h4 data-i18n="notifications">Notifications</h4>
          <div
            style="
              display: flex;
              gap: 10px;
              flex-wrap: wrap;
              align-items: center;
              margin-bottom: 8px;
            "
          >
            <label
              ><input type="checkbox" id="notifEpisodes" /> <span data-i18n="episode_alerts">Upcoming episode alerts</span></label
            >
            <label
              ><input type="checkbox" id="notifDiscover" /> <span data-i18n="weekly_discover">Weekly discover picks</span></label
            >
            <label
              ><input type="checkbox" id="notifDigest" /> <span data-i18n="monthly_digest">Monthly stats digest</span></label
            >
                      </div>
  
          <h4 data-i18n="stats">Stats</h4>
          <div id="statsBasic" class="feedback-card">
            <div id="statsBasicBody" data-i18n="loading">Loading…</div>
          </div>
          <div id="statsPro" class="feedback-card" style="display: none">
            <strong data-i18n="pro">Pro</strong>
            <div id="statsProBody" data-i18n="loading">Loading…</div>
          </div>
          </div>
      </div>
    </div>

    <!-- Firebase (compat for simplicity) -->
      </main>

    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>

    <script>
      /* ============== i18n (EN/ES) ============== */
      const I18N = {
        en: {
          go_dark: "🌙 Go Dark",
          go_light: "☀️ Go Light",
          app_title: "Flicklet",
          subtitle: "TV & Movie Tracker",
          binge_total: "Total Binge Time",
          currently_watching: "Currently Watching",
          want_to_watch: "Want to Watch",
          already_watched: "Already Watched",
          streaming_on: "Streaming",
          clear: "Clear",
          series_complete: "Series Complete",
          coming_soon: "Coming Soon",
          currently_airing: "Currently Airing",
          next: "Next",
          last: "Last",
          start: "Start",
          because_you_liked: "Because you liked",
          search_placeholder: "Search for shows or movies...",
          all_genres: "All Genres",
          search: "Search",
          notes_tags: "Notes/Tags",
          remove: "Remove",
          your_rating: "Your Rating",
          welcome_title: "Welcome! What should we call you?",
          welcome_subtitle: "This will personalize your headers and stats.",
          display_name: "Display name",
          save: "Save",
          sign_in_title: "Sign in to sync",
          sign_in_subtitle: "Sign in to back up your lists and sync across devices.",
          continue_google: "Continue with Google",
          email_signin: "Email Sign-In",
          sign_out: "Sign Out",
          home: "Home",
          discover: "Discover",
          settings: "Settings",
          no_items: "No items.",
          no_description: "No description.",
          already_in_list: "Already in {list}.",
          moved_to: "Moved to {list}.",
          added_to: "Added to {list}.",
          // Additional English translations
          feedback: "Feedback",
          feedback_placeholder: "Your feedback...",
          send: "Send",
          search_results: "Search Results",
          no_results: "No results",
          searching: "Searching...",
          search_failed: "Search failed",
          episode_alerts: "Episode alerts",
          weekly_discover: "Weekly discover picks",
          monthly_digest: "Monthly stats digest",
          backup_import: "Backup & Import",
          nuclear_option: "Nuclear Option",
          share_this_list: "Share This List",
          share_link: "Share link",
          choose_file: "Choose File",
                  no_file_chosen: "No file chosen",
        next: "Next",
        last: "Last",
        upcoming_episode: "Upcoming episode",
          welcome: "Welcome",
          theme: "Theme",
          theme_description: "Switch between different visual themes for the app.",
          mardi_gras_mode: "Mardi Gras mode",
          sign_in_account: "Sign in / Account",
          language: "Language",
          all_genres: "All Genres",
          search_for_shows: "Search for shows or movies...",
          currently_watching_count: "Currently Watching",
          want_to_watch_count: "Want to Watch",
          already_watched_count: "Already Watched",
          discover_description: "Recommendations based on your likes and ratings.",
          settings_description: "Application settings",
          display_name_placeholder: "Display name",
          save_name: "Save",
          pro_simulate: "Pro (simulate)",
          notifications: "Notifications",
          stats: "Stats",
          total_items: "Total items",
          watching_count: "Watching",
          wishlist_count: "Wishlist",
          watched_count: "Watched",
          top_genres: "Top Genres",
          average_rating: "Average Rating",
          loading: "Loading...",
          failed_to_load: "Failed to load",
          not_enough_signals: "Not enough signals yet. Like or rate a few items first.",
          recommendations_failed: "Failed to load recommendations.",
          building_recommendations: "Building recommendations...",
          remove_confirmation: "Remove \"{title}\" from this list?",
          already_in_list_warning: "Already in {list}.",
          moved_to_list: "Moved to {list}.",
          added_to_list: "Added to {list}.",
          cloud_sync_ok: "Cloud sync OK",
          cloud_load_failed: "Cloud load failed. Using local.",
          cloud_sync_failed: "Cloud sync failed. Saved locally.",
          signed_in: "Signed in",
          signed_out: "Signed out",
          login_failed: "Login failed",
          name_saved: "Name saved!",
          enter_name_first: "Enter a name first.",
          imported_backup: "Imported backup.",
          invalid_file: "Invalid file.",
          all_data_cleared: "All data cleared.",
          share_link_generated: "Share link generated.",
          switch_to_share: "Switch to Watching/Wishlist/Watched to share.",
          imported_from_link: "Imported list from link",
          could_not_read_item: "Couldn't read item details. Try again.",
          upcoming_episode_alert: "Upcoming: {title} • {date}",
          streaming_horoscope: "Streaming Horoscope",
          feedback_working: "Tell us what's working and what's not. Be blunt.",
          quote_loading: "Loading quote of questionable value...",
          // Quote translations
          quote_1: "I am serious... and don't call me Shirley.",
          quote_2: "Streaming is a lifestyle, not a choice.",
          quote_3: "Binge now. Cry later.",
          quote_4: "One does not simply watch one episode.",
          quote_5: "You had me at 'skip recap.'",
          quote_6: "Art is long, episodes are longer.",
          quote_7: "We were on a break! From reality.",
          quote_8: "I came, I saw, I queued it.",
          quote_9: "To stream, perchance to nap.",
          quote_10: "In this house we respect the 'Are you still watching?' prompt.",
          quote_11: "The algorithm thinks I'm complicated. It's right.",
          quote_12: "If found, return to the couch.",
          quote_13: "My love language is 'skip ad.'",
          quote_14: "I contain multitudes and several watchlists.",
          quote_15: "Sundays are for pilots and denial.",
          quote_16: "Ctrl+Z for life, play for comfort.",
          quote_17: "I fear no man, but I fear finales.",
          quote_18: "This app gets me. Terrifying.",
          quote_19: "Plot holes are just cardio for the brain.",
          quote_20: "We accept the dopamine we think we deserve.",
          quote_21: "I have never finished anything. Except seasons.",
          quote_22: "Today's vibe: closed captions and open snacks.",
          quote_23: "Foreshadowing? I hardly know her.",
          quote_24: "Character development is my cardio.",
          quote_25: "If the title card hits, I'm staying.",
          quote_26: "Minimalism, but for episodes.",
          quote_27: "'Are you still watching?' yes, Netflix, I'm thriving.",
          quote_28: "I ship productivity with naps.",
          quote_29: "Comfort show supremacy.",
          quote_30: "This queue is a personality test I'm failing.",
          // Horoscope translations
          you_love_a_slow_burn_and_fast_wifi: "You love a slow burn and fast Wi‑Fi.",
          youre_allergic_to_laugh_tracks: "You're allergic to laugh tracks.",
          you_pause_for_snacks_like_its_a_ritual: "You pause for snacks like it's a ritual.",
          you_are_a_spoiler_ninja_and_an_ending_apologist: "You are a spoiler ninja and an ending apologist.",
          you_think_limited_series_means_limits_dont_apply_to_you: "You think 'limited series' means limits don't apply to you.",
          you_fastforward_opening_credits_but_respect_end_credits: "You fast‑forward opening credits but respect end credits.",
          you_crave_vibes_plot_bold_choice: "You crave vibes > plot. Bold choice.",
          you_treat_recommended_for_you_as_a_dare: "You treat 'recommended for you' as a dare.",
          you_chase_vibes_like_a_sommelier_of_scenes: "You chase vibes like a sommelier of scenes.",
          you_watch_with_subtitles_you_are_cultured_and_quiet: "You watch with subtitles; you are cultured (and quiet).",
          you_fear_the_finale_but_press_play_anyway: "You fear the finale but press play anyway.",
          you_bookmark_chaos_and_call_it_variety: "You bookmark chaos and call it variety.",
          you_own_three_blankets_all_the_good_one: "You own three blankets. All 'the good one'.",
          you_pretend_the_algorithm_is_your_friend: "You pretend the algorithm is your friend.",
          you_rewatch_comfort_episodes_like_vitamins: "You rewatch comfort episodes like vitamins.",
          you_hoard_tabs_and_storylines_with_equal_skill: "You hoard tabs and storylines with equal skill.",
          you_skip_recaps_then_google_plot_summaries_iconic: "You skip recaps, then Google plot summaries. Iconic.",
          // Additional missing horoscope translations
          you_are_a_chaotic_good_you_like_drama_but_call_it_cinema: "You are a Chaotic Good. You like drama but call it 'cinema.'",
          binge_minimalist_planning_watching: "Binge Minimalist: 90% planning, 10% watching.",
          comfort_chaos_and_clever_twists: "Comfort, chaos, and clever twists. In that order.",
          on_your_rewatch_arc_brave: "On your 14th rewatch arc. Brave.",
          fueled_by_snacks_and_unresolved_plotlines: "63% fueled by snacks and unresolved plotlines.",
          human_embodiment_of_skip_intro: "Human embodiment of 'skip intro.'",
          your_spirit_animal_is_a_loading_spinner: "Your spirit animal is a loading spinner.",
          you_collect_pilots_like_pokemon: "You collect pilots like Pokémon.",
          you_claim_you_hate_cliffhangers_you_dont: "You claim you hate cliffhangers. You don't.",
          you_alphabetize_your_watchlist_and_then_ignore_it: "You alphabetize your watchlist and then ignore it.",
          you_believe_one_more_episode_is_a_contract_with_destiny: "You believe 'one more episode' is a contract with destiny.",
          you_rate_with_your_heart_not_the_stars: "You rate with your heart, not the stars.",
          youre_here_to_procrastinate_responsibly: "You're here to procrastinate responsibly.",
          export: "Export",
          unknown_title: "Unknown Title",
          no_image: "No Image",
          like: "Like",
          dislike: "Dislike",
          rate_out_of_5: "Rate {n} out of 5",
          notifications_enabled: "Notifications enabled! You'll get episode reminders.",
          pro_features: "Pro Features:",
          pro_feature_analytics: "Advanced analytics & insights",
          pro_feature_categories: "Custom watchlist categories",
          pro_feature_export: "Export to multiple formats",
          pro_feature_support: "Priority customer support",
          pro_feature_early_access: "Early access to new features",
          pro: "Pro",
          // Genre translations
          action: "Action",
          adventure: "Adventure",
          animation: "Animation",
          comedy: "Comedy",
          crime: "Crime",
          documentary: "Documentary",
          drama: "Drama",
          family: "Family",
          fantasy: "Fantasy",
          history: "History",
          horror: "Horror",
          music: "Music",
          mystery: "Mystery",
          romance: "Romance",
          science_fiction: "Science Fiction",
          tv_movie: "TV Movie",
          thriller: "Thriller",
          war: "War",
          western: "Western",
          // Additional genre combinations
          action_adventure: "Action & Adventure",
          kids: "Kids",
          news: "News",
          reality: "Reality",
          sci_fi_fantasy: "Sci-Fi & Fantasy",
          soap: "Soap",
          talk: "Talk",
          war_politics: "War & Politics",
          // Additional missing genres
          talk_show: "Talk Show",
          // Additional TMDB genre variations
          reality_tv: "Reality TV",
        },
        es: {
          // Genre translations
          action: "Acción",
          adventure: "Aventura",
          animation: "Animación",
          comedy: "Comedia",
          crime: "Crimen",
          documentary: "Documental",
          drama: "Drama",
          family: "Familiar",
          fantasy: "Fantasía",
          history: "Historia",
          horror: "Terror",
          music: "Música",
          mystery: "Misterio",
          romance: "Romance",
          science_fiction: "Ciencia ficción",
          tv_movie: "Película de TV",
          thriller: "Suspenso",
          war: "Guerra",
          western: "Western",
          // Add Spanish genre names that TMDB returns
          animación: "Animación",
          comedia: "Comedia",
          crimen: "Crimen",
          documental: "Documental",
          familiar: "Familiar",
          misterio: "Misterio",
          // Additional genre combinations
          action_adventure: "Acción y Aventura",
          kids: "Niños",
          news: "Noticias",
          reality: "Realidad",
          sci_fi_fantasy: "Ciencia Ficción y Fantasía",
          soap: "Telenovela",
          talk: "Programa de Entrevistas",
          war_politics: "Guerra y Política",
          // Additional missing genres
          talk_show: "Programa de Entrevistas",
          // Additional TMDB genre variations
          reality_tv: "Realidad TV",
          // Fix for specific genres still in English
          sci_fi_fantasy: "Ciencia Ficción y Fantasía",
          action_adventure: "Acción y Aventura",
          go_dark: "🌙 Modo oscuro",
          go_light: "☀️ Modo claro",
          app_title: "Flicklet",
          subtitle: "Seguimiento de series y películas",
          binge_total: "Tiempo total de maratón",
          currently_watching: "Viendo actualmente",
          want_to_watch: "Quiero ver",
          already_watched: "Ya visto",
          streaming_on: "En",
          clear: "Limpiar",
          series_complete: "Serie terminada",
          coming_soon: "Próximamente",
          currently_airing: "En emisión",
          next: "Próx.",
          last: "Últ.",
          start: "Comenzar",
          because_you_liked: "Porque te gustó",
          search_placeholder: "Buscar series o películas...",
          all_genres: "Todos los géneros",
          search: "Buscar",
          notes_tags: "Notas/Etiquetas",
          remove: "Eliminar",
          your_rating: "Tu calificación",
          welcome_title: "¡Bienvenido! ¿Cómo te llamamos?",
          welcome_subtitle: "Esto personalizará tus encabezados y estadísticas.",
          display_name: "Nombre para mostrar",
          save: "Guardar",
          sign_in_title: "Iniciar sesión para sincronizar",
          sign_in_subtitle: "Inicia sesión para respaldar tus listas y sincronizar entre dispositivos.",
          continue_google: "Continuar con Google",
          email_signin: "Iniciar sesión con email",
          sign_out: "Cerrar sesión",
          home: "Inicio",
          discover: "Descubrir",
          settings: "Configuración",
          no_items: "No hay elementos.",
          no_description: "Sin descripción.",
          already_in_list: "Ya está en {list}.",
          moved_to: "Movido a {list}.",
          added_to: "Agregado a {list}.",
          // Additional Spanish translations
          feedback: "Comentarios",
          feedback_placeholder: "Tu comentario...",
          send: "Enviar",
          search_results: "Resultados de búsqueda",
          no_results: "Sin resultados",
          searching: "Buscando...",
          search_failed: "Búsqueda falló",
          episode_alerts: "Alertas de episodios",
          weekly_discover: "Descubrimientos semanales",
          monthly_digest: "Resumen mensual",
          backup_import: "Respaldo e importación",
          nuclear_option: "Opción nuclear",
          share_this_list: "Compartir esta lista",
          share_link: "Enlace de compartir",
          choose_file: "Elegir Archivo",
                  no_file_chosen: "Ningún archivo elegido",
        next: "Próximo",
        last: "Último",
        upcoming_episode: "Episodio próximo",
          welcome: "Bienvenido",
          theme: "Tema",
          theme_description: "Cambia entre diferentes temas visuales para la aplicación.",
          mardi_gras_mode: "Modo Mardi Gras",
          sign_in_account: "Iniciar sesión / Cuenta",
          language: "Idioma",
          all_genres: "Todos los géneros",
          search_for_shows: "Buscar series o películas...",
          currently_watching_count: "Viendo actualmente",
          want_to_watch_count: "Quiero ver",
          already_watched_count: "Ya visto",
          discover_description: "Recomendaciones basadas en tus gustos y calificaciones.",
          settings_description: "Configuración de la aplicación",
          display_name_placeholder: "Nombre para mostrar",
          save_name: "Guardar",
          pro_simulate: "Pro (simular)",
          notifications: "Notificaciones",
          stats: "Estadísticas",
          total_items: "Total de elementos",
          watching_count: "Viendo",
          wishlist_count: "Lista de deseos",
          watched_count: "Visto",
          top_genres: "Géneros principales",
          average_rating: "Calificación promedio",
          loading: "Cargando...",
          failed_to_load: "Falló al cargar",
          not_enough_signals: "No hay suficientes señales. Dale me gusta o califica algunos elementos primero.",
          recommendations_failed: "Falló al cargar recomendaciones.",
          building_recommendations: "Construyendo recomendaciones...",
          remove_confirmation: "¿Eliminar \"{title}\" de esta lista?",
          already_in_list_warning: "Ya está en {list}.",
          moved_to_list: "Movido a {list}.",
          added_to_list: "Agregado a {list}.",
          cloud_sync_ok: "Sincronización en la nube OK",
          cloud_load_failed: "Carga de la nube falló. Usando local.",
          cloud_sync_failed: "Sincronización en la nube falló. Guardado localmente.",
          signed_in: "Sesión iniciada",
          signed_out: "Sesión cerrada",
          login_failed: "Inicio de sesión falló",
          name_saved: "¡Nombre guardado!",
          enter_name_first: "Ingresa un nombre primero.",
          imported_backup: "Respaldo importado.",
          invalid_file: "Archivo inválido.",
          all_data_cleared: "Todos los datos borrados.",
          share_link_generated: "Enlace de compartir generado.",
          switch_to_share: "Cambia a Ver/Lista de deseos/Visto para compartir.",
          imported_from_link: "Lista importada desde enlace",
          could_not_read_item: "No se pudieron leer los detalles del item. Intenta de nuevo.",
          upcoming_episode_alert: "Próximo: {title} • {date}",
          streaming_horoscope: "Horóscopo de streaming",
          feedback_working: "Dinos qué está funcionando y qué no. Sé directo.",
          quote_loading: "Cargando cita de valor cuestionable...",
          // Quote translations
          quote_1: "Soy serio... y no me llames Shirley.",
          quote_2: "El streaming es un estilo de vida, no una elección.",
          quote_3: "Maratón ahora. Llora después.",
          quote_4: "Uno no simplemente ve un episodio.",
          quote_5: "Me tuviste en 'saltar resumen.'",
          quote_6: "El arte es largo, los episodios son más largos.",
          quote_7: "¡Estábamos en una pausa! De la realidad.",
          quote_8: "Vine, vi, lo puse en cola.",
          quote_9: "Transmitir, tal vez dormir.",
          quote_10: "En esta casa respetamos el aviso '¿Sigues viendo?'",
          quote_11: "El algoritmo piensa que soy complicado. Tiene razón.",
          quote_12: "Si se encuentra, devolver al sofá.",
          quote_13: "Mi lenguaje del amor es 'saltar anuncio.'",
          quote_14: "Contengo multitudes y varias listas de reproducción.",
          quote_15: "Los domingos son para pilotos y negación.",
          quote_16: "Ctrl+Z para la vida, reproducir para comodidad.",
          quote_17: "No temo a ningún hombre, pero temo a los finales.",
          quote_18: "Esta aplicación me entiende. Aterrador.",
          quote_19: "Los agujeros de trama son solo cardio para el cerebro.",
          quote_20: "Aceptamos la dopamina que creemos merecer.",
          quote_21: "Nunca he terminado nada. Excepto temporadas.",
          quote_22: "Vibra de hoy: subtítulos cerrados y aperitivos abiertos.",
          quote_23: "¿Presagio? Apenas la conozco.",
          quote_24: "El desarrollo de personajes es mi cardio.",
          quote_25: "Si golpea la tarjeta de título, me quedo.",
          quote_26: "Minimalismo, pero para episodios.",
          quote_27: "'¿Sigues viendo?' sí, Netflix, estoy prosperando.",
          quote_28: "Envío productividad con siestas.",
          quote_29: "Supremacía del programa de comodidad.",
          quote_30: "Esta cola es una prueba de personalidad que estoy fallando.",
          // Horoscope translations in Spanish
          you_love_a_slow_burn_and_fast_wifi: "Te encanta el desarrollo lento y el Wi‑Fi rápido.",
          youre_allergic_to_laugh_tracks: "Eres alérgico a las risas enlatadas.",
          you_pause_for_snacks_like_its_a_ritual: "Pausas para bocadillos como si fuera un ritual.",
          you_are_a_spoiler_ninja_and_an_ending_apologist: "Eres un ninja de spoilers y un apologista de finales.",
          you_think_limited_series_means_limits_dont_apply_to_you: "Crees que 'serie limitada' significa que los límites no se aplican a ti.",
          you_fastforward_opening_credits_but_respect_end_credits: "Avanzas rápidamente los créditos iniciales pero respetas los finales.",
          you_crave_vibes_plot_bold_choice: "Anhelas vibes > trama. Elección audaz.",
          you_treat_recommended_for_you_as_a_dare: "Tratas 'recomendado para ti' como un desafío.",
          you_chase_vibes_like_a_sommelier_of_scenes: "Persigues vibes como un sommelier de escenas.",
          you_watch_with_subtitles_you_are_cultured_and_quiet: "Ves con subtítulos; eres culto (y silencioso).",
          you_fear_the_finale_but_press_play_anyway: "Temes el final pero presionas play de todos modos.",
          you_bookmark_chaos_and_call_it_variety: "Marcas el caos y lo llamas variedad.",
          you_own_three_blankets_all_the_good_one: "Tienes tres mantas. Todas 'la buena'.",
          you_pretend_the_algorithm_is_your_friend: "Finges que el algoritmo es tu amigo.",
          you_rewatch_comfort_episodes_like_vitamins: "Revés episodios de consuelo como vitaminas.",
          you_hoard_tabs_and_storylines_with_equal_skill: "Acumulas pestañas e historias con igual habilidad.",
          you_skip_recaps_then_google_plot_summaries_iconic: "Saltas los resúmenes, luego buscas en Google. Icónico.",
          // Additional missing horoscope translations
          you_are_a_chaotic_good_you_like_drama_but_call_it_cinema: "Eres un Caótico Bueno. Te gusta el drama pero lo llamas 'cine.'",
          binge_minimalist_planning_watching: "Minimalista de maratón: 90% planificación, 10% visualización.",
          comfort_chaos_and_clever_twists: "Comodidad, caos y giros inteligentes. En ese orden.",
          on_your_rewatch_arc_brave: "En tu arco de re-visualización número 14. Valiente.",
          fueled_by_snacks_and_unresolved_plotlines: "63% alimentado por bocadillos y tramas sin resolver.",
          human_embodiment_of_skip_intro: "Encarnación humana de 'saltar intro.'",
          your_spirit_animal_is_a_loading_spinner: "Tu animal espiritual es un indicador de carga.",
          you_collect_pilots_like_pokemon: "Coleccionas pilotos como Pokémon.",
          you_claim_you_hate_cliffhangers_you_dont: "Dices que odias los cliffhangers. No es cierto.",
          you_alphabetize_your_watchlist_and_then_ignore_it: "Alfabetizas tu lista de reproducción y luego la ignoras.",
          you_believe_one_more_episode_is_a_contract_with_destiny: "Crees que 'un episodio más' es un contrato con el destino.",
          you_rate_with_your_heart_not_the_stars: "Calificas con tu corazón, no con las estrellas.",
          youre_here_to_procrastinate_responsibly: "Estás aquí para procrastinar responsablemente.",
          export: "Exportar",
          unknown_title: "Título Desconocido",
          no_image: "Sin Imagen",
          like: "Me Gusta",
          dislike: "No Me Gusta",
          rate_out_of_5: "Calificar {n} de 5",
          notifications_enabled: "Notificaciones habilitadas! Recibirás recordatorios de episodios.",
          pro_features: "Características Pro:",
          pro_feature_analytics: "Análisis avanzado e insights",
          pro_feature_categories: "Categorías personalizadas de lista de deseos",
          pro_feature_export: "Exportar a múltiples formatos",
          pro_feature_support: "Soporte prioritario al cliente",
          pro_feature_early_access: "Acceso temprano a nuevas funciones",
          pro: "Pro",
        },
      };
      function t(k) {
        const lang = appData?.settings?.lang || "en";
        const translation = (I18N[lang] && I18N[lang][k]) || I18N.en[k] || k;

        return translation;
      }
      function applyTranslations() {
        const elements = document.querySelectorAll("[data-i18n]");
        
        elements.forEach((el) => {
          const k = el.getAttribute("data-i18n");
          if (k) {
            const translation = t(k);
    
            el.textContent = translation;
          }
        });
        
        // Handle placeholder translations
        const placeholderElements = document.querySelectorAll("[data-i18n-placeholder]");

        
        placeholderElements.forEach((el) => {
          const k = el.getAttribute("data-i18n-placeholder");
          if (k) {
            const translation = t(k);
    
            el.placeholder = translation;
          }
        });
      }
      function formatDateShort(dateStr) {
        if (!dateStr) return "";
        const lang = appData?.settings?.lang === "es" ? "es-ES" : "en-US";
        const d = new Date(dateStr);
        if (Number.isNaN(d.getTime())) return dateStr;
        return d.toLocaleDateString(lang, {
          month: "short",
          day: "numeric",
          year: "numeric",
        });
      }
      
      function updateFileLabel(input) {
        const label = document.getElementById("fileLabel");
        if (label) {
          if (input.files && input.files[0]) {
            label.textContent = input.files[0].name;
          } else {
            label.textContent = t("no_file_chosen");
          }
        }
      }

      /* ============== Firebase (config) ============== */
      firebase.initializeApp({
        apiKey: "AIzaSyDEiqf8cxQJ11URcQeE8jqq5EMa5M6zAXM",
        authDomain: "flicklet-71dff.firebaseapp.com",
        projectId: "flicklet-71dff",
        storageBucket: "flicklet-71dff.firebasestorage.app",
        messagingSenderId: "1034923556763",
        appId: "1:1034923556763:web:bba5489cd1d9412c9c2b3e",
      });
      const auth = firebase.auth();
      const db = firebase.firestore();
      let currentUser = null;

      /* ============== App constants / state ============== */
      const DEV = ["localhost","127.0.0.1","::1"].includes(location.hostname) || !!location.port;
      const TMDB_IMG_BASE = "https://image.tmdb.org/t/p/w200";
      const API_BASE = DEV
        ? "https://api.themoviedb.org/3"
        : "/.netlify/functions/tmdb";
      const TMDB_KEY = "b7247bb415b50f25b5e35e2566430b96";

      const appData = {
        tv: { watching: [], wishlist: [], watched: [] },
        movies: { watching: [], wishlist: [], watched: [] },
        settings: {
          theme: "light",
          displayName: "",
          lang: "en",
          pro: false,
          notif: { episodes: false, discover: false, digest: false },
        },
      };

      /* ============== TMDB Localization System ============== */
      const TMDB = {
        base: "https://api.themoviedb.org/3",
        key: window.TMDB_API_KEY || "b7247bb415b50f25b5e35e2566430b96"
      };

      const localizedCache = new Map(); // key: `${lang}:${type}:${id}` -> payload

      async function tmdbFetch(path, lang) {
        const url = `${TMDB.base}${path}?language=${encodeURIComponent(lang)}&api_key=${encodeURIComponent(TMDB.key)}`;
        const r = await fetch(url);
        if (!r.ok) throw new Error(`TMDB ${r.status} on ${path}`);
        return r.json();
      }

            async function fetchLocalizedCore({ id, type }, lang) {
        
        const cacheKey = `${lang}:${type}:${id}`;
        if (localizedCache.has(cacheKey)) {
          
          return localizedCache.get(cacheKey);
        }
        
        const path = type === "tv" ? `/tv/${id}` : `/movie/${id}`;
        
        try {
          let data = await tmdbFetch(path, lang);
          
          // Minimal fields used by the cards
          let title = (data.title || data.name || "").trim();
          let overview = (data.overview || "").trim();
          const networks = Array.isArray(data.networks) ? data.networks.map(n => n?.name).filter(Boolean) : [];
          
          // Fallback to en-US if locale returns empty strings
          if ((!title || !overview) && lang !== "en-US") {
            try {
              const en = await tmdbFetch(path, "en-US");
              title = title || (en.title || en.name || "");
              overview = overview || (en.overview || "");
            } catch (fallbackError) {
              // Silent fallback - use original data
            }
          }
          
          const result = { title, overview, networks };
          localizedCache.set(cacheKey, result);
          return result;
        } catch (error) {
          // Handle 404 and other errors gracefully
          return null;
        }
      }

      // Preserve user-specific fields when merging
      function mergeLocalizedFields(original, localized) {
        // Do NOT touch user data (notes, tags, rating, list position, etc.)
        return {
          ...original,
          title: localized.title || original.title || original.name || "",
          name: undefined, // normalize to title for rendering
          overview: localized.overview ?? original.overview ?? "",
          networks: localized.networks ?? original.networks ?? []
        };
      }

      // --- Rehydrate lists in the chosen locale ---
      async function rehydrateListsForLocale(lang) {
        // Guards
        if (!appData || !appData.movies || !appData.tv) {
          return;
        }

        const lists = ["watching", "wishlist", "watched"];
        const allItems = [];
        
        // Process movies
        for (const list of lists) {
          const arr = appData.movies[list] || [];
          for (let i = 0; i < arr.length; i++) {
            const item = arr[i];
            if (item && (item.id || item.tmdbId)) {
              // Normalize the ID and determine type
              const id = Number(item.id ?? item.tmdbId);
              // Better type detection - avoid 'person' type
              let type = item.media_type;
              if (!type || type === "person") {
                // Infer from available fields
                if (item.first_air_date || item.episode_run_time || item.number_of_seasons) {
                  type = "tv";
                } else if (item.release_date || item.runtime) {
                  type = "movie";
                } else {
                  // Default to movie for items in movies list
                  type = "movie";
                }
              }
              
              if (id && type && type !== "person") {
                allItems.push({ 
                  item, 
                  list, 
                  category: "movies",
                  arrayIndex: i,
                  id,
                  type
                });
              }
            }
          }
        }
        
        // Process TV shows
        for (const list of lists) {
          const arr = appData.tv[list] || [];
          for (let i = 0; i < arr.length; i++) {
            const item = arr[i];
            if (item && (item.id || item.tmdbId)) {
              // Normalize the ID and determine type
              const id = Number(item.id ?? item.tmdbId);
              // Better type detection - avoid 'person' type
              let type = item.media_type;
              if (!type || type === "person") {
                // Infer from available fields
                if (item.first_air_date || item.episode_run_time || item.number_of_seasons) {
                  type = "tv";
                } else if (item.release_date || item.runtime) {
                  type = "movie";
                } else {
                  // Default to tv for items in tv list
                  type = "tv";
                }
              }
              
              if (id && type && type !== "person") {
                allItems.push({ 
                  item, 
                  list, 
                  category: "tv",
                  arrayIndex: i,
                  id,
                  type
                });
              }
            }
          }
        }

        // Process items sequentially to avoid rate limits and race conditions
        let successCount = 0;
        

        
        for (const { item, list, category, arrayIndex, id, type } of allItems) {
          try {
            const localized = await fetchLocalizedCore({ id, type }, lang);
            
            // Skip items that couldn't be localized (404 errors, etc.)
            if (!localized) {
              continue;
            }
            
            const merged = mergeLocalizedFields({ ...item, id, type }, localized);
            
            // Write back into the correct array position
            appData[category][list][arrayIndex] = merged;
            successCount++;
            
          } catch (error) {
            console.warn(`Failed to localize ${type}/${id}:`, error.message);
          }
          
          // Small delay to be nice to TMDB API
          if (allItems.length > 10) {
            await new Promise(resolve => setTimeout(resolve, 100));
          }
        }
      }

      /* ============== Small utilities ============== */
      function toB64Url(str) {
        const bin = new TextEncoder().encode(str);
        let b64 = btoa(String.fromCharCode(...bin));
        return b64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/,'');
      }
      function fromB64Url(b64url) {
        const b64 = b64url.replace(/-/g,'+').replace(/_/g,'/') + '==='.slice((b64url.length + 3) % 4);
        const bytes = Uint8Array.from(atob(b64), c => c.charCodeAt(0));
        return new TextDecoder().decode(bytes);
      }
      function showNotification(msg, type = "info") {
        const n = document.createElement("div");
        n.className = `notification ${type}`;
        n.textContent = msg;
        const live = document.getElementById('liveRegion');
        if (live) { live.textContent = msg; }
        document.body.appendChild(n);
        setTimeout(() => n.remove(), 2800);
      }

      function updateWelcomeText() {
        try {
          const n = (appData?.settings?.displayName || "").trim();
  
          

          
          const el = document.getElementById("welcomeText");
          if (!el) {
            console.log("welcomeText element not found");
            return;
          }
          const pool = [
            "Chaos",
            "Questionable Taste",
            "Binge Empire",
            "Streaming Madness",
            "Watch List",
          ];
          const newText = n
            ? `${n}'s ${pool[Math.floor(Math.random() * pool.length)]}`
            : t("app_title");
  
          

          
          el.textContent = newText;

        } catch (e) {
          console.warn("updateWelcomeText failed:", e);
        }
      }

      function loadAppData() {
        try {
          const saved = localStorage.getItem("tvMovieTrackerData");
          if (saved) {
            const parsed = JSON.parse(saved);
            Object.assign(appData, {
              tv: parsed.tv || { watching: [], wishlist: [], watched: [] },
              movies: parsed.movies || {
                watching: [],
                wishlist: [],
                watched: [],
              },
              settings: {
                theme: parsed.settings?.theme ?? "light",
                displayName: parsed.settings?.displayName ?? "",
                lang: parsed.settings?.lang ?? "en",
                pro: !!parsed.settings?.pro,
                notif: parsed.settings?.notif || {
                  episodes: false,
                  discover: false,
                  digest: false,
                },
              },
            });
          }
        } catch (e) {
          console.warn("Local load failed", e);
        }
        if (appData.settings.theme === "dark")
          document.body.classList.add("dark-mode");
        
        // Language toggle is now handled by the onchange event directly

        
        // Only update welcome text if we have a display name
        if (appData.settings.displayName && appData.settings.displayName.trim()) {
          updateWelcomeText();
        }
        applyTranslations();
        
        // Refresh the current tab content after app data is loaded
        setTimeout(() => {
          const currentTab = document.querySelector(".tab-section[style*='display: block']") || 
                            document.querySelector(".tab-section[style*='display: flex']");
          if (currentTab && currentTab.id !== "homeSection") {
            if (currentTab.id === "watchingSection") {
              const items = appData.tv.watching.concat(appData.movies.watching);
              if (typeof updateList === "function") updateList("watchingList", items);
            } else if (currentTab.id === "wishlistSection") {
              const items = appData.tv.wishlist.concat(appData.movies.wishlist);
              if (typeof updateList === "function") updateList("wishlistList", items);
            } else if (currentTab.id === "watchedSection") {
              const items = appData.tv.watched.concat(appData.movies.watched);
              if (typeof updateList === "function") updateList("watchedList", items);
            } else if (currentTab.id === "discoverSection") {
              if (typeof renderDiscover === "function") renderDiscover();
            }
          }
        }, 100);
      }

      function sanitizeForFirestore(value) {
        if (value === undefined) return undefined;
        if (value === null) return null;
        const t = typeof value;
        if (t === "string" || t === "boolean") return value;
        if (t === "number") return Number.isFinite(value) ? value : null;
        if (value instanceof Date) return value;
        if (Array.isArray(value))
          return value.map(sanitizeForFirestore).filter((v) => v !== undefined);
        if (t === "object") {
          const out = {};
          for (const [k, v] of Object.entries(value)) {
            const c = sanitizeForFirestore(v);
            if (c !== undefined) out[k] = c;
          }
          return out;
        }
        return undefined;
      }

      async function loadUserDataFromCloud(uid) {
        try {
          const snap = await db.collection("users").doc(uid).get();
          if (!snap.exists) return;
          const cloud = snap.data() || {};
          
          // Preserve local settings before any cloud operations
          const localDisplayName = (appData.settings?.displayName || "").trim();
          const localLanguage = (appData.settings?.lang || "en");
          
          
          if (cloud.watchlists) {
            if (cloud.watchlists.tv) appData.tv = cloud.watchlists.tv;
            if (cloud.watchlists.movies)
              appData.movies = cloud.watchlists.movies;
          }
                      if (cloud.settings) {
              const incoming = { ...cloud.settings };
              // Always preserve local display name if it exists
              if (localDisplayName) {
                incoming.displayName = localDisplayName;
              }
              // Don't override language setting from cloud - let user's choice persist
              appData.settings = { ...appData.settings, ...incoming };
            }

          if (typeof cloud.pro === "boolean") appData.settings.pro = cloud.pro;

          // Ensure display name is preserved after sanitization
          const cleaned = sanitizeForFirestore({
            tv: appData.tv,
            movies: appData.movies,
            settings: appData.settings,
          });
          appData.tv = cleaned.tv || {
            watching: [],
            wishlist: [],
            watched: [],
          };
          appData.movies = cleaned.movies || {
            watching: [],
            wishlist: [],
            watched: [],
          };
          appData.settings = cleaned.settings || appData.settings;
          
          // Restore local settings if they were lost during sanitization
          if (localDisplayName && (!appData.settings.displayName || !appData.settings.displayName.trim())) {
            appData.settings.displayName = localDisplayName;
          }
          // Don't restore language setting - let user's choice persist

          localStorage.setItem("tvMovieTrackerData", JSON.stringify(appData));
          
          // Prevent dropdown resets during language changes
          if (!window.isChangingLanguage) {
            const langSel = document.getElementById("langToggle");
            if (langSel) {
                          langSel.value = appData.settings.lang || "en";
          }
        }
          
          applyTranslations();
          updateWelcomeText?.();
          if (typeof updateUI === "function") updateUI();
          
          showNotification(t("cloud_sync_ok"), "success");
        } catch (e) {
          console.warn("load cloud failed", e);
          showNotification(t("cloud_load_failed"), "warning");
        }
      }

      async function saveAppData() {
        localStorage.setItem("tvMovieTrackerData", JSON.stringify(appData));
        
        // Prevent dropdown resets during language changes
        if (!window.isChangingLanguage) {
          const langSel = document.getElementById("langToggle");
          if (langSel) {
            langSel.value = appData.settings.lang || "en";
          }
        }

        applyTranslations?.();
        updateWelcomeText?.();
        updateUI?.();

        if (!currentUser) return;
        try {
          const payload = sanitizeForFirestore({
            watchlists: { tv: appData.tv, movies: appData.movies },
            settings: appData.settings,
            pro: !!appData.settings.pro,
            lastUpdated: firebase.firestore.FieldValue.serverTimestamp(),
          });
          await db
            .collection("users")
            .doc(currentUser.uid)
            .set(payload, { merge: true });
        } catch (error) {
          console.error("cloud sync failed", error);
          showNotification(t("cloud_sync_failed"), "warning");
        }
      }

      /* ============== Auth helpers ============== */
      function login() {
        const provider = new firebase.auth.GoogleAuthProvider();
        return auth.signInWithPopup(provider).catch((err) => {
          const msg = String(err?.message || "");
          const code = err?.code || "";
          const coopBlocked =
            msg.includes("Cross-Origin-Opener-Policy") ||
            msg.includes("window.close") ||
            msg.includes("message channel closed") ||
            code === "auth/popup-closed-by-user" ||
            code === "auth/popup-blocked" ||
            code === "auth/cancelled-popup-request";
          if (coopBlocked) return auth.signInWithRedirect(provider);
          throw err;
        });
      }
      function emailLogin() {
        const email = prompt("Email:");
        if (!email) return;
        const pw = prompt("Password:");
        if (!pw) return;
        return auth
          .signInWithEmailAndPassword(email, pw)
          .catch(() => auth.createUserWithEmailAndPassword(email, pw));
      }
      window.login = login;
      window.emailLogin = emailLogin;

      function setAccountLabel(u) {
        const btn = document.getElementById("accountBtn");
        if (!btn) return;
        const manual = (appData?.settings?.displayName || "").trim();
        const firebaseName = (u?.displayName || "").trim();
        const emailPrefix = u?.email ? u.email.split("@")[0] : "";
        const chosen = manual || firebaseName || emailPrefix;
        btn.textContent = chosen
          ? `👤 ${chosen.split(/\s+/)[0]}`
          : "👤 Sign In";
      }

      /* ============== Single global auth listener ============== */
      auth.onAuthStateChanged(async (user) => {
        currentUser = user;
        setAccountLabel(user);

        if (user) {
          try {
            await db
              .collection("users")
              .doc(user.uid)
              .set(
                {
                  profile: {
                    email: user.email || "",
                    displayName: user.displayName || "",
                    photoURL: user.photoURL || "",
                  },
                  lastLoginAt: firebase.firestore.FieldValue.serverTimestamp(),
                },
                { merge: true }
              );

            await loadUserDataFromCloud(user.uid);

            // Refresh the current tab content after cloud data is loaded
            setTimeout(() => {
              if (typeof applyTranslations === "function") {
                applyTranslations();
              }
              // Also refresh the current tab content
              const currentTab = document.querySelector(".tab-section[style*='display: block']") || 
                                document.querySelector(".tab-section[style*='display: flex']");
              if (currentTab && currentTab.id !== "homeSection") {
                if (currentTab.id === "watchingSection") {
                  const items = appData.tv.watching.concat(appData.movies.watching);
                  if (typeof updateList === "function") updateList("watchingList", items);
                } else if (currentTab.id === "wishlistSection") {
                  const items = appData.tv.wishlist.concat(appData.movies.wishlist);
                  if (typeof updateList === "function") updateList("wishlistList", items);
                } else if (currentTab.id === "watchedSection") {
                  const items = appData.tv.watched.concat(appData.movies.watched);
                  if (typeof updateList === "function") updateList("watchedList", items);
                } else if (currentTab.id === "discoverSection") {
                  if (typeof renderDiscover === "function") renderDiscover();
                }
              }
            }, 300);

            // Only seed displayName if user hasn't manually set one
            const currentDisplayName = (appData?.settings?.displayName || "").trim();
            if (!currentDisplayName) {
              const guess =
                (user.displayName && user.displayName.trim()) ||
                (user.email && user.email.split("@")[0]) ||
                "";
              if (guess) {
                appData.settings.displayName = guess.trim();
                if (typeof saveAppData === "function") saveAppData();
                if (typeof updateWelcomeText === "function")
                  updateWelcomeText();
                if (typeof rebuildStats === "function") rebuildStats();
                localStorage.setItem("__flicklet_onboarded__", "1");
                setAccountLabel(user);
              }
            }
          } catch (e) {
            console.warn("Cloud sync failed", e);
          }
        }
      });

      /* ======= Sign-in modal + Name onboarding ======= */
      function openModal(title, html, testId = "generic-modal") {
        const wrap = document.createElement("div");
        wrap.className = "modal-backdrop";
        wrap.setAttribute("data-testid", "modal-backdrop");
        wrap.innerHTML = `
          <div class="modal" role="dialog" aria-modal="true" aria-labelledby="modal-title" data-testid="${testId}" tabindex="-1">
            <h3 id="modal-title">${title}</h3>
            <div class="modal-body">${html}</div>
            <div class="modal-actions">
              <button class="btn secondary" data-testid="modal-close" type="button">Close</button>
            </div>
          </div>`;
        document.body.appendChild(wrap);

        const close = () => wrap.remove();
        wrap.addEventListener("click", (e) => {
          if (e.target === wrap) close();
        });
        wrap.addEventListener("keydown", (e) => {
          if (e.key === "Escape") close();
        });
        const modalEl = wrap.querySelector('.modal');
        modalEl.focus();
        wrap
          .querySelector('[data-testid="modal-close"]')
          .addEventListener("click", close);
      }

      function showNameModal(force = false) {
        const current = (appData.settings.displayName || "").trim();
        if (!force && current) {
          return;
        }

        openModal(
          "Welcome! What should we call you?",
          `
            <p>This will personalize your headers and stats.</p>
            <input id="onboardName" class="search-input" placeholder="Display name"
                   value="${(current || "").replace(/"/g, "&quot;")}" />
          `,
          "name-onboarding"
        );

        const saveBtn = document.createElement("button");
        saveBtn.className = "btn success";
        saveBtn.textContent = "Save";
        saveBtn.onclick = () => {
          const v = (document.getElementById("onboardName").value || "").trim();
          if (!v) {
            const el = document.getElementById('onboardName');
            if (el) {
              el.setAttribute('aria-invalid','true');
              let err = document.getElementById('onboardError');
              if (!err) {
                err = document.createElement('div');
                err.id = 'onboardError';
                err.className = 'form-error';
                err.textContent = 'Please enter a display name.';
                el.setAttribute('aria-describedby','onboardError');
                el.insertAdjacentElement('afterend', err);
              } else { err.textContent = 'Please enter a display name.'; }
            }
            return;
          }
          appData.settings.displayName = v;
          saveAppData();
          updateWelcomeText?.();
          rebuildStats?.();
          localStorage.setItem("__flicklet_onboarded__", "1");
          document.querySelector(".modal-backdrop")?.remove();
          if (currentUser) setAccountLabel?.(currentUser);
          else showSignInModal();
        };
        document.querySelector(".modal .modal-actions").prepend(saveBtn);

        // Add Enter key handler to the name input
        const nameInput = document.getElementById("onboardName");
        if (nameInput) {
          nameInput.addEventListener("keydown", (e) => {
            if (e.key === "Enter") {
              e.preventDefault();
              saveBtn.click();
            }
          });
        }
      }

      function showSignInModal() {
        openModal(
          "Sign in to sync",
          `
            <p>Sign in to back up your lists and sync across devices.</p>
            <div style="display:flex; gap:8px; flex-wrap:wrap">
              <button id="googleBtn" class="btn">🔒 Continue with Google</button>
              <button id="emailBtn" class="btn secondary">✉️ Email Sign-In</button>
              <button id="signOutBtn" class="btn danger" style="display:none">Sign Out</button>
            </div>
          `,
          "auth-modal"
        );

        const google = document.getElementById("googleBtn");
        const email = document.getElementById("emailBtn");
        const out = document.getElementById("signOutBtn");

        if (currentUser) {
          google.style.display = "none";
          email.style.display = "none";
          out.style.display = "inline-block";
          out.onclick = () =>
            auth.signOut().then(() => {
              showNotification(t("signed_out"), "success");
              document.querySelector(".modal-backdrop")?.remove();
              setAccountLabel?.(null);
            });
        } else {
          google.onclick = () =>
            login()
              .then(() => {
                showNotification(t("signed_in"), "success");
                document.querySelector(".modal-backdrop")?.remove();
                // auth listener will call setAccountLabel and sync
              })
              .catch((e) =>
                showNotification(e.message || t("login_failed"), "error")
              );

          email.onclick = () =>
            emailLogin()
              .then(() => {
                showNotification(t("signed_in"), "success");
                document.querySelector(".modal-backdrop")?.remove();
                // auth listener will call setAccountLabel and sync
              })
              .catch((e) =>
                showNotification(e.message || t("login_failed"), "error")
              );
        }
      }

      function escapeHtml(str) {
        return (str || "").replace(
          /[&<>"']/g,
          (s) =>
            ({
              "&": "&amp;",
              "<": "&lt;",
              ">": "&gt;",
              '"': "&quot;",
              "'": "&#39;",
            }[s])
        );
      }

      /* ============== TMDB helpers (Localization + Fallback) ============== */
      function langQuery() {
        return appData.settings.lang === "es"
          ? "&language=es-ES"
          : "&language=en-US";
      }

      async function tmdbGet(endpoint, params = "", tryFallback = true) {
        const lang = langQuery();
        let url;

        if (DEV) {
          const sep = params && params[0] === "&" ? "" : "&";
          url = `${API_BASE}/${endpoint}?api_key=${encodeURIComponent(
            TMDB_KEY
          )}${sep}${params}${lang}`;
        } else {
          url = `${API_BASE}?endpoint=${endpoint}${params}${lang}`;
        }

        const r = await fetch(url);
        if (r.ok) {
          const data = await r.json();
          if (
            tryFallback &&
            (!data || (Array.isArray(data.results) && !data.results.length))
          ) {
            const fallback = DEV
              ? `${API_BASE}/${endpoint}?api_key=${encodeURIComponent(
                  TMDB_KEY
                )}${params}&language=en-US`
              : `${API_BASE}?endpoint=${endpoint}${params}&language=en-US`;
            const r2 = await fetch(fallback);
            if (r2.ok) return await r2.json();
          }
          return data;
        }

        if (tryFallback) {
          const fallback = DEV
            ? `${API_BASE}/${endpoint}?api_key=${encodeURIComponent(
                TMDB_KEY
              )}${params}&language=en-US`
            : `${API_BASE}?endpoint=${endpoint}${params}&language=en-US`;
          const r2 = await fetch(fallback);
          if (r2.ok) return await r2.json();
        }
        throw new Error(`TMDB request failed: ${r.status}`);
      }
      



        

        


      async function fetchShowData(query, page = 1, genre = "") {
        let endpoint, params;
        if (genre && !query) {
          endpoint = "discover/tv";
          params = `&page=${page}&with_genres=${genre}`;
        } else {
          endpoint = "search/multi";
          params = `&page=${page}${
            query ? `&query=${encodeURIComponent(query)}` : ""
          }`;
        }

        const data = await tmdbGet(endpoint, params, true);
        const enhanced = await Promise.all(
          (data.results || []).map(async (item) => {
            try {
              if (item.media_type === "tv" || item.first_air_date) {
                const d = await tmdbGet(`tv/${item.id}`, "", true);
                return {
                  ...item,
                  status: d.status,
                  number_of_seasons: d.number_of_seasons,
                  number_of_episodes: d.number_of_episodes,
                  last_air_date: d.last_air_date,
                  first_air_date: d.first_air_date,
                  next_episode_to_air: d.next_episode_to_air,
                  last_episode_to_air: d.last_episode_to_air,
                  in_production: d.in_production,
                  genres: d.genres,
                  networks: d.networks || [],
                  episode_run_time: d.episode_run_time || [45],
                  runtime: d.episode_run_time ? d.episode_run_time[0] : 45,
                };
              } else if (item.media_type === "movie" || item.release_date) {
                const d = await tmdbGet(`movie/${item.id}`, "", true);
                return {
                  ...item,
                  status: d.status,
                  release_date: d.release_date,
                  genres: d.genres,
                  runtime: d.runtime || 120,
                };
              }
            } catch (_) {}
            return item;
          })
        );
        return enhanced;
      }

              async function loadGenres() {
        try {
          const data = await tmdbGet("genre/tv/list", "", true);
          
          const sel = document.getElementById("genreFilter");
          if (!sel) return;
          sel.innerHTML = "";
          const all = document.createElement("option");
          all.value = "";
          all.textContent = t("all_genres");
          sel.appendChild(all);
          
          (data.genres || []).forEach((g) => {
            const opt = document.createElement("option");
            opt.value = String(g.id);
            // Try to translate the genre name, fallback to original if no translation
            let genreKey = g.name.toLowerCase().replace(/\s+/g, '_');
    
            
            // Handle special cases
            if (genreKey === "action_&_adventure") genreKey = "action_adventure";
            if (genreKey === "sci-fi_&_fantasy") genreKey = "sci_fi_fantasy";
            if (genreKey === "war_&_politics") genreKey = "war_politics";
            if (genreKey === "talk_show") genreKey = "talk_show";
            
            const translation = t(genreKey);

            opt.textContent = translation || g.name;
            sel.appendChild(opt);
          });
          
        } catch (e) {
          console.error("loadGenres error:", e);
        }
      }

      /* ============== Episode reminders (Enhanced notifications) ============== */
      function checkUpcomingEpisodes() {
        if (!appData.settings?.notif?.episodes) return;
        
        const now = new Date();
        const soonMs = 36 * 60 * 60 * 1000; // 36 hours
        const verySoonMs = 24 * 60 * 60 * 1000; // 24 hours
        
        const watching = [
          ...appData.tv.watching,
          ...appData.movies.watching,
        ].filter((it) => it.media_type === "tv" || it.first_air_date);
        
        watching.forEach((it) => {
          const nextAir = it.next_episode_to_air?.air_date || null;
          if (!nextAir) return;
          
          const airDate = new Date(nextAir + "T00:00:00Z");
          const diff = airDate - now;
          
          if (diff >= 0 && diff <= soonMs) {
            const title = it.name || it.title;
            const dateStr = formatDateShort(nextAir);
            const message = t("upcoming_episode_alert").replace("{title}", title).replace("{date}", dateStr);
            
            // Show notification with proper localization
            showNotification(message, "success");
            
            
          }
        });
      }
      
      // Request notification permission on app load
      function requestNotificationPermission() {
        if ("Notification" in window && Notification.permission === "default") {
          Notification.requestPermission().then(permission => {
            if (permission === "granted") {
              showNotification(t("notifications_enabled"), "success");
            }
          });
        }
      }
      

      async function changeLanguage(newLang) {
        // Set a flag to prevent dropdown resets during language change
        window.isChangingLanguage = true;
        
        // Update app data
        if (window.appData?.settings) {
          window.appData.settings.lang = newLang;
        }
        if (appData?.settings) {
          appData.settings.lang = newLang;
        }
        
        // Apply translations FIRST (before rehydration)
        applyTranslations?.();
        
        // Show loading state
        const currentTab = document.querySelector(".tab.active")?.id?.replace("Tab", "");
        if (currentTab && ["watching", "wishlist", "watched"].includes(currentTab)) {
          const listContainer = document.getElementById(currentTab + "List");
          if (listContainer) {
            listContainer.innerHTML = `<div style="text-align: center; padding: 20px;">${t("loading")}...</div>`;
          }
        }
        
        try {
          // Rehydrate lists with localized TMDB data
          await rehydrateListsForLocale(newLang);
          
          // Save the data AFTER rehydration completes
          saveAppData?.();
          
          // Update UI AFTER rehydration completes
          updateUI?.();
          
        } catch (error) {
          console.warn("Failed to rehydrate lists for locale:", error);
          // Still save and update UI even if rehydration fails
          saveAppData?.();
          updateUI?.();
        }
        
        // Force refresh of genre dropdown
        setTimeout(() => {
          if (typeof loadGenres === "function") {
            loadGenres();
          }
        }, 200);
        
        // Show notification
        const langName = newLang === "es" ? "Spanish" : "English";
        showNotification(`Language changed to ${langName}`, "success");
        
        // Clear the flag after operations complete
        setTimeout(() => {
          window.isChangingLanguage = false;
        }, 3000);
        
        // Final refresh of horoscope and quote
        setTimeout(() => {
          const hEl = document.getElementById("fakeFortune");
          const qEl = document.getElementById("randomQuote");
          if (hEl) {
            hEl.textContent = pickDailyHoroscope();
          }
          if (qEl) {
            qEl.textContent = drawQuote();
          }
          
          const fileInput = document.getElementById("importFile");
          if (fileInput) {
            updateFileLabel(fileInput);
          }
        }, 600);
      }

      /* ============== Discover (Phase 1) ============== */
      function buildUserProfileVector() {
        const liked = getAllItems().filter(
          (it) => it.likeStatus === "like" || (Number(it.userRating) || 0) >= 4
        );
        const genreCounts = {};
        liked.forEach((it) =>
          (it.genres || []).forEach(
            (g) => (genreCounts[g.id] = (genreCounts[g.id] || 0) + 1)
          )
        );
        return genreCounts;
      }

      async function fetchDiscover() {
        const profile = buildUserProfileVector();
        
        // Get more diverse content sources
        const [trendingTv, trendingMovie, popularTv, popularMovie] = await Promise.all([
          tmdbGet("trending/tv/week", "", true).catch(() => ({ results: [] })),
          tmdbGet("trending/movie/week", "", true).catch(() => ({ results: [] })),
          tmdbGet("tv/popular", "", true).catch(() => ({ results: [] })),
          tmdbGet("movie/popular", "", true).catch(() => ({ results: [] }))
        ]);
        
        const pool = [
          ...(trendingTv.results || []),
          ...(trendingMovie.results || []),
          ...(popularTv.results || []),
          ...(popularMovie.results || [])
        ];

        // Remove duplicates by ID
        const uniquePool = pool.filter((item, index, self) => 
          index === self.findIndex(t => t.id === item.id)
        );

        const scored = uniquePool
          .map((it) => {
            const g = (it.genres || it.genre_ids || []).map((x) =>
              typeof x === "number" ? { id: x } : x
            );
            const score = g.reduce((m, gg) => m + (profile[gg.id] || 0), 0);
            
            // Add bonus points for highly rated content
            const rating = Number(it.vote_average) || 0;
            const ratingBonus = rating >= 8 ? 2 : rating >= 7 ? 1 : 0;
            
            return { ...it, _score: score + ratingBonus };
          })
          .filter((it) => it._score > 0)
          .sort((a, b) => b._score - a._score);

        // If no personalized recommendations, fall back to top-rated content
        if (scored.length === 0) {
          const fallback = uniquePool
            .filter(it => (Number(it.vote_average) || 0) >= 7)
            .sort((a, b) => (Number(b.vote_average) || 0) - (Number(a.vote_average) || 0))
            .slice(0, 10);
          
          return await Promise.all(
            fallback.map(async (it) => {
              try {
                if (it.media_type === "tv" || it.first_air_date) {
                  const d = await tmdbGet(`tv/${it.id}`, "", true);
                  return { ...it, ...d, because: "Popular and highly-rated content" };
                } else {
                  const d = await tmdbGet(`movie/${it.id}`, "", true);
                  return { ...it, ...d, because: "Popular and highly-rated content" };
                }
              } catch (_) {
                return it;
              }
            })
          );
        }

        const top = await Promise.all(
          scored.slice(0, 20).map(async (it) => {
            try {
              if (it.media_type === "tv" || it.first_air_date) {
                const d = await tmdbGet(`tv/${it.id}`, "", true);
                return { ...it, ...d, because: pickBecauseLabel() };
              } else {
                const d = await tmdbGet(`movie/${it.id}`, "", true);
                return { ...it, ...d, because: pickBecauseLabel() };
              }
            } catch (_) {
              return it;
            }
          })
        );
        return top;

        function pickBecauseLabel() {
          const liked = getAllItems().filter(
            (x) => x.likeStatus === "like" || (Number(x.userRating) || 0) >= 4
          );
          if (!liked.length) return "";
          const anchor = liked[Math.floor(Math.random() * liked.length)];
          const title = anchor.name || anchor.title || "this";
          return `${t("because_you_liked")} "${title}"`;
        }
      }

      /* ============== Notes & Tags ============== */
      function openNotesTagsModal(itemId) {
        const item = findItem(itemId);
        if (!item) return;
        const currentNotes = item.notes || "";
        const currentTags = Array.isArray(item.tags)
          ? item.tags.join(", ")
          : item.tags || "";
        openModal(
          "Notes & Tags",
          `
            <label>Notes</label>
            <textarea id="notesText" style="width:100%; min-height:120px;">${escapeHtml(
              currentNotes
            )}</textarea>
            <label style="margin-top:8px; display:block;">Tags (comma-separated)</label>
            <input id="tagsInput" class="search-input" value="${escapeHtml(
              currentTags
            )}" />
          `,
          "notes-tags-modal"
        );

        const saveBtn = document.createElement("button");
        saveBtn.className = "btn success";
        saveBtn.textContent = "Save";
        saveBtn.onclick = () => {
          const notes = (
            document.getElementById("notesText").value || ""
          ).trim();
          const tagsRaw = (
            document.getElementById("tagsInput").value || ""
          ).trim();
          const tags = tagsRaw
            ? tagsRaw
                .split(",")
                .map((s) => s.trim())
                .filter(Boolean)
            : [];
          const it = findItem(itemId);
          if (!it) return;
          it.notes = notes;
          it.tags = tags;
          saveAppData?.();
          updateTagFiltersUI?.();
          updateUI?.();
          document.querySelector(".modal-backdrop")?.remove();
        };
        document.querySelector(".modal .modal-actions").prepend(saveBtn);
      }

      function updateTagFiltersUI() {
        const all = new Set();
        getAllItems().forEach((it) =>
          (it.tags || []).forEach((tag) => all.add(tag))
        );
        const row = document.getElementById("tagFilterRow");
        row.innerHTML = "";
        [...all].sort().forEach((tag) => {
          const btn = document.createElement("button");
          btn.className =
            "tag-pill" + (activeTagFilters.has(tag) ? " active" : "");
          btn.textContent = `#${tag}`;
          btn.onclick = () => {
            if (activeTagFilters.has(tag)) activeTagFilters.delete(tag);
            else activeTagFilters.add(tag);
            updateTagFiltersUI();
            updateUI();
          };
          row.appendChild(btn);
        });
        if (all.size === 0) row.innerHTML = "";
      }

      function filterByTags(items) {
        if (!activeTagFilters.size) return items;
        return items.filter((it) => {
          const tags = new Set(it.tags || []);
          for (const tag of activeTagFilters) if (!tags.has(tag)) return false;
          return true;
        });
      }

      /* ============== Shareable lists (read-only links) ============== */
      function generateShareLinkForCurrentTab() {
        const tab = currentActiveTab;
        let listKey = null;
        if (tab === "watching") listKey = "watching";
        if (tab === "wishlist") listKey = "wishlist";
        if (tab === "watched") listKey = "watched";
        if (!listKey)
          return showNotification(
            t("switch_to_share"),
            "warning"
          );

        const payload = {
          v: 1,
          list: listKey,
          tv: appData.tv[listKey],
          movies: appData.movies[listKey],
        };
        const b64 = toB64Url(JSON.stringify(payload));
        const url = `${location.origin}${location.pathname}#share=${b64}`;
        document.getElementById("shareLinkOut").value = url;
                  showNotification(t("share_link_generated"), "success");
      }

      function tryImportFromShareLink() {
        const hash = location.hash || "";
        const m = hash.match(/#share=([A-Za-z0-9_\-]+)/);
        if (!m) return;
        try {
          const decoded = JSON.parse(fromB64Url(m[1]));
          if (decoded && decoded.v === 1) {
            if (Array.isArray(decoded.tv))
              appData.tv[decoded.list] = decoded.tv;
            if (Array.isArray(decoded.movies))
              appData.movies[decoded.list] = decoded.movies;
            saveAppData?.();
            updateUI?.();
            showNotification(t("imported_from_link"), "success");
          }
        } catch (e) {
          console.warn("share import failed", e);
        }
      }

      /* ============== UI helpers ============== */
      function getSeriesPill(item) {
        if (!item || (item.media_type !== "tv" && !item.first_air_date))
          return "";
        const status = (item.status || "").toLowerCase();
        const nextAir = item.next_episode_to_air?.air_date || null;
        const lastAir =
          item.last_episode_to_air?.air_date || item.last_air_date || null;
        const firstAir = item.first_air_date || null;

        const today = new Date();
        today.setHours(0, 0, 0, 0);
        const firstAirFuture = firstAir ? new Date(firstAir) > today : false;

        let mode;
        if (["ended", "canceled", "cancelled"].includes(status)) mode = "ended";
        else if (
          ["planned", "pilot"].includes(status) ||
          firstAirFuture ||
          (status === "in production" && !lastAir)
        )
          mode = "upcoming";
        else mode = "ongoing";

        let label = "",
          cls = "";
        if (mode === "ended") {
          cls = "status-ended";
          label = `${t("series_complete")}${
            lastAir ? ` • ${formatDateShort(lastAir)}` : ""
          }`;
        } else if (mode === "upcoming") {
          cls = "status-upcoming";
          const when = firstAir || nextAir;
          label = `${t("coming_soon")}${
            when ? ` • ${formatDateShort(when)}` : ""
          }`;
        } else {
          cls = "status-ongoing";
          const when = nextAir
            ? `${t("next")}: ${formatDateShort(nextAir)}`
            : lastAir
            ? `${t("last")}: ${formatDateShort(lastAir)}`
            : null;
          label = [t("currently_airing"), when].filter(Boolean).join(" • ");
        }

        const title = [
          item.status || null,
          nextAir ? `${t("next")}: ${formatDateShort(nextAir)}` : null,
          lastAir ? `${t("last")}: ${formatDateShort(lastAir)}` : null,
        ]
          .filter(Boolean)
          .join(" • ");

        return `<span class="series-pill ${cls}" title="${title}">${label}</span>`;
      }

      async function ensureTvDetails(item, card) {
        if (item.media_type !== "tv" && !item.first_air_date) return;
        const needs = !(
          item.status &&
          (item.next_episode_to_air || item.last_air_date) &&
          item.networks
        );
        if (!needs) return;
        try {
          const d = await tmdbGet(`tv/${item.id}`, "", true);
          Object.assign(item, {
            status: d.status,
            number_of_seasons: d.number_of_seasons,
            number_of_episodes: d.number_of_episodes,
            last_air_date: d.last_air_date,
            first_air_date: d.first_air_date,
            next_episode_to_air: d.next_episode_to_air,
            last_episode_to_air: d.last_episode_to_air,
            in_production: d.in_production,
            genres: d.genres,
            networks: d.networks || [],
            episode_run_time: d.episode_run_time || [45],
            runtime:
              item.runtime ?? (d.episode_run_time ? d.episode_run_time[0] : 45),
          });
          const meta = card.querySelector(".show-meta");
          const pillWrap = card.querySelector(".rating-container");
          if (meta) {
            const networkNames = (item.networks || [])
              .map((n) => n.name)
              .join(", ");
            const date = item.first_air_date || item.release_date || "";
            const rating = item.vote_average
              ? Number(item.vote_average).toFixed(1)
              : "N/A";
            const mediaType = item.media_type || "tv";
            meta.textContent = [
              `⭐ ${rating}`,
              date ? ` • ${date.split("-")[0]}` : "",
              ` • ${mediaType.toUpperCase()}`,
              networkNames ? ` • ${t("streaming_on")}: ${networkNames}` : ""
            ].join("");
          }
          if (pillWrap) {
            const old = pillWrap.querySelector(".series-pill");
            if (old) old.remove();
            pillWrap.insertAdjacentHTML("beforeend", getSeriesPill(item));
          }
        } catch (_) {}
      }

      function createShowCard(item, isSearch = false, listTab = null) {
        // Use the passed listTab if available, otherwise fall back to currentActiveTab
        const activeTab = listTab || currentActiveTab;


        const card = document.createElement("div");
        card.className = "show-card";
        const title = item.name || item.title || t("unknown_title");
        const date = item.first_air_date || item.release_date || "";
        const rating = item.vote_average ? Number(item.vote_average).toFixed(1) : "N/A";
        const mediaType = item.media_type || (item.first_air_date ? "tv" : "movie");

        card.setAttribute("data-id", String(item.id));
        card.setAttribute("data-media-type", mediaType);

        const posterHtml = item.poster_path
          ? `<button class="poster-button" data-action="open" data-id="${item.id}" data-media-type="${mediaType}" aria-label="Open on TMDB"><img class="show-poster" src="${TMDB_IMG_BASE}${item.poster_path}" alt="${escapeHtml(title)}"></button>`
          : `<button class="poster-button" data-action="open" data-id="${item.id}" data-media-type="${mediaType}" aria-label="Open on TMDB"><div class="poster-placeholder">${t("no_image")}</div></button>`;

        const runtimeMinutes =
          Number(item.runtime) ||
          (mediaType === "tv"
            ? (Array.isArray(item.episode_run_time) && Number(item.episode_run_time[0])) || 45
            : 120);
        card.setAttribute("data-runtime-minutes", String(runtimeMinutes));

        const networkNames = (item.networks || []).map((n) => n.name).join(", ");

        let actions = "";
        if (isSearch) {
          actions = `
        <div class="show-actions">
          <button class="btn" data-action='addFromCache' data-id='${Number(item.id)}' data-list='watching'>▶️ ${t("currently_watching")}</button>
          <button class="btn" data-action='addFromCache' data-id='${Number(item.id)}' data-list='wishlist'>📖 ${t("want_to_watch")}</button>
          <button class="btn" data-action='addFromCache' data-id='${Number(item.id)}' data-list='watched'>✅ ${t("already_watched")}</button>
        </div>`;
        } else {
          const likeStatus = item.likeStatus || "none";
          const userRating = item.userRating || 0;

          const stars = [1,2,3,4,5].map((n) =>
            `<button type="button" class="star-btn ${n <= userRating ? "active" : ""}"
                    aria-label="${t("rate_out_of_5").replace("{n}", n)}"
                    aria-pressed="${n <= userRating}"
                    data-action="rate" data-id="${item.id}" data-rating="${n}">${n <= userRating ? "★" : "☆"}</button>`
          ).join("");
          actions = `
            <div class="rating-container">
              <span>${t("your_rating")}:</span>
              <div class="star-rating">${stars}</div>
              <div class="like-dislike">
                <button class="like-btn ${likeStatus === "like" ? "active" : ""}" data-action="like" data-id="${item.id}" aria-pressed="${likeStatus === "like"}" aria-label="${t("like")}">👍</button>
                <button class="dislike-btn ${likeStatus === "dislike" ? "active" : ""}" data-action="dislike" data-id="${item.id}" aria-pressed="${likeStatus === "dislike"}" aria-label="${t("dislike")}">👎</button>
              </div>
              ${mediaType === "tv" ? getSeriesPill(item) : ""}
            </div>

            <div class="show-actions" style="margin-top:6px; display:flex; gap:8px; flex-wrap:wrap">
                      ${activeTab !== "watching" ? `<button class="btn secondary" data-action="move" data-id="${item.id}" data-list="watching">→ ${t("currently_watching")}</button>` : ''}
        ${activeTab !== "wishlist" ? `<button class="btn secondary" data-action="move" data-id="${item.id}" data-list="wishlist">→ ${t("want_to_watch")}</button>` : ''}
        ${activeTab !== "watched" ? `<button class="btn secondary" data-action="move" data-id="${item.id}" data-list="watched">→ ${t("already_watched")}</button>` : ''}
              <button class="btn" data-action="notes" data-id="${item.id}">✎ ${t("notes_tags")}</button>
              <button class="btn danger" data-action="remove" data-id="${item.id}">🗑️ ${t("remove")}</button>
            </div>`;
        }

        card.innerHTML = `
          ${posterHtml}
          <div class="show-details">
            <h4 class="show-title">
              <button class="btn-link" data-action="open" data-id="${item.id}" data-media-type="${mediaType}" aria-label="Open ${escapeHtml(title)} on TMDB">
                ${escapeHtml(title)} <span aria-hidden="true" style="opacity:.6">🔗</span>
              </button>
            </h4>
            <div class="show-meta"></div>
            <div class="show-overview">${escapeHtml(item.overview || t("no_description"))}</div>
            ${actions}
          </div>`;

        const meta = card.querySelector(".show-meta");
        if (meta) {
          meta.textContent = [
            `⭐ ${rating}`,
            date ? ` • ${date.split("-")[0]}` : "",
            ` • ${mediaType.toUpperCase()}`,
            networkNames ? ` • ${t("streaming_on")}: ${networkNames}` : ""
          ].join("");
        }

        // Add direct click handlers to star rating buttons
        const starButtons = card.querySelectorAll(".star-btn");
        starButtons.forEach(starBtn => {
          starBtn.addEventListener("click", (e) => {
            e.preventDefault();
            e.stopPropagation();
            const rating = Number(starBtn.getAttribute("data-rating"));
            const id = Number(starBtn.getAttribute("data-id"));
            setRating(id, rating);
            
            // Update the visual state of all stars in this card
            const allStars = card.querySelectorAll(".star-btn");
            allStars.forEach((star, index) => {
              const starRating = index + 1;
              if (starRating <= rating) {
                star.classList.add("active");
                star.setAttribute("aria-pressed", "true");
              } else {
                star.classList.remove("active");
                star.setAttribute("aria-pressed", "false");
              }
            });
          });
        });

        ensureTvDetails(item, card);
        return card;
      }

      function openTMDBLink(id, type) {
        window.open(`https://www.themoviedb.org/${type}/${id}`, "_blank");
      }

      /* Lists & ops */
      function getAllItems() {
        return ["tv", "movies"].flatMap((cat) =>
          ["watching", "wishlist", "watched"].flatMap(
            (lst) => appData[cat][lst] || []
          )
        );
      }
      function addToList(item, list) {
        // --- normalize incoming search item ---
        const norm = { ...item };
        if (norm.id != null) norm.id = Number(norm.id);
        if (!norm.media_type) {
          norm.media_type = norm.first_air_date ? "tv" : "movie";
        }

        const cat =
          norm.media_type === "tv" || norm.first_air_date ? "tv" : "movies";

        // Already in target?
        const inTarget = (appData[cat][list] || []).some(
          (s) => Number(s.id) === Number(norm.id)
        );
        if (inTarget) {
          showNotification(
            t("already_in_list_warning").replace("{list}", list.replace("wishlist", t("want_to_watch"))),
            "warning"
          );
          return;
        }
        // Remove from everywhere else (both cats; all lists)
        let foundElsewhere = false;
        ["tv", "movies"].forEach((c) => {
          ["watching", "wishlist", "watched"].forEach((lst) => {
            const before = appData[c][lst].length;
            appData[c][lst] = appData[c][lst].filter(
              (s) => Number(s.id) !== Number(norm.id)
            );
            if (appData[c][lst].length !== before) foundElsewhere = true;
          });
        });

        // Add to target
        appData[cat][list].unshift(norm);
        saveAppData();
        updateUI();

        // Generate snarky feedback message for adding from search
        const title = norm.name || norm.title || "This show";
        let message = "";
        
        if (list === "watching") {
          message = `"${title}" is now in the spotlight! ✨`;
        } else if (list === "wishlist") {
          message = `"${title}" added to the queue! 📋`;
        } else if (list === "watched") {
          message = `"${title}" marked as watched! ✅`;
        }
        
        if (message) {
          showNotification(message, "success");
        }
      }

      function moveItem(id, dest) {
        const item = findItem(id);
        if (!item) return;
        
        // Find where the item currently is
        let currentList = null;
        ["tv", "movies"].forEach((cat) =>
          ["watching", "wishlist", "watched"].forEach((lst) => {
            if (appData[cat][lst].some((s) => s.id === id)) {
              currentList = lst;
            }
            appData[cat][lst] = appData[cat][lst].filter((s) => s.id !== id);
          })
        );
        
        const cat = item.media_type === "tv" ? "tv" : "movies";
        appData[cat][dest].unshift(item);
        saveAppData?.();
        updateUI?.();
        
        // Generate snarky feedback message
        const title = item.name || item.title || "This show";
        let message = "";
        
        if (dest === "watching") {
          if (currentList === "wishlist") {
            message = `"${title}" must be in the front of the line! 🚀`;
          } else if (currentList === "watched") {
            message = `"${title}" is back from the dead! 🧟‍♂️`;
          } else {
            message = `"${title}" is now in the spotlight! ✨`;
          }
        } else if (dest === "wishlist") {
          if (currentList === "watching") {
            message = `Successfully put "${title}" in the backseat! 🚗`;
          } else if (currentList === "watched") {
            message = `"${title}" is back on the wishlist! 📝`;
          } else {
            message = `"${title}" added to the queue! 📋`;
          }
        } else if (dest === "watched") {
          if (currentList === "watching") {
            message = `Well, at least we can say we accomplished something! 👏`;
          } else if (currentList === "wishlist") {
            message = `"${title}" jumped straight to completion! 🎯`;
          } else {
            message = `"${title}" marked as watched! ✅`;
          }
        }
        
        if (message) {
          showNotification(message, "success");
        }
      }
      function setRating(id, rating) {
        const it = findItem(id);
        if (!it) {
          return;
        }
        it.userRating = rating;
        saveAppData?.();
        updateUI?.();
      }
      function setLikeStatus(id, status) {
        const it = findItem(id);
        if (!it) return;
        it.likeStatus = status;
        saveAppData?.();
        updateUI?.();
      }
      function removeItemFromCurrentList(id) {
        const item = findItem(id);
        if (!item) return;
        if (!confirm(t("remove_confirmation").replace("{title}", item.title || item.name)))
          return;
        ["tv", "movies"].forEach((cat) =>
          ["watching", "wishlist", "watched"].forEach((lst) => {
            appData[cat][lst] = appData[cat][lst].filter((s) => s.id !== id);
          })
        );
        saveAppData?.();
        updateUI?.();
      }
      function findItem(id) {
        for (const cat of ["tv", "movies"]) {
          for (const lst of ["watching", "wishlist", "watched"]) {
            const f = appData[cat][lst].find((s) => s.id === id);
            if (f) return f;
          }
        }
        return null;
      }

      /* Binge calc / banners / meter */
      function calculateBingeTime({ scope = "all" } = {}) {
        const cards =
          scope === "watching"
            ? [
                ...document.querySelectorAll(
                  "#watchingList .show-card[data-runtime-minutes]"
                ),
              ]
            : [
                ...document.querySelectorAll(
                  ".show-card[data-runtime-minutes]"
                ),
              ];
        const total = cards.reduce(
          (m, c) => m + (parseInt(c.getAttribute("data-runtime-minutes")) || 0),
          0
        );
        const h = Math.floor(total / 60),
          m = total % 60,
          d = Math.floor(h / 24),
          rh = h % 24;
        let str = "";
        if (d) str += `${d}d `;
        if (rh) str += `${rh}h `;
        str += `${m}m`;
        return { totalMinutes: total, timeStr: str, showCount: cards.length };
      }
      function updateBingeMeter() {
        const stats = calculateBingeTime({ scope: "all" });
        const el = document.getElementById("bingeMeter");
        el.innerHTML = `<div class="stat-num">${
          stats.timeStr
        }</div><div class="stat-label">${t("binge_total")}</div>`;
      }
      function updateBingeBanner() {
        const stats = calculateBingeTime({ scope: "watching" });
        const banner = document.getElementById("bingeBanner");
        const msgs =
          appData.settings.lang === "es"
            ? [
                "de decisiones cuestionables en cola. 🎭",
                "de procrastinación medida con precisión. 🤡",
                "de vergüenza en streaming calculada. 📺",
                "de maratón sin arrepentimientos (mentira). 🍿",
              ]
            : [
                "of questionable life choices queued! 🎭",
                "of procrastination precisely measured. 🤡",
                "of streaming shame calculated. 📺",
                "of binge you definitely won't regret. 🍿",
              ];
        const msg = msgs[Math.floor(Math.random() * msgs.length)];
        banner.innerHTML = `
          <span class="binge-time" id="bingeTimeText">${
            stats.timeStr
          }</span>
          <span class="binge-label">${msg}</span>
          <button class="binge-cta" id="startBingeBtn" type="button" aria-label="${t(
            "start"
          )}">${t("start")} ▶</button>`;
        document
          .getElementById("startBingeBtn")
          ?.addEventListener("click", () => {
            switchToTab("watching");
            setTimeout(
              () =>
                document
                  .getElementById("watchingList")
                  ?.scrollIntoView({ behavior: "smooth", block: "start" }),
              120
            );
          });
      }

      /* Stats v2 */
      function rebuildStats() {
        const totals = {
          watching:
            (appData.tv.watching?.length || 0) +
            (appData.movies.watching?.length || 0),
          wishlist:
            (appData.tv.wishlist?.length || 0) +
            (appData.movies.wishlist?.length || 0),
          watched:
            (appData.tv.watched?.length || 0) +
            (appData.movies.watched?.length || 0),
        };
        const total = totals.watching + totals.wishlist + totals.watched;
        document.getElementById("statsBasicBody").innerHTML = `
          <ul>
            <li>${t("total_items")}: <strong>${total}</strong></li>
            <li>${t("watching_count")}: <strong>${
              totals.watching
            }</strong> • ${t("wishlist_count")}: <strong>${
          totals.wishlist
        }</strong> • ${t("watched_count")}: <strong>${totals.watched}</strong></li>
            <li>${t("binge_total")}: <strong>${
          calculateBingeTime().timeStr
        }</strong></li>
          </ul>`;

        const proWrap = document.getElementById("statsPro");
        proWrap.style.display = appData.settings.pro ? "block" : "none";
        if (appData.settings.pro) {
          const byGenre = {};
          getAllItems().forEach((it) =>
            (it.genres || []).forEach(
              (g) => (byGenre[g.name] = (byGenre[g.name] || 0) + 1)
            )
          );
          const topGenres = Object.entries(byGenre)
            .sort((a, b) => b[1] - a[1])
            .slice(0, 5);
          const r = getAllItems()
            .map((x) => Number(x.userRating) || 0)
            .filter(Boolean);
          const avgRating = r.length
            ? (r.reduce((m, v) => m + v, 0) / r.length).toFixed(2)
            : "N/A";
          document.getElementById(
            "statsProBody"
          ).innerHTML = `<div><strong>${t("top_genres")}:</strong> ${
            topGenres.map(([g, c]) => `${g} (${c})`).join(", ") || "N/A"
          }</div>
                           <div><strong>${t("average_rating")}:</strong> ${avgRating}</div>`;
        }
      }

      /* Tabs + list rendering + search */
      function switchToTab(tab) {
        currentActiveTab = tab;

        // Hide/clear search so tab change is obvious
        try {
          const results = document.getElementById("searchResults");
          if (results) {
            results.style.display = "none";
            results.innerHTML = "";
          }
          const qEl = document.getElementById("searchInput");
          if (qEl) qEl.value = "";
        } catch {}

        document
          .querySelectorAll(".tab")
          .forEach((t) => t.classList.remove("active"));
        document.getElementById(tab + "Tab").classList.add("active");
        document
          .querySelectorAll(".tab-section")
          .forEach((s) => (s.style.display = "none"));
        document.getElementById(tab + "Section").style.display = "block";

        if (tab === "discover") renderDiscover();
        if (tab === "settings") {
          // Populate the display name input with current value
          const displayNameInput = document.getElementById("displayNameInput");
          if (displayNameInput) {
            displayNameInput.value = appData?.settings?.displayName || "";
            
            // Add Enter key handling
            displayNameInput.addEventListener("keydown", (e) => {
              if (e.key === "Enter") {
                e.preventDefault();
                document.getElementById("saveNameBtn")?.click();
              }
            });
          }
        }
        
        // Apply translations to the newly visible tab content
        setTimeout(() => {
          if (typeof applyTranslations === "function") {
            applyTranslations();
          }
        }, 100);
      }

      window.switchToTab = switchToTab;

      async function renderDiscover() {
        const list = document.getElementById("discoverList");
        list.innerHTML = t("building_recommendations");
        try {
          const recs = await fetchDiscover();
          if (!recs.length) {
            list.innerHTML = t("not_enough_signals");
            return;
          }
          list.innerHTML = "";
          recs.forEach((it) => {
            const card = createShowCard(it, false);
            const meta = card.querySelector(".show-meta");
            if (meta && it.because) {
              const el = document.createElement("div");
              el.style.fontSize = ".85rem";
              el.style.opacity = ".8";
              el.textContent = it.because;
              meta.appendChild(el);
            }
            list.appendChild(card);
          });
        } catch {
          list.innerHTML = t("recommendations_failed");
        }
      }

      function updateList(containerId, items) {
        const c = document.getElementById(containerId);
        if (!c) return;
        if (!items || !items.length) {
          c.innerHTML = `<div class="empty-state">${t("no_items")}</div>`;
          return;
        }
        
        // Determine which tab this list belongs to based on containerId
        let listTab = "home";
        if (containerId === "watchingList") listTab = "watching";
        else if (containerId === "wishlistList") listTab = "wishlist";
        else if (containerId === "watchedList") listTab = "watched";
        
        c.innerHTML = "";
        items.forEach((it) => c.appendChild(createShowCard(it, false, listTab)));
      }

      function updateUI() {

        const totals = {
          watching:
            (appData.tv.watching?.length || 0) +
            (appData.movies.watching?.length || 0),
          wishlist:
            (appData.tv.wishlist?.length || 0) +
            (appData.movies.wishlist?.length || 0),
          watched:
            (appData.tv.watched?.length || 0) +
            (appData.movies.watched?.length || 0),
        };
        const totalAll = totals.watching + totals.wishlist + totals.watched;

        const setText = (id, v) => {
          const el = document.getElementById(id);
          if (el) el.textContent = String(v);
        };
        setText("watchingBadge", totals.watching);
        setText("watchingCount", totals.watching);
        setText("wishlistBadge", totals.wishlist);
        setText("wishlistCount", totals.wishlist);
        setText("watchedBadge", totals.watched);
        setText("watchedCount", totals.watched);
        setText("totalCount", totalAll);

        if (typeof updateTagFiltersUI === "function") updateTagFiltersUI();

        const maybeFilter = (arr) =>
          typeof filterByTags === "function" ? filterByTags(arr) : arr;
        const watching = maybeFilter([
          ...(appData.tv.watching || []),
          ...(appData.movies.watching || []),
        ]);
        const wishlist = maybeFilter([
          ...(appData.tv.wishlist || []),
          ...(appData.movies.wishlist || []),
        ]);
        const watched = maybeFilter([
          ...(appData.tv.watched || []),
          ...(appData.movies.watched || []),
        ]);

        updateList("watchingList", watching);
        updateList("wishlistList", wishlist);
        updateList("watchedList", watched);

        // updateBingeMeter?.(); // Disabled - removed from home page
        // updateBingeBanner?.(); // Disabled - removed from front page
        
        // Ensure home page blocks are inserted (quotes, horoscope, feedback)
        const blocksResult = ensureBlocks?.();
        
        applyTranslations?.();
        
        rebuildStats?.();
      }
      // Cache search results so we don't inline JSON into onclick
      const searchItemCache = new Map();

      function cacheSearchItem(it) {
        if (it && it.id != null) searchItemCache.set(Number(it.id), it);
      }

      function addToListFromCache(id, list) {
        const it = searchItemCache.get(Number(id));
        if (!it) {
          showNotification(t("could_not_read_item"), "warning");
          return;
        }
        addToList(it, list);
      }
      window.addToListFromCache = addToListFromCache; // used by inline handlers

      /* ---------- SEARCH HELPERS ---------- */
      async function performSearch() {
        try {
          const qEl = document.getElementById("searchInput");
          const gEl = document.getElementById("genreFilter");
          const out = document.getElementById("searchResults");
          if (!qEl || !out) return;

          const q = (qEl.value || "").trim();
          const genre = gEl ? gEl.value || "" : "";
          if (!q) {
            clearSearch();
            return;
          }

          out.style.display = "";
          out.innerHTML = t("searching");

          if (typeof tmdbGet !== "function") {
            out.innerHTML = "Search service not ready.";
            return;
          }

          const data = await tmdbGet(
            "search/multi",
            `&query=${encodeURIComponent(q)}`
          );
          const results = (data?.results || []).filter(
            (r) => !genre || (r.genre_ids || []).includes(Number(genre))
          );

          if (!results.length) {
            out.innerHTML = t("no_results");
            return;
          }

          // --- Cache every result before rendering ---
          out.innerHTML = "";
          results.forEach((it) => {
            cacheSearchItem(it);
            out.appendChild(createShowCard(it, true)); // true => search-mode actions
          });
        } catch (err) {
          console.error("performSearch error", err);
          const out = document.getElementById("searchResults");
          if (out) out.innerHTML = t("search_failed");
        }
      }

      function clearSearch() {
        const qEl = document.getElementById("searchInput");
        const out = document.getElementById("searchResults");
        if (qEl) qEl.value = "";
        if (out) {
          out.innerHTML = "";
          out.style.display = "none";
        }
      }

      // Tag filters / state used by updateTagFiltersUI
      let currentActiveTab = "home";
      let searchCache = [];
      let currentPage = 1;
      let showTVOnly = false,
        showMoviesOnly = false;
      let activeTagFilters = new Set();

      /* ============== Personality Patch Script ============== */
      (function() {
        // ---------- Big pools (edit as you like) ----------
        const FORTUNES = [
          "You are a Chaotic Good. You like drama but call it 'cinema.'",
          "Binge Minimalist: 90% planning, 10% watching.",
          "Comfort, chaos, and clever twists. In that order.",
          "On your 14th rewatch arc. Brave.",
          "63% fueled by snacks and unresolved plotlines.",
          "Human embodiment of 'skip intro'.",
          "Your spirit animal is a loading spinner.",
          "You collect pilots like Pokémon.",
          "You claim you hate cliffhangers. You don't.",
          "You alphabetize your watchlist and then ignore it.",
          "You believe 'one more episode' is a contract with destiny.",
          "You rate with your heart, not the stars.",
          "You're here to procrastinate responsibly.",
          "You love a slow burn and fast Wi‑Fi.",
          "You're allergic to laugh tracks.",
          "You pause for snacks like it's a ritual.",
          "You are a spoiler ninja and an ending apologist.",
          "You think 'limited series' means limits don't apply to you.",
          "You fast‑forward opening credits but respect end credits.",
          "You crave vibes > plot. Bold choice.",
          "You treat 'recommended for you' as a dare.",
          "You chase vibes like a sommelier of scenes.",
          "You watch with subtitles; you are cultured (and quiet).",
          "You fear the finale but press play anyway.",
          "You bookmark chaos and call it variety.",
          "You own three blankets. All 'the good one'.",
          "You pretend the algorithm is your friend.",
          "You rewatch comfort episodes like vitamins.",
          "You hoard tabs and storylines with equal skill.",
          "You skip recaps, then Google plot summaries. Iconic.",
        ];

        const QUOTES = [
          `"I am serious... and don't call me Shirley." — *Airplane!*`,
          `"Streaming is a lifestyle, not a choice." — Ancient Proverb`,
          `"Binge now. Cry later." — You, last night at 2AM`,
          `"One does not simply watch one episode." — Boromir, probably`,
          `"You had me at 'skip recap.'"`,
          `"Art is long, episodes are longer." — Someone with no plans`,
          `"We were on a break! From reality."`,
          `"I came, I saw, I queued it."`,
          `"To stream, perchance to nap." — Hamlet (director's cut)`,
          `"In this house we respect the 'Are you still watching?' prompt."`,
          `"The algorithm thinks I'm complicated. It's right."`,
          `"If found, return to the couch."`,
          `"My love language is 'skip ad.'"`,
          `"I contain multitudes and several watchlists."`,
          `"Sundays are for pilots and denial."`,
          `"Ctrl+Z for life, play for comfort."`,
          `"I fear no man, but I fear finales."`,
          `"This app gets me. Terrifying."`,
          `"Plot holes are just cardio for the brain."`,
          `"We accept the dopamine we think we deserve."`,
          `"I have never finished anything. Except seasons."`,
          `"Today's vibe: closed captions and open snacks."`,
          `"Foreshadowing? I hardly know her."`,
          `"Character development is my cardio."`,
          `"If the title card hits, I'm staying."`,
          `"Minimalism, but for episodes."`,
          `"'Are you still watching?' yes, Netflix, I'm thriving."`,
          `"I ship productivity with naps."`,
          `"Comfort show supremacy."`,
          `"This queue is a personality test I'm failing."`,
        ];

        // ---------- Utilities ----------
        const STORAGE_KEYS = {
          QUOTE_DECK: "__flicklet_quote_deck_v1__",
        };

        function dayOfYear(d = new Date()) {
          const start = new Date(d.getFullYear(), 0, 0);
          const diff = d - start;
          return Math.floor(diff / 86400000); // ms->days
        }

        // Cheap stable hash for a string
        function hashString(str) {
          let h = 2166136261 >>> 0;
          for (let i = 0; i < str.length; i++) {
            h ^= str.charCodeAt(i);
            h = Math.imul(h, 16777619);
          }
          return h >>> 0;
        }

        // Fisher‑Yates shuffle
        function shuffle(arr) {
          const a = arr.slice();
          for (let i = a.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [a[i], a[j]] = [a[j], a[i]];
          }
          return a;
        }

        // ---------- Horoscope (daily, deterministic) ----------
        function pickDailyHoroscope() {
          // Try to personalize with displayName if it exists in your appData
          let name = "";
          try {
            name = (window.appData?.settings?.displayName || "").trim();
          } catch {}
          const seed = (dayOfYear() + hashString(name)).toString();
          const idx = hashString(seed) % FORTUNES.length;
          const fortune = FORTUNES[idx];
          
          // Try to translate the fortune if we have a translation key
          const fortuneKey = fortune.toLowerCase().replace(/[^a-z\s]/g, '').replace(/\s+/g, '_');
          const translation = t(fortuneKey);
          
  
          return translation || fortune;
        }
        
        // Make functions globally accessible
        window.pickDailyHoroscope = pickDailyHoroscope;
        window.drawQuote = drawQuote;

        // ---------- Quotes (deck‑based, no repeats until exhausted) ----------
        function getQuoteDeck() {
          try {
            const raw = localStorage.getItem(STORAGE_KEYS.QUOTE_DECK);
            if (raw) {
              const deck = JSON.parse(raw);
              if (Array.isArray(deck) && deck.every(Number.isInteger))
                return deck;
            }
          } catch {}
          // Build a fresh shuffled deck of indices
          const fresh = shuffle([...QUOTES.keys()]);
          localStorage.setItem(
            STORAGE_KEYS.QUOTE_DECK,
            JSON.stringify(fresh)
          );
          return fresh;
        }

        function drawQuote() {
          const deck = getQuoteDeck();
          const next = deck.shift();
          const quoteIndex = next || 0;
          // Get translated quote based on current language
          const quoteKey = `quote_${quoteIndex + 1}`;
          const quote = t(quoteKey) || QUOTES[quoteIndex] || QUOTES[0];
          // Save remaining deck; if empty, rebuild next time
          try {
            if (deck.length) {
              localStorage.setItem(
                STORAGE_KEYS.QUOTE_DECK,
                JSON.stringify(deck)
              );
            } else {
              localStorage.removeItem(STORAGE_KEYS.QUOTE_DECK);
            }
          } catch {}
          return quote;
        }

        // ---------- DOM injection (idempotent) ----------
        window.ensureBlocks = function() {
          const home = document.getElementById("homeSection");
          if (!home) {
    
            return false;
          }


          
          // If home section is empty, create a container div first
          if (!home.firstElementChild) {
            const container = document.createElement("div");
            container.id = "homeContentContainer";
            home.appendChild(container);
    
          }
          
          const anchor = home.firstElementChild;

          // Insert quotes first (after tabs, before feedback)
          if (!document.getElementById("quoteBlock")) {
            const block = document.createElement("blockquote");
            block.className = "feedback-card";
            block.id = "quoteBlock";
            block.style.textAlign = "center";
            block.style.fontStyle = "italic";
            block.innerHTML = `<p id="randomQuote">"${t("quote_loading")}"</p>`;
            anchor.insertAdjacentElement("afterend", block);
          }

          // Insert horoscope second (after quotes)
          if (!document.getElementById("personalityForecast")) {
            const card = document.createElement("div");
            card.className = "feedback-card";
            card.id = "personalityForecast";
            card.innerHTML = `
                    <h3>🧠 <span data-i18n="streaming_horoscope">Streaming Horoscope</span></h3>
        <p id="fakeFortune" style="margin:0; font-style:italic;"></p>
      `;
            const insertAfter = document.getElementById("quoteBlock") || anchor;
            insertAfter.insertAdjacentElement("afterend", card);
          }

          // Insert feedback section last (at the bottom)
          if (!document.getElementById("feedbackSection")) {
            const feedbackCard = document.createElement("div");
            feedbackCard.className = "feedback-card";
            feedbackCard.id = "feedbackSection";
            feedbackCard.innerHTML = `
                          <h3 data-i18n="feedback">Feedback</h3>
            <p data-i18n="feedback_working">Tell us what's working and what's not. Be blunt.</p>
              <form name="feedback" method="POST" data-netlify="true" class="feedback-form">
                <input type="hidden" name="form-name" value="feedback" />
                <div style="display: flex; gap: 8px; flex-wrap: wrap">
                  <textarea
                    name="message"
                    class="search-input"
                    placeholder=""
                    data-i18n-placeholder="feedback_placeholder"
                    rows="3"
                    required
                    style="resize: vertical; min-height: 60px;"
                  ></textarea>
                  <button type="submit" class="btn" data-i18n="send">Send</button>
                </div>
              </form>
            `;
            const insertAfter = document.getElementById("personalityForecast") || document.getElementById("quoteBlock") || anchor;
            insertAfter.insertAdjacentElement("afterend", feedbackCard);
          }

          const hEl = document.getElementById("fakeFortune");
          const qEl = document.getElementById("randomQuote");
          if (hEl) hEl.textContent = pickDailyHoroscope();
          if (qEl) qEl.textContent = drawQuote();

          return true;
        }

        const start = () => {
                  const result = ensureBlocks();
        if (!result) {
            requestAnimationFrame(ensureBlocks);
          }
        };

        if (document.readyState === "loading") {
          document.addEventListener("DOMContentLoaded", start, {
            once: true,
          });
        } else {
          start();
        }
      })();
    </script>

    <script>
      /* ============== bootstrap ============== */
      document.addEventListener("DOMContentLoaded", () => {
        // --- SEARCH BAR PROTECTION - Prevent it from disappearing

        
        
        
        // --- SEARCH BAR PROTECTION - CSS sticky positioning handles visibility
        // Removed aggressive visibility enforcement - CSS sticky positioning is sufficient
        
        // --- small util
        const bind = (id, fn) => {
          const el = document.getElementById(id);
          if (el) el.onclick = fn;
        };

        // --- initial load order
        tryImportFromShareLink?.();
        loadAppData?.();
        loadGenres?.();
        
        // Show home tab by default FIRST
        switchToTab("home");
        
        // Then update UI (which will call ensureBlocks)
        updateUI?.();
        checkUpcomingEpisodes?.();
        
        // Apply translations to the initial tab content
        setTimeout(() => {
          if (typeof applyTranslations === "function") {
            applyTranslations();
          }
        }, 200);
        
        // Request notification permissions
        requestNotificationPermission?.();
        
        // Initialize file label
        const fileInput = document.getElementById("importFile");
        if (fileInput) {
          updateFileLabel(fileInput);
        }
        
        // Language toggle is now handled by the onchange event directly

        
        // Paint account button based on currentUser if auth has already resolved
        if (typeof setAccountLabel === "function") setAccountLabel(currentUser);

        // --- tabs
        bind("homeTab", () => switchToTab("home"));
        bind("watchingTab", () => switchToTab("watching"));
        bind("wishlistTab", () => switchToTab("wishlist"));
        bind("watchedTab", () => switchToTab("watched"));
        bind("discoverTab", () => switchToTab("discover"));
        bind("settingsTab", () => switchToTab("settings"));

        
        // --- delegated actions for cards & search results

        
        // Try both event delegation and direct binding
        document.addEventListener("click", (e) => {
          
          
          const btn = e.target.closest("[data-action]");
          if (!btn) {
            return;
          }
          
          const action = btn.getAttribute("data-action");
          const id = Number(btn.getAttribute("data-id"));
          const list = btn.getAttribute("data-list");
          const mediaType = btn.getAttribute("data-media-type");
          
  
          if (action === "addFromCache") {
            addToListFromCache(id, list);
          } else if (action === "move") {
            moveItem(id, list);
          } else if (action === "notes") {
            openNotesTagsModal(id);
          } else if (action === "remove") {
            removeItemFromCurrentList(id);
          } else if (action === "rate") {
            const rating = Number(btn.getAttribute("data-rating"));
            setRating(id, rating);
          } else if (action === "like") {
            setLikeStatus(id, "like");
          } else if (action === "dislike") {
            setLikeStatus(id, "dislike");
          } else if (action === "open") {
            openTMDBLink(id, mediaType);
          }
        });
// --- dark mode
        const darkBtn = document.getElementById("darkModeToggle");
        const setDarkLabel = () => {
          if (!darkBtn) return;
          const dark = document.body.classList.contains("dark-mode");
          const label = darkBtn.querySelector('span');
          if (label) {
            label.textContent = t(dark ? "go_light" : "go_dark");
          }
        };
        setDarkLabel();
        if (darkBtn) {
          darkBtn.onclick = () => {
            document.body.classList.toggle("dark-mode");
            if (window.appData?.settings) {
              appData.settings.theme = document.body.classList.contains(
                "dark-mode"
              )
                ? "dark"
                : "light";
              saveAppData?.();
            }
            setDarkLabel();
          };
        }

        // --- mardi toggle
        const root = document.getElementById("appRoot");
        bind("mardiToggle", () => root && root.classList.toggle("mardi"));
        bind("mardiOnBtn", () => root && root.classList.toggle("mardi"));

        // --- language switch (will be set up after data loads)

        // --- ensure display name prompt on first boot (no extra auth listener here)
        (function ensureDisplayNameOnBoot() {
          const hasName =
            (appData?.settings?.displayName || "").trim().length > 0;
          
          if (!hasName) {
            // If user is already signed in, the top-level auth listener (outside) may seed displayName.
            // Still, prompt after a short delay if we remain nameless.
            setTimeout(() => {
              const stillNoName = !(
                appData?.settings?.displayName || ""
              ).trim();
              if (stillNoName && typeof showNameModal === "function") {
                showNameModal(true);
              }
            }, 1000); // Increased delay to ensure appData is loaded
          }
        })();

        // --- Account / Auth entry point (modal)
        const accountBtn = document.getElementById("accountBtn");
        if (accountBtn && typeof showSignInModal === "function") {
          accountBtn.onclick = showSignInModal;
        }

        // --- Save name button
        bind("saveNameBtn", () => {
          const val = (document.getElementById("displayNameInput")?.value || "").trim();
          if (!val) return showNotification?.(t("enter_name_first"), "warning");
          if (appData?.settings) {
            appData.settings.displayName = val;
            saveAppData?.();
            updateWelcomeText?.();
            showNotification?.(t("name_saved"), "success");
          }
        });
        


        // --- feedback handled by Netlify Forms



        // --- search controls
        bind("searchBtn", performSearch);
        bind("clearSearchBtn", clearSearch);
        const searchInput = document.getElementById("searchInput");
        if (searchInput) {
          searchInput.addEventListener("keydown", (e) => {
            if (e.key === "Enter") performSearch?.();
          });
        }

        // --- backup / import / clear / share
        bind("exportBtn", () => {
          const blob = new Blob([JSON.stringify(appData, null, 2)], {
            type: "application/json",
          });
          const a = document.createElement("a");
          a.href = URL.createObjectURL(blob);
          a.download = "flicklet-backup.json";
          document.body.appendChild(a);
          a.click();
          a.remove();
        });

        const importFile = document.getElementById("importFile");
        if (importFile) {
          importFile.onchange = (e) => {
            const f = e.target.files?.[0];
            if (!f) return;
            const r = new FileReader();
            r.onload = () => {
              try {
                const d = JSON.parse(r.result);
                Object.assign(appData, d);
                saveAppData?.();
                updateUI?.();
                showNotification?.(t("imported_backup"), "success");
              } catch {
                showNotification?.(t("invalid_file"), "error");
              }
            };
            r.readAsText(f);
          };
        }

        bind("clearAllBtn", () => {
          if (!confirm("This wipes everything. You sure?")) return;
          if (appData?.tv)
            appData.tv = { watching: [], wishlist: [], watched: [] };
          if (appData?.movies)
            appData.movies = { watching: [], wishlist: [], watched: [] };
          saveAppData?.();
          updateUI?.();
          showNotification?.(t("all_data_cleared"), "warning");
        });

        bind("shareListBtn", generateShareLinkForCurrentTab);

        // --- notification toggles
        const ep = document.getElementById("notifEpisodes");
        const dp = document.getElementById("notifDiscover");
        const md = document.getElementById("notifDigest");
        if (ep)
          ep.addEventListener("change", (e) => {
            if (appData?.settings?.notif) {
              appData.settings.notif.episodes = !!e.target.checked;
              saveAppData?.();
            }
          });
        if (dp)
          dp.addEventListener("change", (e) => {
            if (appData?.settings?.notif) {
              appData.settings.notif.discover = !!e.target.checked;
              saveAppData?.();
            }
          });
        if (md)
          md.addEventListener("change", (e) => {
            if (appData?.settings?.notif) {
              appData.settings.notif.digest = !!e.target.checked;
              saveAppData?.();
            }
          });

        // --- pro toggle
        const proToggle = document.getElementById("proToggle");
        if (proToggle) {
          proToggle.checked = !!appData?.settings?.pro;
          proToggle.addEventListener("change", (e) => {
            if (appData?.settings) {
              appData.settings.pro = !!e.target.checked;
              saveAppData?.();
              rebuildStats?.();
              
              // Show/hide Pro features explanation
              const proFeatures = document.getElementById("proFeatures");
              if (proFeatures) {
                proFeatures.style.display = e.target.checked ? "block" : "none";
              }
            }
          });
          
          // Show Pro features if already enabled
          const proFeatures = document.getElementById("proFeatures");
          if (proFeatures && proToggle.checked) {
            proFeatures.style.display = "block";
          }
        }

        console.debug("[Flicklet] Boot OK");

      });
    </script>
  </body>
</html>