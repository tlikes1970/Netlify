# Ratings & Discovery Code Dump

## apps/web/src/lib/ratingSystem.ts
### Summary
Handles rating normalization, dedup detection, and timestamp-based conflict resolution before writes.
### Content
```ts
/**
 * Process: Enhanced Rating System with Conflict Resolution
 * Purpose: Manages user ratings with timestamps, deduplication, and conflict resolution
 * Data Source: Library entries with userRating and ratingUpdatedAt
 * Update Path: Modify rating update logic or conflict resolution rules
 * Dependencies: Library storage, event system
 */

import type { MediaType } from '../components/cards/card.types';

export type RatingState = 'null' | 'zero' | 'unchanged' | 'changed';

export interface RatingUpdate {
  id: string | number;
  mediaType: MediaType;
  rating: number; // 1-5 stars, must be integer
  timestamp: number; // epoch ms
  origin: 'user' | 'sync' | 'discovery'; // Track where update came from
}

// Track recent updates to prevent duplicates
const recentUpdates = new Map<string, { rating: number; timestamp: number; origin: string }>();
const DEDUP_WINDOW_MS = 500; // 500ms window for deduplication

/**
 * Normalize rating to 1-5 integer scale
 */
export function normalizeRating(rating: number | null | undefined): number | null {
  if (rating === null || rating === undefined) return null;
  // Clamp to 1-5 and round to nearest integer
  const normalized = Math.max(1, Math.min(5, Math.round(rating)));
  return normalized;
}

/**
 * Determine rating state: null, zero, unchanged, or changed
 */
export function getRatingState(
  oldRating: number | null | undefined,
  newRating: number | null | undefined
): RatingState {
  const oldNorm = normalizeRating(oldRating);
  const newNorm = normalizeRating(newRating);
  
  if (newNorm === null) return 'null';
  if (newNorm === 0) return 'zero';
  if (oldNorm === newNorm) return 'unchanged';
  return 'changed';
}

/**
 * Check if rating update should be applied (last-write-wins with timestamp)
 */
export function shouldApplyRating(
  existingTimestamp: number | undefined,
  newTimestamp: number
): boolean {
  // If no existing timestamp, always apply
  if (!existingTimestamp) return true;
  // Apply if new timestamp is newer (last-write-wins)
  return newTimestamp > existingTimestamp;
}

/**
 * Check if update is duplicate within deduplication window
 */
export function isDuplicateUpdate(
  key: string,
  rating: number,
  timestamp: number,
  origin: string
): boolean {
  const recent = recentUpdates.get(key);
  if (!recent) return false;
  
  const timeDiff = timestamp - recent.timestamp;
  if (timeDiff > DEDUP_WINDOW_MS) return false; // Outside window
  
  // Same rating, same origin, within window = duplicate
  return recent.rating === rating && recent.origin === origin;
}

/**
 * Record update for deduplication
 */
export function recordUpdate(
  key: string,
  rating: number,
  timestamp: number,
  origin: string
): void {
  recentUpdates.set(key, { rating, timestamp, origin });
  
  // Clean up old entries (older than dedup window)
  const cutoff = Date.now() - DEDUP_WINDOW_MS;
  for (const [k, v] of recentUpdates.entries()) {
    if (v.timestamp < cutoff) {
      recentUpdates.delete(k);
    }
  }
}

/**
 * Create rating update with proper normalization and deduplication
 */
export function createRatingUpdate(
  id: string | number,
  mediaType: MediaType,
  rating: number | null | undefined,
  origin: 'user' | 'sync' | 'discovery' = 'user'
): RatingUpdate | null {
  const normalized = normalizeRating(rating);
  if (normalized === null) return null; // Don't create update for null ratings
  
  const key = `${mediaType}:${id}`;
  const timestamp = Date.now();
  
  // Check for duplicate
  if (isDuplicateUpdate(key, normalized, timestamp, origin)) {
    return null; // Duplicate, skip
  }
  
  // Record for future deduplication
  recordUpdate(key, normalized, timestamp, origin);
  
  return {
    id,
    mediaType,
    rating: normalized,
    timestamp,
    origin
  };
}
















```

## apps/web/src/lib/libraryIndex.ts
### Summary
Maintains a tag-based index of the library to support fast lookup for discovery/search filters.
### Content
```ts
/**
 * Library tag index
 * Purpose: Provides fast tag-based search across user's library items
 * Data Source: Library state from storage.ts
 * Update Path: Call rebuildIndex() when library changes
 * Dependencies: Uses Library from storage.ts
 */

import { Library } from './storage';
import type { MediaItem } from '../components/cards/card.types';

type MediaKey = string; // format: "mediaType:id"

interface TagIndex {
  byTag: Map<string, Set<MediaKey>>;
  byItem: Map<MediaKey, Set<string>>;
}

class LibraryTagIndex {
  private index: TagIndex = { byTag: new Map(), byItem: new Map() };
  private lastRebuild: number = 0;
  private readonly REBUILD_INTERVAL = 5000; // rebuild at most once per 5 seconds

  /**
   * Rebuild the index from current library state
   */
  rebuildIndex(): void {
    const now = Date.now();
    if (now - this.lastRebuild < this.REBUILD_INTERVAL) {
      return;
    }
    this.lastRebuild = now;

    this.index.byTag.clear();
    this.index.byItem.clear();

    // Get all library items across all lists
    const lists: Array<'watching' | 'wishlist' | 'watched' | 'not'> = ['watching', 'wishlist', 'watched', 'not'];
    
    for (const list of lists) {
      const items = Library.getByList(list);
      for (const item of items) {
        const key = `${item.mediaType}:${item.id}`;
        const tags = item.tags || [];
        
        // Index tags
        for (const tag of tags) {
          const normalizedTag = this.normalizeTag(tag);
          if (!this.index.byTag.has(normalizedTag)) {
            this.index.byTag.set(normalizedTag, new Set());
          }
          this.index.byTag.get(normalizedTag)!.add(key);
        }
        
        // Index item -> tags for reverse lookup
        this.index.byItem.set(key, new Set(tags.map(this.normalizeTag)));
      }
    }
  }

  /**
   * Search for items by tag
   */
  searchTags(query: string): MediaKey[] {
    this.rebuildIndex();
    
    const normalizedQuery = this.normalizeTag(query);
    const results = new Set<MediaKey>();

    // Exact match
    if (this.index.byTag.has(normalizedQuery)) {
      for (const key of this.index.byTag.get(normalizedQuery)!) {
        results.add(key);
      }
    }

    // Partial matches (substring)
    for (const [tag, items] of this.index.byTag) {
      if (tag.includes(normalizedQuery) || normalizedQuery.includes(tag)) {
        for (const key of items) {
          results.add(key);
        }
      }
    }

    return Array.from(results);
  }

  /**
   * Get all tags used in the library
   */
  getAllTags(): string[] {
    this.rebuildIndex();
    return Array.from(this.index.byTag.keys());
  }

  /**
   * Check if an item has a specific tag
   */
  hasTag(item: MediaItem, tag: string): boolean {
    const key = `${item.mediaType}:${item.id}`;
    const tags = this.index.byItem.get(key);
    if (!tags) return false;
    return tags.has(this.normalizeTag(tag));
  }

  /**
   * Normalize tag for indexing (lowercase, trimmed)
   */
  private normalizeTag(tag: string): string {
    return tag.toLowerCase().trim();
  }
}

export const libraryTagIndex = new LibraryTagIndex();

/**
 * Search library items by tag
 */
export function searchTagsLocal(query: string): MediaItem[] {
  const keys = libraryTagIndex.searchTags(query);
  
  // Get all items from library
  const allItems: MediaItem[] = [];
  const lists: Array<'watching' | 'wishlist' | 'watched' | 'not'> = ['watching', 'wishlist', 'watched', 'not'];
  
  for (const list of lists) {
    const items = Library.getByList(list);
    allItems.push(...items);
  }
  
  // Filter to matching keys
  const keySet = new Set(keys);
  return allItems.filter(item => {
    const key = `${item.mediaType}:${item.id}`;
    return keySet.has(key);
  });
}









































```

## apps/web/src/lib/language.types.ts
### Summary
Defines every translation key (including ratings/discovery copy) used by the UI.
### Content
```ts
export type Language = 'en' | 'es';

export interface LanguageStrings {
  // Navigation
  home: string;
  currentlyWatching: string;
  wantToWatch: string;
  watched: string;
  alreadyWatched: string;
  holidays: string;
  discovery: string;
  
  // Actions
  wantToWatchAction: string;
  currentlyWatchingAction: string;
  watchedAction: string;
  notInterestedAction: string;
  deleteAction: string;
  removeAction: string;
  reviewNotesAction: string;
  addTagAction: string;
  holidayAddAction: string;
  
  // Settings
  settings: string;
  general: string;
  notifications: string;
  accountAndProfile: string;
  displayAndLayout: string;
  notificationSettings: string;
  notificationSettingsDescription: string;
  notificationCenter: string;
  notificationCenterDescription: string;
  currentSettings: string;
  notificationTiming: string;
  notificationMethods: string;
  episodeReminders: string;
  enabled: string;
  disabled: string;
  timing24HoursBefore: string;
  timingCustomPro: string;
  methodsInAppPush: string;
  methodsInAppPushEmail: string;
  layout: string;
  data: string;
  pro: string;
  about: string;
  
  // General Settings
  displayName: string;
  myStatistics: string;
  tvShows: string;
  movies: string;
  notInterested: string;
  notInterestedManagement: string;
  manageNotInterestedList: string;
  personalityLevel: string;
  regular: string;
  semiSarcastic: string;
  severelySarcastic: string;
  friendlyAndHelpful: string;
  aBitCheeky: string;
  maximumSass: string;
  preview: string;
  resetSystemToDefaults: string;
  resetSettingsToDefaults: string;
  confirmResetSettings: string;
  resetSettingsSuccess: string;
  
  // Layout Settings
  themePreference: string;
  dark: string;
  light: string;
  darkBackgroundWithLightText: string;
  lightBackgroundWithDarkText: string;
  condensedView: string;
  enableEpisodeTracking: string;
  discoveryRecommendations: string;
  discoveryRecommendationsDescription: string;
  otherLayoutSettings: string;
  condensedViewDescription: string;
  episodeTrackingCondensedProRequired: string;
  episodeTrackingCondensedProAllowed: string;
  proFeatures: string;
  themePacksComingSoon: string;
  
  // My Lists
  myLists: string;
  enterListName: string;
  addToList: string;
  selectListFor: string;
  items: string;
  noListsYet: string;
  createFirstList: string;
  createNewList: string;
  listName: string;
  listDescription: string;
  listDescriptionOptional: string;
  default: string;
  edit: string;
  setAsDefault: string;
  delete: string;
  noListsCreated: string;
  createYourFirstList: string;
  listsUsed: string;
  confirmDeleteList: string;
  thisActionCannotBeUndone: string;
  save: string;
  cancel: string;
  darkThemeDescription: string;
  lightThemeDescription: string;
  
  // Additional My Lists
  enterNewName: string;
  rename: string;
  addItemsFromSearchOrDiscovery: string;
  createListsToOrganize: string;
  maxListsReached: string;
  upgradeForMoreLists: string;
  upgradeToPro: string;
  proUpgradeComingSoon: string;
  itemAlreadyExists: string;
  alreadyInList: string;
  confirmMoveToList: string;
  moveToList: string;
  listNotFound: string;
  failedToCreateList: string;
  failedToUpdateList: string;
  failedToDeleteList: string;
  failedToSetDefaultList: string;
  forYouSectionConfiguration: string;
  forYouSectionDescription: string;
  forYouAddAnotherRow: string;
  forYouTipText: string;
  
  // Notifications
  notificationTypes: string;
  upcomingEpisodeAlerts: string;
  weeklyDiscover: string;
  monthlyStatsDigest: string;
  alertConfiguration: string;
  advancedNotificationByLeadTime: string;
  pickTheList: string;
  
  // Data Management
  standardDataManagement: string;
  shareList: string;
  chooseListsAndShowsToShare: string;
  generatesCopyPasteableFormattedList: string;
  backupSystem: string;
  exportAllPersonalData: string;
  import: string;
  importPreviouslyExportedData: string;
  resetAllData: string;
  restoreSystemToDefaults: string;
  advancedSharingOptions: string;
  
  // Pro Features
  proManagement: string;
  unlockProFeatures: string;
  paymentPromptNotImplemented: string;
  proFeatureList: string;
  alertConfigurationDetails: string;
  hourlyConfig: string;
  themePacks: string;
  holidayAndMovieThemes: string;
  socialFeatures: string;
  flickwordTriviaSharedWatchlists: string;
  bloopersBehindTheScenes: string;
  activatesButtonOnShowCards: string;
  additionalFeaturesTBD: string;
  
  // About
  informationSections: string;
  aboutUniqueForYou: string;
  aboutTheCreators: string;
  aboutTheApp: string;
  shareYourThoughts: string;
  feedbackQuotesForMarquee: string;
  clipsForHomePagePlayer: string;
  venting: string;
  
  // Authentication
  signIn: string;
  signOut: string;
  signInHere: string;
  clickToSignOut: string;
  clickToSignIn: string;
  signedInAs: string;
  signInWithGoogle: string;
  signInWithApple: string;
  signInWithEmail: string;
  signInDescription: string;
  welcomeToFlicklet: string;
  whatShouldWeCallYou: string;
  username: string;
  usernameRequired: string;
  usernameDescription: string;
  saving: string;
  skip: string;

  // Common
  close: string;
  confirm: string;
  areYouSure: string;
  comingSoon: string;
  notImplemented: string;
  
  // Home Rails
  yourShows: string;
  upNext: string;
  inTheatersNearYou: string;
  
  // Placeholders
  noShowsInCurrentlyWatching: string;
  addSomeFromSearchOrDiscovery: string;
  noUpcomingEpisodes: string;
  addTvShowsToWatchingList: string;
  noPoster: string;
  
  // Statistics
  currentlyWatchingCount: string;
  wantToWatchCount: string;
  watchedCount: string;
  totalCount: string;
  
  // Feedback Panel
  tellUsWhatToImprove: string;
  typeYourFeedback: string;
  sendFeedback: string;
  whatsComing: string;
  betterRecommendations: string;
  episodeUpNextWithDates: string;
  shareListsWithFriends: string;
  
  // Theater Info
  yourLocalTheater: string;
  
  // Header
  logIn: string;
  logOut: string;
  guest: string;
  
  // Search Results
  noSynopsisAvailable: string;
  opensInTmdb: string;
  searchFailed: string;
  
  // Personality Messages
  procrastinatingProductively: string;
  curatingYourIndecision: string;
  becauseTimeIsAnIllusion: string;
  cinemaNowWithCommitmentIssues: string;
  yourBacklogCalledItsGrowing: string;
  
  // Confirmation Messages
  areYouSureChangeDisplayName: string;
  thisWillUpdateYourProfile: string;
  areYouSureResetSettings: string;
  usernameUpdateFailed: string;
  
  // Language Labels
  language: string;
  english: string;
  spanish: string;
  
  // Home Page Sections
  community: string;
  forYou: string;
  feedback: string;
  
  // Games
  flickword: string;
  flickword_tagline: string;
  daily_trivia: string;
  daily_trivia_tagline: string;
  play_now: string;
  close_game: string;
  games: string;
  won: string;
  lost: string;
  streak: string;
  best: string;
  win_percent: string;
  played: string;
  accuracy: string;
  
  // Theater
  detectingLocation: string;
  locationUnavailable: string;
  enableLocation: string;
  hideShowtimes: string;
  findShowtimes: string;
  loadingTheaters: string;
  noTheatersFound: string;
  kmAway: string;
  hideTimes: string;
  showTimes: string;
  todaysShowtimes: string;
  
  // Personality
  hasExquisiteTaste: string;
  definitelyNotProcrastinating: string;
  breaksForPopcornOnly: string;
  curatesChaosLikeAPro: string;
  
  // Community Player
  community_player_placeholder: string;
  
  // Data Management
  dataManagementComingSoon: string;
  
  // Rail Titles
  drama: string;
  comedy: string;
  horror: string;
  nowPlaying: string;
  
  // Search
  searchPlaceholder: string;
  allGenres: string;
  action: string;
  search: string;
  clear: string;
  
  // Marquee Controls
  showMarquee: string;
  hideMarquee: string;
  
  // Marquee Messages
  marqueeMessage1: string;
  marqueeMessage2: string;
  marqueeMessage3: string;
  marqueeMessage4: string;
  marqueeMessage5: string;
}

```

## apps/web/src/components/settingsSections.tsx
### Summary
Shared settings sections that surface stats, discovery toggles, and user preferences used across desktop/mobile UIs.
### Content
```tsx
/**
 * Process: Settings Section Components
 * Purpose: Shared section rendering logic used by both desktop and mobile Settings UIs
 * Data Source: Settings hooks, library data, translations
 * Update Path: Modify section components here to update both desktop and mobile
 * Dependencies: settingsConfig.ts, settings.ts, proStatus.ts, useAdminRole.ts
 */

import { useState, useEffect } from "react";
import {
  useSettings,
  settingsManager,
  PersonalityLevel,
  getPersonalityText,
} from "../lib/settings";
import { useProStatus } from "../lib/proStatus";
import { useTranslations, useLanguage, changeLanguage } from "../lib/language";
import { PRO_FEATURES_AVAILABLE, PRO_FEATURES_COMING_SOON } from "./settingsProConfig";
import { UpgradeToProCTA } from "./UpgradeToProCTA";
import { useCustomLists, customListManager } from "../lib/customLists";
import { useUsername } from "../hooks/useUsername";
import { useAuth } from "../hooks/useAuth";
import { useLibrary } from "../lib/storage";
import { useAdminRole } from "../hooks/useAdminRole";
import PersonalityExamples from "./PersonalityExamples";
import ForYouGenreConfig from "./ForYouGenreConfig";
import type { Language } from "../lib/language.types";
import type { SettingsSectionId } from "./settingsConfig";
import type { ListName } from "../state/library.types";
import { lazy, Suspense } from "react";

// Lazy load heavy components
const NotificationSettings = lazy(() =>
  import("./modals/NotificationSettings").then((m) => ({
    default: m.NotificationSettings,
  }))
);
const NotificationCenter = lazy(() =>
  import("./modals/NotificationCenter").then((m) => ({
    default: m.NotificationCenter,
  }))
);
const AdminExtrasPage = lazy(() => import("../pages/AdminExtrasPage"));

export interface SettingsSectionProps {
  onShowNotInterestedModal?: () => void;
  onShowSharingModal?: () => void;
  onShowNotificationSettings?: () => void;
  onShowNotificationCenter?: () => void;
  isMobile?: boolean; // If true, render mobile-optimized layout
}

/**
 * Render a settings section by ID
 * This is the single source of truth for section content
 */
export function renderSettingsSection(
  sectionId: SettingsSectionId,
  props: SettingsSectionProps = {}
): JSX.Element | null {
  switch (sectionId) {
    case "account":
      return <AccountSection {...props} />;
    case "notifications":
      return <NotificationsSection {...props} />;
    case "display":
      return <DisplaySection {...props} />;
    case "community":
      return <CommunitySection {...props} />;
    case "pro":
      return <ProSection {...props} />;
    case "data":
      return <DataSection {...props} />;
    case "about":
      return <AboutSection {...props} />;
    case "admin":
      return <AdminSection {...props} />;
    default:
      return null;
  }
}

// ============================================================================
// SECTION COMPONENTS
// ============================================================================

function AccountSection({ onShowNotInterestedModal }: SettingsSectionProps) {
  const settings = useSettings();
  const translations = useTranslations();
  const currentLanguage = useLanguage();
  const watchingItems = useLibrary("watching");
  const wishlistItems = useLibrary("wishlist");
  const watchedItems = useLibrary("watched");
  const notItems = useLibrary("not");
  const { username, updateUsername } = useUsername();
  const [displayName, setDisplayName] = useState(username);
  const [showWarning, setShowWarning] = useState(false);

  // Calculate stats by media type
  const tvStats = {
    watching: watchingItems.filter((item) => item.mediaType === "tv").length,
    wishlist: wishlistItems.filter((item) => item.mediaType === "tv").length,
    watched: watchedItems.filter((item) => item.mediaType === "tv").length,
    not: notItems.filter((item) => item.mediaType === "tv").length,
  };

  const movieStats = {
    watching: watchingItems.filter((item) => item.mediaType === "movie").length,
    wishlist: wishlistItems.filter((item) => item.mediaType === "movie").length,
    watched: watchedItems.filter((item) => item.mediaType === "movie").length,
    not: notItems.filter((item) => item.mediaType === "movie").length,
  };

  useEffect(() => {
    setDisplayName(username);
  }, [username]);

  const handleDisplayNameChange = (newName: string) => {
    setDisplayName(newName);
    if (newName !== username) {
      setShowWarning(true);
    } else {
      setShowWarning(false);
    }
  };

  const saveDisplayName = async () => {
    if (showWarning) {
      const confirmed = window.confirm(
        `${translations.areYouSureChangeDisplayName} ${translations.thisWillUpdateYourProfile}`
      );
      if (confirmed) {
        try {
          await updateUsername(displayName);
          setShowWarning(false);
        } catch (error) {
          console.error("Failed to update username:", error);
          alert(translations.usernameUpdateFailed);
        }
      }
    }
  };

  return (
    <div className="space-y-6">
      <h3 className="text-xl font-semibold" style={{ color: "var(--text)" }}>
        {translations.accountAndProfile}
      </h3>

      {/* Language Selection */}
      <div>
        <label
          className="block text-sm font-medium mb-2"
          style={{ color: "var(--text)" }}
        >
          {translations.language} / Idioma
        </label>
        <div className="space-y-2">
          {[
            { lang: "en" as Language, label: translations.english, flag: "üá∫üá∏" },
            { lang: "es" as Language, label: translations.spanish, flag: "üá™üá∏" },
          ].map(({ lang, label, flag }) => (
            <label
              key={lang}
              className="flex items-center space-x-3 cursor-pointer"
            >
              <input
                type="radio"
                name="language"
                value={lang}
                checked={currentLanguage === lang}
                onChange={() => changeLanguage(lang)}
                className="w-4 h-4 text-blue-600 bg-neutral-800 border-neutral-600 focus:ring-blue-500"
              />
              <div>
                <div className="font-medium" style={{ color: "var(--text)" }}>
                  {flag} {label}
                </div>
              </div>
            </label>
          ))}
        </div>
      </div>

      {/* Display Name */}
      <div>
        <label
          className="block text-sm font-medium mb-2"
          style={{ color: "var(--text)" }}
        >
          {translations.username}
        </label>
        <div className="flex gap-2">
          <input
            type="text"
            value={displayName}
            onChange={(e) => handleDisplayNameChange(e.target.value)}
            className="flex-1 px-3 py-2 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
            style={{
              backgroundColor: "var(--card)",
              borderColor: "var(--line)",
              color: "var(--text)",
              border: "1px solid",
            }}
            placeholder={translations.username}
          />
          {showWarning && (
            <button
              onClick={saveDisplayName}
              className="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-lg text-sm transition-colors"
            >
              {translations.save}
            </button>
          )}
        </div>
        {showWarning && (
          <p className="mt-1 text-sm text-yellow-400">
            ‚ö†Ô∏è Changing your display name will update your profile
          </p>
        )}
      </div>

      {/* My Statistics */}
      <div>
        <h4
          className="text-lg font-medium mb-3"
          style={{ color: "var(--text)" }}
        >
          {translations.myStatistics}
        </h4>
        <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
          <div
            className="p-4 rounded-lg"
            style={{ backgroundColor: "var(--card)" }}
          >
            <h5
              className="text-sm font-medium mb-2"
              style={{ color: "var(--text)" }}
            >
              {translations.tvShows}
            </h5>
            <div
              className="space-y-1 text-sm"
              style={{ color: "var(--muted)" }}
            >
              <div>
                {translations.currentlyWatching}: {tvStats.watching}
              </div>
              <div>
                {translations.wantToWatch}: {tvStats.wishlist}
              </div>
              <div>
                {translations.watched}: {tvStats.watched}
              </div>
              <div>
                {translations.notInterested}: {tvStats.not}
              </div>
            </div>
          </div>
          <div
            className="p-4 rounded-lg"
            style={{ backgroundColor: "var(--card)" }}
          >
            <h5
              className="text-sm font-medium mb-2"
              style={{ color: "var(--text)" }}
            >
              {translations.movies}
            </h5>
            <div
              className="space-y-1 text-sm"
              style={{ color: "var(--muted)" }}
            >
              <div>
                {translations.currentlyWatching}: {movieStats.watching}
              </div>
              <div>
                {translations.wantToWatch}: {movieStats.wishlist}
              </div>
              <div>
                {translations.watched}: {movieStats.watched}
              </div>
              <div>
                {translations.notInterested}: {movieStats.not}
              </div>
            </div>
          </div>
        </div>
      </div>

      {/* Not Interested Management */}
      <div>
        <h4
          className="text-lg font-medium mb-3"
          style={{ color: "var(--text)" }}
        >
          {translations.notInterestedManagement}
        </h4>
        <button
          className="px-4 py-2 rounded-lg transition-colors"
          style={{ backgroundColor: "var(--btn)", color: "var(--text)" }}
          onClick={onShowNotInterestedModal}
        >
          {translations.manageNotInterestedList}
        </button>
      </div>

      {/* Personality Level */}
      <div>
        <label
          className="block text-sm font-medium mb-2"
          style={{ color: "var(--text)" }}
        >
          {translations.personalityLevel}
        </label>
        <div className="space-y-2">
          {[
            {
              level: 1 as PersonalityLevel,
              label: translations.regular,
              description: translations.friendlyAndHelpful,
            },
            {
              level: 2 as PersonalityLevel,
              label: translations.semiSarcastic,
              description: translations.aBitCheeky,
            },
            {
              level: 3 as PersonalityLevel,
              label: translations.severelySarcastic,
              description: translations.maximumSass,
            },
          ].map(({ level, label, description }) => (
            <label
              key={level}
              className="flex items-center space-x-3 cursor-pointer"
            >
              <input
                type="radio"
                name="personality"
                value={level}
                checked={settings.personalityLevel === level}
                onChange={() => settingsManager.updatePersonalityLevel(level)}
                className="w-4 h-4 text-blue-600 bg-neutral-800 border-neutral-600 focus:ring-blue-500"
              />
              <div>
                <div className="font-medium" style={{ color: "var(--text)" }}>
                  {label}
                </div>
                <div className="text-sm" style={{ color: "var(--muted)" }}>
                  {description}
                </div>
              </div>
            </label>
          ))}
        </div>
        <div
          className="mt-2 p-3 rounded-lg"
          style={{ backgroundColor: "var(--card)" }}
        >
          <p className="text-sm" style={{ color: "var(--text)" }}>
            {translations.preview}:{" "}
            {getPersonalityText("welcome", settings.personalityLevel)}
          </p>
        </div>
        <div className="mt-4">
          <PersonalityExamples personalityLevel={settings.personalityLevel} />
        </div>
      </div>

      {/* Reset to Defaults */}
      <div>
        <button
          onClick={() => {
            if (window.confirm(translations.confirmResetSettings)) {
              settingsManager.resetToDefaults();
            }
          }}
          className="px-4 py-2 bg-red-600 hover:bg-red-700 text-white rounded-lg transition-colors"
        >
          {translations.resetSettingsToDefaults}
        </button>
      </div>
    </div>
  );
}

function NotificationsSection({
  onShowNotificationSettings,
  onShowNotificationCenter,
}: SettingsSectionProps) {
  const [showNotificationSettings, setShowNotificationSettings] = useState(false);
  const [showNotificationCenter, setShowNotificationCenter] = useState(false);
  const proStatus = useProStatus();
  const isProUser = proStatus.isPro;
  const translations = useTranslations();

  const handleOpenSettings = () => {
    if (onShowNotificationSettings) {
      onShowNotificationSettings();
    } else {
      setShowNotificationSettings(true);
    }
  };

  const handleOpenCenter = () => {
    if (onShowNotificationCenter) {
      onShowNotificationCenter();
    } else {
      setShowNotificationCenter(true);
    }
  };

  return (
    <>
      <div className="space-y-6">
        <h3 className="text-xl font-semibold" style={{ color: "var(--text)" }}>
          {translations.notifications}
        </h3>

        {/* Quick Actions */}
        <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
          <button
            onClick={handleOpenSettings}
            className="p-4 rounded-lg border transition-colors hover:opacity-80"
            style={{
              backgroundColor: "var(--card)",
              borderColor: "var(--line)",
              color: "var(--text)",
            }}
          >
            <div className="flex items-center space-x-3">
              <div className="text-2xl">‚öôÔ∏è</div>
              <div className="text-left">
                <div className="font-medium">{translations.notificationSettings}</div>
                <div className="text-sm" style={{ color: "var(--muted)" }}>
                  {translations.notificationSettingsDescription}
                </div>
              </div>
            </div>
          </button>

          <button
            onClick={handleOpenCenter}
            className="p-4 rounded-lg border transition-colors hover:opacity-80"
            style={{
              backgroundColor: "var(--card)",
              borderColor: "var(--line)",
              color: "var(--text)",
            }}
          >
            <div className="flex items-center space-x-3">
              <div className="text-2xl">üìã</div>
              <div className="text-left">
                <div className="font-medium">{translations.notificationCenter}</div>
                <div className="text-sm" style={{ color: "var(--muted)" }}>
                  {translations.notificationCenterDescription}
                </div>
              </div>
            </div>
          </button>
        </div>


        {/* Current Settings Summary */}
        <div
          className="p-4 rounded-lg"
          style={{
            backgroundColor: "var(--card)",
            borderColor: "var(--line)",
            border: "1px solid",
          }}
        >
          <h4
            className="text-lg font-medium mb-3"
            style={{ color: "var(--text)" }}
          >
            {translations.currentSettings}
          </h4>
          <div className="space-y-2 text-sm">
            <div className="flex justify-between">
              <span style={{ color: "var(--muted)" }}>
                {translations.episodeReminders}:
              </span>
              <span style={{ color: "var(--text)" }}>{translations.enabled}</span>
            </div>
            <div className="flex justify-between">
              <span style={{ color: "var(--muted)" }}>
                {translations.notificationTiming}:
              </span>
              <span style={{ color: "var(--text)" }}>
                {isProUser
                  ? translations.timingCustomPro
                  : translations.timing24HoursBefore}
              </span>
            </div>
            <div className="flex justify-between">
              <span style={{ color: "var(--muted)" }}>
                {translations.notificationMethods}:
              </span>
              <span style={{ color: "var(--text)" }}>
                {isProUser
                  ? translations.methodsInAppPushEmail
                  : translations.methodsInAppPush}
              </span>
            </div>
          </div>
        </div>

        {/* Pro Upgrade Banner - Small note only */}
        <UpgradeToProCTA variant="banner" />
      </div>

      {/* Modals */}
      {showNotificationSettings && (
        <Suspense fallback={<div>Loading...</div>}>
          <NotificationSettings
            isOpen={showNotificationSettings}
            onClose={() => setShowNotificationSettings(false)}
          />
        </Suspense>
      )}
      {showNotificationCenter && (
        <Suspense fallback={<div>Loading...</div>}>
          <NotificationCenter
            isOpen={showNotificationCenter}
            onClose={() => setShowNotificationCenter(false)}
          />
        </Suspense>
      )}
    </>
  );
}

function CommunitySection({ isMobile: _isMobile }: SettingsSectionProps) {
  const { isAuthenticated, user } = useAuth();
  const [emailSubscribed, setEmailSubscribed] = useState<boolean | null>(null);
  const [updatingEmailSub, setUpdatingEmailSub] = useState(false);
  const settings = useSettings();

  useEffect(() => {
    if (isAuthenticated && user) {
      fetchEmailSubscriptionStatus();
    }
  }, [isAuthenticated, user]);

  const fetchEmailSubscriptionStatus = async () => {
    try {
      const { doc, getDoc } = await import("firebase/firestore");
      const { db } = await import("../lib/firebaseBootstrap");
      const userRef = doc(db, "users", user!.uid);
      const userSnap = await getDoc(userRef);
      if (userSnap.exists()) {
        const data = userSnap.data();
        setEmailSubscribed(data.emailSubscriber === true);
      } else {
        setEmailSubscribed(false);
      }
    } catch (err) {
      console.error("Failed to fetch email subscription status:", err);
      setEmailSubscribed(false);
    }
  };

  const handleEmailSubscriptionToggle = async (enabled: boolean) => {
    if (!isAuthenticated || !user || updatingEmailSub) return;

    setUpdatingEmailSub(true);
    try {
      const { doc, updateDoc } = await import("firebase/firestore");
      const { db } = await import("../lib/firebaseBootstrap");
      const userRef = doc(db, "users", user.uid);
      await updateDoc(userRef, {
        emailSubscriber: enabled,
      });
      setEmailSubscribed(enabled);
    } catch (err) {
      console.error("Failed to update email subscription:", err);
      alert("Failed to update email subscription. Please try again.");
    } finally {
      setUpdatingEmailSub(false);
    }
  };

  return (
    <div className="space-y-6">
      <h3 className="text-xl font-semibold" style={{ color: "var(--text)" }}>
        Community
      </h3>

      {/* Weekly Email Digest */}
      {isAuthenticated && (
        <div
          className="p-4 rounded-lg"
          style={{
            backgroundColor: "var(--card)",
            borderColor: "var(--line)",
            border: "1px solid",
          }}
        >
          <div className="flex items-center justify-between">
            <div className="flex-1">
              <h4
                className="text-lg font-medium mb-1"
                style={{ color: "var(--text)" }}
              >
                üìß Weekly Email Digest
              </h4>
              <p className="text-sm mb-3" style={{ color: "var(--muted)" }}>
                Receive a weekly email with top posts, new comments, and
                mentions from the community hub.
              </p>
            </div>
            <label className="relative inline-flex items-center cursor-pointer">
              <input
                type="checkbox"
                checked={emailSubscribed === true}
                onChange={(e) =>
                  handleEmailSubscriptionToggle(e.target.checked)
                }
                disabled={updatingEmailSub || emailSubscribed === null}
                className="sr-only peer"
              />
              <div className="w-11 h-6 bg-gray-600 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-blue-800 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600"></div>
            </label>
          </div>
          {emailSubscribed === null && (
            <p className="text-xs mt-2" style={{ color: "var(--muted)" }}>
              Loading...
            </p>
          )}
          {emailSubscribed === true && (
            <p className="text-xs mt-2" style={{ color: "var(--muted)" }}>
              ‚úì You'll receive weekly emails every Friday at 9 AM UTC
            </p>
          )}
        </div>
      )}

      {/* Topic Following - Placeholder for future settings */}
      <div
        className="p-4 rounded-lg"
        style={{
          backgroundColor: "var(--card)",
          borderColor: "var(--line)",
          border: "1px solid",
        }}
      >
        <h4
          className="text-lg font-medium mb-1"
          style={{ color: "var(--text)" }}
        >
          üìå Topic Following
        </h4>
        <p className="text-sm" style={{ color: "var(--muted)" }}>
          Manage your followed topics in the Community Hub. Follow topics to
          prioritize posts in your feed.
        </p>
        <p className="text-xs mt-2 italic" style={{ color: "var(--muted)" }}>
          Currently managed in the Community Hub interface
        </p>
      </div>

      {/* Community Stats - Placeholder for future stats */}
      {settings.community.followedTopics.length > 0 && (
        <div
          className="p-4 rounded-lg"
          style={{
            backgroundColor: "var(--card)",
            borderColor: "var(--line)",
            border: "1px solid",
          }}
        >
          <h4
            className="text-lg font-medium mb-2"
            style={{ color: "var(--text)" }}
          >
            Community Activity
          </h4>
          <div className="text-sm" style={{ color: "var(--muted)" }}>
            <div>Following {settings.community.followedTopics.length} topic{settings.community.followedTopics.length !== 1 ? 's' : ''}</div>
          </div>
        </div>
      )}
    </div>
  );
}

function DisplaySection({ isMobile: _isMobile }: SettingsSectionProps) {
  const settings = useSettings();
  const translations = useTranslations();
  const { isPro } = useProStatus();
  const userLists = useCustomLists();
  const [editingListId, setEditingListId] = useState<string | null>(null);
  const [editName, setEditName] = useState("");
  const [editDescription, setEditDescription] = useState("");

  const handleCreateList = () => {
    const name = prompt(translations.enterListName || "Enter list name:");
    if (!name?.trim()) return;

    try {
      customListManager.createList(name.trim());
    } catch (error) {
      alert(error instanceof Error ? error.message : translations.failedToCreateList);
    }
  };

  const handleEditList = (listId: string) => {
    const list = customListManager.getListById(listId);
    if (!list) return;

    setEditingListId(listId);
    setEditName(list.name);
    setEditDescription(list.description || "");
  };

  const handleSaveEdit = () => {
    if (!editingListId || !editName.trim()) return;

    try {
      customListManager.updateList(editingListId, {
        name: editName.trim(),
        description: editDescription.trim() || undefined,
      });
      setEditingListId(null);
      setEditName("");
      setEditDescription("");
    } catch (error) {
      alert(error instanceof Error ? error.message : translations.failedToUpdateList);
    }
  };

  const handleCancelEdit = () => {
    setEditingListId(null);
    setEditName("");
    setEditDescription("");
  };

  const handleDeleteList = (listId: string) => {
    try {
      const list = customListManager.getListById(listId);
      if (!list) {
        alert(translations.listNotFound);
        return;
      }

      const confirmed = window.confirm(
        `${translations.confirmDeleteList || "Are you sure you want to delete"} "${list.name}"? ${translations.thisActionCannotBeUndone || "This action cannot be undone."}`
      );

      if (confirmed) {
        customListManager.deleteList(listId);
      }
      } catch (error) {
      alert(error instanceof Error ? error.message : translations.failedToDeleteList);
    }
  };

  const handleSetDefault = (listId: string) => {
    try {
      customListManager.setSelectedList(listId);
    } catch (error) {
      alert(
        error instanceof Error ? error.message : translations.failedToSetDefaultList
      );
    }
  };

  return (
    <div className="space-y-6">
      <h3 className="text-xl font-semibold" style={{ color: "var(--text)" }}>
        {translations.displayAndLayout}
      </h3>

      {/* Theme Preference */}
      <div>
        <label
          className="block text-sm font-medium mb-2"
          style={{ color: "var(--text)" }}
        >
          {translations.themePreference}
        </label>
        <div className="space-y-2">
          {[
            {
              theme: "dark" as const,
              label: translations.dark,
              description: translations.darkThemeDescription,
            },
            {
              theme: "light" as const,
              label: translations.light,
              description: translations.lightThemeDescription,
            },
          ].map(({ theme, label, description }) => (
            <label
              key={theme}
              className="flex items-center space-x-3 cursor-pointer"
            >
              <input
                type="radio"
                name="theme"
                value={theme}
                checked={settings.layout.theme === theme}
                onChange={() => settingsManager.updateTheme(theme)}
                className="w-4 h-4 text-blue-600 bg-neutral-800 border-neutral-600 focus:ring-blue-500"
              />
              <div>
                <div className="font-medium" style={{ color: "var(--text)" }}>
                  {label}
                </div>
                <div className="text-sm" style={{ color: "var(--muted)" }}>
                  {description}
                </div>
              </div>
            </label>
          ))}
        </div>
      </div>

      {/* Discovery Limit */}
      <div>
        <label
          className="block text-sm font-medium mb-2"
          style={{ color: "var(--text)" }}
        >
          {translations.discoveryRecommendations}
        </label>
        <div className="space-y-2">
          <p className="text-sm" style={{ color: "var(--muted)" }}>
            {translations.discoveryRecommendationsDescription}
          </p>
          <div className="flex gap-2 flex-wrap">
            {[25, 50, 75, 100].map((limit) => (
              <label
                key={limit}
                className="flex items-center space-x-2 cursor-pointer px-4 py-2 rounded-lg transition-colors"
                style={{
                  backgroundColor:
                    settings.layout.discoveryLimit === limit
                      ? "var(--accent)"
                      : "var(--btn)",
                  color:
                    settings.layout.discoveryLimit === limit
                      ? "white"
                      : "var(--text)",
                  border: "1px solid",
                  borderColor:
                    settings.layout.discoveryLimit === limit
                      ? "var(--accent)"
                      : "var(--line)",
                }}
              >
                <input
                  type="radio"
                  name="discoveryLimit"
                  value={limit}
                  checked={settings.layout.discoveryLimit === limit}
                  onChange={() =>
                    settingsManager.updateDiscoveryLimit(
                      limit as 25 | 50 | 75 | 100
                    )
                  }
                  className="w-4 h-4 text-blue-600 bg-neutral-800 border-neutral-600 focus:ring-blue-500"
                />
                <span className="font-medium">{limit}</span>
              </label>
            ))}
          </div>
        </div>
      </div>

      {/* My Lists Management */}
      <div>
        <div className="flex items-center justify-between mb-3">
          <h4 className="text-lg font-medium" style={{ color: "var(--text)" }}>
            {translations.myLists}
          </h4>
          {userLists.customLists.length < userLists.maxLists && (
              <button
                onClick={handleCreateList}
                className="px-3 py-1.5 rounded-lg text-sm transition-colors"
                style={{ backgroundColor: "var(--accent)", color: "white" }}
              >
                {translations.createNewList}
              </button>
          )}
        </div>

        <div className="space-y-3">
          {userLists.customLists.map((list) => (
            <div
              key={list.id}
              className="p-4 rounded-lg"
              style={{
                backgroundColor: "var(--card)",
                borderColor: "var(--line)",
                border: "1px solid",
              }}
            >
              {editingListId === list.id ? (
                <div className="space-y-3">
                  <input
                    type="text"
                    value={editName}
                    onChange={(e) => setEditName(e.target.value)}
                    className="w-full px-3 py-2 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                    style={{
                      backgroundColor: "var(--btn)",
                      borderColor: "var(--line)",
                      color: "var(--text)",
                      border: "1px solid",
                    }}
                    placeholder={translations.listName}
                  />
                  <input
                    type="text"
                    value={editDescription}
                    onChange={(e) => setEditDescription(e.target.value)}
                    className="w-full px-3 py-2 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                    style={{
                      backgroundColor: "var(--btn)",
                      borderColor: "var(--line)",
                      color: "var(--text)",
                      border: "1px solid",
                    }}
                    placeholder={translations.listDescriptionOptional}
                  />
                  <div className="flex gap-2">
                    <button
                      onClick={handleSaveEdit}
                      className="px-3 py-1.5 rounded-lg text-sm transition-colors"
                      style={{
                        backgroundColor: "var(--accent)",
                        color: "white",
                      }}
                    >
                      {translations.save || "Save"}
                    </button>
                    <button
                      onClick={handleCancelEdit}
                      className="px-3 py-1.5 rounded-lg text-sm transition-colors"
                      style={{
                        backgroundColor: "var(--btn)",
                        color: "var(--text)",
                        borderColor: "var(--line)",
                        border: "1px solid",
                      }}
                    >
                      {translations.cancel || "Cancel"}
                    </button>
                  </div>
                </div>
              ) : (
                <div className="flex items-center justify-between">
                  <div className="flex-1">
                    <div className="flex items-center gap-2">
                      <h5
                        className="font-medium"
                        style={{ color: "var(--text)" }}
                      >
                        {list.name}
                      </h5>
                      {list.isDefault && (
                        <span
                          className="px-2 py-0.5 rounded text-xs"
                          style={{
                            backgroundColor: "var(--accent)",
                            color: "white",
                          }}
                        >
                          {translations.default || "Default"}
                        </span>
                      )}
                    </div>
                    {list.description && (
                      <p
                        className="text-sm mt-1"
                        style={{ color: "var(--muted)" }}
                      >
                        {list.description}
                      </p>
                    )}
                    <p
                      className="text-xs mt-1"
                      style={{ color: "var(--muted)" }}
                    >
                      {list.itemCount} {translations.items}
                    </p>
                  </div>
                  <div className="flex gap-1">
                    <button
                      onClick={() => handleEditList(list.id)}
                      className="px-2 py-1 rounded text-xs transition-colors"
                      style={{
                        backgroundColor: "var(--btn)",
                        color: "var(--text)",
                      }}
                      title={translations.edit || "Edit"}
                    >
                      ‚úèÔ∏è
                    </button>
                    {!list.isDefault && (
                      <button
                        onClick={() => handleSetDefault(list.id)}
                        className="px-2 py-1 rounded text-xs transition-colors"
                        style={{
                          backgroundColor: "var(--btn)",
                          color: "var(--text)",
                        }}
                        title={translations.setAsDefault || "Set as Default"}
                      >
                        ‚≠ê
                      </button>
                    )}
                    <button
                      onClick={() => handleDeleteList(list.id)}
                      className="px-2 py-1 rounded text-xs transition-colors"
                      style={{
                        backgroundColor: "var(--btn)",
                        color: "var(--text)",
                      }}
                      title={translations.delete || "Delete"}
                    >
                      üóëÔ∏è
                    </button>
                  </div>
                </div>
              )}
            </div>
          ))}

          {userLists.customLists.length === 0 && (
            <div className="text-center py-8">
              <p className="text-sm mb-4" style={{ color: "var(--muted)" }}>
                {translations.noListsCreated}
              </p>
              <button
                onClick={handleCreateList}
                className="px-4 py-2 rounded-lg transition-colors"
                style={{ backgroundColor: "var(--accent)", color: "white" }}
              >
                {translations.createYourFirstList}
              </button>
            </div>
          )}
        </div>

        <div className="mt-3 text-xs" style={{ color: "var(--muted)" }}>
          {translations.listsUsed}:{" "}
          {userLists.customLists.length}/{userLists.maxLists}
        </div>
      </div>

      {/* Other Layout Settings */}
      <div>
        <h4
          className="text-lg font-medium mb-3"
          style={{ color: "var(--text)" }}
        >
          {translations.otherLayoutSettings}
        </h4>
        <div className="space-y-3">
          <div className="space-y-1">
            <label className="flex items-center space-x-3 cursor-pointer">
              <input
                type="checkbox"
                checked={settings.layout.condensedView}
                onChange={(e) =>
                  settingsManager.updateSettings({
                    layout: {
                      ...settings.layout,
                      condensedView: e.target.checked,
                    },
                  })
                }
                className="w-4 h-4 text-blue-600 bg-neutral-800 border-neutral-600 rounded focus:ring-blue-500"
              />
              <span style={{ color: "var(--text)" }}>
                {translations.condensedView}
              </span>
            </label>
            <p className="text-xs ml-7" style={{ color: "var(--muted)" }}>
              {translations.condensedViewDescription}
            </p>
          </div>

          <div className="space-y-1">
            <label
              className={`flex items-center space-x-3 ${settings.layout.condensedView && !isPro ? "cursor-not-allowed opacity-50" : "cursor-pointer"}`}
            >
              <input
                type="checkbox"
                checked={settings.layout.episodeTracking}
                onChange={() => settingsManager.toggleEpisodeTracking()}
                disabled={settings.layout.condensedView && !isPro}
                className="w-4 h-4 text-blue-600 bg-neutral-800 border-neutral-600 rounded focus:ring-blue-500"
              />
              <span style={{ color: "var(--text)" }}>
                {translations.enableEpisodeTracking}
              </span>
            </label>
            {settings.layout.condensedView && !isPro && (
              <p className="text-xs ml-7" style={{ color: "var(--muted)" }}>
                {translations.episodeTrackingCondensedProRequired}{" "}
                <UpgradeToProCTA variant="inline" />
              </p>
            )}
            {settings.layout.condensedView && isPro && (
              <p className="text-xs ml-7" style={{ color: "var(--muted)" }}>
                {translations.episodeTrackingCondensedProAllowed}
              </p>
            )}
          </div>
        </div>
      </div>

      {/* For You Section Configuration */}
      <div>
        <h4
          className="text-lg font-medium mb-3"
          style={{ color: "var(--text)" }}
        >
          {translations.forYouSectionConfiguration}
        </h4>
        <p className="text-sm mb-4" style={{ color: "var(--muted)" }}>
          {translations.forYouSectionDescription}
        </p>

        <ForYouGenreConfig />
      </div>

      {/* Pro Features - Theme Packs */}
      {/* Pro gating: Theme packs are Pro-only (future feature) */}
      {/* Config: settings.pro.features.themePacks, settingsProConfig.ts - PRO_FEATURES_COMING_SOON */}
      {settings.pro.isPro && (
        <div>
          <h4
            className="text-lg font-medium mb-3"
            style={{ color: "var(--text)" }}
          >
            {translations.proFeatures}
          </h4>
          <p style={{ color: "var(--muted)" }}>
            {translations.themePacksComingSoon}
          </p>
        </div>
      )}
    </div>
  );
}

function ProSection({ isMobile: _isMobile }: SettingsSectionProps) {
  const proStatus = useProStatus();
  const isProUser = proStatus.isPro;
  const { isAdmin } = useAdminRole();

  return (
    <div className="space-y-6">
      {/* Pro Status */}
      <div
        className="text-center p-6 rounded-lg"
        style={{ backgroundColor: "var(--btn)" }}
      >
        <div className="text-4xl mb-3">üíé</div>
        <h3
          className="text-xl font-semibold mb-2"
          style={{ color: "var(--text)" }}
        >
          {isProUser ? "You are a Pro User!" : "Upgrade to Flicklet Pro"}
        </h3>
        <p className="text-sm mb-4" style={{ color: "var(--muted)" }}>
          {isProUser
            ? "Thank you for supporting Flicklet! Enjoy all Pro features."
            : "Unlock advanced features and premium content to enhance your TV and movie tracking experience."}
        </p>
        {!isProUser && (
          <UpgradeToProCTA variant="button" />
        )}
      </div>

      {/* Alpha/Testing Toggle - Admin only */}
      {isAdmin && (
        <div
          className="p-4 rounded-lg border"
          style={{ backgroundColor: "var(--bg)", borderColor: "var(--line)" }}
        >
          <div className="flex items-center justify-between">
            <div className="flex-1">
              <h4
                className="text-sm font-medium mb-1"
                style={{ color: "var(--text)" }}
              >
                Treat this device as Pro (Alpha / Testing)
              </h4>
              <p className="text-xs" style={{ color: "var(--muted)" }}>
                This is for testing only and is not a real purchase. Toggle this
                to test Pro features.
              </p>
            </div>
            <label className="relative inline-flex items-center cursor-pointer ml-4">
              <input
                type="checkbox"
                checked={isProUser}
                onChange={(e) => {
                  settingsManager.updateProStatus(e.target.checked);
                }}
                className="sr-only peer"
              />
              <div
                className="w-11 h-6 rounded-full peer transition-colors"
                style={{
                  backgroundColor: isProUser ? "var(--accent)" : "var(--line)",
                }}
              >
                <div
                  className="w-5 h-5 rounded-full transition-transform peer-checked:translate-x-5"
                  style={{
                    backgroundColor: "#fff",
                    transform: isProUser
                      ? "translateX(1.25rem)"
                      : "translateX(0.125rem)",
                    marginTop: "0.125rem",
                  }}
                />
              </div>
            </label>
          </div>
        </div>
      )}

      {/* Pro Features */}
      <div>
        <h4
          className="text-lg font-medium mb-4"
          style={{ color: "var(--text)" }}
        >
          Pro Features
        </h4>

        <div className="mb-6">
          <h5
            className="text-sm font-medium mb-3"
            style={{ color: "var(--text)" }}
          >
            Available Now
          </h5>

          <div className="space-y-4">
            {PRO_FEATURES_AVAILABLE.map((feature) => (
              <div
                key={feature.id}
                className="p-4 rounded-lg border"
                style={{
                  backgroundColor: "var(--bg)",
                  borderColor: "var(--line)",
                }}
              >
                <div className="flex items-start gap-3">
                  <div className="text-2xl">{feature.icon}</div>
                  <div className="flex-1">
                    <h5
                      className="font-medium mb-1"
                      style={{ color: "var(--text)" }}
                    >
                      {feature.title}
                    </h5>
                    <p className="text-sm mb-2" style={{ color: "var(--muted)" }}>
                      {feature.description}
                    </p>
                    <div className="flex items-center gap-2">
                      <span
                        className="px-2 py-1 text-xs rounded-full"
                        style={{
                          backgroundColor: "var(--accent)",
                          color: "white",
                        }}
                      >
                        PRO
                      </span>
                      <span className="text-xs" style={{ color: "var(--muted)" }}>
                        Available Now
                      </span>
                    </div>
                  </div>
                </div>
              </div>
            ))}
          </div>
        </div>

        {/* Coming Soon Section */}
        {PRO_FEATURES_COMING_SOON.length > 0 && (
          <div className="mt-8">
            <h5
              className="text-sm font-medium mb-3"
              style={{ color: "var(--text)" }}
            >
              Coming Soon
            </h5>
            <div className="space-y-4">
              {PRO_FEATURES_COMING_SOON.map((feature) => (
                <div
                  key={feature.id}
                  className="p-4 rounded-lg border"
                  style={{
                    backgroundColor: "var(--bg)",
                    borderColor: "var(--line)",
                  }}
                >
                  <div className="flex items-start gap-3">
                    <div className="text-2xl">{feature.icon}</div>
                    <div className="flex-1">
                      <h5
                        className="font-medium mb-1"
                        style={{ color: "var(--text)" }}
                      >
                        {feature.title}
                      </h5>
                      <p className="text-sm mb-2" style={{ color: "var(--muted)" }}>
                        {feature.description}
                      </p>
                      <div className="flex items-center gap-2">
                        <span
                          className="px-2 py-1 text-xs rounded-full"
                          style={{
                            backgroundColor: "var(--accent)",
                            color: "white",
                          }}
                        >
                          PRO
                        </span>
                        <span className="text-xs" style={{ color: "var(--muted)" }}>
                          Coming Soon
                        </span>
                      </div>
                    </div>
                  </div>
                </div>
              ))}
            </div>
          </div>
        )}
      </div>
    </div>
  );
}

function DataSection({ onShowSharingModal }: SettingsSectionProps) {
  /**
   * Process: User Data Backup & Restore
   * Purpose: Manual, local-only backup/restore plus share-entry surface in Settings
   * Data Source: localStorage keys prefixed with flicklet.*
   * Update Path: DataSection in settingsSections.tsx
   * Dependencies: Library storage helpers, Sharing modal flow
   */
  const [showSharingModal, setShowSharingModal] = useState(false);

  const handleBackup = async () => {
    try {
      const libraryData = JSON.parse(
        localStorage.getItem("flicklet.library.v2") || "{}"
      );

      const watchlists = {
        movies: {
          watching: [] as any[],
          wishlist: [] as any[],
          watched: [] as any[],
        },
        tv: {
          watching: [] as any[],
          wishlist: [] as any[],
          watched: [] as any[],
        },
        customLists: [] as any[],
        customItems: {} as Record<string, any[]>,
      };

      Object.values(libraryData).forEach((item: any) => {
        const mediaItem = {
          id: item.id,
          mediaType: item.mediaType,
          title: item.title || "Untitled",
          year: item.year,
          posterUrl: item.posterUrl,
          voteAverage: item.voteAverage,
          userRating: item.userRating,
          runtimeMins: item.runtimeMins,
          synopsis: item.synopsis,
          nextAirDate: item.nextAirDate,
          showStatus: item.showStatus,
          lastAirDate: item.lastAirDate,
          userNotes: item.userNotes,
          tags: item.tags,
          networks: item.networks,
          productionCompanies: item.productionCompanies,
        };

        if (item.list?.startsWith("custom:")) {
          const customListId = item.list.replace("custom:", "");
          if (!watchlists.customItems[customListId]) {
            watchlists.customItems[customListId] = [];
          }
          watchlists.customItems[customListId].push(mediaItem);
        } else if (
          item.list &&
          ["watching", "wishlist", "watched"].includes(item.list)
        ) {
          if (
            item.mediaType === "movie" &&
            watchlists.movies[item.list as keyof typeof watchlists.movies]
          ) {
            (
              watchlists.movies[
                item.list as keyof typeof watchlists.movies
              ] as any[]
            ).push(mediaItem);
          } else if (
            item.mediaType === "tv" &&
            watchlists.tv[item.list as keyof typeof watchlists.tv]
          ) {
            (
              watchlists.tv[
                item.list as keyof typeof watchlists.tv
              ] as any[]
            ).push(mediaItem);
          }
        }
      });

      const customListsData = localStorage.getItem("flicklet.customLists.v2");
      if (customListsData) {
        try {
          const customLists = JSON.parse(customListsData);
          watchlists.customLists = customLists.customLists || [];
        } catch (error) {
          console.warn("Failed to parse custom lists:", error);
        }
      }

      const settings = JSON.parse(
        localStorage.getItem("flicklet-settings") || "{}"
      );
      const user = JSON.parse(localStorage.getItem("flicklet-user") || "{}");

      const userData = {
        watchlists,
        settings,
        user,
        timestamp: new Date().toISOString(),
        version: "2.0",
      };

      const dataStr = JSON.stringify(userData, null, 2);
      const dataBlob = new Blob([dataStr], { type: "application/json" });
      const url = URL.createObjectURL(dataBlob);

      const link = document.createElement("a");
      link.href = url;
      link.download = `flicklet-backup-${new Date()
        .toISOString()
        .split("T")[0]}.json`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);

      alert("‚úÖ Backup downloaded successfully!");
    } catch (error) {
      console.error("Backup failed:", error);
      alert("‚ùå Backup failed. Please try again.");
    }
  };

  const handleRestore = () => {
    const input = document.createElement("input");
    input.type = "file";
    input.accept = ".json";
    input.onchange = async (e) => {
      const file = (e.target as HTMLInputElement).files?.[0];
      if (!file) return;

      let userData: any;
      try {
        const text = await file.text();
        userData = JSON.parse(text);
      } catch (error) {
        console.error("Restore failed to parse file:", error);
        alert(
          "‚ùå Restore failed: Unable to read the backup file. Please select a Flicklet backup."
        );
        return;
      }

      if (
        !userData?.watchlists ||
        typeof userData.watchlists !== "object" ||
        !(
          userData.watchlists.movies ||
          userData.watchlists.tv ||
          userData.watchlists.customLists
        )
      ) {
        alert(
          "‚ùå Restore failed: The backup file is missing watchlist data. Please choose a valid Flicklet backup."
        );
        return;
      }

      const backupDate = userData.timestamp
        ? new Date(userData.timestamp)
        : null;
      const formattedDate = backupDate
        ? backupDate.toLocaleString(undefined, {
            dateStyle: "medium",
            timeStyle: "short",
          })
        : "unknown date";
      const backupVersion = userData.version || "unknown version";
      const confirmed = window.confirm(
        `‚ö†Ô∏è This will overwrite ALL local data on this device with the backup from ${formattedDate} (version ${backupVersion}). This action cannot be undone. Continue?`
      );

      if (!confirmed) return;

      const safeSetItem = (key: string, value: string) => {
        try {
          localStorage.setItem(key, value);
          return true;
        } catch (error) {
          console.error(`Failed to write ${key}:`, error);
          return false;
        }
      };

      try {
        localStorage.removeItem("flicklet.library.v2");

        let restoredCount = 0;
        const { Library } = await import("../lib/storage");

        // Process movies
        if (userData.watchlists.movies) {
          const lists: Array<{ list: ListName; items: any[] }> = [
            {
              list: "watching",
              items: userData.watchlists.movies.watching || [],
            },
            {
              list: "wishlist",
              items: userData.watchlists.movies.wishlist || [],
            },
            {
              list: "watched",
              items: userData.watchlists.movies.watched || [],
            },
          ];

          lists.forEach(({ list, items }) => {
            items.forEach((item: any) => {
              if (item && item.id) {
                const mediaItem = {
                  id: item.id,
                  mediaType: "movie" as const,
                  title: item.title || item.name || "Untitled",
                  year: item.year,
                  posterUrl: item.posterUrl || item.poster_path,
                  voteAverage: item.voteAverage || item.vote_average,
                  userRating: item.userRating || item.user_rating,
                  runtimeMins: item.runtimeMins || item.runtime,
                  synopsis: item.synopsis || item.overview,
                  userNotes: item.userNotes || item.notes,
                  tags: item.tags || [],
                  productionCompanies: item.productionCompanies || [],
                };
                Library.upsert(mediaItem, list);
                restoredCount++;
              }
            });
          });
        }

        // Process TV shows
        if (userData.watchlists.tv) {
          const lists: Array<{ list: ListName; items: any[] }> = [
            {
              list: "watching",
              items: userData.watchlists.tv.watching || [],
            },
            {
              list: "wishlist",
              items: userData.watchlists.tv.wishlist || [],
            },
            {
              list: "watched",
              items: userData.watchlists.tv.watched || [],
            },
          ];

          lists.forEach(({ list, items }) => {
            items.forEach((item: any) => {
              if (item && item.id) {
                const mediaItem = {
                  id: item.id,
                  mediaType: "tv" as const,
                  title: item.title || item.name || "Untitled",
                  year: item.year || item.first_air_date?.substring(0, 4),
                  posterUrl: item.posterUrl || item.poster_path,
                  voteAverage: item.voteAverage || item.vote_average,
                  userRating: item.userRating || item.user_rating,
                  synopsis: item.synopsis || item.overview,
                  nextAirDate: item.nextAirDate,
                  showStatus: item.showStatus || item.status,
                  lastAirDate: item.lastAirDate || item.last_air_date,
                  userNotes: item.userNotes || item.notes,
                  tags: item.tags || [],
                  networks: item.networks || [],
                };
                Library.upsert(mediaItem, list);
                restoredCount++;
              }
            });
          });
        }

        // Restore custom lists
        if (
          userData.watchlists.customLists &&
          Array.isArray(userData.watchlists.customLists)
        ) {
          const customListsData = {
            customLists: userData.watchlists.customLists,
            selectedListId: userData.watchlists.selectedListId || null,
            maxLists: userData.watchlists.maxLists || 10,
          };
          if (
            !safeSetItem(
              "flicklet.customLists.v2",
              JSON.stringify(customListsData)
            )
          ) {
            throw new Error("Unable to restore custom lists.");
          }
        }

        if (
          userData.watchlists.customItems &&
          typeof userData.watchlists.customItems === "object"
        ) {
          Object.entries(userData.watchlists.customItems).forEach(
            ([listId, items]: [string, any]) => {
              if (Array.isArray(items)) {
                items.forEach((item: any) => {
                  if (item && item.id) {
                    const mediaItem = {
                      id: item.id,
                      mediaType: (item.mediaType || "movie") as "movie" | "tv",
                      title: item.title || item.name || "Untitled",
                      year: item.year,
                      posterUrl: item.posterUrl || item.poster_path,
                      voteAverage: item.voteAverage || item.vote_average,
                      userRating: item.userRating || item.user_rating,
                      synopsis: item.synopsis || item.overview,
                      userNotes: item.userNotes || item.notes,
                      tags: item.tags || [],
                    };
                    Library.upsert(mediaItem, `custom:${listId}` as ListName);
                    restoredCount++;
                  }
                });
              }
            }
          );
        }

        if (userData.settings) {
          if (
            !safeSetItem(
              "flicklet-settings",
              JSON.stringify(userData.settings)
            )
          ) {
            throw new Error("Unable to restore settings.");
          }
        }

        if (userData.user) {
          if (
            !safeSetItem("flicklet-user", JSON.stringify(userData.user))
          ) {
            throw new Error("Unable to restore user data.");
          }
        }

        alert(
          `‚úÖ Data restored from ${formattedDate} (version ${backupVersion}). A reload will ensure the restored data appears. ${restoredCount} items restored.`
        );

        setTimeout(() => {
          window.location.reload();
        }, 1000);
      } catch (error) {
        console.error("Restore failed:", error);
        alert(
          `‚ùå Restore failed: ${
            error instanceof Error ? error.message : "Unknown error"
          }. Please check the backup file and try again.`
        );
      }
    };
    input.click();
  };

  const handleSystemWipe = () => {
    try {
      const confirmed = confirm(
        "üö® NUCLEAR OPTION: This will permanently delete ALL your data including:\n\n" +
          "‚Ä¢ All watchlists (movies & TV)\n" +
          "‚Ä¢ All settings\n" +
          "‚Ä¢ All user preferences\n" +
          "‚Ä¢ Everything stored locally\n\n" +
          "This action CANNOT be undone. Are you absolutely sure?"
      );

      if (!confirmed) return;

      const doubleConfirmed = confirm(
        "‚ö†Ô∏è FINAL WARNING: This will completely wipe your Flicklet data.\n\n" +
          'Type "DELETE" in the next prompt to confirm.'
      );

      if (!doubleConfirmed) return;

      const finalCheck = prompt('Type "DELETE" to confirm system wipe:');

      if (finalCheck !== "DELETE") {
        alert(
          '‚ùå System wipe cancelled. You must type exactly "DELETE" to confirm.'
        );
        return;
      }

      const keys = Object.keys(localStorage).filter((key) =>
        key.startsWith("flicklet-")
      );
      keys.forEach((key) => localStorage.removeItem(key));

      const allKeys = Object.keys(localStorage);
      const flickletKeys = allKeys.filter(
        (key) =>
          key.toLowerCase().includes("flicklet") ||
          key.toLowerCase().includes("library") ||
          key.startsWith("flag:")
      );
      flickletKeys.forEach((key) => localStorage.removeItem(key));

      alert("üí• System wiped successfully! The page will refresh.");

      setTimeout(() => {
        window.location.reload();
      }, 1000);
    } catch (error) {
      console.error("System wipe failed:", error);
      alert(
        "‚ùå System wipe failed: " +
          (error instanceof Error ? error.message : String(error))
      );
    }
  };

  const handleShowSharing = () => {
    if (onShowSharingModal) {
      onShowSharingModal();
    } else {
      setShowSharingModal(true);
    }
  };

  return (
    <>
      <div className="space-y-6">
        <h3 className="text-xl font-semibold" style={{ color: "var(--text)" }}>
          Data & Backups
        </h3>

        {/* Share with Friends */}
        <div>
          <h4 className="text-lg font-medium mb-3" style={{ color: "var(--text)" }}>
            üì§ Share Your Lists
          </h4>
          <div className="space-y-3">
            <div
              className="p-4 rounded-lg"
              style={{
                backgroundColor: "var(--card)",
                borderColor: "var(--line)",
                border: "1px solid",
              }}
            >
              <h5 className="font-medium mb-2" style={{ color: "var(--text)" }}>
                Share your lists
              </h5>
              <p className="text-sm mb-3" style={{ color: "var(--muted)" }}>
                Generate a text snapshot of your lists that you can paste into messages or social posts.
              </p>
              <button
                onClick={handleShowSharing}
                className="px-3 py-2 rounded-lg text-sm font-medium transition-colors hover:opacity-90"
                style={{
                  backgroundColor: "var(--accent)",
                  color: "white",
                  border: "none",
                }}
              >
                üì§ Share your lists
              </button>
            </div>
          </div>
        </div>

        {/* Data Management */}
        <div>
          <h4 className="text-lg font-medium mb-3" style={{ color: "var(--text)" }}>
            üíæ Data Management
          </h4>
          <div className="space-y-3">
            {/* Backup */}
            <div
              className="p-4 rounded-lg"
              style={{
                backgroundColor: "var(--card)",
                borderColor: "var(--line)",
                border: "1px solid",
              }}
            >
              <h5 className="font-medium mb-2" style={{ color: "var(--text)" }}>
                üíæ Backup Data
              </h5>
              <p className="text-sm mb-3" style={{ color: "var(--muted)" }}>
                Download a local JSON file that includes your watchlists, custom lists, and settings. The file is saved to your device only and never uploaded to the cloud.
              </p>
              <button
                onClick={handleBackup}
                className="px-3 py-2 rounded-lg text-sm transition-colors"
                style={{ backgroundColor: "var(--accent)", color: "white" }}
              >
                üíæ Download Backup
              </button>
            </div>

            {/* Restore */}
            <div
              className="p-4 rounded-lg"
              style={{
                backgroundColor: "var(--card)",
                borderColor: "var(--line)",
                border: "1px solid",
              }}
            >
              <h5 className="font-medium mb-2" style={{ color: "var(--text)" }}>
                üì• Restore Data
              </h5>
              <p className="text-sm mb-3" style={{ color: "var(--muted)" }}>
                Upload a Flicklet backup file to overwrite data on this device only. This restores the library, lists, and settings from the chosen snapshot.
              </p>
              <button
                onClick={handleRestore}
                className="px-4 py-2 rounded-lg text-sm font-medium transition-colors hover:opacity-90"
                style={{ 
                  backgroundColor: "#10b981", 
                  color: "white",
                  border: "none",
                  cursor: "pointer"
                }}
              >
                üì• Restore from Backup
              </button>
            </div>

            {/* System Wipe */}
            <div
              className="p-4 rounded-lg"
              style={{
                backgroundColor: "var(--card)",
                borderColor: "var(--error)",
                border: "1px solid",
              }}
            >
              <h5 className="font-medium mb-2" style={{ color: "var(--error)" }}>
                üö® System Wipe
              </h5>
              <p className="text-sm mb-3" style={{ color: "var(--muted)" }}>
                Permanently delete ALL your data. This action cannot be undone.
              </p>
              <button
                onClick={handleSystemWipe}
                className="px-4 py-2 rounded-lg text-sm font-medium transition-colors hover:opacity-90"
                style={{ 
                  backgroundColor: "#ef4444", 
                  color: "white",
                  border: "none",
                  cursor: "pointer"
                }}
              >
                üö® Nuclear Option
              </button>
            </div>
          </div>
        </div>
      </div>

      {/* Sharing fallback for contexts without a global SharingModal */}
      {showSharingModal && !onShowSharingModal && (
        <div
          className="p-4 rounded-lg mt-4"
          style={{
            backgroundColor: "var(--card)",
            borderColor: "var(--line)",
            border: "1px solid",
          }}
        >
          <p className="text-sm" style={{ color: "var(--text)" }}>
            The sharing experience is managed by the parent view in this layout.
            Please open Settings from the main app to share your lists.
          </p>
          <button
            onClick={() => setShowSharingModal(false)}
            className="mt-3 px-3 py-1 text-xs font-medium rounded-lg transition-colors"
            style={{
              backgroundColor: "var(--btn)",
              color: "var(--text)",
            }}
          >
            Close
          </button>
        </div>
      )}
    </>
  );
}

function AboutSection(_props: SettingsSectionProps) {
  return (
    <div className="space-y-6">
      <h3 className="text-xl font-semibold" style={{ color: "var(--text)" }}>
        About
      </h3>

      <div
        className="space-y-4 text-sm leading-relaxed"
        style={{ color: "var(--text)" }}
      >
        <p>
          We're not here to reinvent the wheel ‚Äî we're here to make the wheel
          less squeaky. At Unique4U, our rule is simple: keep it simple. The
          world already has enough apps that feel like a second job to use. We'd
          rather give you tools that just‚Ä¶ work.
        </p>

        <p>
          Everything we build has its own personality, but they all live under
          one roof: a people-first, all-inclusive, slightly offbeat house we
          call Unique4U. If it's fun, useful, and a little different from the
          pack ‚Äî it belongs here.
        </p>
      </div>

      <div className="space-y-4">
        <h4 className="text-lg font-semibold" style={{ color: "var(--text)" }}>
          üë• About the Creators
        </h4>

        <div
          className="space-y-3 text-sm leading-relaxed"
          style={{ color: "var(--text)" }}
        >
          <p>
            We're Pam and Travis. Think of us as casual builders with a shared
            allergy to overcomplication. We make things because we need them,
            and we figure you probably do too.
          </p>

          <p>
            Pam once trained dolphins (true story) and also happens to be really
            good with numbers. Travis studied English and Philosophy, which
            means he can overthink and explain it in writing, then somehow turn
            that into practical business know-how. Together, we're like a
            mash-up of "creative meets operations" ‚Äî and that combo lets us
            build apps that are simple, useful, and not boring.
          </p>
        </div>
      </div>

      <div className="space-y-4">
        <h4 className="text-lg font-semibold" style={{ color: "var(--text)" }}>
          üì± About the App
        </h4>

        <div
          className="space-y-3 text-sm leading-relaxed"
          style={{ color: "var(--text)" }}
        >
          <p>
            Here's the deal: you want to remember what you're watching without
            needing a PhD in App Navigation. We built this because we got tired
            of two bad options ‚Äî messy notes on our phones or bloated apps that
            make you log your "episode 7 mid-season thoughts." (Hard pass.)
          </p>

          <p className="text-xs italic" style={{ color: "var(--muted)" }}>
            Data Attribution: This product uses the TMDB API but is not endorsed
            or certified by TMDB.
          </p>

          <p>So we made this instead:</p>

          <ul className="space-y-2 ml-4">
            <li className="flex items-start gap-2">
              <span className="mt-0.5">‚Ä¢</span>
              <span>
                <strong>Stupidly easy.</strong> Open it, add your show, done.
              </span>
            </li>
            <li className="flex items-start gap-2">
              <span className="mt-0.5">‚Ä¢</span>
              <span>
                <strong>Always free at the core.</strong> No paywalls for the
                basics.
              </span>
            </li>
            <li className="flex items-start gap-2">
              <span className="mt-0.5">‚Ä¢</span>
              <span>
                <strong>Friend-proof sharing.</strong> Copy your list and drop
                it in a text when someone asks, "What should I watch?"
              </span>
            </li>
          </ul>

          <p>
            If you watch TV or movies and don't want to make it a hobby just to
            track them, this app's for you. Simple lists, zero drama.
          </p>
        </div>
      </div>
    </div>
  );
}

function AdminSection(props: SettingsSectionProps) {
  const { isAdmin, loading } = useAdminRole();
  
  if (loading) {
    return <div>Loading admin...</div>;
  }
  
  if (!isAdmin) {
    return null;
  }
  
  return (
    <div className="w-full" style={{ minWidth: 0, maxWidth: "100%", overflow: "hidden", boxSizing: "border-box" }}>
      <Suspense fallback={<div>Loading admin...</div>}>
        <AdminExtrasPage isMobile={props.isMobile ?? false} />
      </Suspense>
    </div>
  );
}


```

## apps/web/src/lib/translations.ts
### Summary
Populates the English/Spanish string bundles referenced by rating/discovery components and settings.
### Content
```ts
import type { Language, LanguageStrings } from './language.types';

const TRANSLATIONS: Record<Language, LanguageStrings> = {
  en: {
    // Navigation
    home: 'Home',
    currentlyWatching: 'Currently Watching',
    wantToWatch: 'Want to Watch',
    watched: 'Watched',
    alreadyWatched: 'Already Watched',
    holidays: 'Holidays',
    discovery: 'Discovery',
    
    // Actions
    wantToWatchAction: 'Want to Watch',
    currentlyWatchingAction: 'Currently Watching',
    watchedAction: 'Watched',
    notInterestedAction: 'Not Interested',
    deleteAction: 'Delete',
    removeAction: 'Remove',
    reviewNotesAction: 'Review/Notes',
    addTagAction: 'Add Tag',
    holidayAddAction: 'Holiday +',
    
    // Settings
    settings: 'Settings',
    general: 'General',
    notifications: 'Notifications',
    displayAndLayout: 'Display & Layout',
    notificationSettings: 'Notification Settings',
    notificationSettingsDescription: 'Configure timing and methods',
    notificationCenter: 'Notification Center',
    notificationCenterDescription: 'View notification history',
    currentSettings: 'Current Settings',
    notificationTiming: 'Timing',
    notificationMethods: 'Methods',
    episodeReminders: 'Episode Reminders',
    enabled: 'Enabled',
    disabled: 'Disabled',
    timing24HoursBefore: '24 hours before',
    timingCustomPro: 'Custom (Pro)',
    methodsInAppPush: 'In-app, Push',
    methodsInAppPushEmail: 'In-app, Push, Email',
    layout: 'Layout',
    data: 'Data',
    pro: 'Pro',
    about: 'About',
    accountAndProfile: 'Account & Profile',
    resetSettingsToDefaults: 'Reset Settings to Defaults',
    confirmResetSettings: 'Are you sure you want to reset your local settings to defaults? This only affects this device.',
    resetSettingsSuccess: 'Your settings have been reset to defaults.',
    
    // General Settings
    displayName: 'Display Name',
    myStatistics: 'My Statistics',
    tvShows: 'TV Shows',
    movies: 'Movies',
    notInterested: 'Not Interested',
    notInterestedManagement: 'Not Interested Management',
    manageNotInterestedList: 'Manage Not Interested List',
    personalityLevel: 'Personality Level',
    regular: 'Regular',
    semiSarcastic: 'Semi-sarcastic',
    severelySarcastic: 'Severely sarcastic',
    friendlyAndHelpful: 'Friendly and helpful',
    aBitCheeky: 'A bit cheeky',
    maximumSass: 'Maximum sass',
    preview: 'Preview',
    resetSystemToDefaults: 'Reset System to Defaults',
    
    // Layout Settings
    themePreference: 'Theme Preference',
    dark: 'Dark',
    light: 'Light',
    darkBackgroundWithLightText: 'Dark background with light text',
    lightBackgroundWithDarkText: 'Light background with dark text',
    discoveryRecommendations: 'Discovery Recommendations',
    discoveryRecommendationsDescription: 'Number of recommendations to show in Discovery',
    otherLayoutSettings: 'Other Layout Settings',
    condensedView: 'Condensed View',
    condensedViewDescription: 'Show more items per screen with smaller cards and shorter button labels. Hides episode tracking and detailed features.',
    enableEpisodeTracking: 'Enable Episode Tracking',
    episodeTrackingCondensedProRequired: 'Episode tracking is disabled in condensed view. Upgrade to Pro to enable it.',
    episodeTrackingCondensedProAllowed: 'Pro users can enable episode tracking even in condensed view',
    proFeatures: 'Pro Features',
    themePacksComingSoon: 'Theme packs coming soon...',
    
    // My Lists
    myLists: 'My Lists',
    enterListName: 'Enter list name:',
    addToList: 'Add to List',
    selectListFor: 'Select a list for',
    items: 'items',
    noListsYet: 'No lists created yet',
    createFirstList: 'Create Your First List',
    createNewList: 'Create New List',
    listName: 'List name',
    listDescription: 'List description (optional)',
    listDescriptionOptional: 'List description (optional)',
    default: 'Default',
    edit: 'Edit',
    setAsDefault: 'Set as Default',
    delete: 'Delete',
    noListsCreated: 'No lists created yet',
    createYourFirstList: 'Create Your First List',
    listsUsed: 'Lists used',
    confirmDeleteList: 'Are you sure you want to delete',
    thisActionCannotBeUndone: 'This action cannot be undone.',
    save: 'Save',
    cancel: 'Cancel',
    darkThemeDescription: 'Dark background with light text',
    lightThemeDescription: 'Light background with dark text',
    
    // Additional My Lists
    enterNewName: 'Enter new name:',
    rename: 'Rename',
    addItemsFromSearchOrDiscovery: 'Add items from search or discovery',
    createListsToOrganize: 'Create lists to organize your favorite shows and movies',
    maxListsReached: 'Maximum lists reached',
    upgradeForMoreLists: 'Upgrade to Pro for more lists',
    upgradeToPro: 'Upgrade to Pro',
    proUpgradeComingSoon: 'Pro upgrade coming soon!',
    itemAlreadyExists: 'Item Already Exists',
    alreadyInList: 'is already in',
    confirmMoveToList: 'Do you want to move it to the selected list?',
    moveToList: 'Move to List',
    listNotFound: 'List not found',
    failedToCreateList: 'Failed to create list',
    failedToUpdateList: 'Failed to update list',
    failedToDeleteList: 'Failed to delete list',
    failedToSetDefaultList: 'Failed to set default list',
    forYouSectionConfiguration: 'For You Section Configuration',
    forYouSectionDescription:
      'Customize the three "For You" rows on your home page. Each row combines a main genre with a subgenre for personalized recommendations.',
    forYouAddAnotherRow: '+ Add Another Row',
    forYouTipText:
      'üí° Tip: Your For You section will show personalized recommendations based on these genre combinations. The titles will automatically update as you make selections.',
    
    // Notifications
    notificationTypes: 'Notification Types',
    upcomingEpisodeAlerts: 'Upcoming episode alerts',
    weeklyDiscover: 'Weekly discover',
    monthlyStatsDigest: 'Monthly stats digest',
    alertConfiguration: 'Alert Configuration (Pro)',
    advancedNotificationByLeadTime: 'Advanced notification by lead time in hours',
    pickTheList: 'Pick the list (currently watching or want to watch)',
    
    // Data Management
    standardDataManagement: 'Standard Data Management',
    shareList: 'Share List',
    chooseListsAndShowsToShare: 'Choose lists and shows to share',
    generatesCopyPasteableFormattedList: 'Generates copy/pasteable formatted list with Flicklet branding and link',
    backupSystem: 'Backup System (JSON)',
    exportAllPersonalData: 'Export all personal data',
    import: 'Import (JSON)',
    importPreviouslyExportedData: 'Import previously exported data',
    resetAllData: 'Reset All Data',
    restoreSystemToDefaults: 'Restore system to defaults',
    advancedSharingOptions: 'Advanced sharing options',
    
    // Pro Features
    proManagement: 'Pro Management',
    unlockProFeatures: 'Unlock pro features button (payment prompt - not implemented)',
    paymentPromptNotImplemented: 'Payment prompt - not implemented',
    proFeatureList: 'Pro feature list and descriptions',
    alertConfigurationDetails: 'Alert configuration details (hourly config)',
    hourlyConfig: 'Hourly config',
    themePacks: 'Theme packs (holiday and movie themes - not implemented)',
    holidayAndMovieThemes: 'Holiday and movie themes - not implemented',
    socialFeatures: 'Social features (FlickWord, Trivia, shared watchlists among friends)',
    flickwordTriviaSharedWatchlists: 'FlickWord, Trivia, shared watchlists among friends',
    bloopersBehindTheScenes: 'Bloopers/Behind the scenes (activates button on show cards)',
    activatesButtonOnShowCards: 'Activates button on show cards',
    additionalFeaturesTBD: 'Additional features TBD',
    
    // About
    informationSections: 'Information Sections',
    aboutUniqueForYou: 'About unique for you',
    aboutTheCreators: 'About the creators',
    aboutTheApp: 'About the app',
    shareYourThoughts: 'Share your thoughts (feedback, quotes for marquee, clips for home page player, venting, etc.)',
    feedbackQuotesForMarquee: 'Feedback, quotes for marquee, clips for home page player, venting, etc.',
    clipsForHomePagePlayer: 'Clips for home page player',
    venting: 'Venting',
    
    // Authentication
    signIn: 'Sign In',
    signOut: 'Sign Out',
    signInHere: 'Sign in here',
    clickToSignOut: 'Click to sign out',
    clickToSignIn: 'Click to sign in',
    signedInAs: 'Signed in as',
    signInWithGoogle: 'Sign in with Google',
    signInWithApple: 'Sign in with Apple',
    signInWithEmail: 'Sign in with Email',
    signInDescription: 'Sign in to sync your lists across devices',
    welcomeToFlicklet: 'Welcome to Flicklet!',
    whatShouldWeCallYou: 'What should we call you?',
    username: 'Username',
    usernameRequired: 'Username is required',
    usernameDescription: 'This will be used for personalized messages',
    saving: 'Saving...',
    skip: 'Skip',

    // Common
    close: 'Close',
    confirm: 'Confirm',
    areYouSure: 'Are you sure?',
    comingSoon: 'Coming soon...',
    notImplemented: 'Not implemented',
    
    // Home Rails
    yourShows: 'Your Shows',
    upNext: 'Up Next',
    inTheatersNearYou: 'In Theaters Near You',
    
    // Placeholders
    noShowsInCurrentlyWatching: 'No shows in your currently watching list. Add some from search or discovery!',
    addSomeFromSearchOrDiscovery: 'Add some from search or discovery!',
    noUpcomingEpisodes: 'No upcoming episodes. Add TV shows to your watching list to see when new episodes air!',
    addTvShowsToWatchingList: 'Add TV shows to your watching list to see when new episodes air!',
    noPoster: 'No poster',
    
    // Statistics
    currentlyWatchingCount: 'Currently Watching',
    wantToWatchCount: 'Want to Watch',
    watchedCount: 'Watched',
    totalCount: 'Total',
    
    // Feedback Panel
    tellUsWhatToImprove: 'Tell us what to improve',
    typeYourFeedback: 'Type your feedback...',
    sendFeedback: 'Send Feedback',
    whatsComing: 'What\'s coming',
    betterRecommendations: 'Better recommendations',
    episodeUpNextWithDates: 'Episode "Up Next" with dates',
    shareListsWithFriends: 'Share lists with friends',
    
    // Theater Info
    yourLocalTheater: 'Your Local Theater',
    
    // Header
    logIn: 'Log in',
    logOut: 'Log out',
    guest: 'Guest',
    
    // Search Results
    noSynopsisAvailable: 'No synopsis available.',
    opensInTmdb: 'Opens in TMDB',
    searchFailed: 'Search failed',
    
    // Personality Messages
    procrastinatingProductively: 'Procrastinating productively.',
    curatingYourIndecision: 'Curating your indecision.',
    becauseTimeIsAnIllusion: 'Because time is an illusion.',
    cinemaNowWithCommitmentIssues: 'Cinema, now with commitment issues.',
    yourBacklogCalledItsGrowing: 'Your backlog called. It\'s growing.',
    
    // Confirmation Messages
    areYouSureChangeDisplayName: 'Are you sure you want to change your display name?',
    thisWillUpdateYourProfile: 'This will update your profile.',
    areYouSureResetSettings: 'Are you sure you want to reset all settings to defaults?',
    usernameUpdateFailed: 'Failed to update username. Please try again.',
    
    // Language Labels
    language: 'Language',
    english: 'English',
    spanish: 'Espa√±ol',
    
    // Home Page Sections
    community: 'Community',
    forYou: 'For you',
    feedback: 'Feedback',
    
    // Games
    flickword: 'FlickWord',
    flickword_tagline: 'Wordle-style daily word play',
    daily_trivia: 'Daily Trivia',
    daily_trivia_tagline: 'Fresh question, new bragging rights',
    play_now: 'Play Now',
    close_game: 'Close Game',
    games: 'Games',
    won: 'Won',
    lost: 'Lost',
    streak: 'Streak',
    best: 'Best',
    win_percent: 'Win %',
    played: 'Played',
    accuracy: 'Accuracy',
    
    // Theater
    detectingLocation: 'Detecting your location...',
    locationUnavailable: 'Location unavailable',
    enableLocation: 'Enable location',
    hideShowtimes: 'Hide',
    findShowtimes: 'Find',
    loadingTheaters: 'Loading theaters...',
    noTheatersFound: 'No theaters found nearby. Try expanding your search radius.',
    kmAway: 'km away',
    hideTimes: 'Hide',
    showTimes: 'Show',
    todaysShowtimes: 'Today\'s Showtimes:',
    
    // Rail Titles
    drama: 'Drama',
    comedy: 'Comedy',
    horror: 'Horror',
    nowPlaying: 'Now Playing',
    
    // Personality
    hasExquisiteTaste: 'Has exquisite taste',
    definitelyNotProcrastinating: 'Definitely not procrastinating',
    breaksForPopcornOnly: 'Breaks for popcorn only',
    curatesChaosLikeAPro: 'Curates chaos like a pro',
    
    // Community Player
    community_player_placeholder: 'Community content coming soon',
    
    // Data Management
    dataManagementComingSoon: 'Data management features coming soon',
    
    // Search
    searchPlaceholder: 'Search movies, shows, people‚Ä¶',
    allGenres: 'All genres',
    action: 'Action',
    search: 'Search',
    clear: 'Clear',
    
    // Marquee Controls
    showMarquee: 'Show marquee',
    hideMarquee: 'Hide',
    
    // Marquee Messages
    marqueeMessage1: 'I\'m sorry, Dave. I\'m afraid I can\'t do that.',
    marqueeMessage2: 'Roads? Where we\'re going, we don\'t need roads.',
    marqueeMessage3: 'Houston, we have a problem.',
    marqueeMessage4: 'May the odds be ever in your favor.',
    marqueeMessage5: 'I\'ll be back.',
    
    // Theater & Location
  },
  
  es: {
    // Navigation
    home: 'Inicio',
    currentlyWatching: 'Viendo Ahora',
    wantToWatch: 'Quiero Ver',
    watched: 'Visto',
    alreadyWatched: 'Ya Visto',
    holidays: 'Fiestas',
    discovery: 'Descubrir',
    
    // Actions
    wantToWatchAction: 'Quiero Ver',
    currentlyWatchingAction: 'Viendo Ahora',
    watchedAction: 'Visto',
    notInterestedAction: 'No Me Interesa',
    deleteAction: 'Eliminar',
    removeAction: 'Quitar',
    reviewNotesAction: 'Rese√±a/Notas',
    addTagAction: 'Agregar Etiqueta',
    holidayAddAction: 'Fiesta +',
    
    // Settings
    settings: 'Configuraci√≥n',
    general: 'General',
    notifications: 'Notificaciones',
    displayAndLayout: 'Pantalla y dise√±o',
    notificationSettings: 'Configuraci√≥n de notificaciones',
    notificationSettingsDescription: 'Configura el horario y los m√©todos',
    notificationCenter: 'Centro de notificaciones',
    notificationCenterDescription: 'Ver historial de notificaciones',
    currentSettings: 'Configuraci√≥n actual',
    notificationTiming: 'Horario',
    notificationMethods: 'M√©todos',
    episodeReminders: 'Recordatorios de episodios',
    enabled: 'Activado',
    disabled: 'Desactivado',
    timing24HoursBefore: '24 horas antes',
    timingCustomPro: 'Personalizado (Pro)',
    methodsInAppPush: 'En la app, Push',
    methodsInAppPushEmail: 'En la app, Push, Email',
    layout: 'Dise√±o',
    data: 'Datos',
    pro: 'Pro',
    about: 'Acerca De',
    accountAndProfile: 'Cuenta y perfil',
    resetSettingsToDefaults: 'Restablecer configuraci√≥n a valores predeterminados',
    confirmResetSettings: '¬øEst√°s seguro de que quieres restablecer la configuraci√≥n local a valores predeterminados? Esto solo afecta a este dispositivo.',
    resetSettingsSuccess: 'Tu configuraci√≥n se ha restablecido a los valores predeterminados.',
    
    // General Settings
    displayName: 'Nombre de Pantalla',
    myStatistics: 'Mis Estad√≠sticas',
    tvShows: 'Programas de TV',
    movies: 'Pel√≠culas',
    notInterested: 'No Me Interesa',
    notInterestedManagement: 'Gesti√≥n de No Me Interesa',
    manageNotInterestedList: 'Gestionar Lista de No Me Interesa',
    personalityLevel: 'Nivel de Personalidad',
    regular: 'Regular',
    semiSarcastic: 'Semi-sarc√°stico',
    severelySarcastic: 'Severamente sarc√°stico',
    friendlyAndHelpful: 'Amigable y √∫til',
    aBitCheeky: 'Un poco descarado',
    maximumSass: 'M√°ximo descaro',
    preview: 'Vista Previa',
    resetSystemToDefaults: 'Restablecer Sistema a Valores Predeterminados',
    
    // Layout Settings
    themePreference: 'Preferencia de Tema',
    dark: 'Oscuro',
    light: 'Claro',
    darkBackgroundWithLightText: 'Fondo oscuro con texto claro',
    lightBackgroundWithDarkText: 'Fondo claro con texto oscuro',
    discoveryRecommendations: 'Recomendaciones de descubrimiento',
    discoveryRecommendationsDescription: 'N√∫mero de recomendaciones que se muestran en Descubrir',
    otherLayoutSettings: 'Otras opciones de dise√±o',
    condensedView: 'Vista condensada',
    condensedViewDescription: 'Muestra m√°s elementos por pantalla con tarjetas m√°s peque√±as y etiquetas de botones m√°s cortas. Oculta seguimiento de episodios y funciones detalladas.',
    enableEpisodeTracking: 'Habilitar Seguimiento de Episodios',
    episodeTrackingCondensedProRequired: 'El seguimiento de episodios est√° desactivado en la vista condensada. Actualiza a Pro para activarlo.',
    episodeTrackingCondensedProAllowed: 'Los usuarios Pro pueden activar el seguimiento de episodios incluso en vista condensada',
    proFeatures: 'Caracter√≠sticas Pro',
    themePacksComingSoon: 'Paquetes de temas pr√≥ximamente...',
    
    // My Lists
    myLists: 'Mis Listas',
    enterListName: 'Ingresa nombre de lista:',
    addToList: 'Agregar a Lista',
    selectListFor: 'Selecciona una lista para',
    items: 'elementos',
    noListsYet: 'A√∫n no hay listas creadas',
    createFirstList: 'Crea Tu Primera Lista',
    createNewList: 'Crear Nueva Lista',
    listName: 'Nombre de lista',
    listDescription: 'Descripci√≥n de lista (opcional)',
    listDescriptionOptional: 'Descripci√≥n de lista (opcional)',
    default: 'Predeterminada',
    edit: 'Editar',
    setAsDefault: 'Establecer como Predeterminada',
    delete: 'Eliminar',
    noListsCreated: 'A√∫n no hay listas creadas',
    createYourFirstList: 'Crea Tu Primera Lista',
    listsUsed: 'Listas usadas',
    confirmDeleteList: '¬øEst√°s seguro de que quieres eliminar',
    thisActionCannotBeUndone: 'Esta acci√≥n no se puede deshacer.',
    save: 'Guardar',
    cancel: 'Cancelar',
    darkThemeDescription: 'Fondo oscuro con texto claro',
    lightThemeDescription: 'Fondo claro con texto oscuro',
    
    // Additional My Lists
    enterNewName: 'Ingresa nuevo nombre:',
    rename: 'Renombrar',
    addItemsFromSearchOrDiscovery: 'Agregar elementos desde b√∫squeda o descubrimiento',
    createListsToOrganize: 'Crea listas para organizar tus programas y pel√≠culas favoritas',
    maxListsReached: 'M√°ximo de listas alcanzado',
    upgradeForMoreLists: 'Actualiza a Pro para m√°s listas',
    upgradeToPro: 'Actualizar a Pro',
    proUpgradeComingSoon: '¬°Actualizaci√≥n a Pro pr√≥ximamente!',
    itemAlreadyExists: 'El Elemento Ya Existe',
    alreadyInList: 'ya est√° en',
    confirmMoveToList: '¬øQuieres moverlo a la lista seleccionada?',
    moveToList: 'Mover a Lista',
    listNotFound: 'Lista no encontrada',
    failedToCreateList: 'No se pudo crear la lista',
    failedToUpdateList: 'No se pudo actualizar la lista',
    failedToDeleteList: 'No se pudo eliminar la lista',
    failedToSetDefaultList: 'No se pudo establecer la lista como predeterminada',
    forYouSectionConfiguration: 'Configuraci√≥n de la secci√≥n Para ti',
    forYouSectionDescription:
      'Personaliza las tres filas "Para ti" de tu p√°gina principal. Cada fila combina un g√©nero principal con un subg√©nero para recomendaciones personalizadas.',
    forYouAddAnotherRow: '+ Agregar otra fila',
    forYouTipText:
      'üí° Consejo: Tu secci√≥n Para ti mostrar√° recomendaciones personalizadas seg√∫n estas combinaciones de g√©neros. Los t√≠tulos se actualizar√°n autom√°ticamente conforme hagas selecciones.',
    
    // Notifications
    notificationTypes: 'Tipos de Notificaci√≥n',
    upcomingEpisodeAlerts: 'Alertas de episodios pr√≥ximos',
    weeklyDiscover: 'Descubrimiento semanal',
    monthlyStatsDigest: 'Resumen de estad√≠sticas mensuales',
    alertConfiguration: 'Configuraci√≥n de Alertas (Pro)',
    advancedNotificationByLeadTime: 'Notificaci√≥n avanzada por tiempo de anticipaci√≥n en horas',
    pickTheList: 'Elige la lista (viendo ahora o quiero ver)',
    
    // Data Management
    standardDataManagement: 'Gesti√≥n de Datos Est√°ndar',
    shareList: 'Compartir Lista',
    chooseListsAndShowsToShare: 'Elige listas y programas para compartir',
    generatesCopyPasteableFormattedList: 'Genera lista formateada copiable/pegable con marca Flicklet y enlace',
    backupSystem: 'Sistema de Respaldo (JSON)',
    exportAllPersonalData: 'Exportar todos los datos personales',
    import: 'Importar (JSON)',
    importPreviouslyExportedData: 'Importar datos previamente exportados',
    resetAllData: 'Restablecer Todos los Datos',
    restoreSystemToDefaults: 'Restaurar sistema a valores predeterminados',
    advancedSharingOptions: 'Opciones de compartir avanzadas',
    
    // Pro Features
    proManagement: 'Gesti√≥n Pro',
    unlockProFeatures: 'Bot√≥n de desbloquear caracter√≠sticas pro (prompt de pago - no implementado)',
    paymentPromptNotImplemented: 'Prompt de pago - no implementado',
    proFeatureList: 'Lista de caracter√≠sticas pro y descripciones',
    alertConfigurationDetails: 'Detalles de configuraci√≥n de alertas (configuraci√≥n por horas)',
    hourlyConfig: 'Configuraci√≥n por horas',
    themePacks: 'Paquetes de temas (temas de fiestas y pel√≠culas - no implementado)',
    holidayAndMovieThemes: 'Temas de fiestas y pel√≠culas - no implementado',
    socialFeatures: 'Caracter√≠sticas sociales (FlickWord, Trivia, listas compartidas entre amigos)',
    flickwordTriviaSharedWatchlists: 'FlickWord, Trivia, listas compartidas entre amigos',
    bloopersBehindTheScenes: 'Bloopers/Detr√°s de escena (activa bot√≥n en tarjetas de programas)',
    activatesButtonOnShowCards: 'Activa bot√≥n en tarjetas de programas',
    additionalFeaturesTBD: 'Caracter√≠sticas adicionales por determinar',
    
    // About
    informationSections: 'Secciones de Informaci√≥n',
    aboutUniqueForYou: 'Acerca de √∫nico para ti',
    aboutTheCreators: 'Acerca de los creadores',
    aboutTheApp: 'Acerca de la aplicaci√≥n',
    shareYourThoughts: 'Comparte tus pensamientos (comentarios, citas para marquesina, clips para reproductor de p√°gina principal, desahogo, etc.)',
    feedbackQuotesForMarquee: 'Comentarios, citas para marquesina, clips para reproductor de p√°gina principal, desahogo, etc.',
    clipsForHomePagePlayer: 'Clips para reproductor de p√°gina principal',
    venting: 'Desahogo',
    
    // Authentication
    signIn: 'Iniciar Sesi√≥n',
    signOut: 'Cerrar Sesi√≥n',
    signInHere: 'Inicia sesi√≥n aqu√≠',
    clickToSignOut: 'Haz clic para cerrar sesi√≥n',
    clickToSignIn: 'Haz clic para iniciar sesi√≥n',
    signedInAs: 'Conectado como',
    signInWithGoogle: 'Iniciar sesi√≥n con Google',
    signInWithApple: 'Iniciar sesi√≥n con Apple',
    signInWithEmail: 'Iniciar sesi√≥n con Email',
    signInDescription: 'Inicia sesi√≥n para sincronizar tus listas entre dispositivos',
    welcomeToFlicklet: '¬°Bienvenido a Flicklet!',
    whatShouldWeCallYou: '¬øC√≥mo deber√≠amos llamarte?',
    username: 'Nombre de usuario',
    usernameRequired: 'El nombre de usuario es requerido',
    usernameDescription: 'Esto se usar√° para mensajes personalizados',
    saving: 'Guardando...',
    skip: 'Omitir',

    // Common
    close: 'Cerrar',
    confirm: 'Confirmar',
    areYouSure: '¬øEst√°s seguro?',
    comingSoon: 'Pr√≥ximamente...',
    notImplemented: 'No implementado',
    
    // Home Rails
    yourShows: 'Tus Programas',
    upNext: 'Pr√≥ximamente',
    inTheatersNearYou: 'En Cines Cerca de Ti',
    
    // Placeholders
    noShowsInCurrentlyWatching: 'No hay programas en tu lista de viendo ahora. ¬°Agrega algunos desde b√∫squeda o descubrimiento!',
    addSomeFromSearchOrDiscovery: '¬°Agrega algunos desde b√∫squeda o descubrimiento!',
    noUpcomingEpisodes: 'No hay episodios pr√≥ximos. ¬°Agrega programas de TV a tu lista de viendo para ver cu√°ndo salen nuevos episodios!',
    addTvShowsToWatchingList: '¬°Agrega programas de TV a tu lista de viendo para ver cu√°ndo salen nuevos episodios!',
    noPoster: 'Sin p√≥ster',
    
    // Statistics
    currentlyWatchingCount: 'Viendo Ahora',
    wantToWatchCount: 'Quiero Ver',
    watchedCount: 'Visto',
    totalCount: 'Total',
    
    // Feedback Panel
    tellUsWhatToImprove: 'Dinos qu√© mejorar',
    typeYourFeedback: 'Escribe tu comentario...',
    sendFeedback: 'Enviar Comentario',
    whatsComing: 'Lo que viene',
    betterRecommendations: 'Mejores recomendaciones',
    episodeUpNextWithDates: 'Episodio "Pr√≥ximo" con fechas',
    shareListsWithFriends: 'Compartir listas con amigos',
    
    // Theater Info
    yourLocalTheater: 'Tu Cine Local',
    
    // Header
    logIn: 'Iniciar sesi√≥n',
    logOut: 'Cerrar sesi√≥n',
    guest: 'Invitado',
    
    // Search Results
    noSynopsisAvailable: 'Sin sinopsis disponible.',
    opensInTmdb: 'Abre en TMDB',
    searchFailed: 'B√∫squeda fallida',
    
    // Personality Messages
    procrastinatingProductively: 'Procrastinando productivamente.',
    curatingYourIndecision: 'Curando tu indecisi√≥n.',
    becauseTimeIsAnIllusion: 'Porque el tiempo es una ilusi√≥n.',
    cinemaNowWithCommitmentIssues: 'Cine, ahora con problemas de compromiso.',
    yourBacklogCalledItsGrowing: 'Tu lista pendiente llam√≥. Est√° creciendo.',
    
    // Confirmation Messages
    areYouSureChangeDisplayName: '¬øEst√°s seguro de que quieres cambiar tu nombre de pantalla?',
    thisWillUpdateYourProfile: 'Esto actualizar√° tu perfil.',
    areYouSureResetSettings: '¬øEst√°s seguro de que quieres restablecer todas las configuraciones a los valores predeterminados?',
    usernameUpdateFailed: 'No se pudo actualizar el nombre de usuario. Int√©ntalo de nuevo.',
    
    // Language Labels
    language: 'Idioma',
    english: 'English',
    spanish: 'Espa√±ol',
    
    // Home Page Sections
    community: 'Comunidad',
    forYou: 'Para ti',
    feedback: 'Comentarios',
    
    // Games
    flickword: 'FlickWord',
    flickword_tagline: 'Juego de palabras diario estilo Wordle',
    daily_trivia: 'Trivia Diaria',
    daily_trivia_tagline: 'Pregunta fresca, nuevos derechos de presumir',
    play_now: 'Jugar Ahora',
    close_game: 'Cerrar Juego',
    games: 'Juegos',
    won: 'Ganados',
    lost: 'Perdidos',
    streak: 'Racha',
    best: 'Mejor',
    win_percent: '% Ganados',
    played: 'Jugados',
    accuracy: 'Precisi√≥n',
    
    // Theater
    detectingLocation: 'Detectando tu ubicaci√≥n...',
    locationUnavailable: 'Ubicaci√≥n no disponible',
    enableLocation: 'Habilitar ubicaci√≥n',
    hideShowtimes: 'Ocultar',
    findShowtimes: 'Buscar',
    loadingTheaters: 'Cargando cines...',
    noTheatersFound: 'No se encontraron cines cerca. Intenta expandir tu radio de b√∫squeda.',
    kmAway: 'km de distancia',
    hideTimes: 'Ocultar',
    showTimes: 'Mostrar',
    todaysShowtimes: 'Horarios de Hoy:',
    
    // Personality
    hasExquisiteTaste: 'Tiene gusto exquisito',
    definitelyNotProcrastinating: 'Definitivamente no procrastinando',
    breaksForPopcornOnly: 'Descansos solo para palomitas',
    curatesChaosLikeAPro: 'Curadur√≠a del caos como profesional',
    
    // Community Player
    community_player_placeholder: 'Contenido comunitario pr√≥ximamente',
    
    // Data Management
    dataManagementComingSoon: 'Funciones de gesti√≥n de datos pr√≥ximamente',
    
    // Rail Titles
    drama: 'Drama',
    comedy: 'Comedia',
    horror: 'Terror',
    nowPlaying: 'En Cartelera',
    
    // Search
    searchPlaceholder: 'Buscar pel√≠culas, programas, personas‚Ä¶',
    allGenres: 'Todos los g√©neros',
    action: 'Acci√≥n',
    search: 'Buscar',
    clear: 'Limpiar',
    
    // Marquee Controls
    showMarquee: 'Mostrar marquesina',
    hideMarquee: 'Ocultar',
    
    // Marquee Messages
    marqueeMessage1: 'Lo siento, Dave. Me temo que no puedo hacer eso.',
    marqueeMessage2: '¬øCarreteras? A donde vamos, no necesitamos carreteras.',
    marqueeMessage3: 'Houston, tenemos un problema.',
    marqueeMessage4: 'Que la suerte est√© siempre de tu lado.',
    marqueeMessage5: 'Volver√©.',
    
    // Theater & Location
  },
};

export default TRANSLATIONS;

```

## apps/web/src/components/SettingsPage.tsx
### Summary
Settings shell that wires each section (account, layout, notifications) and exposes discovery configuration controls.
### Content
```tsx
import { useState, useEffect, useRef, lazy, Suspense } from "react";
import { useTranslations } from "../lib/language";
import { useAdminRole } from "../hooks/useAdminRole";
import { lockScroll, unlockScroll } from "../utils/scrollLock";
import NotInterestedModal from "./modals/NotInterestedModal";
import { getVisibleSections, type SettingsSectionId } from "./settingsConfig";
import { renderSettingsSection } from "./settingsSections";
import { isMobileNow } from "../lib/isMobile";
import { useUsername } from "../hooks/useUsername";
import { useAuth } from "../hooks/useAuth";
import { useLibrary } from "../lib/storage";
import { useCustomLists } from "../lib/customLists";
import { Library } from "../lib/storage";
import type { MediaItem } from "./cards/card.types";
import type { ListName } from "../state/library.types";

// Lazy load heavy notification modals
const NotificationSettings = lazy(() =>
  import("./modals/NotificationSettings").then((m) => ({
    default: m.NotificationSettings,
  }))
);
const NotificationCenter = lazy(() =>
  import("./modals/NotificationCenter").then((m) => ({
    default: m.NotificationCenter,
  }))
);

export default function SettingsPage({ onClose }: { onClose: () => void }) {
  const [activeSection, setActiveSection] = useState<SettingsSectionId>("account");
  const [showSharingModal, setShowSharingModal] = useState(false);
  const [showNotInterestedModal, setShowNotInterestedModal] = useState(false);
  const [showNotificationSettings, setShowNotificationSettings] =
    useState(false);
  const [showNotificationCenter, setShowNotificationCenter] = useState(false);
  const [showMobileSectionMenu, setShowMobileSectionMenu] = useState(false);
  const translations = useTranslations();
  const { isAdmin } = useAdminRole();
  const isMobile = isMobileNow();
  const { user } = useAuth();
  
  // Map old tab navigation events to new sections
  useEffect(() => {
    const handleNavigateToPro = () => {
      setActiveSection("pro");
    };
    const handleNavigateToLayout = () => {
      setActiveSection("display");
    };
    const handleNavigateToSection = (e: Event) => {
      const customEvent = e as CustomEvent<{ sectionId: SettingsSectionId }>;
      if (customEvent.detail?.sectionId) {
        setActiveSection(customEvent.detail.sectionId);
      }
    };

    window.addEventListener(
      "navigate-to-pro-settings",
      handleNavigateToPro as EventListener
    );
    window.addEventListener(
      "navigate-to-layout-settings",
      handleNavigateToLayout as EventListener
    );
    window.addEventListener(
      "navigate-to-settings-section",
      handleNavigateToSection as EventListener
    );
    return () => {
      window.removeEventListener(
        "navigate-to-pro-settings",
        handleNavigateToPro as EventListener
      );
      window.removeEventListener(
        "navigate-to-layout-settings",
        handleNavigateToLayout as EventListener
      );
      window.removeEventListener(
        "navigate-to-settings-section",
        handleNavigateToSection as EventListener
      );
    };
  }, []);

  // Resizable modal state
  const modalRef = useRef<HTMLDivElement>(null);
  const resizeHandleRef = useRef<HTMLDivElement>(null);
  const resizeStartRef = useRef<{
    x: number;
    y: number;
    width: number;
    height: number;
  } | null>(null);
  const [isResizing, setIsResizing] = useState(false);
  const [modalSize, setModalSize] = useState(() => {
    // Load saved size from localStorage
    const saved = localStorage.getItem("settings-modal-size");
    if (saved) {
      try {
        const parsed = JSON.parse(saved);
        return { width: parsed.width || 1024, height: parsed.height || 600 };
      } catch {
        // Fallback to defaults if parse fails
      }
    }
    return { width: 1024, height: 600 };
  });

  // Lock scroll when settings modal is open
  useEffect(() => {
    lockScroll();
    return () => {
      unlockScroll();
    };
  }, []);

  // Listen for navigation to Pro tab (from startProUpgrade)
  useEffect(() => {
    const handleNavigateToPro = () => {
      setActiveSection("pro");
    };

    window.addEventListener(
      "navigate-to-pro-settings",
      handleNavigateToPro as EventListener
    );
    return () => {
      window.removeEventListener(
        "navigate-to-pro-settings",
        handleNavigateToPro as EventListener
      );
    };
  }, []);

  // Listen for navigation to Layout tab (from For You section)
  useEffect(() => {
    const handleNavigateToLayout = () => {
      setActiveSection("display");
    };

    window.addEventListener(
      "navigate-to-layout-settings",
      handleNavigateToLayout as EventListener
    );
    return () => {
      window.removeEventListener(
        "navigate-to-layout-settings",
        handleNavigateToLayout as EventListener
      );
    };
  }, []);

  // Handle resize
  useEffect(() => {
    if (!isResizing) return;

    const handleMouseMove = (e: MouseEvent) => {
      if (!modalRef.current || !resizeStartRef.current) return;

      const deltaX = e.clientX - resizeStartRef.current.x;
      const deltaY = e.clientY - resizeStartRef.current.y;

      const newWidth = Math.max(
        320,
        Math.min(window.innerWidth - 32, resizeStartRef.current.width + deltaX)
      );
      const newHeight = Math.max(
        400,
        Math.min(
          window.innerHeight - 100,
          resizeStartRef.current.height + deltaY
        )
      );

      setModalSize({ width: newWidth, height: newHeight });
    };

    const handleMouseUp = () => {
      setIsResizing(false);
      resizeStartRef.current = null;
      // Save size to localStorage
      if (modalRef.current) {
        const currentSize = {
          width: modalRef.current.offsetWidth,
          height: modalRef.current.offsetHeight,
        };
        localStorage.setItem(
          "settings-modal-size",
          JSON.stringify(currentSize)
        );
      }
    };

    document.addEventListener("mousemove", handleMouseMove);
    document.addEventListener("mouseup", handleMouseUp);
    document.body.style.cursor = "nwse-resize";
    document.body.style.userSelect = "none";

    return () => {
      document.removeEventListener("mousemove", handleMouseMove);
      document.removeEventListener("mouseup", handleMouseUp);
      document.body.style.cursor = "";
      document.body.style.userSelect = "";
    };
  }, [isResizing]);

  const handleResizeStart = (e: React.MouseEvent) => {
    e.preventDefault();
    e.stopPropagation();

    if (modalRef.current) {
      const rect = modalRef.current.getBoundingClientRect();
      resizeStartRef.current = {
        x: e.clientX,
        y: e.clientY,
        width: rect.width,
        height: rect.height,
      };
      setIsResizing(true);
    }
  };

  // Get visible sections (filters out admin if not admin)
  const visibleSections = getVisibleSections(isAdmin);

  return (
    <div
      className={`fixed inset-0 z-modal backdrop-blur-sm flex ${isMobile ? 'items-start' : 'items-start justify-center'} ${isMobile ? '' : 'pt-24 p-4'}`}
      style={{
        backgroundColor: "rgba(0,0,0,0.8)",
        ...(isMobile ? {
          top: 0,
          left: 0,
          padding: 0,
        } : {}),
      }}
    >
      <div
        ref={modalRef}
        className={`flex ${isMobile ? 'flex-col' : ''} overflow-hidden relative ${isMobile ? '' : 'rounded-xl'}`}
        style={{
          backgroundColor: "var(--card)",
          borderColor: "var(--line)",
          border: "1px solid",
          // Mobile: full-screen
          ...(isMobile ? {
            top: 0,
            left: 0,
            width: "100vw",
            height: "100vh",
            maxWidth: "100vw",
            maxHeight: "100vh",
            minWidth: 0,
            minHeight: 0,
            borderRadius: 0,
          } : {
            // Desktop: resizable modal
            width: `min(${modalSize.width}px, 100vw - 32px)`,
            height: `${modalSize.height}px`,
            minWidth: "320px",
            minHeight: "400px",
            maxWidth: "min(1024px, 100vw - 32px)",
            maxHeight: "95vh",
          }),
        }}
      >
        {/* Mobile Header */}
        {isMobile && (
          <>
            <div
              className="flex items-center justify-between p-4 flex-shrink-0"
              style={{
                backgroundColor: "var(--btn)",
                borderBottomColor: "var(--line)",
                borderBottom: "1px solid",
              }}
            >
              <button
                onClick={() => setShowMobileSectionMenu(!showMobileSectionMenu)}
                className="flex items-center space-x-2 transition-colors"
                style={{ color: "var(--text)" }}
                aria-label="Select section"
              >
                <h2
                  className="text-lg font-semibold"
                  style={{ color: "var(--text)" }}
                >
                  {visibleSections.find((s) => s.id === activeSection)?.label || translations.settings}
                </h2>
                <svg
                  className={`w-5 h-5 transition-transform ${showMobileSectionMenu ? 'rotate-180' : ''}`}
                  fill="none"
                  stroke="currentColor"
                  viewBox="0 0 24 24"
                >
                  <path
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    strokeWidth={2}
                    d="M19 9l-7 7-7-7"
                  />
                </svg>
              </button>
              <button
                onClick={onClose}
                className="transition-colors ml-4"
                style={{ color: "var(--muted)" }}
                aria-label="Close Settings"
              >
                <svg
                  className="w-6 h-6"
                  fill="none"
                  stroke="currentColor"
                  viewBox="0 0 24 24"
                >
                  <path
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    strokeWidth={2}
                    d="M6 18L18 6M6 6l12 12"
                  />
                </svg>
              </button>
            </div>
            {/* Mobile Section Menu */}
            {showMobileSectionMenu && (
              <div
                className="flex-shrink-0 border-b"
                style={{
                  backgroundColor: "var(--card)",
                  borderBottomColor: "var(--line)",
                }}
              >
                <div className="p-2 space-y-1 max-h-64 overflow-y-auto">
                  {visibleSections.map((section) => (
                    <button
                      key={section.id}
                      onClick={() => {
                        setActiveSection(section.id);
                        setShowMobileSectionMenu(false);
                      }}
                      className="w-full text-left px-4 py-3 rounded-lg transition-colors"
                      style={{
                        backgroundColor:
                          activeSection === section.id ? "var(--btn)" : "transparent",
                        color: activeSection === section.id ? "var(--text)" : "var(--muted)",
                      }}
                    >
                      {section.label}
                    </button>
                  ))}
                </div>
              </div>
            )}
          </>
        )}

        {/* Desktop Header - Title and Close button at top */}
        {!isMobile && (
          <div
            className="hidden lg:flex absolute top-0 left-0 right-0 h-16 items-center justify-between px-6 flex-shrink-0 z-10"
            style={{
              backgroundColor: "var(--card)",
              borderBottomColor: "var(--line)",
              borderBottom: "1px solid",
            }}
          >
            <div>
              <h2
                className="text-lg font-semibold"
                style={{ color: "var(--text)" }}
              >
                {translations.settings}
              </h2>
              <p
                className="text-sm mt-0.5"
                style={{ color: "var(--muted)" }}
              >
                {user?.email ? `Signed in as ${user.email}` : "Signed in"}
              </p>
            </div>
            <button
              onClick={onClose}
              className="transition-colors"
              style={{ color: "var(--muted)" }}
              onMouseEnter={(e) =>
                (e.currentTarget.style.color = "var(--text)")
              }
              onMouseLeave={(e) =>
                (e.currentTarget.style.color = "var(--muted)")
              }
              aria-label="Close Settings"
            >
              <svg
                className="w-6 h-6"
                fill="none"
                stroke="currentColor"
                viewBox="0 0 24 24"
              >
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  strokeWidth={2}
                  d="M6 18L18 6M6 6l12 12"
                />
              </svg>
            </button>
          </div>
        )}

        {/* Left sidebar - Sections (desktop only) */}
        {!isMobile && (
          <div
            className="hidden lg:flex w-48 p-4 flex-shrink-0 flex-col"
            style={{
              backgroundColor: "var(--btn)",
              borderRightColor: "var(--line)",
              borderRight: "1px solid",
              paddingTop: "80px", // Account for header height
            }}
          >
            <nav className="space-y-1">
              {visibleSections.map((section) => (
                <button
                  key={section.id}
                  onClick={() => setActiveSection(section.id)}
                  className="w-full text-left px-3 py-2 rounded-lg text-sm transition-colors"
                  style={{
                    backgroundColor:
                      activeSection === section.id ? "var(--card)" : "transparent",
                    color: activeSection === section.id ? "var(--text)" : "var(--muted)",
                    textAlign: "left", // Ensure left alignment
                  }}
                  onMouseEnter={(e) => {
                    if (activeSection !== section.id) {
                      e.currentTarget.style.backgroundColor = "var(--card)";
                      e.currentTarget.style.opacity = "0.5";
                    }
                  }}
                  onMouseLeave={(e) => {
                    if (activeSection !== section.id) {
                      e.currentTarget.style.backgroundColor = "transparent";
                      e.currentTarget.style.opacity = "1";
                    }
                  }}
                >
                  {section.label}
                </button>
              ))}
            </nav>
          </div>
        )}

        {/* Content area */}
        <div 
          className={`flex-1 overflow-y-auto ${isMobile ? 'w-full p-4' : 'p-6'}`}
          style={{
            WebkitOverflowScrolling: isMobile ? 'touch' : 'auto',
            ...(!isMobile ? {
              paddingTop: "88px", // Account for header height
            } : {}),
          }}
        >
          {renderSettingsSection(activeSection, {
            onShowNotInterestedModal: () => setShowNotInterestedModal(true),
            onShowSharingModal: () => setShowSharingModal(true),
            onShowNotificationSettings: () => setShowNotificationSettings(true),
            onShowNotificationCenter: () => setShowNotificationCenter(true),
            isMobile: isMobile,
          })}
        </div>

        {/* Resize handle - Desktop only */}
        {!isMobile && (
          <div
            ref={resizeHandleRef}
            onMouseDown={handleResizeStart}
            className="absolute bottom-0 right-0 w-6 h-6 cursor-nwse-resize flex items-end justify-end p-1 z-10"
            style={{
              backgroundColor: "transparent",
            }}
            aria-label="Resize settings modal"
            title="Drag to resize"
          >
            <svg
              width="16"
              height="16"
              viewBox="0 0 16 16"
              fill="none"
              style={{ color: "var(--muted)", pointerEvents: "none" }}
            >
              <path
                d="M6 10L10 6M10 10L14 6M2 14L14 2"
                stroke="currentColor"
                strokeWidth="1.5"
                strokeLinecap="round"
                strokeLinejoin="round"
              />
            </svg>
          </div>
        )}
      </div>

      {/* Sharing Modal */}
      {showSharingModal && (
        <SharingModal onClose={() => setShowSharingModal(false)} />
      )}

      {/* Not Interested Modal */}
      <NotInterestedModal
        isOpen={showNotInterestedModal}
        onClose={() => setShowNotInterestedModal(false)}
      />

      {/* Notification Settings Modal */}
      {showNotificationSettings && (
        <Suspense
          fallback={
            <div className="loading-spinner">
              Loading notification settings...
            </div>
          }
        >
          <NotificationSettings
            isOpen={showNotificationSettings}
            onClose={() => setShowNotificationSettings(false)}
          />
        </Suspense>
      )}

      {/* Notification Center Modal */}
      {showNotificationCenter && (
        <Suspense
          fallback={
            <div className="loading-spinner">
              Loading notification center...
            </div>
          }
        >
          <NotificationCenter
            isOpen={showNotificationCenter}
            onClose={() => setShowNotificationCenter(false)}
          />
        </Suspense>
      )}
    </div>
  );
}

// OLD TAB COMPONENTS REMOVED - Now using shared sections from settingsSections.tsx
// The following old components are kept for reference but are no longer used:
// - GeneralTab (replaced by AccountSection)
// - NotificationsTab (replaced by NotificationsSection)
// - LayoutTab (replaced by DisplaySection)
// - DataTab (replaced by DataSection)
// - SocialTab (removed - placeholder content)
// - CommunityTab (removed - placeholder content)
// - ProTab (replaced by ProSection)
// - AboutTab (replaced by AboutSection)

// Sharing Modal Component
function SharingModal({ onClose }: { onClose: () => void }) {
  const { username } = useUsername();
  const watchingItems = useLibrary("watching");
  const wishlistItems = useLibrary("wishlist");
  const watchedItems = useLibrary("watched");
  const userLists = useCustomLists();

  // Initialize selectedTabs with custom lists
  const [selectedTabs, setSelectedTabs] = useState<Record<string, boolean>>(
    () => {
      const initial: Record<string, boolean> = {
        watching: true,
        wishlist: true,
        watched: true,
      };
      // Add custom lists, default to false (not selected)
      userLists.customLists.forEach((list) => {
        initial[`custom:${list.id}`] = false;
      });
      return initial;
    }
  );

  // Update selectedTabs when custom lists change
  useEffect(() => {
    setSelectedTabs((prev) => {
      const updated = { ...prev };
      // Add any new custom lists that don't exist yet
      userLists.customLists.forEach((list) => {
        const listKey = `custom:${list.id}`;
        if (!(listKey in updated)) {
          updated[listKey] = false;
        }
      });
      // Remove custom lists that no longer exist
      Object.keys(updated).forEach((key) => {
        if (key.startsWith("custom:")) {
          const listId = key.replace("custom:", "");
          if (!userLists.customLists.some((list) => list.id === listId)) {
            delete updated[key];
          }
        }
      });
      return updated;
    });
  }, [userLists.customLists]);

  const [selectedItems, setSelectedItems] = useState<Set<string>>(new Set());
  const [contentOptions, setContentOptions] = useState({
    includeMovies: true,
    includeTV: true,
    includeRatings: true,
    includeDescriptions: false,
  });

  const [showResult, setShowResult] = useState(false);
  const [shareableText, setShareableText] = useState("");

  // Get all items from selected tabs
  const getAllItems = () => {
    const items: MediaItem[] = [];
    if (selectedTabs.watching) items.push(...watchingItems);
    if (selectedTabs.wishlist) items.push(...wishlistItems);
    if (selectedTabs.watched) items.push(...watchedItems);

    // Add items from selected custom lists
    userLists.customLists.forEach((list) => {
      const listKey = `custom:${list.id}`;
      if (selectedTabs[listKey]) {
        const customListItems = Library.getByList(
          `custom:${list.id}` as ListName
        );
        items.push(...customListItems);
      }
    });

    return items;
  };

  // Filter items based on content options
  const getFilteredItems = () => {
    let items = getAllItems();

    if (!contentOptions.includeMovies && !contentOptions.includeTV) {
      return [];
    }

    if (!contentOptions.includeMovies) {
      items = items.filter((item) => item.mediaType !== "movie");
    }

    if (!contentOptions.includeTV) {
      items = items.filter((item) => item.mediaType !== "tv");
    }

    return items;
  };

  // Get items to include in share
  const getItemsToShare = () => {
    const filteredItems = getFilteredItems();

    if (selectedItems.size === 0) {
      return filteredItems; // If nothing selected individually, include all filtered items
    }

    return filteredItems.filter((item) =>
      selectedItems.has(item.id.toString())
    );
  };

  const handleTabToggle = (tab: string) => {
    setSelectedTabs((prev) => ({ ...prev, [tab]: !prev[tab] }));
  };

  const handleOptionToggle = (option: keyof typeof contentOptions) => {
    setContentOptions((prev) => ({ ...prev, [option]: !prev[option] }));
  };

  const handleItemToggle = (itemId: string) => {
    setSelectedItems((prev) => {
      const newSet = new Set(prev);
      if (newSet.has(itemId)) {
        newSet.delete(itemId);
      } else {
        newSet.add(itemId);
      }
      return newSet;
    });
  };

  const handleSelectAll = () => {
    const allItemIds = getFilteredItems().map((item) => item.id.toString());
    setSelectedItems(new Set(allItemIds));
  };

  const handleSelectNone = () => {
    setSelectedItems(new Set());
  };

  const generateShareableText = () => {
    const userName = username || "Flicklet User";
    const itemsToShare = getItemsToShare();

    let text = `üé¨ Flicklet - ${userName}'s Watchlist\n`;
    text += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n`;

    if (
      selectedTabs.watching &&
      itemsToShare.some((item) => watchingItems.some((w) => w.id === item.id))
    ) {
      text += `‚ñ∂Ô∏è Currently Watching\n`;
      text += `${"‚îÄ".repeat(30)}\n`;
      const watchingItemsToShare = itemsToShare.filter((item) =>
        watchingItems.some((w) => w.id === item.id)
      );
      watchingItemsToShare.forEach((item) => {
        const icon = item.mediaType === "movie" ? "üé¨" : "üì∫";
        const rating =
          contentOptions.includeRatings && item.voteAverage
            ? ` ‚≠ê ${item.voteAverage.toFixed(1)}`
            : "";
        text += `${icon} ${item.title}${rating}\n`;
      });
      text += "\n";
    }

    if (
      selectedTabs.wishlist &&
      itemsToShare.some((item) => wishlistItems.some((w) => w.id === item.id))
    ) {
      text += `‚ù§Ô∏è Want to Watch\n`;
      text += `${"‚îÄ".repeat(30)}\n`;
      const wishlistItemsToShare = itemsToShare.filter((item) =>
        wishlistItems.some((w) => w.id === item.id)
      );
      wishlistItemsToShare.forEach((item) => {
        const icon = item.mediaType === "movie" ? "üé¨" : "üì∫";
        const rating =
          contentOptions.includeRatings && item.voteAverage
            ? ` ‚≠ê ${item.voteAverage.toFixed(1)}`
            : "";
        text += `${icon} ${item.title}${rating}\n`;
      });
      text += "\n";
    }

    if (
      selectedTabs.watched &&
      itemsToShare.some((item) => watchedItems.some((w) => w.id === item.id))
    ) {
      text += `‚úÖ Already Watched\n`;
      text += `${"‚îÄ".repeat(30)}\n`;
      const watchedItemsToShare = itemsToShare.filter((item) =>
        watchedItems.some((w) => w.id === item.id)
      );
      watchedItemsToShare.forEach((item) => {
        const icon = item.mediaType === "movie" ? "üé¨" : "üì∫";
        const rating =
          contentOptions.includeRatings && item.voteAverage
            ? ` ‚≠ê ${item.voteAverage.toFixed(1)}`
            : "";
        text += `${icon} ${item.title}${rating}\n`;
      });
      text += "\n";
    }

    // Add custom lists
    userLists.customLists.forEach((list) => {
      const listKey = `custom:${list.id}`;
      if (selectedTabs[listKey]) {
        const customListItems = Library.getByList(
          `custom:${list.id}` as ListName
        );
        const customItemsToShare = itemsToShare.filter((item) =>
          customListItems.some((c) => c.id === item.id)
        );
        if (customItemsToShare.length > 0) {
          text += `üìã ${list.name}\n`;
          text += `${"‚îÄ".repeat(30)}\n`;
          customItemsToShare.forEach((item) => {
            const icon = item.mediaType === "movie" ? "üé¨" : "üì∫";
            const rating =
              contentOptions.includeRatings && item.voteAverage
                ? ` ‚≠ê ${item.voteAverage.toFixed(1)}`
                : "";
            text += `${icon} ${item.title}${rating}\n`;
          });
          text += "\n";
        }
      }
    });

    text += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n`;
    text += `üì± Track your shows and movies with Flicklet!\n`;
    text += `üîó https://flicklet.netlify.app\n`;

    return text;
  };

  const handleGenerate = () => {
    const text = generateShareableText();
    setShareableText(text);
    setShowResult(true);
  };

  const handleCopy = async () => {
    try {
      await navigator.clipboard.writeText(shareableText);
      alert("Copied to clipboard!");
    } catch (_error) {
      // Fallback for older browsers
      const textarea = document.createElement("textarea");
      textarea.value = shareableText;
      document.body.appendChild(textarea);
      textarea.select();
      document.execCommand("copy");
      document.body.removeChild(textarea);
      alert("Copied to clipboard!");
    }
  };

  const filteredItems = getFilteredItems();

  if (showResult) {
    return (
      <div className="fixed inset-0 z-modal backdrop-blur-sm flex items-center justify-center p-4">
        <div className="bg-white dark:bg-gray-800 rounded-lg shadow-xl max-w-2xl w-full max-h-[90vh] overflow-hidden">
          <div className="p-6">
            <div className="flex justify-between items-center mb-4">
              <h3 className="text-xl font-semibold text-gray-900 dark:text-gray-100">
                üìã Your Shareable List
              </h3>
              <button
                onClick={onClose}
                className="text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200"
              >
                ‚úï
              </button>
            </div>

            <div className="mb-4">
              <p className="text-sm text-gray-600 dark:text-gray-400">
                Copy the text below and share it with your friends! They can see
                what you're watching and get recommendations.
              </p>
            </div>

            <textarea
              value={shareableText}
              readOnly
              className="w-full h-64 p-3 border rounded-lg font-mono text-sm bg-gray-50 dark:bg-gray-700 border-gray-300 dark:border-gray-600 text-gray-900 dark:text-gray-100"
            />

            <div className="flex gap-2 mt-4">
              <button
                onClick={onClose}
                className="px-4 py-2 rounded-lg text-sm transition-colors"
                style={{
                  backgroundColor: "var(--btn)",
                  color: "var(--text)",
                  borderColor: "var(--line)",
                  border: "1px solid",
                }}
              >
                Close
              </button>
              <button
                onClick={handleCopy}
                className="px-4 py-2 rounded-lg text-sm transition-colors"
                style={{ backgroundColor: "var(--accent)", color: "white" }}
              >
                üìã Copy to Clipboard
              </button>
            </div>
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className="fixed inset-0 z-modal backdrop-blur-sm flex items-center justify-center p-4">
      <div className="bg-white dark:bg-gray-800 rounded-lg shadow-xl max-w-4xl w-full max-h-[90vh] overflow-hidden">
        <div className="p-6">
          <div className="flex justify-between items-center mb-6">
            <h3 className="text-xl font-semibold text-gray-900 dark:text-gray-100">
              üì§ Share Your Lists
            </h3>
            <button
              onClick={onClose}
              className="text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200"
            >
              ‚úï
            </button>
          </div>

          <div className="space-y-6 max-h-[70vh] overflow-y-auto">
            {/* Tab Selection */}
            <div>
              <h4 className="text-lg font-medium mb-3 text-gray-800 dark:text-gray-200">
                üìã Select Lists to Share
              </h4>
              <div className="space-y-2">
                {[
                  {
                    key: "watching",
                    label: "‚ñ∂Ô∏è Currently Watching",
                    items: watchingItems,
                  },
                  {
                    key: "wishlist",
                    label: "‚ù§Ô∏è Want to Watch",
                    items: wishlistItems,
                  },
                  {
                    key: "watched",
                    label: "‚úÖ Already Watched",
                    items: watchedItems,
                  },
                ].map(({ key, label, items }) => (
                  <label
                    key={key}
                    className="flex items-center justify-between p-3 rounded-lg cursor-pointer"
                    style={{
                      backgroundColor: "var(--btn)",
                      borderColor: "var(--line)",
                      border: "1px solid",
                    }}
                  >
                    <div className="flex items-center gap-3">
                      <input
                        type="checkbox"
                        checked={selectedTabs[key] || false}
                        onChange={() => handleTabToggle(key)}
                        className="w-4 h-4"
                      />
                      <span className="text-gray-900 dark:text-gray-100">
                        {label}
                      </span>
                    </div>
                    <span className="text-sm text-gray-600 dark:text-gray-400">
                      {items.length} items
                    </span>
                  </label>
                ))}

                {/* Custom Lists */}
                {userLists.customLists.length > 0 && (
                  <>
                    <div
                      className="pt-2 mt-2 border-t"
                      style={{ borderColor: "var(--line)" }}
                    >
                      <h5 className="text-sm font-medium mb-2 text-gray-700 dark:text-gray-300">
                        üìã Custom Lists
                      </h5>
                    </div>
                    {userLists.customLists.map((list) => {
                      const listKey = `custom:${list.id}`;
                      const customListItems = Library.getByList(
                        `custom:${list.id}` as ListName
                      );
                      return (
                        <label
                          key={list.id}
                          className="flex items-center justify-between p-3 rounded-lg cursor-pointer"
                          style={{
                            backgroundColor: "var(--btn)",
                            borderColor: "var(--line)",
                            border: "1px solid",
                          }}
                        >
                          <div className="flex items-center gap-3">
                            <input
                              type="checkbox"
                              checked={selectedTabs[listKey] || false}
                              onChange={() => handleTabToggle(listKey)}
                              className="w-4 h-4"
                            />
                            <span className="text-gray-900 dark:text-gray-100">
                              üìã {list.name}
                            </span>
                          </div>
                          <span className="text-sm text-gray-600 dark:text-gray-400">
                            {customListItems.length} items
                          </span>
                        </label>
                      );
                    })}
                  </>
                )}
              </div>
            </div>

            {/* Content Options */}
            <div>
              <h4 className="text-lg font-medium mb-3 text-gray-800 dark:text-gray-200">
                üéØ Content Options
              </h4>
              <div className="space-y-2">
                {[
                  { key: "includeMovies", label: "üé¨ Include Movies" },
                  { key: "includeTV", label: "üì∫ Include TV Shows" },
                  { key: "includeRatings", label: "‚≠ê Include Ratings" },
                  {
                    key: "includeDescriptions",
                    label: "üìù Include Descriptions",
                  },
                ].map(({ key, label }) => (
                  <label
                    key={key}
                    className="flex items-center gap-3 p-3 rounded-lg cursor-pointer"
                    style={{
                      backgroundColor: "var(--btn)",
                      borderColor: "var(--line)",
                      border: "1px solid",
                    }}
                  >
                    <input
                      type="checkbox"
                      checked={
                        contentOptions[key as keyof typeof contentOptions]
                      }
                      onChange={() =>
                        handleOptionToggle(key as keyof typeof contentOptions)
                      }
                      className="w-4 h-4"
                    />
                    <span className="text-gray-900 dark:text-gray-100">
                      {label}
                    </span>
                  </label>
                ))}
              </div>
            </div>

            {/* Item Selection */}
            {filteredItems.length > 0 && (
              <div>
                <div className="flex items-center justify-between mb-3">
                  <h4 className="text-lg font-medium text-gray-800 dark:text-gray-200">
                    üé¨ Select Items to Share
                  </h4>
                  <div className="flex gap-2">
                    <button
                      onClick={handleSelectAll}
                      className="px-3 py-1 rounded text-sm transition-colors"
                      style={{
                        backgroundColor: "var(--accent)",
                        color: "white",
                      }}
                    >
                      Select All
                    </button>
                    <button
                      onClick={handleSelectNone}
                      className="px-3 py-1 rounded text-sm transition-colors"
                      style={{
                        backgroundColor: "var(--btn)",
                        color: "var(--text)",
                        borderColor: "var(--line)",
                        border: "1px solid",
                      }}
                    >
                      Select None
                    </button>
                  </div>
                </div>

                <div className="max-h-48 overflow-y-auto space-y-2">
                  {filteredItems.map((item) => (
                    <label
                      key={item.id}
                      className="flex items-center gap-3 p-2 rounded cursor-pointer hover:bg-gray-100 dark:hover:bg-gray-700"
                    >
                      <input
                        type="checkbox"
                        checked={selectedItems.has(item.id.toString())}
                        onChange={() => handleItemToggle(item.id.toString())}
                        className="w-4 h-4"
                      />
                      <span className="flex-1 text-sm text-gray-900 dark:text-gray-100">
                        {item.mediaType === "movie" ? "üé¨" : "üì∫"} {item.title}
                        {contentOptions.includeRatings && item.voteAverage && (
                          <span className="ml-2 text-xs text-gray-600 dark:text-gray-400">
                            ‚≠ê {item.voteAverage.toFixed(1)}
                          </span>
                        )}
                      </span>
                    </label>
                  ))}
                </div>
              </div>
            )}

            {/* Actions */}
            <div
              className="flex gap-2 pt-4 border-t"
              style={{ borderColor: "var(--line)" }}
            >
              <button
                onClick={onClose}
                className="px-4 py-2 rounded-lg text-sm transition-colors"
                style={{
                  backgroundColor: "var(--btn)",
                  color: "var(--text)",
                  borderColor: "var(--line)",
                  border: "1px solid",
                }}
              >
                Cancel
              </button>
              <button
                onClick={handleGenerate}
                className="px-4 py-2 rounded-lg text-sm transition-colors"
                style={{ backgroundColor: "var(--accent)", color: "white" }}
              >
                üìã Generate Shareable List
              </button>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}

```

## apps/web/src/components/cards/CardV2.tsx
### Summary
Modern media card that renders posters, voteAverage, rating actions, and context-specific membership badges for home/discovery rails.
### Content
```tsx
import React from 'react';
import type { CardContext, CardActionHandlers, MediaItem } from './card.types';
import type { ListName } from '../../state/library.types';
import { useTranslations } from '../../lib/language';
import { useIsDesktop } from '../../hooks/useDeviceDetection';
import SwipeableCard from '../SwipeableCard';
import MyListToggle from '../MyListToggle';
import { OptimizedImage } from '../OptimizedImage';
import { CompactPrimaryAction } from '../../features/compact/CompactPrimaryAction';
import { CompactOverflowMenu } from '../../features/compact/CompactOverflowMenu';
import { EpisodeProgressDisplay } from '../EpisodeProgressDisplay';
import { ListMembershipBadge } from '../ListMembershipBadge';

export type CardV2Props = {
  item: MediaItem;
  context: CardContext;
  actions?: CardActionHandlers;
  // optional presentation flags
  compact?: boolean;          // smaller text; still 2:3 poster
  showRating?: boolean;       // default true where voteAverage exists
  disableSwipe?: boolean;     // disable swipe actions for horizontal scrolling contexts
  disableOverflow?: boolean;  // hide overflow menu (e.g., home currently watching rail)
  // optional: override the list context derived from 'context' prop (useful for custom lists)
  currentListContext?: ListName;
};

/**
 * Cards V2 ‚Äî unified card for rails, tabs, and search
 * - 2:3 poster with safe fallback
 * - context-specific action bar
 * - optional Holiday + chip top-right (where relevant)
 * - SWIPE ONLY ON MOBILE: Desktop has zero swipe wrapper
 * 
 * Badge contexts:
 * - ListMembershipBadge SHOWS in mixed contexts: 'home', 'search', 'tab-foryou', 'holiday'
 * - ListMembershipBadge HIDES in list-specific contexts: 'tab-watching', 'tab-want', 'tab-watched', 'tab-not'
 * - Usage: HomeYourShowsRail (tab-watching - hide), DiscoveryPage (tab-foryou - show), MyListsPage (tab-watching - hide)
 */
/**
 * Helper to determine if membership badge should be shown based on context.
 * Badge shows in mixed contexts (where list membership is useful info).
 * Badge hides in list-specific contexts (where tab/section already implies membership).
 */
function shouldShowMembershipBadge(context: CardContext): boolean {
  // Mixed contexts where badge is useful (items from various lists mixed together)
  const mixedContexts: CardContext[] = [
    'home',
    'search',
    'tab-foryou',
    'holiday',
  ];

  return mixedContexts.includes(context);
}

function getListContextFromCardContext(context: CardContext): ListName | undefined {
  switch (context) {
    case 'tab-watching':
      return 'watching';
    case 'tab-want':
      return 'wishlist';
    case 'tab-watched':
      return 'watched';
    case 'tab-not':
      return 'not';
    default:
      return undefined;
  }
}

export default function CardV2({ item, context, actions, compact, showRating = true, disableSwipe = false, disableOverflow = false, currentListContext: propCurrentListContext }: CardV2Props) {
  const { title, year, posterUrl, voteAverage } = item;
  const rating = typeof voteAverage === 'number' ? Math.round(voteAverage * 10) / 10 : undefined;
  const translations = useTranslations();
  const isDesktop = useIsDesktop(); // Device detection for conditional swipe

  const showMyListBtn = context === 'tab-foryou' || context === 'search' || context === 'home' || context === 'tab-watching' || context === 'holiday';

  // Card content (shared between mobile and desktop)
  const cardContent = (
      <article className="curated-card v2 group select-none" data-testid="cardv2" aria-label={title} style={{ width: 'var(--poster-w-desktop, var(--poster-w, 160px))' }}>
      <div 
        className="relative border shadow-sm overflow-hidden"
        style={{ backgroundColor: 'var(--card)', borderColor: 'var(--line)', borderRadius: 'var(--radius, 12px)' }}
      >
        {/* Poster (2:3) */}
        <div 
          className="poster-wrap relative aspect-[2/3] cursor-pointer" 
          role="img" 
          aria-label={title}
          style={{ backgroundColor: 'var(--muted)' }}
          onClick={(e) => {
            // Don't open TMDB if clicking on a button inside the poster
            if ((e.target as HTMLElement).closest('button')) {
              return;
            }
            if (item.id && item.mediaType) {
              const tmdbUrl = `https://www.themoviedb.org/${item.mediaType}/${item.id}`;
              window.open(tmdbUrl, '_blank', 'noopener,noreferrer');
            }
          }}
        >
          {posterUrl ? (
            <OptimizedImage
              src={posterUrl}
              alt={title}
              context="poster"
              className="h-full w-full"
              loading="lazy"
            />
          ) : (
            <div 
              className="flex h-full w-full items-center justify-center text-xs"
              style={{ color: 'var(--muted)' }}
            >
              {translations.noPoster}
            </div>
          )}

          {/* My List + */}
          {showMyListBtn && (
            <MyListToggle 
              item={item} 
              currentListContext={
                // Use prop if provided (for custom lists), otherwise derive from context
                propCurrentListContext !== undefined
                  ? propCurrentListContext
                  : getListContextFromCardContext(context)
              }
            />
          )}
        </div>

        {/* Meta */}
        <div className="p-1">
          <div className="flex items-center gap-1">
            <h3 
              className={["truncate", compact ? "font-medium" : "text-sm", "font-medium"].join(' ')} 
              style={{ 
                fontSize: compact ? 'var(--font-md, 13px)' : undefined,
                color: 'var(--text)' 
              }}
              title={title}
            >
              {title}
            </h3>
            
            {/* Notes and Tags Indicators */}
            <div className="flex gap-0.5 flex-shrink-0">
              {item.userNotes && item.userNotes.trim() && (
                <span 
                  className="cursor-pointer hover:scale-110 transition-transform"
                  style={{ fontSize: 'var(--font-sm, 10px)' }}
                  title={`Notes: ${item.userNotes.substring(0, 50)}${item.userNotes.length > 50 ? '...' : ''}`}
                  onClick={() => actions?.onNotesEdit?.(item)}
                >
                  üìù
                </span>
              )}
              {item.tags && item.tags.length > 0 && (
                <span 
                  className="cursor-pointer hover:scale-110 transition-transform"
                  style={{ fontSize: 'var(--font-sm, 10px)' }}
                  title={`Tags: ${item.tags.join(', ')}`}
                  onClick={() => actions?.onNotesEdit?.(item)}
                >
                  üè∑Ô∏è
                </span>
              )}
            </div>
          </div>
          
          {/* Episode progress indicator for TV shows - only show on tab contexts, not home/search */}
          {item.mediaType === 'tv' && (context === 'tab-watching' || context === 'tab-want' || context === 'tab-watched' || context === 'tab-not') && (
            <div className="mb-1">
              <EpisodeProgressDisplay 
                showId={typeof item.id === 'string' ? parseInt(item.id) : item.id}
                compact={true}
              />
            </div>
          )}
          
          {/* List membership badge - only show in mixed contexts */}
          {shouldShowMembershipBadge(context) && (
            <div className="mb-1">
              <ListMembershipBadge item={item} />
            </div>
          )}
          
          <div 
            className="mt-0 flex items-center justify-between"
            style={{ fontSize: 'var(--font-sm, 11px)', color: 'var(--muted)' }}
          >
            <span>{year || 'TBA'}</span>
            {showRating && <span aria-label="rating">{rating || '‚Äî'}</span>}
          </div>
        </div>

        {/* Actions per context */}
        <CardActions context={context} item={item} actions={actions} />
        
        {/* Compact Actions - only visible when gate and flag are enabled */}
        <div className="compact-actions-container" style={{ padding: 'var(--space-1, 4px)' }}>
          <CompactPrimaryAction 
            item={item as any} 
            context={context === 'home' || context === 'tab-foryou' || context === 'search' ? 'home' : 'tab'}
            actions={actions}
          />
          {!disableOverflow && (
            <CompactOverflowMenu 
              item={item as any} 
              context={context === 'home' || context === 'tab-foryou' || context === 'search' ? 'home' : 'tab'}
              actions={actions}
            />
          )}
        </div>
      </div>
    </article>
  );

  // Mobile: wrap with SwipeableCard (swipe functionality + More menu)
  // Desktop: no wrapper at all (just the card + More menu)
  if (isDesktop || disableSwipe) {
    return cardContent;
  }

  return (
    <SwipeableCard
      item={item}
      actions={actions}
      context={context}
      disableSwipe={false}
    >
      {cardContent}
    </SwipeableCard>
  );
}

function CardActions({ context, item, actions }: { context: CardContext; item: MediaItem; actions?: CardActionHandlers }) {
  const translations = useTranslations();
  const [pressedButtons, setPressedButtons] = React.useState<Set<string>>(new Set());
  const [loadingButtons, setLoadingButtons] = React.useState<Set<string>>(new Set());
  
  const btn = (
    label: string,
    onClick?: () => void,
    testId?: string,
    isLoading = false,
    isSquare = false
  ) => {
    const buttonKey = `${testId}-${item.id}`;
    const isPressed = pressedButtons.has(buttonKey);
    const isLoadingState = loadingButtons.has(buttonKey) || isLoading;

    const handleClick = async () => {
      if (!onClick || isLoadingState) return;

      setPressedButtons(prev => new Set(prev).add(buttonKey));
      if (testId === 'act-watched' || testId === 'act-want') {
        setLoadingButtons(prev => new Set(prev).add(buttonKey));
      }
      try {
        await onClick();
      } finally {
        setTimeout(() => {
          setPressedButtons(prev => {
            const s = new Set(prev);
            s.delete(buttonKey);
            return s;
          });
          setLoadingButtons(prev => {
            const s = new Set(prev);
            s.delete(buttonKey);
            return s;
          });
        }, 150);
      }
    };

    const base =
      'inline-flex items-center justify-center rounded-xl border ' +
      'bg-[var(--btn)] text-[var(--text)] border-[var(--line)] ' +
      'shadow-sm transition-[transform,box-shadow,background-color] duration-150 ease-out ' +
      'hover:shadow-md hover:-translate-y-0.5 active:translate-y-0 active:shadow-inner ' +
      'focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 ' +
      'focus-visible:ring-[var(--accent)] disabled:opacity-60 disabled:cursor-not-allowed';

    const variant = isSquare
      ? 'w-[68px] h-[40px] sm:w-[72px] sm:h-[44px] p-1.5 text-[10px] leading-[1.05] text-center'
      : 'w-full h-9 px-3 text-[length:var(--font-sm,12px)] leading-tight font-medium tracking-tight';

    const state = isPressed ? 'translate-y-0.5 shadow-inner' : '';

    return (
      <button
        type="button"
        onClick={handleClick}
        className={`${base} ${variant} ${state}`}
        style={{
          backgroundColor: isPressed ? 'var(--btn-pressed, var(--btn))' : 'var(--btn)',
        }}
        data-testid={testId}
        disabled={isPressed || isLoadingState}
        aria-busy={isLoadingState || undefined}
      >
        {isLoadingState ? (
          <span className="inline-flex items-center gap-2">
            <span
              className="h-4 w-4 animate-spin rounded-full border-2 border-current border-t-transparent"
              aria-hidden="true"
            />
            {!isSquare && <span className="text-[length:var(--font-sm,11px)]">Working‚Ä¶</span>}
          </span>
        ) : (
          <span className="block px-0.5 text-center leading-[1.05] [text-wrap:balance] break-words">
            {label}
          </span>
        )}
      </button>
    );
  };

  // Map the context to a set of buttons, min 1, max 4 as per spec
  if (context === 'tab-watching') {
    return (
      <div
        className="actions grid grid-cols-2 justify-items-center gap-1.5 p-2"
        style={{ ['--btn-pressed' as any]: 'var(--accent-weak, var(--accent))' }}
        data-testid="cardv2-actions"
      >
        {btn(translations.wantToWatchAction, () => actions?.onWant?.(item), 'act-want', false, true)}
        {btn(translations.watchedAction, () => actions?.onWatched?.(item), 'act-watched', false, true)}
        {btn(translations.notInterestedAction, () => actions?.onNotInterested?.(item), 'act-not', false, true)}
        {btn(translations.deleteAction, () => actions?.onDelete?.(item), 'act-delete', false, true)}
      </div>
    );
  }

  if (context === 'tab-foryou' || context === 'search' || context === 'home') {
    return (
      <div className="actions grid grid-cols-2 gap-1 p-1" data-testid="cardv2-actions">
        {btn(translations.wantToWatchAction, () => actions?.onWant?.(item), 'act-want')}
        {btn(translations.watchedAction, () => actions?.onWatched?.(item), 'act-watched')}
      </div>
    );
  }

  if (context === 'holiday') {
    return (
        <div className="actions grid grid-cols-2 gap-1 p-1" data-testid="cardv2-actions">
        {btn(translations.watchedAction, () => actions?.onWatched?.(item), 'act-watched')}
        {btn(translations.removeAction, () => actions?.onDelete?.(item), 'act-delete')}
      </div>
    );
  }

  return <div className="p-2" />; // default no-op
}

```

## apps/web/src/lib/firebaseSync.ts
### Summary
Syncs local library/rating data to Firebase via debounced writes triggered by the `library:changed` event.
### Content
```ts
import { doc, setDoc, getDoc, serverTimestamp } from 'firebase/firestore';
import { db } from './firebaseBootstrap';
import type { LibraryEntry } from './storage';

/**
 * Firebase Sync Manager for V2
 * Handles syncing watchlists to/from Firestore with lean data structure
 * Based on V1 implementation with size limits and data pruning
 */

export class FirebaseSyncManager {
  private static instance: FirebaseSyncManager;
  private isInitialized = false;
  private syncInProgress = false;
  private syncTimeout: ReturnType<typeof setTimeout> | null = null;

  static getInstance(): FirebaseSyncManager {
    if (!FirebaseSyncManager.instance) {
      FirebaseSyncManager.instance = new FirebaseSyncManager();
    }
    return FirebaseSyncManager.instance;
  }

  /**
   * Get Firebase db instance - use direct import
   */
  private getFirebaseDb() {
    return db;
  }

  /**
   * Initialize the sync manager and set up event listeners
   */
  init() {
    if (this.isInitialized) return;
    this.isInitialized = true;
    
    // Listen for Library changes
    window.addEventListener('library:changed', (event: Event) => {
      const { uid, operation } = (event as CustomEvent).detail;
      console.log('üì° FirebaseSyncManager received library:changed event:', { uid, operation });
      this.syncToFirebase(uid);
    });
    
    console.log('üîÑ FirebaseSyncManager initialized with event listeners');
  }

  /**
   * Prune item data to essential fields only (based on V1 implementation)
   */
  private pruneItem(item: LibraryEntry): any {
    return {
      id: Number(item.id),
      media_type: item.mediaType,
      title: String(item.title || '').slice(0, 200),
      poster_path: item.posterUrl || null,
      release_date: item.year || null,
      vote_average: typeof item.voteAverage === 'number' ? item.voteAverage : null,
      user_rating: typeof item.userRating === 'number' ? item.userRating : null, // V2 addition
      added_date: item.addedAt ? new Date(item.addedAt).toISOString() : null,
      user_notes: item.userNotes || null, // V2 addition for user notes
      user_tags: item.tags || [], // V2 addition for user tags
      next_air_date: item.nextAirDate || null, // V2 addition for TV shows
      synopsis: item.synopsis || null, // V2 addition for show descriptions
      show_status: item.showStatus || null, // V2 addition for TV show status
      last_air_date: item.lastAirDate || null, // V2 addition for TV shows
      networks: item.networks || null, // V2 addition
      production_companies: item.productionCompanies || null, // V2 addition
    };
  }

  /**
   * Create lean watchlists structure for Firebase
   */
  private createLeanWatchlists(): any {
    const watchlists = {
      movies: {
        watching: [],
        wishlist: [],
        watched: [],
      },
      tv: {
        watching: [],
        wishlist: [],
        watched: [],
      },
      customLists: [], // Add custom list definitions
      customItems: {}, // FIXED: Store custom list items separately
    };

    // Get Library data from localStorage to avoid circular import
    try {
      const libraryData = JSON.parse(localStorage.getItem('flicklet.library.v2') || '{}');
      
      // Group by media type and list
      Object.values(libraryData).forEach((item: any) => {
        const prunedItem = this.pruneItem(item);
        
        if (item.list.startsWith('custom:')) {
          // FIXED: Store custom list items in separate structure
          const customListId = item.list.replace('custom:', '');
          if (!(watchlists as any).customItems[customListId]) {
            (watchlists as any).customItems[customListId] = [];
          }
          (watchlists as any).customItems[customListId].push(prunedItem);
        } else {
          // Standard lists (watching, wishlist, watched)
          if (item.mediaType === 'movie') {
            if (watchlists.movies[item.list as keyof typeof watchlists.movies]) {
              (watchlists.movies[item.list as keyof typeof watchlists.movies] as any).push(prunedItem);
            }
          } else if (item.mediaType === 'tv') {
            if (watchlists.tv[item.list as keyof typeof watchlists.tv]) {
              (watchlists.tv[item.list as keyof typeof watchlists.tv] as any).push(prunedItem);
            }
          }
        }
      });
      
      // Add custom list definitions
      const customListsData = localStorage.getItem('flicklet.customLists.v2');
      if (customListsData) {
        try {
          const customLists = JSON.parse(customListsData);
          watchlists.customLists = customLists.customLists || [];
        } catch (error) {
          console.warn('Failed to parse custom lists data:', error);
        }
      }
      
    } catch (error) {
      console.warn('Failed to read Library data from localStorage:', error);
    }

    return watchlists;
  }

  /**
   * Calculate payload size in bytes
   */
  private calculatePayloadSize(data: any): number {
    return new Blob([JSON.stringify(data)]).size;
  }

  /**
   * Save data to Firebase with size limits
   */
  async saveToFirebase(uid: string): Promise<boolean> {
    if (this.syncInProgress) {
      console.log('üîÑ Sync already in progress, skipping');
      return false;
    }

    try {
      this.syncInProgress = true;
      console.log('üíæ Starting Firebase sync for user:', uid);

      const watchlists = this.createLeanWatchlists();
      const payload = {
        watchlists,
        uid,
        lastUpdated: serverTimestamp(),
      };

      const sizeBytes = this.calculatePayloadSize(payload);
      const sizeKB = sizeBytes / 1024;

      console.log(`üìä Payload size: ${sizeKB.toFixed(1)} KB`);

      // V1 limit: 900KB
      if (sizeBytes > 900 * 1024) {
        console.warn(`‚ö†Ô∏è Payload too large (${sizeKB.toFixed(1)} KB), skipping Firebase save`);
        return false;
      }

      // Save to Firestore
      const firebaseDb = this.getFirebaseDb();
      
      const userRef = doc(firebaseDb, 'users', uid);
      await setDoc(userRef, payload, { merge: true });

      console.log(`‚úÖ Firebase sync successful: ${sizeKB.toFixed(1)} KB`);
      return true;

    } catch (error) {
      console.error('‚ùå Firebase sync failed:', error);
      return false;
    } finally {
      this.syncInProgress = false;
    }
  }

  /**
   * Load data from Firebase and merge with local
   */
  async loadFromFirebase(uid: string): Promise<boolean> {
    try {
      console.log('üì• Loading data from Firebase for user:', uid);

      const firebaseDb = this.getFirebaseDb();

      const userRef = doc(firebaseDb, 'users', uid);
      const userDoc = await getDoc(userRef);

      if (!userDoc.exists()) {
        console.log('üì≠ No Firebase data found for user');
        return false;
      }

      const cloudData = userDoc.data();
      console.log('‚òÅÔ∏è Cloud data loaded:', cloudData);

      if (!cloudData.watchlists) {
        console.log('üì≠ No watchlists in cloud data');
        return false;
      }

      // Merge cloud data with local Library
      await this.mergeCloudData(cloudData.watchlists);
      
      // Load game stats from Firebase
      if (cloudData.gameStats) {
        const { loadGameStatsFromFirebase } = await import('./gameStatsSync');
        await loadGameStatsFromFirebase(uid);
      }

      // Load settings from Firebase for cross-device sync
      const { settingsManager } = await import('./settings');
      await settingsManager.loadSettingsFromFirebase(uid);

      console.log('‚úÖ Firebase data loaded and merged');
      return true;

    } catch (error) {
      console.error('‚ùå Firebase load failed:', error);
      return false;
    }
  }

  /**
   * Merge cloud data with local Library
   */
  private async mergeCloudData(cloudWatchlists: any): Promise<void> {
    const lists = ['watching', 'wishlist', 'watched'] as const;
    
    // Get current Library data from localStorage
    const libraryData = JSON.parse(localStorage.getItem('flicklet.library.v2') || '{}');
    
    // First, clean up any existing duplicates in localStorage
    const cleanedData: Record<string, any> = {};
    const seenIds = new Set<string>();
    
    Object.values(libraryData).forEach((item: any) => {
      const itemId = `${item.mediaType}:${item.id}`;
      if (!seenIds.has(itemId)) {
        seenIds.add(itemId);
        const key = `${item.mediaType}:${item.id}`;
        cleanedData[key] = item;
      } else {
        console.log('üßπ Removing duplicate from localStorage:', item.title);
      }
    });
    
    console.log('üßπ Cleaned localStorage duplicates:', Object.keys(libraryData).length, '‚Üí', Object.keys(cleanedData).length);
    
    // Create a set of existing item IDs to prevent duplicates
    const existingIds = new Set<string>();
    Object.values(cleanedData).forEach((item: any) => {
      existingIds.add(`${item.mediaType}:${item.id}`);
    });
    
    console.log('üîç Existing items before merge:', existingIds.size);
    
    for (const list of lists) {
      // Merge movies
      if (cloudWatchlists.movies?.[list]) {
        for (const cloudItem of cloudWatchlists.movies[list]) {
          const key = `movie:${cloudItem.id}`;
          const itemId = `movie:${cloudItem.id}`;
          
          // Only add if not already in Library
          if (!existingIds.has(itemId)) {
            const localItem = {
              id: String(cloudItem.id),
              mediaType: 'movie',
              title: cloudItem.title,
              year: cloudItem.release_date,
              posterUrl: cloudItem.poster_path,
              voteAverage: cloudItem.vote_average,
              userRating: cloudItem.user_rating || undefined,
              synopsis: cloudItem.synopsis || '',
              list: list,
              addedAt: Date.now(),
            };
            
            cleanedData[key] = localItem;
            existingIds.add(itemId);
            console.log('‚ûï Added movie:', cloudItem.title);
          } else {
            console.log('‚è≠Ô∏è Skipping duplicate movie:', cloudItem.title);
          }
        }
      }

      // Merge TV shows
      if (cloudWatchlists.tv?.[list]) {
        for (const cloudItem of cloudWatchlists.tv[list]) {
          const key = `tv:${cloudItem.id}`;
          const itemId = `tv:${cloudItem.id}`;
          
          // Only add if not already in Library
          if (!existingIds.has(itemId)) {
            const localItem = {
              id: String(cloudItem.id),
              mediaType: 'tv',
              title: cloudItem.title,
              year: cloudItem.release_date,
              posterUrl: cloudItem.poster_path,
              voteAverage: cloudItem.vote_average,
              userRating: cloudItem.user_rating || undefined,
              synopsis: cloudItem.synopsis || '',
              showStatus: cloudItem.show_status,
              lastAirDate: cloudItem.last_air_date,
              nextAirDate: cloudItem.next_air_date,
              networks: cloudItem.networks,
              productionCompanies: cloudItem.production_companies,
              list: list,
              addedAt: Date.now(),
            };
            
            cleanedData[key] = localItem;
            existingIds.add(itemId);
            console.log('‚ûï Added TV show:', cloudItem.title);
          } else {
            console.log('‚è≠Ô∏è Skipping duplicate TV show:', cloudItem.title);
          }
        }
      }
    }
    
    // FIXED: Merge custom list items
    if (cloudWatchlists.customItems && typeof cloudWatchlists.customItems === 'object') {
      for (const [customListId, items] of Object.entries(cloudWatchlists.customItems)) {
        if (Array.isArray(items)) {
          for (const cloudItem of items) {
            const key = `${cloudItem.media_type}:${cloudItem.id}`;
            const itemId = `${cloudItem.media_type}:${cloudItem.id}`;
            
            // Only add if not already in Library
            if (!existingIds.has(itemId)) {
              const localItem = {
                id: String(cloudItem.id),
                mediaType: cloudItem.media_type,
                title: cloudItem.title || cloudItem.name,
                year: cloudItem.release_date || cloudItem.first_air_date,
                posterUrl: cloudItem.poster_path,
                voteAverage: cloudItem.vote_average,
                userRating: cloudItem.user_rating || undefined,
                synopsis: cloudItem.synopsis || '',
                showStatus: cloudItem.show_status,
                lastAirDate: cloudItem.last_air_date,
                nextAirDate: cloudItem.next_air_date,
                networks: cloudItem.networks,
                productionCompanies: cloudItem.production_companies,
                list: `custom:${customListId}`,
                addedAt: Date.now(),
              };
              
              cleanedData[key] = localItem;
              existingIds.add(itemId);
              console.log(`‚ûï Added custom list item: ${cloudItem.title || cloudItem.name} to ${customListId}`);
            } else {
              console.log(`‚è≠Ô∏è Skipping duplicate custom item: ${cloudItem.title || cloudItem.name}`);
            }
          }
        }
      }
    }
    
    console.log('üîç Total items after merge:', Object.keys(cleanedData).length);
    
    // Save cleaned data back to localStorage
    localStorage.setItem('flicklet.library.v2', JSON.stringify(cleanedData));
    
    // Restore custom lists if they exist in cloud data
    if (cloudWatchlists.customLists && Array.isArray(cloudWatchlists.customLists)) {
      try {
        const existingCustomLists = JSON.parse(localStorage.getItem('flicklet.customLists.v2') || '{}');
        const mergedCustomLists = {
          ...existingCustomLists,
          customLists: cloudWatchlists.customLists
        };
        localStorage.setItem('flicklet.customLists.v2', JSON.stringify(mergedCustomLists));
        console.log('üìã Restored custom lists from cloud:', cloudWatchlists.customLists.length);
        
        // Trigger custom lists update event
        window.dispatchEvent(new CustomEvent('customLists:updated'));
      } catch (error) {
        console.warn('Failed to restore custom lists:', error);
      }
    }
    
    // Reload Library state from localStorage to ensure UI updates
    // Skip emit() here - we'll batch both notifications together to prevent cascade
    const { Library } = await import('./storage');
    Library.reloadFromStorage(true); // Skip emit to batch with event
    
    // Batch both notifications together using requestAnimationFrame to prevent cascade
    // This ensures all updates happen in a single frame, preventing re-render loops
    requestAnimationFrame(() => {
      Library.notifyUpdate();
    });
  }

  /**
   * Sync data to Firebase (called after Library changes)
   */
  async syncToFirebase(uid: string): Promise<void> {
    console.log('üîÑ syncToFirebase called for uid:', uid);
    if (!this.isInitialized) {
      console.log('‚ö†Ô∏è FirebaseSyncManager not initialized');
      return;
    }

    // Debounce sync calls
    if (this.syncTimeout) {
      console.log('‚è≥ Sync already queued, clearing previous timeout');
      clearTimeout(this.syncTimeout);
    }

    this.syncTimeout = setTimeout(async () => {
      console.log('üöÄ Executing Firebase sync...');
      await this.saveToFirebase(uid);
    }, 1000); // 1 second debounce
  }
}

// Export singleton instance
export const firebaseSyncManager = FirebaseSyncManager.getInstance();
```

## apps/web/src/components/cards/mobile/TvCardMobile.tsx
### Summary
Mobile-optimized TV card layout that surfaces rating controls and discovery actions for the TV rail.
### Content
```tsx
import type { MediaItem, CardActionHandlers } from '../card.types';
import SwipeableCard from '../../SwipeableCard';
import { OptimizedImage } from '../../OptimizedImage';
import { getShowStatusInfo } from '../../../utils/showStatus';
import { CompactOverflowMenu } from '../../../features/compact/CompactOverflowMenu';
import StarRating from '../StarRating';
import { ProviderBadges } from '../ProviderBadge';
import { DragHandle } from '../DragHandle';
import MyListToggle from '../../MyListToggle';

// neutral 112x168 poster placeholder (SVG data URI)
const POSTER_PLACEHOLDER = 'data:image/svg+xml;utf8,' + encodeURIComponent(`
  <svg xmlns="http://www.w3.org/2000/svg" width="112" height="168" viewBox="0 0 112 168">
    <defs>
      <linearGradient id="g" x1="0" x2="0" y1="0" y2="1">
        <stop stop-color="#1f2937" offset="0"/>
        <stop stop-color="#111827" offset="1"/>
      </linearGradient>
    </defs>
    <rect width="112" height="168" fill="url(#g)"/>
    <rect x="8" y="8" width="96" height="152" rx="8" ry="8" fill="none" stroke="#374151" stroke-width="2"/>
    <g fill="#4B5563">
      <circle cx="56" cy="62" r="22"/>
      <rect x="28" y="96" width="56" height="12" rx="6"/>
      <rect x="36" y="116" width="40" height="10" rx="5"/>
    </g>
  </svg>
`);

/**
 * Process: TV Mobile Card
 * Purpose: TV-specific mobile card wrapper using CardBaseMobile
 * Data Source: MediaItem with TV-specific metadata
 * Update Path: Props passed from parent components
 * Dependencies: CardBaseMobile, getShowStatusInfo
 */

export interface TvCardMobileProps {
  item: MediaItem;
  actions?: CardActionHandlers;
  tabKey?: 'watching' | 'watched' | 'want';
  index?: number;
  onDragStart?: (e: React.DragEvent | React.TouchEvent, index: number) => void;
  onDragEnd?: () => void;
  onKeyboardReorder?: (direction: "up" | "down") => void;
  isDragging?: boolean;
}

export function TvCardMobile({ item, actions, tabKey = 'watching', index = 0, onDragStart, onDragEnd, onKeyboardReorder, isDragging }: TvCardMobileProps) {
  const { title, year, posterUrl, showStatus, userRating, synopsis } = item;
  
  // Get TV-specific meta information
  const getMetaText = () => {
    const yearText = year || 'TBA';
    return `${yearText} ‚Ä¢ TV Show`;
  };

  // Get TV-specific chips/badges
  const getChips = () => {
    const chips = [];
    
    // Only add show status badge if available (removed "TV SERIES" since meta already says "TV Show")
    const statusInfo = getShowStatusInfo(showStatus);
    if (statusInfo) {
      chips.push(
        <span
          key="status"
          className="badge"
          style={{
            fontSize: 'var(--font-xs, 10px)',
            fontWeight: '600',
            color: statusInfo.color,
            backgroundColor: statusInfo.backgroundColor,
            border: `1px solid ${statusInfo.backgroundColor}`,
            borderRadius: 'var(--radius-sm, 4px)',
            padding: '2px 6px'
          }}
        >
          {statusInfo.badge}
        </span>
      );
    }
    
    return chips;
  };

  const handleRatingChange = (rating: number) => {
    if (actions?.onRatingChange) {
      actions.onRatingChange(item, rating);
    }
  };

  // Convert tabKey to SwipeableCard context
  const getContextFromTabKey = (tabKey: 'watching' | 'watched' | 'want') => {
    switch (tabKey) {
      case 'watching': return 'tab-watching';
      case 'watched': return 'tab-watched';
      case 'want': return 'tab-want';
      default: return 'tab-watching';
    }
  };

  // Convert tabKey to currentListContext for MyListToggle (matches desktop TabCard behavior)
  const getCurrentListContext = (tabKey: 'watching' | 'watched' | 'want'): 'watching' | 'wishlist' | 'watched' | undefined => {
    switch (tabKey) {
      case 'watching': return 'watching';
      case 'want': return 'wishlist';
      case 'watched': return 'watched';
      default: return undefined;
    }
  };

  return (
    <SwipeableCard
      item={item}
      actions={actions}
      context={getContextFromTabKey(tabKey)}
    >
      <div 
        className="card-mobile" 
        style={{ position: 'relative', overflow: 'visible' }}
        data-item-index={index}
      >
        {/* Drag Handle - Mobile (always visible, dimmed; full opacity on touch-hold) */}
        {onDragStart && (
          <DragHandle
            itemId={String(item.id)}
            index={index}
            onDragStart={(e, idx) => {
              if ('touches' in e) {
                // Touch event - notify parent
                onDragStart(e as any, idx);
              } else {
                onDragStart(e as any, idx);
              }
            }}
            onDragEnd={onDragEnd}
            onKeyboardReorder={onKeyboardReorder}
            isDragging={isDragging}
            itemTitle={item.title}
            onTouchDragMove={(_e, _idx) => {
              // Touch drag move is handled by global listener in DragHandle
              // This callback is called to notify parent about potential drop target
            }}
          />
        )}
        
        {/* Poster Column */}
        <div className="poster-col" style={{ position: 'relative' }}>
          <OptimizedImage
            src={posterUrl || ''}
            alt={`${title} poster`}
            context="poster"
            fallbackSrc={POSTER_PLACEHOLDER}
            className="poster-image"
            loading="lazy"
          />
          {/* My List + button */}
          <MyListToggle 
            item={item} 
            currentListContext={getCurrentListContext(tabKey)}
          />
        </div>

        {/* Info Column */}
        <div className="info-col">
          <header>
            <h3>{title}</h3>
            <span className="meta">{getMetaText()}</span>
            {getChips().length > 0 && (
              <div style={{ display: 'flex', gap: '4px', flexWrap: 'wrap', marginTop: '8px' }}>
                {getChips()}
              </div>
            )}
            {/* Provider badges */}
            {item.networks && item.networks.length > 0 && (
              <ProviderBadges providers={item.networks} maxVisible={2} mediaType="tv" />
            )}
          </header>

          {/* Synopsis */}
          {synopsis && (
            <div className="synopsis">{synopsis}</div>
          )}

          <div className="mobile-actions-row" style={{ marginTop: '12px' }}>
            <StarRating
              value={userRating || 0}
              onChange={handleRatingChange}
              size="sm"
            />
          </div>
          
          <div className="mobile-overflow-position">
            <CompactOverflowMenu 
              item={item as any} 
              context={`tab-${tabKey}`}
              actions={actions}
              showText={false}
            />
          </div>
        </div>
      </div>
    </SwipeableCard>
  );
}

```

## apps/web/src/components/cards/mobile/MovieCardMobile.tsx
### Summary
Mobile-optimized movie card that mirrors rating/connect actions from the desktop variant.
### Content
```tsx
import type { MediaItem, CardActionHandlers } from '../card.types';
import SwipeableCard from '../../SwipeableCard';
import { OptimizedImage } from '../../OptimizedImage';
import { CompactOverflowMenu } from '../../../features/compact/CompactOverflowMenu';
import StarRating from '../StarRating';
import { ProviderBadges } from '../ProviderBadge';
import { DragHandle } from '../DragHandle';
import MyListToggle from '../../MyListToggle';

// neutral 112x168 poster placeholder (SVG data URI)
const POSTER_PLACEHOLDER = 'data:image/svg+xml;utf8,' + encodeURIComponent(`
  <svg xmlns="http://www.w3.org/2000/svg" width="112" height="168" viewBox="0 0 112 168">
    <defs>
      <linearGradient id="g" x1="0" x2="0" y1="0" y2="1">
        <stop stop-color="#1f2937" offset="0"/>
        <stop stop-color="#111827" offset="1"/>
      </linearGradient>
    </defs>
    <rect width="112" height="168" fill="url(#g)"/>
    <rect x="8" y="8" width="96" height="152" rx="8" ry="8" fill="none" stroke="#374151" stroke-width="2"/>
    <g fill="#4B5563">
      <circle cx="56" cy="62" r="22"/>
      <rect x="28" y="96" width="56" height="12" rx="6"/>
      <rect x="36" y="116" width="40" height="10" rx="5"/>
    </g>
  </svg>
`);

/**
 * Process: Movie Mobile Card
 * Purpose: Movie-specific mobile card wrapper using CardBaseMobile
 * Data Source: MediaItem with Movie-specific metadata
 * Update Path: Props passed from parent components
 * Dependencies: CardBaseMobile
 */

export interface MovieCardMobileProps {
  item: MediaItem;
  actions?: CardActionHandlers;
  tabKey?: 'watching' | 'watched' | 'want';
  index?: number;
  onDragStart?: (e: React.DragEvent | React.TouchEvent, index: number) => void;
  onDragEnd?: () => void;
  onKeyboardReorder?: (direction: "up" | "down") => void;
  isDragging?: boolean;
}

export function MovieCardMobile({ item, actions, tabKey = 'watching', index = 0, onDragStart, onDragEnd, onKeyboardReorder, isDragging }: MovieCardMobileProps) {
  const { title, year, posterUrl, userRating, synopsis } = item;
  
  // Get Movie-specific meta information
  const getMetaText = () => {
    const yearText = year || 'TBA';
    return `${yearText} ‚Ä¢ Movie`;
  };

  // Get Movie-specific chips/badges
  const getChips = () => {
    return []; // No badges for movies - meta already shows "Movie"
  };

  const handleRatingChange = (rating: number) => {
    if (actions?.onRatingChange) {
      actions.onRatingChange(item, rating);
    }
  };

  // Convert tabKey to SwipeableCard context
  const getContextFromTabKey = (tabKey: 'watching' | 'watched' | 'want') => {
    switch (tabKey) {
      case 'watching': return 'tab-watching';
      case 'watched': return 'tab-watched';
      case 'want': return 'tab-want';
      default: return 'tab-watching';
    }
  };

  // Convert tabKey to currentListContext for MyListToggle (matches desktop TabCard behavior)
  const getCurrentListContext = (tabKey: 'watching' | 'watched' | 'want'): 'watching' | 'wishlist' | 'watched' | undefined => {
    switch (tabKey) {
      case 'watching': return 'watching';
      case 'want': return 'wishlist';
      case 'watched': return 'watched';
      default: return undefined;
    }
  };

  return (
    <SwipeableCard
      item={item}
      actions={actions}
      context={getContextFromTabKey(tabKey)}
    >
      <div 
        className="card-mobile" 
        style={{ position: 'relative', overflow: 'visible' }}
        data-item-index={index}
      >
        {/* Drag Handle - Mobile (always visible, dimmed; full opacity on touch-hold) */}
        {onDragStart && (
          <DragHandle
            itemId={String(item.id)}
            index={index}
            onDragStart={(e, idx) => {
              if ('touches' in e) {
                // Touch event - notify parent
                onDragStart(e as any, idx);
              } else {
                onDragStart(e as any, idx);
              }
            }}
            onDragEnd={onDragEnd}
            onKeyboardReorder={onKeyboardReorder}
            isDragging={isDragging}
            itemTitle={item.title}
            onTouchDragMove={(_e, _idx) => {
              // Touch drag move is handled by global listener in DragHandle
              // This callback is called to notify parent about potential drop target
            }}
          />
        )}
        
        {/* Poster Column */}
        <div className="poster-col" style={{ position: 'relative' }}>
          <OptimizedImage
            src={posterUrl || ''}
            alt={`${title} poster`}
            context="poster"
            fallbackSrc={POSTER_PLACEHOLDER}
            className="poster-image"
            loading="lazy"
          />
          {/* My List + button */}
          <MyListToggle 
            item={item} 
            currentListContext={getCurrentListContext(tabKey)}
          />
        </div>

        {/* Info Column */}
        <div className="info-col">
          <header>
            <h3>{title}</h3>
            <span className="meta">{getMetaText()}</span>
            {getChips().length > 0 && (
              <div style={{ display: 'flex', gap: '4px', flexWrap: 'wrap', marginTop: '8px' }}>
                {getChips()}
              </div>
            )}
            {/* Provider badges */}
            {item.networks && item.networks.length > 0 && (
              <ProviderBadges providers={item.networks} maxVisible={2} mediaType="movie" />
            )}
          </header>

          {/* Synopsis */}
          {synopsis && (
            <div className="synopsis">{synopsis}</div>
          )}

          <div className="mobile-actions-row" style={{ marginTop: '12px' }}>
            <StarRating
              value={userRating || 0}
              onChange={handleRatingChange}
              size="sm"
            />
          </div>
          
          <div className="mobile-overflow-position">
            <CompactOverflowMenu 
              item={item as any} 
              context={`tab-${tabKey}`}
              actions={actions}
              showText={false}
            />
          </div>
        </div>
      </div>
    </SwipeableCard>
  );
}

```

## apps/web/src/components/cards/TabCard.tsx
### Summary
Tab-specific card used in list views‚Äîthe layout surfaces voteAverage and shortcuts to rating discovery actions.
### Content
```tsx
import React, { useState, useEffect } from "react";
import type { CardActionHandlers, MediaItem } from "./card.types";
import { useTranslations } from "../../lib/language";
import { useSettings } from "../../lib/settings";
import { Library } from "../../lib/storage";
import StarRating from "./StarRating";
import MyListToggle from "../MyListToggle";
import { useIsDesktop } from "../../hooks/useDeviceDetection";
import SwipeableCard from "../SwipeableCard";
import { OptimizedImage } from "../OptimizedImage";
import { trackOpenFromReturning } from "@/lib/analytics";
import { isCompactMobileV1, isActionsSplit } from "../../lib/mobileFlags";
import { isMobileNow } from "../../lib/isMobile";
import { dlog } from "../../lib/log";
import { TvCardMobile } from "./mobile/TvCardMobile";
import { MovieCardMobile } from "./mobile/MovieCardMobile";
import { ProviderBadges } from "./ProviderBadge";
import { startProUpgrade } from "../../lib/proUpgrade";
import { useProStatus } from "../../lib/proStatus";

export type TabCardProps = {
  item: MediaItem;
  actions?: CardActionHandlers;
  tabType?: "watching" | "want" | "watched" | "returning" | "discovery";
  index?: number;
  dragState?: {
    draggedItem: { id: string; index: number } | null;
    draggedOverIndex: number | null;
    isDragging: boolean;
  };
  onDragStart?: (e: React.DragEvent, index: number) => void;
  onDragEnd?: (e: React.DragEvent) => void;
  onDragOver?: (e: React.DragEvent, index: number) => void;
  onDragLeave?: (e: React.DragEvent) => void;
  onDrop?: (e: React.DragEvent) => void;
  onKeyboardReorder?: (direction: "up" | "down") => void;
};

/**
 * TabCard ‚Äî horizontal card layout for tab pages
 * - Poster on left (160px wide, 2:3 aspect ratio)
 * - Content on right with title, meta, overview, actions
 * - Matches the design mockups exactly
 * 
 * Badge contexts:
 * - TabCard does NOT render ListMembershipBadge (list-specific contexts)
 * - Used in: Watching tab, Want to Watch tab, Watched tab, Returning tab, My Lists detail pages
 * - MyListToggle button still shows current list membership via button text
 */
export default function TabCard({
  item,
  actions,
  tabType = "watching",
  index = 0,
  dragState,
  onDragStart,
  onDragEnd,
  onDragOver,
  onDragLeave,
  onDrop,
  onKeyboardReorder,
}: TabCardProps) {
  const proStatus = useProStatus();
  const isPro = proStatus.isPro;

  dlog("üîî TabCard render:", {
    title: item.title,
    mediaType: item.mediaType,
    hasOnNotificationToggle: !!actions?.onNotificationToggle,
  });

  // Get latest rating from library to ensure we have the most up-to-date value
  const [currentRating, setCurrentRating] = useState(item.userRating);

  // Subscribe to library changes to update rating immediately
  useEffect(() => {
    const updateRating = () => {
      const latestEntry = Library.getEntry(item.id, item.mediaType);
      if (latestEntry?.userRating !== undefined) {
        setCurrentRating(latestEntry.userRating);
      }
    };

    // Update immediately
    updateRating();

    // Subscribe to library changes
    const unsubscribe = Library.subscribe(updateRating);

    return () => {
      unsubscribe();
    };
  }, [item.id, item.mediaType]);

  const { title, year, posterUrl, voteAverage, synopsis, mediaType } = item;
  const userRating = currentRating; // Use the latest rating
  const rating =
    typeof voteAverage === "number"
      ? Math.round(voteAverage * 10) / 10
      : undefined;
  const translations = useTranslations();
  const settings = useSettings();
  const { ready, isDesktop } = useIsDesktop(); // Device detection for conditional swipe
  // DEBUG: isDesktop available for desktop state detection

  const handleRatingChange = (rating: number) => {
    if (actions?.onRatingChange) {
      actions.onRatingChange(item, rating);
    }
  };

  const getTabSpecificActions = () => {
    switch (tabType) {
      case "watching":
        return (
          <>
            <button
              onClick={() => actions?.onWant?.(item)}
              className={buttonClass}
              style={{
                backgroundColor: "var(--btn)",
                color: "var(--text)",
                borderColor: "var(--line)",
                border: "1px solid",
              }}
            >
              {isCondensed ? "Want" : translations.wantToWatchAction}
            </button>
            <button
              onClick={() => actions?.onWatched?.(item)}
              className={buttonClass}
              style={{
                backgroundColor: "var(--btn)",
                color: "var(--text)",
                borderColor: "var(--line)",
                border: "1px solid",
              }}
            >
              {isCondensed ? "Watched" : translations.watchedAction}
            </button>
            <button
              onClick={() => actions?.onNotInterested?.(item)}
              className={buttonClass}
              style={{
                backgroundColor: "var(--btn)",
                color: "var(--text)",
                borderColor: "var(--line)",
                border: "1px solid",
              }}
            >
              {isCondensed ? "Not" : translations.notInterestedAction}
            </button>
            {!isCondensed && (
              <button
                onClick={() => actions?.onNotesEdit?.(item)}
                className={buttonClass}
                style={{
                  backgroundColor: "var(--btn)",
                  color: "var(--text)",
                  borderColor: "var(--line)",
                  border: "1px solid",
                }}
              >
                üìù Notes & Tags
              </button>
            )}
            {/* Simple reminder for TV shows (Free feature) */}
            {mediaType === "tv" && (
              <button
                onClick={() => {
                  dlog(
                    "‚è∞ TabCard simple reminder button clicked for:",
                    item.title
                  );
                  actions?.onSimpleReminder?.(item);
                }}
                className={buttonClass}
                style={{
                  backgroundColor: "var(--btn)",
                  color: "var(--text)",
                  borderColor: "var(--line)",
                  border: "1px solid",
                }}
                title="Set simple reminder (24 hours before)"
              >
                ‚è∞ Remind Me
              </button>
            )}
          </>
        );
      case "want":
        return (
          <>
            <button
              onClick={() => {
                // Move to watching list
                if (item.id && item.mediaType) {
                  Library.move(item.id, item.mediaType, "watching");
                }
              }}
              className={buttonClass}
              style={{
                backgroundColor: "var(--btn)",
                color: "var(--text)",
                borderColor: "var(--line)",
                border: "1px solid",
              }}
            >
              {isCondensed ? "Watching" : translations.currentlyWatchingAction}
            </button>
            <button
              onClick={() => actions?.onWatched?.(item)}
              className={buttonClass}
              style={{
                backgroundColor: "var(--btn)",
                color: "var(--text)",
                borderColor: "var(--line)",
                border: "1px solid",
              }}
            >
              {isCondensed ? "Watched" : translations.watchedAction}
            </button>
            <button
              onClick={() => actions?.onNotInterested?.(item)}
              className={buttonClass}
              style={{
                backgroundColor: "var(--btn)",
                color: "var(--text)",
                borderColor: "var(--line)",
                border: "1px solid",
              }}
            >
              {isCondensed ? "Not" : translations.notInterestedAction}
            </button>
            {!isCondensed && (
              <button
                onClick={() => actions?.onNotesEdit?.(item)}
                className={buttonClass}
                style={{
                  backgroundColor: "var(--btn)",
                  color: "var(--text)",
                  borderColor: "var(--line)",
                  border: "1px solid",
                }}
              >
                üìù Notes & Tags
              </button>
            )}
            {/* Simple reminder for TV shows (Free feature) */}
            {mediaType === "tv" && (
              <button
                onClick={() => {
                  dlog(
                    "‚è∞ TabCard simple reminder button clicked for:",
                    item.title
                  );
                  actions?.onSimpleReminder?.(item);
                }}
                className={buttonClass}
                style={{
                  backgroundColor: "var(--btn)",
                  color: "var(--text)",
                  borderColor: "var(--line)",
                  border: "1px solid",
                }}
                title="Set simple reminder (24 hours before)"
              >
                ‚è∞ Remind Me
              </button>
            )}
          </>
        );
      case "watched":
        return (
          <>
            <button
              onClick={() => actions?.onWant?.(item)}
              className={buttonClass}
              style={{
                backgroundColor: "var(--btn)",
                color: "var(--text)",
                borderColor: "var(--line)",
                border: "1px solid",
              }}
            >
              {isCondensed ? "Want" : translations.wantToWatchAction}
            </button>
            <button
              onClick={() => {
                // Move to watching list
                if (item.id && item.mediaType) {
                  Library.move(item.id, item.mediaType, "watching");
                }
              }}
              className={buttonClass}
              style={{
                backgroundColor: "var(--btn)",
                color: "var(--text)",
                borderColor: "var(--line)",
                border: "1px solid",
              }}
            >
              {isCondensed ? "Watching" : translations.currentlyWatchingAction}
            </button>
            <button
              onClick={() => actions?.onNotInterested?.(item)}
              className={buttonClass}
              style={{
                backgroundColor: "var(--btn)",
                color: "var(--text)",
                borderColor: "var(--line)",
                border: "1px solid",
              }}
            >
              {isCondensed ? "Not" : translations.notInterestedAction}
            </button>
            {!isCondensed && (
              <button
                onClick={() => actions?.onNotesEdit?.(item)}
                className={buttonClass}
                style={{
                  backgroundColor: "var(--btn)",
                  color: "var(--text)",
                  borderColor: "var(--line)",
                  border: "1px solid",
                }}
              >
                üìù Notes & Tags
              </button>
            )}
            {/* Simple reminder for TV shows (Free feature) */}
            {mediaType === "tv" && (
              <button
                onClick={() => {
                  dlog(
                    "‚è∞ TabCard simple reminder button clicked for:",
                    item.title
                  );
                  actions?.onSimpleReminder?.(item);
                }}
                className={buttonClass}
                style={{
                  backgroundColor: "var(--btn)",
                  color: "var(--text)",
                  borderColor: "var(--line)",
                  border: "1px solid",
                }}
                title="Set simple reminder (24 hours before)"
              >
                ‚è∞ Remind Me
              </button>
            )}
          </>
        );
      case "discovery":
        return (
          <>
            <button
              onClick={() => actions?.onWant?.(item)}
              className={buttonClass}
              style={{
                backgroundColor: "var(--btn)",
                color: "var(--text)",
                borderColor: "var(--line)",
                border: "1px solid",
              }}
            >
              {isCondensed ? "Want" : translations.wantToWatchAction}
            </button>
            <button
              onClick={() => actions?.onWant?.(item)}
              className={buttonClass}
              style={{
                backgroundColor: "var(--btn)",
                color: "var(--text)",
                borderColor: "var(--line)",
                border: "1px solid",
              }}
            >
              {isCondensed ? "Watching" : translations.currentlyWatchingAction}
            </button>
            <button
              onClick={() => actions?.onWatched?.(item)}
              className={buttonClass}
              style={{
                backgroundColor: "var(--btn)",
                color: "var(--text)",
                borderColor: "var(--line)",
                border: "1px solid",
              }}
            >
              {isCondensed ? "Watched" : translations.watchedAction}
            </button>
            <button
              onClick={() => actions?.onNotInterested?.(item)}
              className={buttonClass}
              style={{
                backgroundColor: "var(--btn)",
                color: "var(--text)",
                borderColor: "var(--line)",
                border: "1px solid",
              }}
            >
              {isCondensed ? "Not" : translations.notInterestedAction}
            </button>
          </>
        );
      default:
        return null;
    }
  };

  // Determine if this card is being dragged or is a drop target
  const isBeingDragged = dragState?.draggedItem?.id === item.id;
  const isDropTarget = dragState?.draggedOverIndex === index && !isBeingDragged;
  const isDragging = dragState?.isDragging;

  // Map tabType to context for swipe actions
  const getSwipeContext = ():
    | "tab-watching"
    | "tab-want"
    | "tab-watched"
    | "tab-foryou"
    | "search"
    | "home"
    | "holiday" => {
    switch (tabType) {
      case "watching":
        return "tab-watching";
      case "want":
        return "tab-want";
      case "watched":
        return "tab-watched";
      case "discovery":
        return "tab-foryou";
      default:
        return "tab-watching";
    }
  };

  const isCondensed = settings.layout.condensedView;

  // Define buttonClass at component level so it can be used throughout
  const buttonClass = isCondensed
    ? "px-3 py-2 rounded-lg text-xs cursor-pointer transition-all duration-150 ease-out hover:scale-105 active:scale-95 active:shadow-inner hover:shadow-md"
    : "px-4 py-2.5 rounded-xl text-xs cursor-pointer transition-all duration-150 ease-out hover:scale-105 active:scale-95 active:shadow-inner hover:shadow-md";

  // Mobile detection for new mobile cards
  const isMobileCompact = isCompactMobileV1();
  const actionsSplit = isActionsSplit();
  const isMobile = isMobileNow();

  // Convert tabType to tabKey for mobile components
  const getTabKey = (tabType: string): "watching" | "watched" | "want" => {
    switch (tabType) {
      case "watching":
        return "watching";
      case "watched":
        return "watched";
      case "want":
        return "want";
      default:
        return "watching";
    }
  };

  // Guard: wait for viewport detection to avoid hydration mismatch
  if (!ready) {
    // Render a neutral skeleton that works on both mobile and desktop
    return (
      <article
        className="tab-card"
        data-card="skeleton"
        style={{
          display: "flex",
          gap: "16px",
          padding: "16px",
          borderRadius: "16px",
          backgroundColor: "var(--card)",
          border: "1px solid var(--line)",
          minHeight: "180px",
        }}
      >
        <div
          style={{
            width: "160px",
            height: "240px",
            backgroundColor: "var(--muted)",
            borderRadius: "8px",
            flexShrink: 0,
          }}
        />
        <div style={{ flex: 1 }} />
      </article>
    );
  }

  // TEMPORARY: Force mobile components on mobile viewport (bypass flags for testing)
  if (!isDesktop && isMobile) {
    dlog("üì± Mobile viewport detected, using mobile components:", {
      mediaType,
      title: item.title,
      isMobileCompact,
      isActionsSplit: actionsSplit,
    });
    if (mediaType === "tv") {
      return (
        <TvCardMobile
          item={item}
          actions={actions}
          tabKey={getTabKey(tabType)}
          index={index}
          onDragStart={(e, idx) => {
            // Convert TouchEvent to DragEvent-like for useDragAndDrop
            if ("touches" in e) {
              // Touch event - create synthetic drag event
              const syntheticEvent = {
                ...e,
                dataTransfer: {
                  setData: () => {},
                  effectAllowed: "move",
                },
                preventDefault: () => {},
              } as any;
              onDragStart?.(syntheticEvent, idx);
            } else {
              onDragStart?.(e, idx);
            }
          }}
          onDragEnd={() => onDragEnd?.({} as React.DragEvent)}
          onKeyboardReorder={onKeyboardReorder}
          isDragging={isBeingDragged}
        />
      );
    } else if (mediaType === "movie") {
      return (
        <MovieCardMobile
          item={item}
          actions={actions}
          tabKey={getTabKey(tabType)}
          index={index}
          onDragStart={(e, idx) => {
            // Convert TouchEvent to DragEvent-like for useDragAndDrop
            if ("touches" in e) {
              // Touch event - create synthetic drag event
              const syntheticEvent = {
                ...e,
                dataTransfer: {
                  setData: () => {},
                  effectAllowed: "move",
                },
                preventDefault: () => {},
              } as any;
              onDragStart?.(syntheticEvent, idx);
            } else {
              onDragStart?.(e, idx);
            }
          }}
          onDragEnd={() => onDragEnd?.({} as React.DragEvent)}
          onKeyboardReorder={onKeyboardReorder}
          isDragging={isBeingDragged}
        />
      );
    }
  }

  // Use new mobile components when mobile flags are enabled (original logic)
  if (isMobileCompact && actionsSplit && isMobile) {
    if (mediaType === "tv") {
      return (
        <TvCardMobile
          item={item}
          actions={actions}
          tabKey={getTabKey(tabType)}
        />
      );
    } else if (mediaType === "movie") {
      return (
        <MovieCardMobile
          item={item}
          actions={actions}
          tabKey={getTabKey(tabType)}
        />
      );
    }
  }

  // Card content (shared between mobile and desktop)
  const cardContent = (
    <article
      className={`card-desktop tab-card group relative ${
        isBeingDragged ? "is-dragging" : ""
      } ${isDropTarget ? "is-drop-target" : ""}`}
      data-testid="tab-card"
      data-card-type="tab"
      aria-label={title}
      style={{
        touchAction: "pan-y",
      }}
      draggable={false}
      // Note: Drag handlers moved to wrapper div in ListPage for proper drop zone
      // Keeping these for backward compatibility but they may not fire if wrapper handles it first
      onDragOver={(e) => {
        // Only handle if not already handled by wrapper
        e.stopPropagation();
        onDragOver?.(e, index);
        // Add aria-dropeffect for accessibility
        if (isDropTarget && e.currentTarget instanceof HTMLElement) {
          e.currentTarget.setAttribute("aria-dropeffect", "move");
        }
      }}
      onDragLeave={(e) => {
        onDragLeave?.(e);
        // Clear aria-dropeffect when leaving
        if (e.currentTarget instanceof HTMLElement) {
          e.currentTarget.removeAttribute("aria-dropeffect");
        }
      }}
      onDrop={(e) => {
        e.stopPropagation();
        onDrop?.(e);
        // Clear aria-dropeffect on drop
        if (e.currentTarget instanceof HTMLElement) {
          e.currentTarget.removeAttribute("aria-dropeffect");
        }
      }}
      aria-grabbed={isBeingDragged}
    >
      {/* Poster Column */}
      <div
        className="poster-col"
        role="img"
        aria-label={title}
        onClick={(e) => {
          // Don't open TMDB if clicking on a button inside the poster
          if ((e.target as HTMLElement).closest("button")) {
            return;
          }
          if (item.id && item.mediaType) {
            if (tabType === "returning") {
              trackOpenFromReturning(item.id, item.title);
            }
            const tmdbUrl = `https://www.themoviedb.org/${item.mediaType}/${item.id}`;
            window.open(tmdbUrl, "_blank", "noopener,noreferrer");
          }
        }}
      >
        {posterUrl ? (
          <OptimizedImage
            src={posterUrl}
            alt={title}
            context="poster"
            className="h-full w-full"
            loading="lazy"
          />
        ) : (
          <div
            className="flex h-full w-full items-center justify-center text-xs"
            style={{ color: "var(--muted)", minHeight: "240px" }}
          >
            {translations.noPoster}
          </div>
        )}

        {/* My List + button */}
        <MyListToggle 
          item={item} 
          currentListContext={
            tabType === "watching" ? "watching" :
            tabType === "want" ? "wishlist" :
            tabType === "watched" ? "watched" :
            undefined
          }
        />
      </div>

      {/* Info Column */}
      <div className="info-col relative">
        <header>
          <h3>{title}</h3>
          <div className="flex items-center gap-2">
            <span className="meta">
              {year || "TBA"} ‚Ä¢ {mediaType === "tv" ? "TV Show" : "Movie"}
            </span>

            {/* Status badge for TV shows */}
            {mediaType === "tv" && item.showStatus && (
              <span className="status-badge">
                {item.showStatus === "Returning Series" && "RETURNING"}
                {item.showStatus === "Ended" && "COMPLETE"}
                {item.showStatus === "In Production" && "IN PRODUCTION"}
                {item.showStatus === "Canceled" && "CANCELED"}
                {item.showStatus === "Planned" && "UPCOMING"}
              </span>
            )}
          </div>

          {/* Provider badges */}
          {item.networks && item.networks.length > 0 && (
            <ProviderBadges
              providers={item.networks}
              maxVisible={3}
              mediaType={
                mediaType === "tv" || mediaType === "movie" ? mediaType : "tv"
              }
            />
          )}

          {/* Notes and Tags Indicators */}
          <div className="flex gap-1">
            {item.userNotes && item.userNotes.trim() && (
              <span
                className="text-xs cursor-pointer hover:scale-110 transition-transform"
                title={`Notes: ${item.userNotes.substring(0, 100)}${item.userNotes.length > 100 ? "..." : ""}`}
                onClick={() => actions?.onNotesEdit?.(item)}
              >
                üìù
              </span>
            )}
            {item.tags && item.tags.length > 0 && (
              <span
                className="text-xs cursor-pointer hover:scale-110 transition-transform"
                title={`Tags: ${item.tags.join(", ")}`}
                onClick={() => actions?.onNotesEdit?.(item)}
              >
                üè∑Ô∏è
              </span>
            )}
          </div>
        </header>

        {/* Rating Row */}
        {(tabType === "watching" || tabType === "watched") && (
          <div className="rating-row">
            <StarRating
              value={userRating || 0}
              onChange={handleRatingChange}
              size="sm"
            />
            {rating && <span className="rating-score ml-2">({rating}/10)</span>}
          </div>
        )}

        {/* Synopsis - Description */}
        {synopsis ? (
          <div className="synopsis-wrapper" style={{ flexGrow: 1 }}>
            <p className="synopsis">{synopsis}</p>
          </div>
        ) : (
          <div className="synopsis-wrapper" style={{ flexGrow: 1 }} />
        )}

        {/* Buttons Container - Bottom Aligned */}
        <div className="buttons-container">
          {/* Actions Row */}
          <div className="actions-row">
            {/* Tab-specific primary actions */}
            {getTabSpecificActions()}

            {/* Episode tracking (conditional) */}
            {mediaType === "tv" && (
              <button
                onClick={() => actions?.onEpisodeTracking?.(item)}
                className={buttonClass}
                style={{
                  backgroundColor: "var(--btn)",
                  color:
                    settings.layout.episodeTracking || settings.pro.isPro
                      ? "var(--text)"
                      : "var(--muted)",
                  borderColor: "var(--line)",
                  border: "1px solid",
                  opacity:
                    settings.layout.episodeTracking || settings.pro.isPro
                      ? 1
                      : 0.6,
                }}
                disabled={
                  !settings.layout.episodeTracking && !settings.pro.isPro
                }
                title={
                  settings.layout.episodeTracking || settings.pro.isPro
                    ? "Track episode progress"
                    : "Enable episode tracking in settings"
                }
              >
                Episode Progress
              </button>
            )}
          </div>

          {/* Pro Strip - with dotted yellow border */}
          {!isCondensed && (
            <div className="pro-buttons-row">
              <button
                onClick={() => {
                  if (isPro && settings.pro.features.bloopersAccess) {
                    actions?.onGoofsOpen?.(item);
                  } else {
                    startProUpgrade();
                  }
                }}
                title={
                  isPro && settings.pro.features.bloopersAccess
                    ? "View goofs and slip-ups"
                    : "Pro feature - upgrade to unlock"
                }
                className={buttonClass}
                style={{
                  backgroundColor: "var(--btn)",
                  color: "var(--text)",
                  borderColor: "var(--line)",
                  border: "1px solid",
                  opacity:
                    isPro && settings.pro.features.bloopersAccess ? 1 : 0.65,
                  cursor: "pointer",
                }}
              >
                Goofs
              </button>
              <button
                onClick={() => {
                  if (isPro && settings.pro.features.extrasAccess) {
                    actions?.onExtrasOpen?.(item);
                  } else {
                    startProUpgrade();
                  }
                }}
                title={
                  isPro && settings.pro.features.extrasAccess
                    ? "View behind-the-scenes content"
                    : "Pro feature - upgrade to unlock"
                }
                className={buttonClass}
                style={{
                  backgroundColor: "var(--btn)",
                  color: "var(--text)",
                  borderColor: "var(--line)",
                  border: "1px solid",
                  opacity:
                    isPro && settings.pro.features.extrasAccess ? 1 : 0.65,
                  cursor: "pointer",
                }}
              >
                Extras
              </button>
              <button
                onClick={() => {
                  if (isPro) {
                    actions?.onNotificationToggle?.(item);
                  } else {
                    startProUpgrade();
                  }
                }}
                title={
                  isPro
                    ? "Advanced notifications with custom timing"
                    : "Pro feature - upgrade to unlock"
                }
                className={buttonClass}
                style={{
                  backgroundColor: "var(--btn)",
                  color: "var(--text)",
                  borderColor: "var(--line)",
                  border: "1px solid",
                  opacity: isPro ? 1 : 0.65,
                  cursor: "pointer",
                }}
              >
                Advanced Notifications
              </button>
            </div>
          )}
        </div>

        {/* Drag handle - Desktop only, shows on hover/focus */}
        {isDesktop && (
          <div
            className={`handle absolute top-1/4 right-2 transform -translate-y-1/2 cursor-grab text-lg transition-all duration-200 ${
              isDragging ? "cursor-grabbing" : "cursor-grab"
            } ${isBeingDragged ? "is-dragging" : ""}`}
            style={{
              color: isBeingDragged ? "var(--accent)" : "var(--muted)",
              width: "36px",
              height: "36px",
              display: "flex",
              alignItems: "center",
              justifyContent: "center",
              borderRadius: "6px",
              border: "1px solid transparent",
              backgroundColor: "transparent",
              transition: "all 0.2s ease",
            }}
            onMouseEnter={(e) => {
              if (!isBeingDragged) {
                e.currentTarget.style.borderColor = "var(--line)";
                e.currentTarget.style.backgroundColor = "color-mix(in srgb, var(--accent) 10%, transparent)";
              }
            }}
            onMouseLeave={(e) => {
              if (!isBeingDragged) {
                e.currentTarget.style.borderColor = "transparent";
                e.currentTarget.style.backgroundColor = "transparent";
              }
            }}
            title="Drag to reorder (Arrow Up/Down to move with keyboard)"
            aria-label="Drag to reorder. Press Arrow Up or Down to move with keyboard."
            tabIndex={0}
            draggable={true}
            onDragStart={(e) => {
              e.stopPropagation();
              e.dataTransfer.setData("text/plain", String(item.id)); // DEBUG: required for some browsers
              e.dataTransfer.effectAllowed = "move";
              onDragStart?.(e, index);
            }}
            onDragEnd={() => onDragEnd?.({} as React.DragEvent)}
            onKeyDown={(e) => {
              if (e.key === "ArrowUp" || e.key === "ArrowDown") {
                e.preventDefault();
                e.stopPropagation();
                onKeyboardReorder?.(e.key === "ArrowUp" ? "up" : "down");
              }
            }}
            role="button"
            aria-grabbed={isBeingDragged}
          >
            <span style={{ fontSize: "20px", lineHeight: "1", fontWeight: "600", letterSpacing: "-0.5px" }}>‚ãÆ‚ãÆ</span>
          </div>
        )}

        {/* Delete button - bottom right */}
        <button
          onClick={() => actions?.onDelete?.(item)}
          className="absolute bottom-3 right-3 px-4 py-2.5 rounded-lg text-xs cursor-pointer transition-all duration-150 ease-out hover:scale-105 active:scale-95 active:shadow-inner hover:shadow-md font-semibold"
          style={{
            backgroundColor: "var(--btn)",
            color: "#ef4444",
            borderColor: "#ef4444",
            border: "1px solid",
          }}
          title="Delete this item"
        >
          üóëÔ∏è Delete
        </button>
      </div>
    </article>
  );

  // Mobile: wrap with SwipeableCard (swipe functionality)
  // Desktop: no wrapper at all (just the card + More menu)
  if (isDesktop && ready) {
    return cardContent;
  }

  return (
    <SwipeableCard
      item={item}
      actions={actions}
      context={getSwipeContext()}
      className={isCondensed ? "mb-3" : "mb-5"}
    >
      {cardContent}
    </SwipeableCard>
  );
}

```

## apps/web/src/pages/ListPage.tsx
### Summary
Full-page list view (watching/wishlist/watched) that sorts and filters items by rating, date, and tags with card tiles.
### Content
```tsx
import TabCard from "@/components/cards/TabCard";
import UpNextCard from "@/components/cards/UpNextCard";
import type { MediaItem } from "@/components/cards/card.types";
import { Library, LibraryEntry } from "@/lib/storage";
import { useSettings, getPersonalityText } from "@/lib/settings";
import { useDragAndDrop } from "@/hooks/useDragAndDrop";
import ScrollToTopArrow from "@/components/ScrollToTopArrow";
import { EpisodeTrackingModal } from "@/components/modals/EpisodeTrackingModal";
import { getTVShowDetails } from "@/lib/tmdb";
import {
  useState,
  useMemo,
  useEffect,
  useCallback,
  useRef,
  useLayoutEffect,
} from "react";
import ErrorBoundary from "@/components/ErrorBoundary";
import SortDropdown, { type SortMode } from "@/components/SortDropdown";
import ListFilters, { type ListFiltersState } from "@/components/ListFilters";
import {
  getTabKey,
  restoreTabState,
  saveTabState,
  resetTabState,
  validateFilters,
  type TabState,
} from "@/lib/tabState";
import {
  trackSortChange,
  trackFilterChange,
  trackReorderCompleted,
  trackTabStateReset,
} from "@/lib/analytics";
import { flushPendingSaves } from "@/lib/storage";

export default function ListPage({
  title,
  items,
  mode = "watching",
  onNotesEdit,
  onTagsEdit,
  onNotificationToggle,
  onSimpleReminder,
  onBloopersOpen,
  onGoofsOpen,
  onExtrasOpen,
}: {
  title: string;
  items: LibraryEntry[];
  mode?: "watching" | "want" | "watched" | "returning" | "discovery";
  onNotesEdit?: (item: MediaItem) => void;
  onTagsEdit?: (item: MediaItem) => void;
  onNotificationToggle?: (item: MediaItem) => void;
  onSimpleReminder?: (item: MediaItem) => void;
  onBloopersOpen?: (item: MediaItem) => void;
  onGoofsOpen?: (item: MediaItem) => void;
  onExtrasOpen?: (item: MediaItem) => void;
}) {
  const settings = useSettings();
  const [selectedTag, setSelectedTag] = useState<string | null>(null);
  const [sortByTag, setSortByTag] = useState<boolean>(false);
  const [episodeModalOpen, setEpisodeModalOpen] = useState(false);
  const [selectedShow, setSelectedShow] = useState<MediaItem | null>(null);
  const [showDetails, setShowDetails] = useState<any>(null);

  const tabKey = getTabKey(mode);

  // Get available item IDs for validation
  const availableItemIds = useMemo(() => {
    const ids = new Set<string>();
    items.forEach((item) => {
      ids.add(String(item.id));
      ids.add(`${item.id}:${item.mediaType}`);
    });
    return ids;
  }, [items]);

  // Restore tab state using unified utilities
  const [tabState, setTabStateInternal] = useState<TabState>(() => {
    return restoreTabState(tabKey, availableItemIds);
  });

  const [sortMode, setSortMode] = useState<SortMode>(tabState.sort);
  const [filters, setFilters] = useState<ListFiltersState>(tabState.filter);

  // Map mode to CardV2 context
  // const context = mode === 'watching' ? 'tab-watching' : 'tab-foryou'; // Unused

  // Get all unique tags from items
  const allTags = useMemo(() => {
    const tagSet = new Set<string>();
    items.forEach((item) => {
      if (item.tags) {
        item.tags.forEach((tag) => tagSet.add(tag));
      }
    });
    return Array.from(tagSet).sort();
  }, [items]);

  // Get all unique providers from items
  const availableProviders = useMemo(() => {
    const providerSet = new Set<string>();
    items.forEach((item) => {
      if (item.networks && Array.isArray(item.networks)) {
        item.networks.forEach((provider) => {
          if (provider && typeof provider === "string") {
            providerSet.add(provider);
          }
        });
      }
    });
    return Array.from(providerSet).sort();
  }, [items]);

  // Reload tab state when tab changes
  useEffect(() => {
    const restored = restoreTabState(tabKey, availableItemIds);
    setTabStateInternal(restored);
    setSortMode(restored.sort);
    // Validate filters against available providers on mount
    const validatedFilters = validateFilters(
      restored.filter,
      availableProviders
    );
    setFilters(validatedFilters);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [tabKey]);

  // Handler for sort mode change with confirmation
  const handleSortModeChange = useCallback(
    (newMode: SortMode) => {
      // If changing from custom to another mode, confirm first
      if (sortMode === "custom" && newMode !== "custom") {
        const confirmed = window.confirm(
          "Changing the sort mode will reset your custom order. Continue?"
        );
        if (!confirmed) {
          return; // User cancelled
        }
        // Reset custom order
        const listName = getListName(mode);
        if (listName) {
          Library.resetCustomOrder(listName);
        }
        trackSortChange(tabKey, newMode, sortMode);
      } else if (newMode !== sortMode) {
        trackSortChange(tabKey, newMode, sortMode);
      }

      setSortMode(newMode);
      saveTabState(tabKey, { sort: newMode });
    },
    [sortMode, tabKey, mode]
  );

  // Handler for filter change with validation and telemetry
  const handleFilterChange = useCallback(
    (newFilters: ListFiltersState) => {
      // Validate filters against available providers
      const validatedFilters = validateFilters(newFilters, availableProviders);
      setFilters(validatedFilters);
      saveTabState(tabKey, { filter: validatedFilters });
      trackFilterChange(
        tabKey,
        validatedFilters.type,
        validatedFilters.providers.length
      );
    },
    [tabKey, availableProviders]
  );

  // Persist sort mode changes
  useEffect(() => {
    saveTabState(tabKey, { sort: sortMode });
  }, [sortMode, tabKey]);

  // Persist filter changes (already handled by handleFilterChange, but keep for safety)
  useEffect(() => {
    saveTabState(tabKey, { filter: filters });
  }, [filters, tabKey]);

  // Stable sort function with secondary sort key
  const stableSort = useCallback(
    (items: LibraryEntry[], mode: SortMode): LibraryEntry[] => {
      if (mode === "custom") {
        // Custom mode: maintain original order (as set by drag-and-drop)
        return [...items];
      }

      // Create a copy with original indices for stable sorting
      const itemsWithIndex = items.map((item, index) => ({
        item,
        originalIndex: index,
      }));

      // Sort based on mode
      itemsWithIndex.sort((a, b) => {
        let primaryComparison = 0;

        switch (mode) {
          case "date-newest":
            // Newest first (larger addedAt first)
            primaryComparison = (b.item.addedAt || 0) - (a.item.addedAt || 0);
            break;
          case "date-oldest":
            // Oldest first (smaller addedAt first)
            primaryComparison = (a.item.addedAt || 0) - (b.item.addedAt || 0);
            break;
          case "alphabetical-az":
            // A to Z
            primaryComparison = (a.item.title || "").localeCompare(
              b.item.title || "",
              undefined,
              { sensitivity: "base" }
            );
            break;
          case "alphabetical-za":
            // Z to A
            primaryComparison = (b.item.title || "").localeCompare(
              a.item.title || "",
              undefined,
              { sensitivity: "base" }
            );
            break;
          case "streaming-service": {
            // Sort by first streaming service (alphabetically)
            const aService =
              a.item.networks && a.item.networks.length > 0
                ? a.item.networks[0].toLowerCase()
                : "zzz_no_service"; // Items without services go to end
            const bService =
              b.item.networks && b.item.networks.length > 0
                ? b.item.networks[0].toLowerCase()
                : "zzz_no_service";
            primaryComparison = aService.localeCompare(bService, undefined, {
              sensitivity: "base",
            });
            break;
          }
          default:
            primaryComparison = 0;
        }

        // If primary sort is equal, use secondary sort key (item ID for stability)
        if (primaryComparison === 0) {
          const aId = String(a.item.id);
          const bId = String(b.item.id);
          return aId.localeCompare(bId);
        }

        return primaryComparison;
      });

      return itemsWithIndex.map(({ item }) => item);
    },
    []
  );

  // Filter and sort items
  const processedItems = useMemo(() => {
    let result = items;

    // Apply type filter (AND logic)
    if (filters.type !== "all") {
      result = result.filter((item) => item.mediaType === filters.type);
    }

    // Apply provider filter (AND logic - item must have at least one selected provider)
    if (filters.providers.length > 0) {
      result = result.filter((item) => {
        if (
          !item.networks ||
          !Array.isArray(item.networks) ||
          item.networks.length === 0
        ) {
          return false; // Items without providers are excluded when providers are selected
        }
        // Check if item has at least one of the selected providers
        return filters.providers.some((provider) =>
          item.networks!.some(
            (network) =>
              network &&
              typeof network === "string" &&
              network.toLowerCase() === provider.toLowerCase()
          )
        );
      });
    }

    // Filter by selected tag (AND logic)
    if (selectedTag) {
      result = result.filter(
        (item) => item.tags && item.tags.includes(selectedTag)
      );
    }

    // Sort by tag if enabled (takes priority over sort mode)
    if (sortByTag) {
      result = [...result].sort((a, b) => {
        const aHasTags = a.tags && a.tags.length > 0;
        const bHasTags = b.tags && b.tags.length > 0;

        // Items with tags come first
        if (aHasTags && !bHasTags) return -1;
        if (!aHasTags && bHasTags) return 1;

        // If both have tags, sort alphabetically by first tag
        if (aHasTags && bHasTags) {
          const aFirstTag = a.tags![0].toLowerCase();
          const bFirstTag = b.tags![0].toLowerCase();
          return aFirstTag.localeCompare(bFirstTag);
        }

        // If neither has tags, maintain original order
        return 0;
      });
    } else {
      // Apply sort mode (only if not sorting by tag)
      result = stableSort(result, sortMode);
    }

    return result;
  }, [items, filters, selectedTag, sortByTag, sortMode, stableSort]);

  // Map mode to Library list name
  const getListName = (
    mode: string
  ): "watching" | "wishlist" | "watched" | null => {
    switch (mode) {
      case "watching":
        return "watching";
      case "want":
        return "wishlist";
      case "watched":
        return "watched";
      case "returning":
        // Returning is not a standard ListName, return null
        return null;
      default:
        return null;
    }
  };

  // Drag and drop functionality
  const handleReorder = useCallback(
    (fromIndex: number, toIndex: number) => {
      if (mode !== "discovery") {
        // Capture positions BEFORE reorder (critical for FLIP animation)
        const cardMap = cardRefs.current;
        const currentRects = new Map<string, DOMRect>();
        processedItems.forEach((item) => {
          const el = cardMap.get(String(item.id));
          if (el) {
            currentRects.set(String(item.id), el.getBoundingClientRect());
          }
        });
        prevRects.current = currentRects;
        pendingReorderRef.current = { fromIndex, toIndex };

        console.log("[ListPage] Captured positions before reorder", {
          fromIndex,
          toIndex,
          rectCount: currentRects.size,
        });

        // When user manually reorders, switch to Custom mode
        handleSortModeChange("custom");
        const listName = getListName(mode);
        if (listName) {
          Library.reorder(listName, fromIndex, toIndex);
        }

        // Track reorder completion
        trackReorderCompleted(tabKey, fromIndex, toIndex);

        // Clear pending reorder after animation completes
        setTimeout(() => {
          pendingReorderRef.current = null;
        }, 500);
      }
    },
    [mode, processedItems, handleSortModeChange, tabKey]
  );

  const {
    dragState,
    handleDragStart,
    handleDragEnd: originalHandleDragEnd,
    handleDragOver,
    handleDragLeave,
    handleDrop,
  } = useDragAndDrop(
    processedItems.map((item) => ({ ...item, id: String(item.id) })),
    handleReorder
  );

  // Wrap handleDragEnd to flush pending saves on drop completion
  const handleDragEnd = useCallback(
    (e: React.DragEvent) => {
      originalHandleDragEnd(e);
      // Flush pending saves immediately after drop completes
      flushPendingSaves();
      if (import.meta.env.DEV) {
        // eslint-disable-next-line no-console
        console.info("[reorder] flushed on drop completion");
      }
    },
    [originalHandleDragEnd]
  );

  // Aria-live region for accessibility announcements
  const [ariaAnnouncement, setAriaAnnouncement] = useState<string>("");

  // Keyboard reordering
  const cardRefs = useRef<Map<string, HTMLElement>>(new Map()); // Track by item ID, not index
  const prevRects = useRef<Map<string, DOMRect>>(new Map());
  const pendingReorderRef = useRef<{
    fromIndex: number;
    toIndex: number;
  } | null>(null);
  const getItemElement = useCallback(
    (index: number) => {
      const item = processedItems[index];
      return item ? cardRefs.current.get(String(item.id)) || null : null;
    },
    [processedItems]
  );

  const announceChange = useCallback((message: string) => {
    setAriaAnnouncement(message);
    // Clear after announcement is read
    setTimeout(() => setAriaAnnouncement(""), 1000);
  }, []);

  const handleKeyboardReorder = useCallback(
    (fromIndex: number, toIndex: number) => {
      handleReorder(fromIndex, toIndex);
      const item = processedItems[fromIndex];
      const direction = toIndex > fromIndex ? "down" : "up";
      announceChange(
        `${item.title} moved ${direction}, now at position ${toIndex + 1} of ${processedItems.length}`
      );

      // Maintain focus on handle after reorder
      // Use setTimeout to allow DOM to update first
      setTimeout(() => {
        const newElement = getItemElement(toIndex);
        if (newElement) {
          const handle = newElement.querySelector(
            ".handle, .drag-handle"
          ) as HTMLElement;
          if (handle) {
            handle.focus();
          }
        }
      }, 50);
    },
    [processedItems, handleReorder, announceChange, getItemElement]
  );

  // Stable item IDs array for FLIP dependency (prevents unnecessary re-runs)
  const itemIds = useMemo(
    () => processedItems.map((i) => String(i.id)),
    [processedItems]
  );

  // FLIP animation for smooth reorder transitions
  // Disabled during active drag to prevent conflicts with drag transform
  // Feature flag: drag-animation-v1 (enabled by default, can be disabled for rollback)
  const isAnimationDisabled = useMemo(() => {
    // Check if explicitly disabled: if flag exists and is 'false', disable animation
    if (typeof window !== "undefined") {
      try {
        const flagValue = localStorage.getItem("flag:drag-animation-v1");
        return flagValue === "false";
      } catch {
        // Ignore localStorage errors
      }
    }
    return false; // Default: animation enabled
  }, []);

  useLayoutEffect(() => {
    if (!processedItems.length || dragState.isDragging || isAnimationDisabled) {
      console.log("[ListPage] FLIP skipped", {
        hasItems: !!processedItems.length,
        isDragging: dragState.isDragging,
        isDisabled: isAnimationDisabled,
      });
      return;
    }

    // Only run FLIP if we have a pending reorder (prevents running on every render)
    if (!pendingReorderRef.current) {
      console.log("[ListPage] FLIP skipped - no pending reorder");
      return;
    }

    console.log("[ListPage] FLIP running", {
      itemCount: processedItems.length,
      itemIds: itemIds.join(","),
      pendingReorder: pendingReorderRef.current,
    });

    const cardMap = cardRefs.current;
    const prevMap = prevRects.current; // This was captured BEFORE reorder in handleReorder
    const nextRects = new Map<string, DOMRect>();

    // 2. Let React commit the reorder (positions are already captured in handleReorder)
    requestAnimationFrame(() => {
      // 3. Read new positions - track by item ID (after reorder)
      processedItems.forEach((item) => {
        const el = cardMap.get(String(item.id));
        if (el) {
          nextRects.set(String(item.id), el.getBoundingClientRect());
        }
      });

      // 4. Animate each card that moved with enhanced effects
      let animatedCount = 0;
      const animatedCards: Array<{
        el: HTMLElement;
        itemId: string;
        index: number;
      }> = [];

      // First pass: collect all cards that need animation
      nextRects.forEach((nextRect, itemId) => {
        const prevRect = prevMap.get(itemId);
        if (!prevRect) {
          console.log("[ListPage] FLIP no prevRect for", itemId);
          return;
        }

        const dx = prevRect.left - nextRect.left;
        const dy = prevRect.top - nextRect.top;
        if (dx === 0 && dy === 0) {
          console.log("[ListPage] FLIP no movement for", itemId);
          return;
        }

        const el = cardMap.get(itemId);
        if (!el) {
          console.log("[ListPage] FLIP no element for", itemId);
          return;
        }

        // Find index of this item for stagger calculation
        const itemIndex = processedItems.findIndex(
          (item) => String(item.id) === itemId
        );
        animatedCards.push({
          el,
          itemId,
          index: itemIndex >= 0 ? itemIndex : 0,
        });
      });

      // Sort by index for proper stagger order
      animatedCards.sort((a, b) => a.index - b.index);

      // Second pass: apply FLIP animation with enhanced effects
      animatedCards.forEach(({ el, itemId, index }) => {
        const prevRect = prevMap.get(itemId);
        const nextRect = nextRects.get(itemId);
        if (!prevRect || !nextRect) return;

        const dx = prevRect.left - nextRect.left;
        const dy = prevRect.top - nextRect.top;
        const distance = Math.sqrt(dx * dx + dy * dy);

        // Dynamic duration based on distance (medium priority)
        // Base duration 0.3s, scales with distance up to 0.6s
        const baseDuration = 0.3;
        const maxDuration = 0.6;
        const duration = Math.min(baseDuration + distance / 1500, maxDuration);

        // Calculate rotation angle based on direction (flip effect)
        const rotationAngle =
          Math.abs(dy) > Math.abs(dx)
            ? dy > 0
              ? -3
              : 3 // Rotate based on vertical movement
            : dx > 0
              ? -2
              : 2; // Rotate based on horizontal movement

        // Stagger delay: 20ms per card (high priority)
        const staggerDelay = index * 20;

        console.log("[ListPage] FLIP animating card", {
          itemId,
          dx,
          dy,
          distance,
          duration,
          rotationAngle,
          staggerDelay,
        });

        // FLIP: INVERT - Set initial state with flip and scale
        // Add perspective for 3D effect
        el.style.perspective = "1000px";
        el.style.transform = `translate(${dx}px, ${dy}px) rotateX(${rotationAngle}deg) scale(0.95)`;
        el.style.transition = "transform 0s, opacity 0s";
        el.style.opacity = "0.9";
        // Ensure z-index is elevated during animation (below modals)
        el.style.zIndex = "100"; // Matches --z-dragging token
        el.style.position = "relative";
        el.style.transformStyle = "preserve-3d";

        // Stagger the animation start
        setTimeout(() => {
          requestAnimationFrame(() => {
            // FLIP: PLAY - Smooth animated transition with spring physics
            // Spring easing: cubic-bezier(.34, 1.56, .64, 1) creates bounce effect
            el.style.transition = `transform ${duration}s cubic-bezier(.34, 1.56, .64, 1), opacity ${duration}s ease-out`;
            el.style.transform = "translate(0, 0) rotateX(0deg) scale(1)";
            el.style.opacity = "1";

            el.addEventListener(
              "transitionend",
              () => {
                if (el) {
                  el.style.transition = "";
                  el.style.zIndex = "";
                  el.style.position = "";
                  el.style.perspective = "";
                  el.style.transformStyle = "";
                  el.style.opacity = "";
                  animatedCount++;
                  console.log("[ListPage] FLIP animation complete", {
                    itemId,
                    animatedCount,
                  });
                }
              },
              { once: true }
            );
          });
        }, staggerDelay);
      });

      if (animatedCount === 0) {
        console.log("[ListPage] FLIP no cards moved", {
          prevMapSize: prevMap.size,
          nextRectsSize: nextRects.size,
          itemIds: Array.from(nextRects.keys()),
        });
      }

      // 5. Store for next flip
      prevRects.current = nextRects;
    });
  }, [itemIds.join(","), dragState.isDragging, isAnimationDisabled]); // re-run only when order changes or drag ends

  // Listen for touch drag over events from DragHandle
  useEffect(() => {
    const handleTouchDragOver = (e: Event) => {
      const customEvent = e as CustomEvent;
      console.log("[ListPage] touchdragover", customEvent.detail);
      if (customEvent.detail && dragState.isDragging) {
        const targetIndex = customEvent.detail.targetIndex;
        if (targetIndex >= 0 && targetIndex !== dragState.draggedItem?.index) {
          const syntheticEvent = {
            preventDefault: () => {},
            stopPropagation: () => {},
            dataTransfer: { dropEffect: "move" },
            currentTarget: customEvent.target,
          } as any;
          handleDragOver(syntheticEvent, targetIndex);
        }
      }
    };

    document.addEventListener(
      "touchdragover",
      handleTouchDragOver as EventListener
    );
    return () => {
      document.removeEventListener(
        "touchdragover",
        handleTouchDragOver as EventListener
      );
    };
  }, [dragState, handleDragOver]);

  // Get appropriate empty state text based on title
  const getEmptyText = () => {
    if (mode === "returning") {
      return "No returning shows yet. When a series is confirmed, it‚Äôll show up here automatically.";
    }
    if (title.toLowerCase().includes("watching")) {
      return getPersonalityText("emptyWatching", settings.personalityLevel);
    } else if (
      title.toLowerCase().includes("wishlist") ||
      title.toLowerCase().includes("want")
    ) {
      return getPersonalityText("emptyWishlist", settings.personalityLevel);
    } else if (title.toLowerCase().includes("watched")) {
      return getPersonalityText("emptyWatched", settings.personalityLevel);
    } else if (title.toLowerCase().includes("not interested")) {
      return (
        getPersonalityText("empty", settings.personalityLevel) ||
        "No items marked as not interested yet."
      );
    }
    return getPersonalityText("empty", settings.personalityLevel);
  };

  // Action handlers using new Library system
  const actions = {
    onWant: (item: MediaItem) => {
      if (item.id && item.mediaType) {
        Library.move(item.id, item.mediaType, "wishlist");
      }
    },
    onWatched: (item: MediaItem) => {
      if (item.id && item.mediaType) {
        Library.move(item.id, item.mediaType, "watched");
      }
    },
    onNotInterested: (item: MediaItem) => {
      if (item.id && item.mediaType) {
        Library.move(item.id, item.mediaType, "not");
      }
    },
    onDelete: (item: MediaItem) => {
      if (item.id && item.mediaType) {
        Library.remove(item.id, item.mediaType);
      }
    },
    onRatingChange: (item: MediaItem, rating: number) => {
      if (item.id && item.mediaType) {
        Library.updateRating(item.id, item.mediaType, rating);
      }
    },
    onNotesEdit: onNotesEdit,
    onTagsEdit: onTagsEdit,
    onEpisodeTracking: async (item: MediaItem) => {
      if (item.mediaType === "tv") {
        setSelectedShow(item);
        setEpisodeModalOpen(true);

        // Fetch real show details from TMDB
        try {
          const showId =
            typeof item.id === "string" ? parseInt(item.id) : item.id;
          const details = await getTVShowDetails(showId);
          setShowDetails(details);
        } catch (error) {
          console.error("Failed to fetch show details:", error);
          // Still open modal with basic info
          setShowDetails({
            id: typeof item.id === "string" ? parseInt(item.id) : item.id,
            name: item.title,
            number_of_seasons: 1,
            number_of_episodes: 1,
          });
        }
      }
    },
    onNotificationToggle: onNotificationToggle,
    onSimpleReminder: onSimpleReminder,
    onBloopersOpen: onBloopersOpen,
    onGoofsOpen: onGoofsOpen,
    onExtrasOpen: onExtrasOpen,
  };

  return (
    <section className="px-4 py-4">
      <div className="flex items-center justify-between mb-3 flex-wrap gap-3">
        <div className="flex items-center gap-3 flex-wrap">
          <h1
            className="text-base font-semibold"
            style={{ color: "var(--text)" }}
          >
            {title}
          </h1>
          {sortByTag && (
            <span
              className="px-2 py-1 rounded-full text-xs font-medium"
              style={{ backgroundColor: "var(--accent)", color: "white" }}
            >
              üè∑Ô∏è Sorted by Tag
            </span>
          )}
        </div>

        <div className="flex items-center gap-3 flex-wrap">
          {/* Sort Dropdown - only show for tabbed lists (not discovery, not returning) */}
          {mode !== "discovery" && mode !== "returning" && (
            <>
              <SortDropdown
                value={sortMode}
                onChange={handleSortModeChange}
                disabled={sortByTag}
              />
              {/* Unified Reset to Default button - shows when any custom state exists */}
              {(sortMode === "custom" ||
                filters.type !== "all" ||
                filters.providers.length > 0) && (
                <button
                  onClick={() => {
                    const confirmed = window.confirm(
                      "Reset sort, filters, and custom order to defaults?"
                    );
                    if (!confirmed) return;

                    // Reset all state
                    const defaultState = resetTabState(tabKey);
                    const listName = getListName(mode);
                    if (listName) {
                      Library.resetCustomOrder(listName);
                    }
                    setSortMode(defaultState.sort);
                    setFilters(defaultState.filter);

                    // Track reset
                    trackTabStateReset(tabKey);

                    // Reload items to reflect default order
                    window.location.reload();
                  }}
                  className="px-3 py-1.5 rounded text-xs font-medium transition-colors"
                  style={{
                    backgroundColor: "var(--btn)",
                    color: "var(--text)",
                    border: "1px solid var(--line)",
                  }}
                  title="Reset to default (sort, filters, and order)"
                  aria-label="Reset to default sort, filters, and order"
                >
                  Reset to Default
                </button>
              )}
            </>
          )}

          {/* Filters - only show for tabbed lists (not discovery, not returning) */}
          {mode !== "discovery" && mode !== "returning" && (
            <ListFilters
              value={filters}
              onChange={handleFilterChange}
              availableProviders={availableProviders}
              disabled={sortByTag}
            />
          )}

          {/* Tag Controls */}
          {allTags.length > 0 && (
            <div className="flex items-center gap-3">
              {/* Sort by Tag Toggle */}
              <label className="flex items-center gap-2 cursor-pointer">
                <input
                  type="checkbox"
                  checked={sortByTag}
                  onChange={(e) => {
                    setSortByTag(e.target.checked);
                    // If disabling sort by tag, restore sort mode
                    if (!e.target.checked && sortMode === "custom") {
                      // Keep custom mode if it was set
                    }
                  }}
                  className="rounded"
                />
                <span className="text-sm" style={{ color: "var(--muted)" }}>
                  Sort by tag
                </span>
              </label>

              {/* Tag Filter */}
              <div className="flex items-center gap-2">
                <span className="text-sm" style={{ color: "var(--muted)" }}>
                  Filter by tag:
                </span>
                <select
                  value={selectedTag || ""}
                  onChange={(e) => setSelectedTag(e.target.value || null)}
                  className="px-2 py-1 rounded text-sm border"
                  style={{
                    backgroundColor: "var(--menu-bg)",
                    borderColor: "var(--menu-border)",
                    color: "var(--menu-text)",
                  }}
                >
                  <option value="">All items</option>
                  {allTags.map((tag) => (
                    <option
                      key={tag}
                      value={tag}
                      style={{
                        backgroundColor: "var(--menu-bg)",
                        color: "var(--menu-text)",
                      }}
                    >
                      {tag}
                    </option>
                  ))}
                </select>
                {(selectedTag || sortByTag) && (
                  <button
                    onClick={() => {
                      setSelectedTag(null);
                      setSortByTag(false);
                    }}
                    className="text-xs px-2 py-1 rounded"
                    style={{
                      backgroundColor: "var(--btn)",
                      color: "var(--text)",
                      borderColor: "var(--line)",
                      border: "1px solid",
                    }}
                  >
                    Clear All
                  </button>
                )}
              </div>
            </div>
          )}
        </div>
      </div>

      {processedItems.length > 0 ? (
        <ErrorBoundary
          name="MobileList"
          onReset={() => {
            // ListPage receives data as props, so parent component should handle refetch
            // This will reset the error boundary state
          }}
        >
          {mode === "returning" ? (
            <div className="flex gap-3 overflow-x-auto pb-2 scrollbar-thin scrollbar-thumb-gray-300 scrollbar-track-transparent">
              {processedItems.slice(0, 12).map((item) => {
                const mediaItem: MediaItem = {
                  id: item.id,
                  mediaType: item.mediaType,
                  title: item.title,
                  posterUrl: item.posterUrl,
                  year: item.year,
                  voteAverage: item.voteAverage,
                  userRating: item.userRating,
                  synopsis: item.synopsis,
                  nextAirDate: item.nextAirDate,
                  showStatus: item.showStatus,
                  lastAirDate: item.lastAirDate,
                  userNotes: item.userNotes,
                  tags: item.tags,
                };
                return (
                  <div
                    key={`${item.mediaType}:${item.id}:${item.nextAirDate}`}
                    className="flex-shrink-0"
                  >
                    <UpNextCard item={mediaItem} />
                  </div>
                );
              })}
            </div>
          ) : (
            <>
              {/* Aria-live region for accessibility announcements */}
              <div
                role="status"
                aria-live="polite"
                aria-atomic="true"
                className="sr-only"
                style={{
                  position: "absolute",
                  left: "-10000px",
                  width: "1px",
                  height: "1px",
                  overflow: "hidden",
                }}
              >
                {ariaAnnouncement}
              </div>

              <div className="space-y-3">
                {processedItems.map((item, index) => {
                  // LibraryEntry already has all MediaItem properties
                  const mediaItem: MediaItem = {
                    id: item.id,
                    mediaType: item.mediaType,
                    title: item.title,
                    posterUrl: item.posterUrl,
                    year: item.year,
                    voteAverage: item.voteAverage,
                    userRating: item.userRating,
                    synopsis: item.synopsis,
                    nextAirDate: item.nextAirDate,
                    showStatus: item.showStatus, // ‚úÖ ADD THIS
                    lastAirDate: item.lastAirDate, // ‚úÖ ADD THIS
                    userNotes: item.userNotes, // Pass notes
                    tags: item.tags, // Pass tags
                    networks: item.networks, // ‚úÖ ADD THIS - Pass networks for provider badges
                    productionCompanies: item.productionCompanies, // ‚úÖ ADD THIS
                  };

                  // Check if this item is being dragged (compare by id, not index, since index changes during reorder)
                  const isBeingDragged = dragState.draggedItem?.id === item.id;
                  console.log("[ListPage] Rendering item", {
                    itemId: item.id,
                    index,
                    isBeingDragged,
                    draggedItemId: dragState.draggedItem?.id,
                  });

                  // Check if this item is a drop target
                  const isDropTarget =
                    dragState.draggedOverIndex === index && !isBeingDragged;

                  return (
                    <div
                      key={item.id}
                      ref={(el) => {
                        if (el) cardRefs.current.set(String(item.id), el);
                        else cardRefs.current.delete(String(item.id));
                      }}
                      data-item-index={index}
                      className={`${isBeingDragged ? "is-dragging" : ""} ${isDropTarget ? "is-drop-target" : ""}`} // Add CSS classes for animations
                      role="listitem"
                      aria-posinset={index + 1}
                      aria-setsize={processedItems.length}
                      // Drag and drop handlers on wrapper for proper drop zone
                      onDragOver={(e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        e.dataTransfer.dropEffect = "move";
                        // Add aria-dropeffect for screen readers when this is a valid drop target
                        if (
                          isDropTarget &&
                          e.currentTarget instanceof HTMLElement
                        ) {
                          e.currentTarget.setAttribute(
                            "aria-dropeffect",
                            "move"
                          );
                        }
                        console.log("[ListPage] wrapper onDragOver", {
                          index,
                          draggedItem: dragState.draggedItem,
                        });
                        handleDragOver(e, index);
                      }}
                      onDragLeave={(e) => {
                        console.log("[ListPage] wrapper onDragLeave", {
                          index,
                        });
                        // Clear aria-dropeffect when leaving
                        if (e.currentTarget instanceof HTMLElement) {
                          e.currentTarget.removeAttribute("aria-dropeffect");
                        }
                        handleDragLeave(e);
                      }}
                      onDrop={(e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        // Clear aria-dropeffect on drop
                        if (e.currentTarget instanceof HTMLElement) {
                          e.currentTarget.removeAttribute("aria-dropeffect");
                        }
                        console.log("[ListPage] wrapper onDrop", {
                          index,
                          draggedItem: dragState.draggedItem,
                        });
                        handleDrop(e);
                      }}
                      aria-dropeffect={isDropTarget ? "move" : undefined}
                      onTouchEnd={(e) => {
                        // Handle touch drag end
                        if (
                          dragState.isDragging &&
                          dragState.draggedOverIndex !== null
                        ) {
                          const syntheticEvent = {
                            preventDefault: () => {},
                            stopPropagation: () => {},
                            currentTarget: e.currentTarget,
                          } as any;
                          handleDragEnd(syntheticEvent);
                        }
                      }}
                      style={{
                        touchAction: "pan-y", // Allow vertical scroll but enable drag
                        position: "relative", // Ensure z-index works during drag
                      }}
                    >
                      <TabCard
                        item={mediaItem}
                        actions={actions}
                        tabType={mode}
                        index={index}
                        dragState={dragState}
                        onDragStart={(e, idx) => {
                          // Handle both drag and touch events
                          if ("touches" in e) {
                            // Touch event - manually set drag state
                            const item = processedItems[idx];
                            if (item) {
                              // Set drag state manually
                              handleDragStart(
                                {
                                  ...e,
                                  dataTransfer: {
                                    setData: () => {},
                                    effectAllowed: "move",
                                  } as any,
                                  preventDefault: () => {},
                                  stopPropagation: () => {},
                                  currentTarget: e.currentTarget,
                                } as any,
                                idx
                              );
                            }
                          } else {
                            handleDragStart(e, idx);
                          }
                        }}
                        onDragEnd={handleDragEnd}
                        onDragOver={handleDragOver}
                        onDragLeave={handleDragLeave}
                        onDrop={handleDrop}
                        onKeyboardReorder={(direction) => {
                          const newIndex =
                            direction === "up"
                              ? Math.max(0, index - 1)
                              : Math.min(processedItems.length - 1, index + 1);
                          if (newIndex !== index) {
                            handleKeyboardReorder(index, newIndex);
                          }
                        }}
                      />
                    </div>
                  );
                })}
              </div>
            </>
          )}
        </ErrorBoundary>
      ) : (
        <div className="text-center py-8" style={{ color: "var(--muted)" }}>
          <p className="text-sm">
            {(() => {
              // Check what filters are active
              const hasTypeFilter = filters.type !== "all";
              const hasProviderFilter = filters.providers.length > 0;
              const hasFilters = hasTypeFilter || hasProviderFilter;

              if (selectedTag) {
                return `No items found with tag "${selectedTag}"`;
              }
              if (sortByTag) {
                return "No items with tags found";
              }
              if (hasFilters) {
                const filterParts: string[] = [];
                if (hasTypeFilter) {
                  filterParts.push(
                    filters.type === "movie" ? "movies" : "TV shows"
                  );
                }
                if (hasProviderFilter) {
                  filterParts.push(
                    `providers: ${filters.providers.join(", ")}`
                  );
                }
                return `No items match your filters (${filterParts.join(", ")})`;
              }
              return getEmptyText();
            })()}
          </p>
          <p className="text-xs mt-2">
            {(() => {
              const hasTypeFilter = filters.type !== "all";
              const hasProviderFilter = filters.providers.length > 0;
              const hasFilters = hasTypeFilter || hasProviderFilter;

              if (selectedTag) {
                return "Try selecting a different tag or clear the filter";
              }
              if (sortByTag) {
                return "Add tags to items to see them when sorting by tag";
              }
              if (hasFilters) {
                return 'Try adjusting your filters or click "Clear All" to see all items';
              }
              return "Add some shows to get started!";
            })()}
          </p>
        </div>
      )}

      {/* Scroll to top arrow - appears when scrolled down */}
      <ScrollToTopArrow threshold={300} />

      {/* Episode Tracking Modal */}
      {selectedShow && (
        <EpisodeTrackingModal
          isOpen={episodeModalOpen}
          onClose={() => {
            setEpisodeModalOpen(false);
            setSelectedShow(null);
            setShowDetails(null);
          }}
          show={
            showDetails || {
              id:
                typeof selectedShow.id === "string"
                  ? parseInt(selectedShow.id)
                  : selectedShow.id,
              name: selectedShow.title,
              number_of_seasons: 1,
              number_of_episodes: 1,
            }
          }
        />
      )}
    </section>
  );
}

```

## apps/web/src/search/SearchResults.tsx
### Summary
Renders search results consumed from the ranking pipeline and shows voteAverage/metadata per row.
### Content
```tsx
import React, { useEffect, useState, useRef } from "react";
// import CardV2 from '../components/cards/CardV2'; // Unused
import type { MediaItem } from "../components/cards/card.types";
import { cachedSearchMulti } from "./cache";
import { smartSearch } from "./smartSearch";
import { discoverByGenre } from "./api";
import { emit } from "../lib/events";
import { addToListWithConfirmation, Library } from "../lib/storage";
import { fetchFullMediaMetadata, fetchNetworkInfo } from "./api";
import { fetchNextAirDate, fetchShowStatus } from "../tmdb/tv";
import { useTranslations } from "../lib/language";
import { useSettings, getPersonalityText } from "../lib/settings";
import MyListToggle from "../components/MyListToggle";
import { OptimizedImage } from "../components/OptimizedImage";
import { searchTagsLocal } from "../lib/libraryIndex";
import { isMobileNow, onMobileChange } from "../lib/isMobile";
import Portal from "../components/Portal";
import SearchTip from "../components/onboarding/SearchTip";
import { getSearchTipDismissed } from "../lib/onboarding";
import { ListMembershipBadge } from "../components/ListMembershipBadge";

type SearchResultWithPagination = {
  items: MediaItem[];
  page: number;
  totalPages: number;
};

export default function SearchResults({
  query,
  genre,
  searchType = "all",
  mediaTypeFilter,
  onBackToHome,
}: {
  query: string;
  genre?: number | null;
  searchType?: "all" | "movies-tv" | "people";
  mediaTypeFilter?: "tv" | "movie" | null;
  onBackToHome?: () => void;
}) {
  const [items, setItems] = useState<MediaItem[]>([]);
  const [currentPage, setCurrentPage] = useState(1);
  const [totalPages, setTotalPages] = useState(1);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const abortRef = useRef<AbortController | null>(null);
  const observerRef = useRef<IntersectionObserver | null>(null);
  const sentinelRef = useRef<HTMLDivElement | null>(null);
  const settings = useSettings();

  useEffect(() => {
    // reset on any input change
    abortRef.current?.abort();
    setItems([]);
    setCurrentPage(1);
    setTotalPages(1);
    setError(null);
    void fetchPage(1, true);
    // eslint-disable-next-line
  }, [query, genre, searchType, mediaTypeFilter]);

  // Setup intersection observer for infinite scroll
  useEffect(() => {
    if (!sentinelRef.current) return;

    // Create single observer instance
    observerRef.current = new IntersectionObserver(
      (entries) => {
        if (
          entries[0].isIntersecting &&
          !isLoading &&
          currentPage < totalPages
        ) {
          void fetchPage(currentPage + 1);
        }
      },
      { threshold: 0.1 }
    );

    observerRef.current.observe(sentinelRef.current);

    return () => {
      if (observerRef.current) {
        observerRef.current.disconnect();
        observerRef.current = null;
      }
    };
  }, [currentPage, totalPages, isLoading]);

  async function fetchPage(nextPage: number, replace = false) {
    if (isLoading) return;
    abortRef.current?.abort();
    const ac = new AbortController();
    abortRef.current = ac;
    setIsLoading(true);
    try {
      let result: SearchResultWithPagination;

      if (query.startsWith("tag:")) {
        // Tag search from local library
        const tagQuery = query.substring(4);
        const localResults = searchTagsLocal(tagQuery);
        result = {
          items: localResults,
          page: 1,
          totalPages: 1, // Tag search is single page
        };
      } else if (!query.trim() && genre != null && searchType === "movies-tv") {
        // Genre-only search: no text query, genre selected
        const searchResult = await discoverByGenre(genre, nextPage, {
          signal: ac.signal,
        });
        result = searchResult;
      } else {
        const useSmart = searchType !== "people";
        const searchResult = useSmart
          ? await smartSearch(query, nextPage, searchType, {
              signal: ac.signal,
            })
          : await cachedSearchMulti(
              query,
              nextPage,
              genre ?? null,
              searchType,
              { signal: ac.signal }
            );

        result = searchResult;
      }

      // Filter by mediaType if specified
      let filteredItems = result.items;
      if (mediaTypeFilter && searchType === "movies-tv") {
        filteredItems = result.items.filter(
          (item) => item.mediaType === mediaTypeFilter
        );
      }

      setItems((prev) =>
        replace ? filteredItems : [...prev, ...filteredItems]
      );
      setCurrentPage(result.page);
      setTotalPages(result.totalPages);
    } catch (err: any) {
      if (err?.name !== "AbortError") setError(err?.message || "Search failed");
    } finally {
      setIsLoading(false);
    }
  }

  // Allow rendering if there's a query OR a genre selected (for genre-only search)
  if (!query && !genre) return null;

  const isMobile = isMobileNow();

  return (
    <section
      className="mx-auto w-full max-w-7xl px-3 sm:px-4 py-3"
      aria-labelledby="search-results-heading"
    >
      {/* Mobile Back to Home Button */}
      {isMobile && onBackToHome && (
        <button
          onClick={onBackToHome}
          className="flex items-center gap-2 mb-4 px-3 py-2 rounded-lg hover:bg-muted transition-colors"
          style={{
            backgroundColor: "var(--btn)",
            color: "var(--text)",
            border: "1px solid var(--line)",
          }}
          aria-label="Back to home"
        >
          <svg
            className="w-5 h-5"
            fill="none"
            stroke="currentColor"
            viewBox="0 0 24 24"
            xmlns="http://www.w3.org/2000/svg"
          >
            <path
              strokeLinecap="round"
              strokeLinejoin="round"
              strokeWidth={2}
              d="M10 19l-7-7m0 0l7-7m-7 7h18"
            />
          </svg>
          <span className="text-sm font-medium">Back to Home</span>
        </button>
      )}

      <h2 id="search-results-heading" className="text-base font-semibold mb-6">
        {query.startsWith("tag:")
          ? `Tag search results for "${query.substring(4)}"`
          : !query.trim() && genre != null
            ? `Genre results`
            : `Search results for "${query}"`}
      </h2>

      {isLoading && items.length === 0 && (
        <p className="mt-2 text-sm text-muted-foreground">
          {getPersonalityText("searchLoading", settings.personalityLevel)}
        </p>
      )}

      {error && <p className="mt-2 text-sm text-red-600">‚ö†Ô∏è {error}</p>}

      <div className="space-y-6">
        {items.map((item, index) => (
          <SearchResultCard
            key={`${item.mediaType}:${item.id}`}
            item={item}
            index={index}
            onRemove={() =>
              setItems((prev) => prev.filter((i) => i.id !== item.id))
            }
          />
        ))}
      </div>

      {/* Infinite scroll sentinel */}
      {currentPage < totalPages && (
        <div
          ref={sentinelRef}
          className="h-20 flex items-center justify-center"
        >
          {isLoading && (
            <div className="text-sm text-muted-foreground">Loading more...</div>
          )}
        </div>
      )}
    </section>
  );
}

/**
 * Process: Mobile Search Result Card Actions
 * Purpose: Simplify card actions on mobile to reduce visual clutter - show one primary CTA (Add button or status pill) plus More menu
 * Data Source: Library.getCurrentList() determines if item is in a list
 * Update Path: Mobile actions in SearchResultCard component (lines 434-589)
 * Dependencies: Library storage, isMobileNow() detection, More menu dropdown (z-index 10003)
 */
function SearchResultCard({
  item,
  index,
  onRemove,
}: {
  item: MediaItem;
  index: number;
  onRemove: () => void;
}) {
  const translations = useTranslations();
  const { posterUrl, mediaType, synopsis } = item;
  const [pressedButtons, setPressedButtons] = React.useState<Set<string>>(
    new Set()
  );
  const [networkInfo, setNetworkInfo] = React.useState<{
    networks?: string[];
    productionCompanies?: string[];
  }>({});
  const [showMoreMenu, setShowMoreMenu] = React.useState(false);
  const moreMenuRef = React.useRef<HTMLDivElement>(null);
  const moreButtonRef = React.useRef<HTMLButtonElement>(null);
  const addButtonRef = React.useRef<HTMLButtonElement>(null);
  const [isMobile, setIsMobile] = React.useState(isMobileNow());

  // Make mobile detection reactive to viewport changes
  React.useEffect(() => {
    return onMobileChange(setIsMobile);
  }, []);

  // Check if item is already in a list to determine primary action
  const currentList = Library.getCurrentList(item.id, item.mediaType);
  const isInList = !!currentList;
  // Only show tip on first card that's not in a list
  const showSearchTip = !getSearchTipDismissed() && !isInList && index === 0;

  // Fetch network information when component mounts
  React.useEffect(() => {
    if (mediaType === "movie" || mediaType === "tv") {
      fetchNetworkInfo(Number(item.id), mediaType).then(setNetworkInfo);
    }
  }, [item.id, mediaType]);

  // Safe title display helper
  function displayTitle(item: { title?: any; year?: string | number }) {
    const t =
      typeof item.title === "string"
        ? item.title
        : String(item.title ?? "").trim();
    const safe = t || "Untitled";
    return item.year ? `${safe} (${item.year})` : safe;
  }

  const title = displayTitle(item);

  // Genre ID to name mapping (common TMDB genres)
  const getGenreName = (genreIds?: number[]) => {
    if (!genreIds || genreIds.length === 0) return "Genre TBA";

    const genreMap: Record<number, string> = {
      28: "Action",
      12: "Adventure",
      16: "Animation",
      35: "Comedy",
      80: "Crime",
      99: "Documentary",
      18: "Drama",
      10751: "Family",
      14: "Fantasy",
      36: "History",
      27: "Horror",
      10402: "Music",
      9648: "Mystery",
      10749: "Romance",
      878: "Sci-Fi",
      10770: "TV Movie",
      53: "Thriller",
      10752: "War",
      37: "Western",
    };

    const firstGenre = genreIds[0];
    return genreMap[firstGenre] || "Genre TBA";
  };

  // Close more menu when clicking outside
  React.useEffect(() => {
    if (!showMoreMenu) return;
    const handleClickOutside = (e: MouseEvent | TouchEvent) => {
      const target = e.target as Node;
      if (
        moreMenuRef.current &&
        !moreMenuRef.current.contains(target) &&
        moreButtonRef.current &&
        !moreButtonRef.current.contains(target)
      ) {
        setShowMoreMenu(false);
      }
    };
    document.addEventListener("mousedown", handleClickOutside);
    document.addEventListener("touchstart", handleClickOutside);
    return () => {
      document.removeEventListener("mousedown", handleClickOutside);
      document.removeEventListener("touchstart", handleClickOutside);
    };
  }, [showMoreMenu]);

  // Handle person results differently
  if (mediaType === "person") {
    return <PersonCard item={item} />;
  }

  // Use actual data from TMDB or sensible defaults
  const genre = getGenreName((item as any).genre_ids);
  const mediaTypeLabel = mediaType === "movie" ? "Movie" : "TV Series";
  const badges = ["NEW", "TRENDING"]; // TODO: Generate based on actual data

  // Get streaming service information
  const getStreamingInfo = () => {
    if (
      mediaType === "tv" &&
      networkInfo.networks &&
      networkInfo.networks.length > 0
    ) {
      return `On ${networkInfo.networks[0]}${networkInfo.networks.length > 1 ? ` (+${networkInfo.networks.length - 1} more)` : ""}`;
    } else if (
      mediaType === "movie" &&
      networkInfo.productionCompanies &&
      networkInfo.productionCompanies.length > 0
    ) {
      return `From ${networkInfo.productionCompanies[0]}${networkInfo.productionCompanies.length > 1 ? ` (+${networkInfo.productionCompanies.length - 1} more)` : ""}`;
    }
    // Don't show placeholder text - only show when we have real data
    return null;
  };

  const handleAction = async (action: string) => {
    console.log(
      "üé¨ handleAction called with:",
      action,
      "for item:",
      item.title
    );
    const buttonKey = `${action}-${item.id}`;

    // Add pressed state
    setPressedButtons((prev) => new Set(prev).add(buttonKey));

    try {
      switch (action) {
        case "want": {
          // Fetch full metadata to ensure all fields are populated
          const fullMetadata = await fetchFullMediaMetadata(item);

          // Merge full metadata with item, prioritizing fetched metadata
          // Include network data if available (from fetchFullMediaMetadata or networkInfo)
          const networks =
            fullMetadata.networks || networkInfo.networks || item.networks;
          const productionCompanies =
            fullMetadata.productionCompanies ||
            networkInfo.productionCompanies ||
            item.productionCompanies;

          addToListWithConfirmation(
            {
              ...item,
              ...fullMetadata, // Full metadata from TMDB (title, year, synopsis, poster, etc.)
              networks: networks, // ‚úÖ Save network data
              productionCompanies: productionCompanies, // ‚úÖ Save production companies
            },
            "wishlist",
            () => {
              emit("card:want", {
                id: item.id,
                mediaType: item.mediaType as any,
              });
              onRemove(); // Remove from search results
            }
          );
          break;
        }
        case "currently-watching": {
          // Fetch full metadata to ensure all fields are populated
          const fullMetadata = await fetchFullMediaMetadata(item);

          // Fetch next air date and show status for TV shows
          let nextAirDate: string | null = null;
          let showStatus: string | undefined = undefined;
          let lastAirDate: string | undefined = undefined;

          if (mediaType === "tv") {
            nextAirDate = await fetchNextAirDate(Number(item.id));
            const statusData = await fetchShowStatus(Number(item.id));
            if (statusData) {
              showStatus = statusData.status;
              lastAirDate = statusData.lastAirDate || undefined;
            }
          }

          // Merge full metadata with item, prioritizing fetched metadata
          // Include network data if available (from fetchFullMediaMetadata or networkInfo)
          const networks =
            fullMetadata.networks || networkInfo.networks || item.networks;
          const productionCompanies =
            fullMetadata.productionCompanies ||
            networkInfo.productionCompanies ||
            item.productionCompanies;

          addToListWithConfirmation(
            {
              ...item,
              ...fullMetadata, // Full metadata from TMDB (title, year, synopsis, poster, etc.)
              nextAirDate: nextAirDate || item.nextAirDate, // Preserve existing nextAirDate if already set
              showStatus: (showStatus || fullMetadata.showStatus) as
                | "Ended"
                | "Returning Series"
                | "In Production"
                | "Canceled"
                | "Planned"
                | undefined,
              lastAirDate: lastAirDate || fullMetadata.lastAirDate,
              networks: networks, // ‚úÖ Save network data
              productionCompanies: productionCompanies, // ‚úÖ Save production companies
            },
            "watching",
            () => {
              onRemove(); // Remove from search results
            }
          );
          break;
        }
        case "watched": {
          // Fetch full metadata to ensure all fields are populated
          const fullMetadata = await fetchFullMediaMetadata(item);

          // Merge full metadata with item, prioritizing fetched metadata
          // Include network data if available (from fetchFullMediaMetadata or networkInfo)
          const networks =
            fullMetadata.networks || networkInfo.networks || item.networks;
          const productionCompanies =
            fullMetadata.productionCompanies ||
            networkInfo.productionCompanies ||
            item.productionCompanies;

          addToListWithConfirmation(
            {
              ...item,
              ...fullMetadata, // Full metadata from TMDB (title, year, synopsis, poster, etc.)
              networks: networks, // ‚úÖ Save network data
              productionCompanies: productionCompanies, // ‚úÖ Save production companies
            },
            "watched",
            () => {
              emit("card:watched", {
                id: item.id,
                mediaType: item.mediaType as any,
              });
              onRemove(); // Remove from search results
            }
          );
          break;
        }
        case "not-interested":
          addToListWithConfirmation(item, "not", () => {
            emit("card:notInterested", {
              id: item.id,
              mediaType: item.mediaType as any,
            });
            onRemove(); // Remove from search results
          });
          break;
        case "holiday":
          emit("card:holidayAdd", {
            id: item.id,
            mediaType: item.mediaType as any,
          });
          break;
        default:
          console.log(`${action} clicked for ${title}`);
      }
    } finally {
      // Remove pressed state after action completes
      setTimeout(() => {
        setPressedButtons((prev) => {
          const newSet = new Set(prev);
          newSet.delete(buttonKey);
          return newSet;
        });
      }, 300);
    }
  };

  const createButton = (action: string, label: string, isSpecial = false) => {
    const buttonKey = `${action}-${item.id}`;
    const isPressed = pressedButtons.has(buttonKey);
    const isLoading =
      action === "currently-watching" && pressedButtons.has(buttonKey);

    return (
      <button
        onClick={() => handleAction(action)}
        data-onboarding-id={
          action === "currently-watching" && index === 0
            ? "search-add-button"
            : undefined
        }
        className={`px-2.5 py-1.5 rounded-lg text-xs transition-all duration-150 ease-out ${
          isPressed
            ? "scale-95 active:shadow-inner"
            : "hover:scale-105 hover:shadow-md"
        } ${isLoading ? "cursor-wait" : "cursor-pointer"}`}
        style={{
          backgroundColor: isPressed ? "var(--accent)" : "var(--btn)",
          color: isSpecial ? "white" : "var(--text)",
          borderColor: "var(--line)",
          border: "1px solid",
        }}
        disabled={isPressed}
      >
        {isLoading ? (
          <div className="flex items-center justify-center">
            <div className="w-3 h-3 border border-current border-t-transparent rounded-full animate-spin mr-1"></div>
            <span className="text-[10px]">...</span>
          </div>
        ) : (
          label
        )}
      </button>
    );
  };

  return (
    <div
      className={`relative flex bg-card border border-line rounded-xl overflow-hidden shadow-lg ${!isMobile ? "hover:transform hover:-translate-y-0.5 transition-transform" : ""}`}
    >
      {/* Poster - proper size */}
      <a
        href={`https://www.themoviedb.org/${mediaType}/${item.id}`}
        target="_blank"
        rel="noopener noreferrer"
        className={`flex-shrink-0 bg-muted cursor-pointer ${isMobile ? "w-20 h-28" : "w-24 h-36"}`}
        title={translations.opensInTmdb}
      >
        {posterUrl ? (
          <OptimizedImage
            src={posterUrl}
            alt={title}
            context="poster"
            className="w-full h-full"
            loading="lazy"
          />
        ) : (
          <div className="w-full h-full bg-neutral-800 flex items-center justify-center text-sm text-muted-foreground">
            No poster
          </div>
        )}
      </a>

      {/* Content - proper spacing and sizing */}
      <div
        className={`flex-1 flex flex-col relative ${isMobile ? "p-3" : "p-4"}`}
      >
        {/* Title with Rating inline on mobile */}
        <div
          className={`font-bold ${isMobile ? "text-base" : "text-lg"} mb-1 flex items-center gap-2 flex-wrap`}
        >
          <span>{title}</span>
          {isMobile && item.voteAverage && (
            <span className="text-muted-foreground text-xs font-normal">
              ‚≠ê {item.voteAverage.toFixed(1)}/10
            </span>
          )}
        </div>

        {/* Meta */}
        <div
          className={`text-muted-foreground ${isMobile ? "text-xs" : "text-sm"} mb-1 flex items-center gap-2 flex-wrap`}
        >
          <span>{genre} ‚Ä¢ {mediaTypeLabel}</span>
          <ListMembershipBadge item={item} />
        </div>

        {/* Streaming Info - only show when we have real data */}
        {getStreamingInfo() && (
          <div
            className={`text-accent ${isMobile ? "text-xs" : "text-sm"} mb-2`}
          >
            {getStreamingInfo()}
          </div>
        )}

        {/* Synopsis - show truncated on mobile, full on desktop */}
        {isMobile ? (
          synopsis && (
            <div className="text-muted-foreground text-xs mb-2 line-clamp-2">
              {synopsis}
            </div>
          )
        ) : (
          <div className="text-muted-foreground text-sm mb-2 max-h-12 overflow-hidden">
            {synopsis || translations.noSynopsisAvailable}
          </div>
        )}

        {/* Badges - hide on mobile */}
        {!isMobile && (
          <div className="flex gap-2 mb-2">
            {badges.map((badge) => (
              <span
                key={badge}
                className="border border-line rounded px-2 py-0.5 text-xs text-muted-foreground"
              >
                {badge}
              </span>
            ))}
          </div>
        )}

        {/* Rating - desktop only (mobile shows inline with title) */}
        {!isMobile && (
          <div className="flex items-center gap-1 mb-4">
            <span className="text-muted-foreground text-lg cursor-pointer">
              ‚òÜ
            </span>
            <span className="text-muted-foreground text-lg cursor-pointer">
              ‚òÜ
            </span>
            <span className="text-muted-foreground text-lg cursor-pointer">
              ‚òÜ
            </span>
            <span className="text-muted-foreground text-lg cursor-pointer">
              ‚òÜ
            </span>
            <span className="text-muted-foreground text-lg cursor-pointer">
              ‚òÜ
            </span>
            <span className="text-muted-foreground text-xs ml-2">
              (Your rating)
            </span>
            {item.voteAverage && (
              <span className="text-muted-foreground text-xs ml-4">
                TMDB: {item.voteAverage.toFixed(1)}/10
              </span>
            )}
          </div>
        )}

        {/* Actions */}
        {isMobile ? (
          // Mobile: Compact actions with primary button + More menu
          <div className="mt-auto flex gap-2 items-center">
            {/* Primary Action Button or Status Pill */}
            {!isInList ? (
              <div className="flex-1 relative">
                <button
                  ref={addButtonRef}
                  data-onboarding-id={
                    index === 0 ? "search-add-button" : undefined
                  }
                  onClick={() => {
                    handleAction("currently-watching");
                    // Dismiss tip when button is clicked
                    if (showSearchTip) {
                      window.dispatchEvent(
                        new CustomEvent("onboarding:searchTipDismissed")
                      );
                    }
                  }}
                  className="w-full px-3 py-2 text-xs font-medium rounded-lg bg-accent text-white hover:opacity-90 transition-opacity min-h-[36px] flex items-center justify-center"
                  disabled={pressedButtons.has(`currently-watching-${item.id}`)}
                >
                  {pressedButtons.has(`currently-watching-${item.id}`) ? (
                    <div className="flex items-center justify-center">
                      <div className="w-3 h-3 border-2 border-white border-t-transparent rounded-full animate-spin mr-1.5"></div>
                      <span className="text-xs">Adding...</span>
                    </div>
                  ) : (
                    translations.currentlyWatchingAction || "Currently Watching"
                  )}
                </button>
                {showSearchTip && addButtonRef.current && (
                  <SearchTip
                    targetRef={addButtonRef}
                    onDismiss={() => {
                      window.dispatchEvent(
                        new CustomEvent("onboarding:searchTipDismissed")
                      );
                    }}
                  />
                )}
              </div>
            ) : (
              // Show status pill if already in list
              <div
                className="flex-1 px-3 py-2 text-xs font-medium rounded-lg bg-muted min-h-[36px] flex items-center justify-center"
                style={{ color: "var(--text)" }}
              >
                {currentList === "watching"
                  ? translations.currentlyWatchingAction || "Watching"
                  : currentList === "wishlist"
                    ? translations.wantToWatchAction || "Want"
                    : currentList === "watched"
                      ? translations.watchedAction || "Watched"
                      : "In List"}
              </div>
            )}

            {/* More Menu Button */}
            <div className="relative">
              <button
                ref={moreButtonRef}
                onClick={() => setShowMoreMenu(!showMoreMenu)}
                className="px-3 py-2 text-xs font-medium rounded-lg bg-muted hover:bg-muted/80 transition-colors min-h-[36px] min-w-[36px] flex items-center justify-center"
                style={{ color: "var(--text)" }}
                aria-label="More actions"
                aria-haspopup="menu"
                aria-expanded={showMoreMenu}
              >
                <svg
                  className="w-5 h-5"
                  fill="none"
                  stroke="currentColor"
                  viewBox="0 0 24 24"
                >
                  <path
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    strokeWidth={2}
                    d="M12 5v.01M12 12v.01M12 19v.01M12 6a1 1 0 110-2 1 1 0 010 2zm0 7a1 1 0 110-2 1 1 0 010 2zm0 7a1 1 0 110-2 1 1 0 010 2z"
                  />
                </svg>
              </button>

              {/* More Menu Dropdown */}
              {showMoreMenu && (
                <Portal>
                  <div
                    ref={moreMenuRef}
                    role="menu"
                    className="fixed rounded-lg border shadow-2xl"
                    style={{
                      zIndex: 10003,
                      backgroundColor: "var(--card)",
                      borderColor: "var(--line)",
                      bottom: moreButtonRef.current
                        ? `${window.innerHeight - moreButtonRef.current.getBoundingClientRect().top + 8}px`
                        : "80px",
                      right: moreButtonRef.current
                        ? `${window.innerWidth - moreButtonRef.current.getBoundingClientRect().right}px`
                        : "16px",
                      minWidth: "160px",
                      maxWidth: "90vw",
                    }}
                    onPointerDown={(e) => e.stopPropagation()}
                  >
                    <div className="py-2">
                      {!isInList && (
                        <>
                          <button
                            onClick={() => {
                              handleAction("currently-watching");
                              setShowMoreMenu(false);
                            }}
                            className="w-full text-left px-4 py-2.5 text-sm hover:bg-muted transition-colors"
                            style={{ color: "var(--text)" }}
                          >
                            {translations.currentlyWatchingAction}
                          </button>
                          <button
                            onClick={() => {
                              handleAction("watched");
                              setShowMoreMenu(false);
                            }}
                            className="w-full text-left px-4 py-2.5 text-sm hover:bg-muted transition-colors"
                            style={{ color: "var(--text)" }}
                          >
                            {translations.watchedAction}
                          </button>
                          <button
                            onClick={() => {
                              handleAction("not-interested");
                              setShowMoreMenu(false);
                            }}
                            className="w-full text-left px-4 py-2.5 text-sm hover:bg-muted transition-colors"
                            style={{ color: "var(--text)" }}
                          >
                            {translations.notInterestedAction}
                          </button>
                          <div
                            className="h-px bg-line my-1"
                            style={{ backgroundColor: "var(--line)" }}
                          ></div>
                        </>
                      )}
                      {isInList && (
                        <>
                          <button
                            onClick={() => {
                              handleAction("want");
                              setShowMoreMenu(false);
                            }}
                            className="w-full text-left px-4 py-2.5 text-sm hover:bg-muted transition-colors"
                            style={{ color: "var(--text)" }}
                          >
                            {translations.wantToWatchAction}
                          </button>
                          <button
                            onClick={() => {
                              handleAction("watched");
                              setShowMoreMenu(false);
                            }}
                            className="w-full text-left px-4 py-2.5 text-sm hover:bg-muted transition-colors"
                            style={{ color: "var(--text)" }}
                          >
                            {translations.watchedAction}
                          </button>
                          <button
                            onClick={() => {
                              handleAction("not-interested");
                              setShowMoreMenu(false);
                            }}
                            className="w-full text-left px-4 py-2.5 text-sm hover:bg-muted transition-colors"
                            style={{ color: "var(--text)" }}
                          >
                            {translations.notInterestedAction}
                          </button>
                          <div
                            className="h-px bg-line my-1"
                            style={{ backgroundColor: "var(--line)" }}
                          ></div>
                        </>
                      )}
                      <div className="px-4 py-2">
                        <MyListToggle item={item} />
                      </div>
                    </div>
                  </div>
                  {/* Backdrop */}
                  <div
                    className="fixed inset-0"
                    onClick={() => setShowMoreMenu(false)}
                    style={{ zIndex: 10002 }}
                  />
                </Portal>
              )}
            </div>
          </div>
        ) : (
          // Desktop: Full action buttons
          <div className="mt-auto flex flex-wrap gap-2 justify-between items-center">
            <div
              className="flex flex-wrap gap-2 p-2 rounded-lg"
              style={{ borderColor: "var(--line)", border: "1px dashed" }}
            >
              {createButton("want", translations.wantToWatchAction)}
              {createButton(
                "currently-watching",
                translations.currentlyWatchingAction
              )}
              {createButton("watched", translations.watchedAction)}
              {createButton("not-interested", translations.notInterestedAction)}
              <MyListToggle item={item} />
            </div>
          </div>
        )}
      </div>
    </div>
  );
}

function PersonCard({ item }: { item: MediaItem }) {
  const { posterUrl } = item;
  const [pressedButtons, setPressedButtons] = React.useState<Set<string>>(
    new Set()
  );

  // Safe title display helper
  function displayTitle(item: { title?: any; year?: string | number }) {
    const t =
      typeof item.title === "string"
        ? item.title
        : String(item.title ?? "").trim();
    const safe = t || "Untitled";
    return item.year ? `${safe} (${item.year})` : safe;
  }

  const title = displayTitle(item);

  // Get known for works from the item
  const knownFor = (item as any).known_for || [];
  const knownForText =
    knownFor.length > 0
      ? knownFor.map((work: any) => work.title || work.name).join(", ")
      : "Actor/Actress";

  const handleAction = async (action: string) => {
    console.log(
      "üé¨ Person action called with:",
      action,
      "for person:",
      item.title
    );
    const buttonKey = `${action}-${item.id}`;

    // Add pressed state
    setPressedButtons((prev) => new Set(prev).add(buttonKey));

    try {
      switch (action) {
        case "view-profile":
          // Open TMDB person page
          window.open(`https://www.themoviedb.org/person/${item.id}`, "_blank");
          break;
        case "search-works": {
          // Search for their works
          const event = new CustomEvent("search:person-works", {
            detail: {
              personName: item.title,
              personId: item.id,
            },
          });
          document.dispatchEvent(event);
          break;
        }
        default:
          console.log(`${action} clicked for ${title}`);
      }
    } finally {
      // Remove pressed state after action completes
      setTimeout(() => {
        setPressedButtons((prev) => {
          const newSet = new Set(prev);
          newSet.delete(buttonKey);
          return newSet;
        });
      }, 300);
    }
  };

  const createButton = (action: string, label: string, isSpecial = false) => {
    const buttonKey = `${action}-${item.id}`;
    const isPressed = pressedButtons.has(buttonKey);

    return (
      <button
        onClick={() => handleAction(action)}
        className={`px-2.5 py-1.5 rounded-lg text-xs transition-all duration-150 ease-out ${
          isPressed
            ? "scale-95 active:shadow-inner"
            : "hover:scale-105 hover:shadow-md"
        } cursor-pointer`}
        style={{
          backgroundColor: isPressed ? "var(--accent)" : "var(--btn)",
          color: isSpecial ? "white" : "var(--text)",
          borderColor: "var(--line)",
          border: "1px solid",
        }}
        disabled={isPressed}
      >
        {label}
      </button>
    );
  };

  return (
    <div className="relative flex bg-card border border-line rounded-xl overflow-hidden shadow-lg hover:transform hover:-translate-y-0.5 transition-transform">
      {/* Profile Photo */}
      <a
        href={`https://www.themoviedb.org/person/${item.id}`}
        target="_blank"
        rel="noopener noreferrer"
        className="flex-shrink-0 w-24 h-36 bg-muted cursor-pointer"
        title="View profile on TMDB"
      >
        {posterUrl ? (
          <OptimizedImage
            src={posterUrl}
            alt={title}
            context="poster"
            className="w-full h-full object-cover"
            loading="lazy"
          />
        ) : (
          <div className="w-full h-full bg-neutral-800 flex items-center justify-center text-sm text-muted-foreground">
            No photo
          </div>
        )}
      </a>

      {/* Content */}
      <div className="flex-1 p-4 flex flex-col relative">
        {/* Name */}
        <div className="font-bold text-lg mb-1">{title}</div>

        {/* Known For */}
        <div className="text-muted-foreground text-sm mb-2">
          Known for: {knownForText}
        </div>

        {/* Popularity */}
        <div className="text-accent text-sm mb-2">
          Popularity: {item.voteAverage ? Math.round(item.voteAverage) : "N/A"}
        </div>

        {/* Actions */}
        <div className="mt-auto flex flex-wrap gap-2 justify-between items-center">
          <div
            className="flex flex-wrap gap-2 p-2 rounded-lg"
            style={{ borderColor: "var(--line)", border: "1px dashed" }}
          >
            {createButton("view-profile", "View Profile")}
            {createButton("search-works", "Search Works")}
          </div>
        </div>
      </div>
    </div>
  );
}

```

## apps/web/src/version.ts
### Summary
Holds release/version history text that mentions rating/discovery updates for deployments.
### Content
```ts
// Single source of truth for the app version.
// Bump using semantic versioning: major.minor.tweak
// ‚ö†Ô∏è VERSION 0.1.173: Improved drag-and-drop visuals - smoother desktop animations, better mobile floating effect
// - Desktop: Removed redundant inline transforms from useDragAndDrop, simplified to single CSS animation
// - Desktop: Reduced rotation from 2deg to 1deg for smoother feel
// - Mobile: Enhanced shadow (layered shadows) for clearer floating effect above neighbors
// - Mobile: Removed redundant inline width/maxWidth assignments, CSS handles constraints
// - All drag functionality preserved: FLIP animations and custom order persistence unchanged
// - Rollback: Revert this commit to restore previous drag visual behavior
// ‚ö†Ô∏è VERSION 0.1.172: Pro-gating cleanup - Standardized Pro status checks, unified upgrade CTAs, improved error messages
// - Replaced settings.pro.isPro with useProStatus() hook in games and settings components
// - Replaced custom upgrade UIs with unified UpgradeToProCTA component (GoofsModal, CommunityPanel)
// - Improved custom list limit error message for better user guidance
// - Rollback: Revert this commit to restore previous Pro status checks and upgrade flows
// ‚ö†Ô∏è VERSION 0.1.171: Merged trivia-question-fixes branch with main
// - Merged latest changes from main branch into trivia-question-fixes
// - Rollback: Revert this commit to restore previous version
// ‚ö†Ô∏è VERSION 0.1.170: Fixed FlickWord Enter key lag and added validation feedback
// - Added isSubmittingUI state to show visual feedback during word validation
// - Wrapped handleSubmit in try/finally to guarantee guards never get stuck
// - Disabled all keyboard input (physical and on-screen) during validation
// - Enter button now shows "Checking..." with spinner during validation
// - All submission paths (valid, invalid, error) properly reset flags
// - Users now see immediate feedback when pressing Enter, eliminating "dead air" feeling
// - Rollback: Revert this commit to restore previous submit behavior
// ‚ö†Ô∏è VERSION 0.1.169: Fixed FlickWord share ‚Üí review flow - links now correctly open intended games
// - Created FlickWordShareParams type and parseFlickWordShareParams() helper for type-safe share params
// - Fixed share params flow: App.tsx ‚Üí localStorage ‚Üí FlickWordGame ‚Üí FlickWordModal ‚Üí FlickWordReview
// - Single game shares now show only the specific game (filtered by gameNumber)
// - Share all games links now show all games for that date (sharedAll mode)
// - Past date shares now correctly show games for the specified date, not today
// - Review screen now properly filters by date and gameNumber from share params
// - Fixed localStorage cleanup ownership (FlickWordReview clears params after reading)
// - Rollback: Revert this commit to restore previous share behavior
// ‚ö†Ô∏è VERSION 0.1.168: Fixed Settings CTA navigation - opens directly to personalization section
// - Created centralized openSettingsAtSection() helper in settingsNavigation.ts
// - Updated "Click here to personalize these rows" CTA to use helper
// - Works reliably on both desktop and mobile
// - Opens Settings directly to "display" section (home rows/For You config)
// - Rollback: Revert this commit to restore previous CTA behavior
// ‚ö†Ô∏è VERSION 0.1.167: Fixed onboarding, FlickWord, and Trivia issues
// - Onboarding: Fixed welcome box showing for returning users
// - FlickWord: Fixed word repetition, same-letter patterns, and share deep-linking
// - Trivia: Fixed question rotation, added share functionality, improved cache keys and fallback rotation
// - Improved rate limit handling for Trivia API (429 errors)
// ‚ö†Ô∏è VERSION 0.1.166: B3 - Final Pro-Gate Validation - Unified Pro config and consistent gating
// - Created centralized Pro config (proConfig.ts) with list limits and helpers
// - Fixed lists gating: Free (3 lists), Pro (unlimited) using dynamic Pro status
// - Replaced alert() with UpgradeToProCTA in ListSelectorModal
// - Added backend validation in notifications to prevent free users enabling Pro features
// - Added sanitization in CommunityPanel to block Pro sort modes for free users
// - Replaced hardcoded isPro checks with centralized useProStatus() hook
// - Added comprehensive Pro gating documentation comments throughout codebase
// - Rollback: Revert this commit to restore previous Pro gating behavior
// ‚ö†Ô∏è VERSION 0.1.165: Fixed duplicate goofs issue - made insights title-specific with variation
// - Updated buildInsightsForTitle to include title names in all insights
// - Added variation logic based on tmdbId to prevent identical insights for similar metadata
// - Fixed duplicate goofs being written for all titles with same genres/decade
// - Added comprehensive debug logging to track ingestion pipeline
// - Added test mode to limit bulk ingestion to 5 titles for safe testing
// - Rollback: Revert this commit to restore previous generic insights behavior
// ‚ö†Ô∏è VERSION 0.1.164: Fixed goofs-fetch Netlify function deployment - moved to correct location
// - Moved goofs-fetch.cjs from netlify/functions/ to apps/web/netlify/functions/
// - Function now deploys correctly since build base is apps/web
// - Fixes 404 errors during bulk ingestion - function now accessible at /.netlify/functions/goofs-fetch
// - Rollback: Revert this commit to restore previous function location
// ‚ö†Ô∏è VERSION 0.1.163: Increased onboarding timeout for better UX
// - Increased fallback timeout from 30 seconds to 3 minutes (180 seconds) for login modal and location permission
// - Gives users plenty of time to complete the onboarding flow without rushing
// - Login modal and location requests still wait for onboarding completion event, with longer fallback
// ‚ö†Ô∏è VERSION 0.1.162: Added debug logging for onboarding component
// - Added comprehensive debug logging to diagnose why onboarding doesn't appear in production
// - Logs hook initialization, localStorage checks, component mount, and early returns
// - Added window.__onboardingDebug object for easy inspection in browser console
// - Helps identify if component is mounting, what step is initialized, and why it might return null
// ‚ö†Ô∏è VERSION 0.1.161: Onboarding Walkthrough with Coachmarks
// - Added complete onboarding flow with 4 steps: welcome, search, addShow, homeDone, help
// - Implemented coachmark bubbles with arrows pointing to UI elements
// - Added action-oriented language encouraging user interaction
// - Delayed login modal and location permission requests until onboarding completes
// - Added fallback mechanisms to ensure login/location still work if onboarding is skipped
// - Implemented automatic scrolling to show relevant sections during onboarding
// - Added SearchTip component for additional guidance during addShow step
// - Rollback: Revert this commit to remove onboarding and restore immediate login/location prompts
// ‚ö†Ô∏è VERSION 0.1.160: Admin Tab Restructure - Community Content and Moderation First
// - Changed default Admin tab from Auto Content to Community Content
// - Reordered tabs: Community Content first, Moderation second, then other tools
// - Updated tab CSS to allow wrapping on desktop (flex-wrap: wrap)
// - Added specific headings for each tab matching tab labels
// - Updated helper text for Community Content and Moderation tabs
// - Improved tab visibility - Community Content and Moderation are now immediately visible
// - Rollback: Revert this commit to restore previous Admin tab order and default
// ‚ö†Ô∏è VERSION 0.1.159: B2 - Settings Architecture Consolidation
// - Centralized Pro features config (settingsProConfig.ts) - single source of truth for all Pro features
// - Created unified UpgradeToProCTA component with 4 variants (banner, panel, inline, button)
// - Replaced scattered upgrade CTAs across Settings sections with unified component
// - Added Community settings section/tab with Weekly Email Digest and topic following
// - Moved community-related settings from NotificationsSection to dedicated CommunitySection
// - Verified stats are not duplicated (Account stats only in AccountSection)
// - All changes incremental, follow existing patterns, TypeScript passes
// - Rollback: Revert this commit to restore previous Settings architecture
// ‚ö†Ô∏è VERSION 0.1.91: Added comment counter and NEW badge to community posts
// - Added clickable reply counter with show/hide thread functionality in comments
// - Added comment count display on post cards with standout accent styling
// - Added NEW badge indicator for posts published within 24 hours
// - Comment counters encourage engagement by showing discussion activity
// - Rollback: Revert this commit to restore previous post/comment display
// ‚ö†Ô∏è VERSION 0.1.158: Community v1 - Complete implementation with topics, spoilers, Pro badges, sorting, filtering, infinite scroll, and daily limits
// - Added Pro badges, spoiler handling, topic selection and following
// - Implemented sorting (Newest, Oldest, Top, Hot, Trending) with Pro gating
// - Added topic filtering (single-select Free, multi-select Pro)
// - Implemented infinite scroll with cursor-based pagination
// - Added daily posting/commenting limits (3/10 for Free, 100/500 for Pro)
// - Fixed CommunityPanel scrolling and game card sizing
// - Rollback: Revert this commit to restore previous community behavior
// ‚ö†Ô∏è VERSION 0.1.157: Fixed all 23 FlickWord and Trivia game issues - comprehensive game improvements
// - Fixed game state restoration, race conditions, localStorage quota handling
// - Added cache versioning, centralized cache keys, API retry logic
// - Added offline detection, duplicate prevention, proper null checks
// - Improved keyboard color contrast (absent keys now clearly visible)
// - All 23 audit issues resolved, games now production-ready
// ‚ö†Ô∏è VERSION 0.1.156: Improved mobile search result card layout - better use of space
// - Moved rating inline with title on mobile for better space utilization
// - Made action buttons smaller (36px height instead of 44px) for more compact design
// - Added back synopsis description (2-line truncated) to fill white space
// - Better visual balance and information density on mobile cards
// - Rollback: Revert this commit to restore previous mobile card layout
// ‚ö†Ô∏è VERSION 0.1.155: Fixed mobile search result cards - made mobile detection reactive to viewport changes
// - Changed isMobile from one-time check to reactive useState with onMobileChange listener
// - Mobile cards now properly update when viewport size changes
// - Fixes issue where mobile styling wasn't applying correctly
// - Rollback: Revert this commit to restore previous mobile detection behavior
// ‚ö†Ô∏è VERSION 0.1.154: Fixed search suggestion click behavior - suggestions now properly fill search bar and perform search
// - Fixed blur handler interfering with suggestion clicks by adding click tracking flag
// - Added suggestionsContainerRef to properly detect clicks inside suggestions dropdown
// - Updated handleSuggestionClick to set flag and prevent blur from clearing query
// - Added onPointerDown handlers to all suggestion buttons to prevent input blur
// - Fixed issue where clicking "Slow Horses" would reset search bar to just "S"
// - Rollback: Revert this commit to restore previous suggestion click behavior
// ‚ö†Ô∏è VERSION 0.1.153: Improved weekly digest error messages for better debugging
// - Separated error messages for missing config vs inactive config
// - Clear instructions in error messages directing users to Admin panel
// - Helps diagnose whether config needs to be created or just activated
// - Rollback: Revert this commit to restore previous error messages
// ‚ö†Ô∏è VERSION 0.1.152: Fixed weekly digest email content not appearing in emails
// - Fixed loadDigestConfig() to use nullish coalescing (??) instead of logical OR (||)
// - Fixed buildEmailTemplate() to preserve empty strings and use saved content correctly
// - Fixed buildPlainTextTemplate() to preserve empty strings and use saved content correctly
// - Root cause: || operator treated empty strings as falsy, causing fallback to defaults
// - Now uses ?? which only falls back when value is null/undefined, preserving user-entered content
// - Rollback: Revert this commit to restore previous digest template behavior
// ‚ö†Ô∏è VERSION 0.1.151: Mobile search redesign and suggestion relevance improvements
// - Phase A: Simplified mobile search bar - inline clear button, improved spacing
// - Phase B: Mobile-friendly filter sheet with Apply/Reset buttons
// - Phase C: Tidied search suggestions - hide Popular on mobile, improved spacing
// - Phase D: Simplified search result card actions on mobile (primary + More menu)
// - Phase E: Fixed tab switching to preserve search, pull-to-refresh behavior
// - Enhanced suggestion relevance: multi-endpoint fetching, improved substring matching
// - Fixed "bat" ‚Üí "batman" relevance by boosting word-starting substring matches
// - Rollback: Revert this commit to restore previous mobile search behavior
// ‚ö†Ô∏è VERSION 0.1.150: Fixed Apple login redirect loop and email login username prompt
// - Created appleLogin() helper similar to googleLogin() with redirect loop prevention
// - Apple login now uses popup on iOS/Safari and redirect guards to prevent loops
// - Fixed username prompt not showing after email login - ensures usernamePrompted is set
// - Apple login now has same safeguards as Google login (environment checks, guards, error handling)
// - Rollback: Revert this commit to restore previous Apple login behavior
// ‚ö†Ô∏è VERSION 0.1.149: Removed all diagnostic, triage, and troubleshooting tools
// - Disabled flickerDiagnostics (no logging, no event tracking, no exports)
// - Disabled i18nDiagnostics (no auto-download, no JSON file generation)
// - Removed all diagnostic calls from components and hooks
// - Removed debugGate diagnostic imports and calls
// - Removed coldStartRecorder and compactGateDiagnostics from main.tsx
// - All diagnostic systems are now no-ops (disabled but code remains for rollback)
// - This prevents any automatic JSON file downloads or diagnostic overhead
// - Rollback: Revert this commit to restore diagnostic functionality
// ‚ö†Ô∏è VERSION 0.1.148: Fixed production flicker caused by Service Worker aggressive activation loop
// - Fixed sw.js: Made clients.claim() and skipWaiting() conditional to prevent aggressive takeover
// - Fixed sw-register.ts: Removed automatic reg.update() on activation to prevent update loop
// - Fixed sw-register.ts: Added controller change handling and update debouncing (5s)
// - Fixed main.tsx: Guarded releaseFirstPaintGate() to run only once (prevents gate toggling)
// - Fixed main.tsx: Moved SW registration before React render to prevent mid-render takeover
// - Fixed main.tsx: Removed React.StrictMode in production to prevent extra render cycles
// - Fixed sw.js: Changed navigate mode to network-first for HTML (prevents stale content)
// - Fixed useServiceWorker.ts: Removed duplicate auto-registration (SW registered in main.tsx)
// - All fixes address the continuous page flicker in production until hard refresh
// - Rollback: Revert this commit to restore previous behavior
// ‚ö†Ô∏è VERSION 0.1.147: Runtime subsystem kill switch harness for binary isolation
// - Added runtime/switches.ts with isOff() helper for kill switch checking
// - Added runtime/overlay.ts for dev-only visual switch state display
// - Added runtime/firestoreWrapper.ts helper for Firestore listener wrapping
// - Wired kill switches: Service Worker (isw:off), Firebase Auth (iauth:off), Firestore (ifire:off)
// - Wired kill switches: API client (iapiclient:off), FCM (imsg:off), Feature flags (ircfg:off), Analytics (ianalytics:off)
// - Added docs/isolation/README.md with usage instructions and test order
// - Purpose: Binary isolation to identify which subsystem causes UI flicker
// - Usage: Set localStorage keys (e.g., 'isw:off'='1') to disable subsystems at runtime
// ‚ö†Ô∏è VERSION 0.1.146: Fix runaway translation updates with hard no-op guards + one-time settle window
// - Added content hash comparison (hashDict) to prevent commits when content is identical
// - Added one-time settle window (1000ms) to ignore redundant startup updates
// - Added hard guard in emitChange() to check store state before queuing
// - Added boot collector guard to prevent redundant boot emissions
// - Added hash guard in queueUpdate() to catch object recreation with same content
// - Added DEV probe to track commits/min (expected: single digits when idle)
// - Normalized getTranslations() to return direct reference (never synthesizes new objects)
// - Expected: renders per subscription <~2.2 (down from 2.70), commits/min in single digits
// ‚ö†Ô∏è VERSION 0.1.145: i18n: silence residual notifiers (guards/throttles/coalescing), add caller leaderboard, confirm drop in diagnostics
// - Added rapid-notify detector in translationBus.ts (warns when repeated calls occur within 5ms while containment is ON)
// - Added caller tracking and leaderboard dumper (__dumpI18nNotifyLeaderboard) to identify top noisy callers
// - Added equality guard in LanguageManager.emitChange() to drop repeats of the exact same payload
// - Updated i18n-batching.md with leaderboard instructions and pass criteria (<200 bursts, <50 maxEventsIn50ms)
// ‚ö†Ô∏è VERSION 0.1.144: i18n: bind real notify() to rAF batcher via runtime flag; normalize batched payloads; diagnostics prove mode
// - Made translationBus the SINGLE SOURCE OF TRUTH (removed duplicate subscribers from LanguageManager)
// - LanguageManager.emitChange() now ONLY calls translationBus.notify() - no legacy path
// - useTranslations now ONLY subscribes to translationBus - no legacy subscription
// - notify() checks containment flag on EVERY call to honor runtime toggles
// - Added dev logs: [i18n] notify mode=raf|off to prove actual path
// - Diagnostics now use actual mode from translationBus.mode()
// - SSR-safe: localStorage checks, rAF fallback
// ‚ö†Ô∏è VERSION 0.1.143: i18n rAF-batched update containment w/ runtime flags + diagnostics
// - Added i18n/featureFlags.ts for runtime toggles (localStorage-based)
// - Added i18n/rafBatcher.ts for requestAnimationFrame batching
// - Added i18n/translationBus.ts for centralized translation notifications
// - Updated useTranslations to handle batched payloads (array normalization)
// - Enhanced diagnostics to track containment metrics (bursts, maxEventsIn50ms)
// - Runtime toggle: localStorage.setItem('i18n:containment', 'on'|'off')
// - Diagnostics auto-run: localStorage.setItem('i18n:diagnostics:autoRun', 'true')
// - All changes behind flags, default behavior unchanged, reversible in one commit
// ‚ö†Ô∏è VERSION 0.1.142: Added unified I18N diagnostics system
// - Created i18nDiagnostics.ts with structured JSON report generation
// - Tracks: Strict Mode effects, provider identity, subscriber metrics, batching, key violations
// - Saves report to localStorage and downloads as JSON file
// - Enable via ?i18n-diagnostics=true or localStorage.setItem('i18n-diagnostics', 'enabled')
// ‚ö†Ô∏è VERSION 0.1.141: Fixed useTranslations subscription cascade causing flicker
// - Added prevTranslationsRef to track previous translations value
// - Only call setTranslations() when translations actually change (prevent unnecessary re-renders)
// - This fixes the 3600 subscription->render pairs from 160 subscriptions (22.5 renders per subscription)
// - Root cause: subscription callback was always calling setState even when value didn't change
// ‚ö†Ô∏è VERSION 0.1.140: Added root cause analysis function to flicker diagnostics
// - Added analyzeRootCause() method to flickerDiagnostics
// - Answers 3 key questions: mount vs render, subscription cascades, rapid sequences
// - Provides automated analysis with recommendations
// ‚ö†Ô∏è VERSION 0.1.139: Enhanced flicker diagnostics with mount/unmount and render tracking
// - Added logMount() and logUnmount() methods to flickerDiagnostics
// - Enhanced useTranslations to track every render, mount, unmount, and effect lifecycle
// - Added unique mountId to track individual hook instances across mount/unmount cycles
// - Increased MAX_LOGS from 200 to 500 to capture more diagnostic data
// - This will help determine root cause: are components mounting/unmounting or just re-rendering?
// ‚ö†Ô∏è VERSION 0.1.138: Fixed React hooks violation, backend API, and TMDB proxy issues
// - Fixed React hooks violation in App.tsx: moved loadingTimeout hooks before early returns
// - Fixed backend 500 error: changed take: 0 to take: pageSize in posts.js
// - Fixed TMDB proxy 404 errors: changed to use /api/tmdb-proxy redirect instead of direct function path
// - Added HMR configuration for Netlify dev proxy (port 8888)
// - Fixed backend CORS to include localhost:8000 for direct Vite dev server
// ‚ö†Ô∏è VERSION 0.1.137: Comprehensive flicker fixes - all 14 problems addressed
// - Fixed useCustomLists: only log/update when value actually changes, use ref to track previous value
// - Fixed CustomListManager: only sync counts if changed, added 100ms debounce to prevent cascade
// - Fixed AuthManager: reduced triple notification to single notification after operations complete
// - Fixed useAuth: removed subscription logging, fixed stale closure with ref tracking
// - Fixed useReturningShows: only update version when returning shows actually change
// - Fixed SnarkDisplay: only log when values actually change, use refs to track previous values
// - Fixed useUsername: removed subscription logging (only logs when loadUsername() starts)
// - Fixed useLibrary: removed render logging (only logs in subscription callback when changed)
// - Fixed CommunityPanel: memoized to prevent unnecessary re-renders from parent
// - All hooks now use refs to track previous values for accurate logging
// - All state changes now only trigger when values actually change
export const APP_VERSION = "0.1.173";

```

## apps/web/src/styles/cards.css
### Summary
Card-specific styling (rating bubbles, actions, layout) shared by discovery/home/list cards.
### Content
```css
/* Card Styles - Focus, Spacing, and Pro Buttons */

/* Drag Handle Styles */
.tab-card .handle {
  opacity: 0.4; /* More visible by default for better discoverability */
  transition:
    opacity 0.2s ease,
    transform 0.15s ease-out,
    border-color 0.2s ease,
    background-color 0.2s ease;
  pointer-events: auto; /* Always allow pointer events */
}

.tab-card:hover .handle,
.tab-card:focus-within .handle,
.tab-card:focus-visible .handle {
  opacity: 1; /* Fully visible on hover/interaction */
  pointer-events: auto;
}

/* Enhanced hover effects on drag handle */
.tab-card .handle:hover {
  transform: scale(1.05);
  transition:
    transform 0.15s ease-out,
    opacity 0.2s ease,
    border-color 0.2s ease,
    background-color 0.2s ease;
}

/* Active state animation */
.tab-card .handle:active {
  transform: scale(0.98);
  transition: transform 0.1s ease-out;
}

/* Drag state - handle becomes more prominent */
.tab-card .handle.is-dragging,
.tab-card.is-dragging .handle {
  opacity: 1;
  border-color: var(--accent) !important;
  background-color: color-mix(in srgb, var(--accent) 15%, transparent) !important;
  transform: scale(1.1);
  box-shadow: 0 2px 8px color-mix(in srgb, var(--accent) 30%, transparent);
}

.tab-card .handle:focus-visible {
  opacity: 1;
  outline: 2px solid var(--accent);
  outline-offset: 2px;
  border-radius: 6px;
}

/* Fallback for browsers without color-mix support */
@supports not (color-mix: srgb) {
  .tab-card .handle.is-dragging,
  .tab-card.is-dragging .handle {
    background-color: rgba(77, 163, 255, 0.15) !important;
    box-shadow: 0 2px 8px rgba(77, 163, 255, 0.3);
  }
}

/* Card focus outline: subtle, tight, focus-only */
.tab-card:focus {
  outline: none;
}

.tab-card:focus-visible,
.curated-card:focus-visible {
  /* 1px dotted, lower contrast, pulled in */
  outline: 1px dotted color-mix(in srgb, var(--line) 55%, transparent);
  outline-offset: -2px;
}

/* Keyboard-focus helper, if used */
.tab-card.is-keyboard-focus,
.curated-card.is-keyboard-focus {
  outline: 1px dotted color-mix(in srgb, var(--line) 55%, transparent);
  outline-offset: -2px;
}

@supports not (color-mix: srgb) {
  .tab-card:focus-visible,
  .curated-card:focus-visible,
  .tab-card.is-keyboard-focus,
  .curated-card.is-keyboard-focus {
    outline-color: rgba(255, 255, 255, 0.25);
  }
}

/* Pro button container styling */
.pro-actions {
  border: 1px dotted color-mix(in srgb, var(--line) 45%, transparent);
  border-radius: 14px;
  background: color-mix(in srgb, var(--card) 90%, var(--pro) 10%);
}

html[data-compact-mobile-v1="true"] .pro-actions {
  padding: 6px 8px;
  border-radius: 12px;
}

/* Card row spacing - reduce gaps */
.space-y-4 {
  gap: 12px; /* was 16px (space-y-4) */
}

.space-y-3 {
  gap: 9px; /* was 12px (space-y-3) */
}

/* Compact mobile gets even tighter spacing */
html[data-compact-mobile-v1="true"] .space-y-4 {
  gap: 10px;
}

html[data-compact-mobile-v1="true"] .space-y-3 {
  gap: 8px;
}

/* Additional card margin adjustments */
.tab-card.mb-5 {
  margin-bottom: 1.25rem; /* 20px, reduced from mb-8 (32px) */
}

.tab-card.mb-3 {
  margin-bottom: 0.75rem; /* 12px, reduced from mb-4 (16px) */
}

html[data-compact-mobile-v1="true"] .tab-card.mb-5 {
  margin-bottom: 1rem; /* 16px */
}

html[data-compact-mobile-v1="true"] .tab-card.mb-3 {
  margin-bottom: 0.5rem; /* 8px */
}

/* NEW: Unified Desktop Card Layout - Refined spacing and typography */
.card-desktop {
  display: flex;
  gap: 1.25rem; /* Reduced from 1.5rem */
  padding: 1rem 1.25rem 0.875rem 1.25rem; /* Minimal bottom padding */
  border-radius: var(--radius-xl, 16px);
  background: var(--card, #171a21);
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  border: 1px solid var(--line, #242a33);
}

.card-desktop .poster-col {
  flex-shrink: 0;
  align-self: stretch; /* Stretch poster to full card height */
  height: 100%;
}

.card-desktop .poster-col img {
  width: 225px;
  height: 100%; /* Full height of card */
  object-fit: cover;
  border-radius: var(--radius-md, 8px);
}

.card-desktop .info-col {
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 0.75rem; /* Reduced from var(--space-4) - consistent 12px spacing */
}

.card-desktop .info-col header {
  margin-bottom: 0; /* Remove extra margin */
}

.card-desktop .info-col header h3 {
  font-size: 1.1rem; /* Slightly increased from 18px */
  font-weight: 650; /* Stronger weight */
  color: var(--text);
  margin: 0 0 0.375rem 0; /* Tightened to 6px */
  line-height: 1.3;
}

.card-desktop .info-col header .meta {
  font-size: 0.8125rem; /* Slightly smaller */
  color: rgba(255, 255, 255, 0.5); /* More muted */
  margin-bottom: 0.5rem;
}

.card-desktop .streaming-info {
  font-size: var(--font-sm, 13px);
  color: var(--muted);
  margin: 0;
}

.card-desktop .status-badge {
  display: inline-block;
  padding: 4px 10px; /* Slightly smaller */
  background: rgba(34, 197, 94, 0.15);
  color: #4ade80;
  border-radius: 6px;
  font-size: var(--font-xs, 11px);
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  border: 1px solid rgba(34, 197, 94, 0.3);
}

.card-desktop .rating-row {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  margin-bottom: 0.625rem; /* Tightened to 10px */
  line-height: 1; /* Tight line height */
}

.card-desktop .rating-row .rating-score {
  font-size: var(--font-sm, 13px);
  color: var(--muted);
}

.card-desktop .synopsis-wrapper {
  flex-grow: 1;
  margin-bottom: 0.75rem;
}

.card-desktop .synopsis {
  font-size: var(--font-sm, 13px);
  line-height: 1.5;
  color: rgba(255, 255, 255, 0.75); /* Lighter than pure gray */
  margin: 0;
  padding: 0;
  display: -webkit-box;
  -webkit-line-clamp: 2; /* Limit to 2 lines */
  -webkit-box-orient: vertical;
  overflow: hidden;
  text-overflow: ellipsis;
}

.card-desktop .buttons-container {
  display: flex;
  flex-direction: column;
  gap: 0.625rem; /* Tightened to 10px */
  margin-top: auto; /* Push to bottom */
  padding-top: 0.5rem;
}

.card-desktop .actions-row {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
  grid-template-rows: auto auto; /* Two-row grid */
  gap: 0.5rem; /* Equal gaps */
  margin-bottom: 0.75rem;
}

.card-desktop .pro-buttons-row {
  display: flex;
  flex-wrap: wrap;
  gap: 0.5rem; /* Tighter gaps */
  padding: 0.75rem; /* Reduced from var(--space-3) */
  border-radius: var(--radius-lg, 12px);
  border: 2px dotted var(--pro);
  margin-top: 0;
  margin-bottom: 0; /* No extra margin at bottom */
}

/* Compact button styling for desktop cards */
.card-desktop .buttons-container button,
.card-desktop .actions-row button,
.card-desktop .pro-buttons-row button {
  height: 34px; /* Compact height 32-36px */
  font-size: 13px; /* 13-14px */
  padding: 0 8px; /* 8px horizontal padding */
  line-height: 1.3;
  font-weight: 500;
  transition: all 0.15s ease-out;
  border-radius: 6px;
}

.card-desktop .buttons-container button:hover,
.card-desktop .actions-row button:hover,
.card-desktop .pro-buttons-row button:hover {
  transform: translateY(-1px);
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
}

.card-desktop .buttons-container button:active,
.card-desktop .actions-row button:active,
.card-desktop .pro-buttons-row button:active {
  transform: translateY(0);
  box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.3);
}

/* Align Delete button properly with content bottom */
.card-desktop .info-col {
  position: relative;
  padding-bottom: 48px; /* Space for Delete button */
}

/* Remove extra space from empty synopsis */
.card-desktop .synopsis-wrapper:empty {
  display: none;
}

.card-desktop .synopsis-wrapper {
  flex-grow: 0; /* Don't grow to fill space */
  flex-shrink: 1;
}

/* Provider Badge Styles - Match search results style */
.provider-badges-container {
  display: flex;
  flex-wrap: wrap;
  gap: 0.5rem; /* 8px - match search results spacing */
  align-items: center;
  margin-top: 0.5rem;
  margin-bottom: 0.5rem;
  max-width: 100%;
  overflow: hidden; /* Prevent horizontal overflow */
}

.provider-badge {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  height: auto;
  min-width: auto;
  padding: 0;
  border-radius: 0;
  background: transparent;
  color: var(--accent, #4da3ff);
  text-decoration: none;
  font-size: var(--font-sm, 13px);
  line-height: 1.5;
  border: none;
  font-weight: 500;
  font-family:
    -apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto", "Oxygen", "Ubuntu",
    "Cantarell", "Fira Sans", "Droid Sans", "Helvetica Neue", sans-serif;
  white-space: nowrap;
  transition: color 0.15s ease-out;
  cursor: default;
}

.provider-badge:hover {
  color: var(--accent-primary, #4da3ff);
  filter: brightness(1.1);
}

.provider-badge:focus-visible {
  outline: 2px solid var(--accent, #4da3ff);
  outline-offset: 2px;
  border-radius: 2px;
}

.provider-badge-more {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  height: auto;
  min-width: auto;
  padding: 0;
  border-radius: 0;
  background: transparent;
  color: var(--accent, #4da3ff);
  font-size: var(--font-sm, 13px);
  line-height: 1.5;
  border: none;
  font-weight: 500;
  cursor: default;
  opacity: 0.8;
}

/* Desktop: Show full provider names */
@media (min-width: 769px) {
  .provider-badge {
    font-size: var(--font-sm, 13px);
  }
}

/* Mobile: Compact badges */
@media (max-width: 768px) {
  .provider-badge {
    font-size: var(--font-xs, 12px);
  }

  .provider-badges-container {
    gap: 0.375rem; /* 6px on mobile */
  }
}

/* Card-specific provider badge positioning */
.card-desktop .provider-badges-container {
  margin-top: 0.375rem;
  margin-bottom: 0.25rem;
}

.card-mobile .provider-badges-container {
  margin-top: 0.5rem;
  margin-bottom: 0.25rem;
}

/* Medium Priority: Animated drag start - smooth entrance */
.tab-card.is-dragging {
  animation: dragStartAnimation 0.2s ease-out forwards;
  z-index: var(--z-dragging, 100) !important; /* Above base content, below modals */
  position: relative !important; /* Ensure z-index works */
  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3), 0 0 0 1px var(--accent);
  border-color: var(--accent) !important;
}

/* Mobile cards: flat drag (no rotation) */
/* Note: Transform is handled by DragHandle inline styles during active drag */
/* This rule only applies visual styling (shadow, z-index) without conflicting transforms */
.card-mobile.is-dragging {
  z-index: var(--z-dragging, 100) !important; /* Above base content, below modals */
  position: relative !important; /* Ensure z-index works */
  /* Enhanced shadow for clear floating effect */
  box-shadow: 0 12px 32px rgba(0, 0, 0, 0.4), 0 4px 8px rgba(0, 0, 0, 0.2), 0 0 0 1px var(--accent) !important;
  border-color: var(--accent) !important;
  /* Ensure card stays full-width and aligned */
  width: 100% !important;
  max-width: 100% !important;
  /* Don't apply transform here - let DragHandle inline style handle it */
  /* This prevents animation conflicts with the drag transform */
}

@keyframes dragStartAnimation {
  0% {
    transform: scale(1) rotate(0deg);
    opacity: 1;
  }
  100% {
    transform: scale(1.02) rotate(1deg); /* Reduced from 2deg for smoother feel */
    opacity: 0.95;
  }
}

/* Drop target animation - smooth highlight */
.tab-card.is-drop-target,
.card-mobile.is-drop-target {
  animation: dropTargetAnimation 0.2s ease-out forwards;
}

@keyframes dropTargetAnimation {
  0% {
    transform: scale(1);
    box-shadow: 0 0 0 0 rgba(59, 130, 246, 0);
  }
  100% {
    transform: scale(1.02);
    box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.3);
  }
}

/* Ensure wrapper div stays on top during drag */
[data-item-index].is-dragging {
  z-index: var(--z-dragging, 100) !important; /* Above base content, below modals */
  position: relative !important;
  /* Ensure wrapper stays full-width and aligned during drag */
  width: 100% !important;
  max-width: 100% !important;
  /* Enhanced shadow for clear floating effect - applied to wrapper so it elevates the entire card */
  box-shadow: 0 12px 32px rgba(0, 0, 0, 0.4), 0 4px 8px rgba(0, 0, 0, 0.2), 0 0 0 1px var(--accent) !important;
  /* Don't apply transform here - DragHandle inline style handles it */
  /* This prevents conflicts and ensures proper alignment */
  /* Force isolation to ensure z-index works across stacking contexts */
  isolation: isolate;
}

/* Ensure SwipeableCard and card-mobile inside dragged wrapper respect z-index */
[data-item-index].is-dragging > *,
[data-item-index].is-dragging .swipeable,
[data-item-index].is-dragging .card-mobile {
  position: relative;
  z-index: inherit;
}

```

## apps/web/src/pages/AdminExtrasPage.tsx
### Summary
Admin view that surfaces ingestion/moderation panels tied to discovery/rating signals and logs.
### Content
```tsx
import { useState, useEffect } from "react";
import {
  collection,
  query,
  orderBy,
  limit,
  onSnapshot,
  deleteDoc,
  doc,
  getDoc,
  setDoc,
  getDocs,
} from "firebase/firestore";
import { db, functions } from "../lib/firebaseBootstrap";
import { ExtrasVideo } from "../lib/extras/types";
import { extrasProvider } from "../lib/extras/extrasProvider";
import { useSettings, settingsManager } from "../lib/settings";
import { useAdminRole } from "../hooks/useAdminRole";
import { isMobileNow } from "../lib/isMobile";
import {
  getAllReports,
  updateReportStatus,
  toggleItemHidden,
  toggleCommentHidden,
  type Report,
} from "../lib/communityReports";

interface UGCSubmission {
  id: string;
  type: "comment" | "video";
  showName: string;
  content: string;
  submittedBy: string;
  submittedAt: string;
  status: "pending" | "approved" | "rejected";
  rejectionReason?: string;
}

/**
 * Process: Admin Extras Review
 * Purpose: Admin interface for reviewing and approving bloopers/extras content and UGC
 * Data Source: ExtrasProvider, UGC submissions, feedback forms
 * Update Path: Manual admin review, bulk operations
 * Dependencies: ExtrasProvider, admin authentication, email processing
 */

interface ModerationQueueProps {
  reports: Report[];
  reportsLoading: boolean;
  processingReport: string | null;
  onLoadReports: () => Promise<void>;
  onUpdateStatus: (
    reportId: string,
    status: "pending" | "reviewed" | "dismissed"
  ) => Promise<void>;
  onToggleHidden: (report: Report) => Promise<void>;
}

function ModerationQueue({
  reports,
  reportsLoading,
  processingReport,
  onLoadReports,
  onUpdateStatus,
  onToggleHidden,
}: ModerationQueueProps) {
  const [itemPreviews, setItemPreviews] = useState<
    Record<string, { text: string; hidden: boolean }>
  >({});
  const [loadingPreviews, setLoadingPreviews] = useState<
    Record<string, boolean>
  >({});

  // Load reports on mount
  useEffect(() => {
    onLoadReports();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  // Load item previews
  useEffect(() => {
    const loadPreviews = async () => {
      for (const report of reports) {
        if (itemPreviews[report.id]) continue; // Already loaded

        setLoadingPreviews((prev) => ({ ...prev, [report.id]: true }));
        try {
          if (report.itemType === "post") {
            const postRef = doc(db, "posts", report.itemId);
            const postSnap = await getDoc(postRef);
            if (postSnap.exists()) {
              const data = postSnap.data();
              const preview = (
                data.body ||
                data.excerpt ||
                data.title ||
                ""
              ).slice(0, 100);
              setItemPreviews((prev) => ({
                ...prev,
                [report.id]: { text: preview, hidden: data.hidden || false },
              }));
            }
          } else {
            // For comments, find the post
            const postsRef = collection(db, "posts");
            const postsSnapshot = await getDocs(postsRef);
            for (const postDoc of postsSnapshot.docs) {
              const commentRef = doc(
                db,
                "posts",
                postDoc.id,
                "comments",
                report.itemId
              );
              const commentSnap = await getDoc(commentRef);
              if (commentSnap.exists()) {
                const data = commentSnap.data();
                const preview = (data.body || "").slice(0, 100);
                setItemPreviews((prev) => ({
                  ...prev,
                  [report.id]: { text: preview, hidden: data.hidden || false },
                }));
                break;
              }
            }
          }
        } catch (error) {
          console.error(
            `Failed to load preview for report ${report.id}:`,
            error
          );
        } finally {
          setLoadingPreviews((prev) => ({ ...prev, [report.id]: false }));
        }
      }
    };

    if (reports.length > 0) {
      loadPreviews();
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [reports]);

  const formatDate = (timestamp: any) => {
    if (!timestamp) return "Unknown";
    if (timestamp.toDate) {
      return timestamp.toDate().toLocaleDateString("en-US", {
        year: "numeric",
        month: "short",
        day: "numeric",
        hour: "numeric",
        minute: "2-digit",
      });
    }
    return new Date(timestamp).toLocaleDateString("en-US", {
      year: "numeric",
      month: "short",
      day: "numeric",
      hour: "numeric",
      minute: "2-digit",
    });
  };

  return (
    <div className="space-y-6">
      <div
        className="bg-gray-100 rounded-lg p-6"
        style={{ backgroundColor: "var(--card)" }}
      >
        <div className="flex items-center justify-between mb-4">
          <h2 className="text-2xl font-bold">Moderation Queue</h2>
          <button
            onClick={onLoadReports}
            disabled={reportsLoading}
            className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:opacity-50"
          >
            {reportsLoading ? "Loading..." : "Refresh"}
          </button>
        </div>

        {reportsLoading ? (
          <div
            className="text-center py-6 text-sm"
            style={{ color: "var(--muted)" }}
          >
            Loading reports...
          </div>
        ) : reports.length === 0 ? (
          <div
            className="text-center py-6 text-sm"
            style={{ color: "var(--muted)" }}
          >
            No reports pending review
          </div>
        ) : (
          <div className="space-y-3">
            {reports.map((report) => {
              const preview = itemPreviews[report.id];
              const isProcessing = processingReport === report.id;

              return (
                <div
                  key={report.id}
                  className="p-3 rounded-lg border"
                  style={{
                    backgroundColor: "var(--card)",
                    borderColor: "var(--line)",
                  }}
                >
                  <div className="flex items-start justify-between gap-4">
                    <div className="flex-1 min-w-0">
                      <div className="flex items-center gap-2 mb-2">
                        <span
                          className="px-2 py-1 text-xs rounded-full font-medium"
                          style={{
                            backgroundColor:
                              report.itemType === "post"
                                ? "var(--accent-primary)"
                                : "var(--accent)",
                            color: "white",
                          }}
                        >
                          {report.itemType === "post" ? "Post" : "Comment"}
                        </span>
                        <span
                          className="px-2 py-1 text-xs rounded-full"
                          style={{
                            backgroundColor:
                              report.status === "pending"
                                ? "#fbbf24"
                                : report.status === "reviewed"
                                  ? "#10b981"
                                  : "#6b7280",
                            color: "white",
                          }}
                        >
                          {report.status}
                        </span>
                        {preview?.hidden && (
                          <span
                            className="px-2 py-1 text-xs rounded-full font-semibold"
                            style={{
                              backgroundColor: "#ef4444",
                              color: "white",
                            }}
                          >
                            [HIDDEN]
                          </span>
                        )}
                      </div>

                      <div
                        className="text-sm mb-2"
                        style={{ color: "var(--text)" }}
                      >
                        <div>
                          <strong>Item ID:</strong> {report.itemId}
                        </div>
                        <div>
                          <strong>Reported by:</strong> {report.reportedBy}
                        </div>
                        <div>
                          <strong>Date:</strong> {formatDate(report.createdAt)}
                        </div>
                        {report.reason && (
                          <div>
                            <strong>Reason:</strong> {report.reason}
                          </div>
                        )}
                      </div>

                      {loadingPreviews[report.id] ? (
                        <div
                          className="text-xs"
                          style={{ color: "var(--muted)" }}
                        >
                          Loading preview...
                        </div>
                      ) : preview ? (
                        <div
                          className="text-sm mt-2 p-2 rounded"
                          style={{
                            backgroundColor: "var(--card)",
                            color: "var(--muted)",
                          }}
                        >
                          {preview.text}
                          {preview.text.length >= 100 && "..."}
                        </div>
                      ) : (
                        <div
                          className="text-xs"
                          style={{ color: "var(--muted)" }}
                        >
                          Preview unavailable
                        </div>
                      )}
                    </div>

                    <div className="flex flex-col gap-2 flex-shrink-0">
                      <button
                        onClick={() => onToggleHidden(report)}
                        disabled={isProcessing}
                        className="px-3 py-1.5 text-xs rounded transition-colors"
                        style={{
                          backgroundColor: preview?.hidden
                            ? "#10b981"
                            : "#ef4444",
                          color: "white",
                        }}
                      >
                        {isProcessing
                          ? "Processing..."
                          : preview?.hidden
                            ? "Unhide"
                            : "Hide"}
                      </button>
                      <button
                        onClick={() => onUpdateStatus(report.id, "reviewed")}
                        disabled={isProcessing || report.status === "reviewed"}
                        className="px-3 py-1.5 text-xs rounded transition-colors disabled:opacity-50"
                        style={{
                          backgroundColor: "#10b981",
                          color: "white",
                        }}
                      >
                        Mark Reviewed
                      </button>
                      <button
                        onClick={() => onUpdateStatus(report.id, "dismissed")}
                        disabled={isProcessing || report.status === "dismissed"}
                        className="px-3 py-1.5 text-xs rounded transition-colors disabled:opacity-50"
                        style={{
                          backgroundColor: "#6b7280",
                          color: "white",
                        }}
                      >
                        Dismiss
                      </button>
                    </div>
                  </div>
                </div>
              );
            })}
          </div>
        )}
      </div>
    </div>
  );
}

export default function AdminExtrasPage({
  isMobile: isMobileProp,
}: { isMobile?: boolean } = {}) {
  const settings = useSettings();
  const { isAdmin, loading: adminLoading } = useAdminRole();
  const [videos, setVideos] = useState<ExtrasVideo[]>([]);
  const [ugcSubmissions, setUgcSubmissions] = useState<UGCSubmission[]>([]);
  const [loading, setLoading] = useState(false);
  const [selectedShow, setSelectedShow] = useState<string>("");
  const [showId, setShowId] = useState<number>(0);
  const [activeTab, setActiveTab] = useState<
    | "content"
    | "comments"
    | "videos"
    | "pro"
    | "community"
    | "admin"
    | "insights"
    | "moderation"
  >("community");

  // Use prop if provided, otherwise fall back to isMobileNow()
  const isMobile = isMobileProp ?? isMobileNow();

  // Insights generation state
  const [insightsTmdbId, setInsightsTmdbId] = useState<string>("");
  const [insightsTitle, setInsightsTitle] = useState<string>("");
  const [insightsMediaType, setInsightsMediaType] = useState<"movie" | "tv">(
    "tv"
  );
  const [insightsGenres, setInsightsGenres] = useState<string>("");
  const [insightsYear, setInsightsYear] = useState<string>("");
  const [insightsRuntime, setInsightsRuntime] = useState<string>("");
  const [insightsGenerating, setInsightsGenerating] = useState(false);
  const [insightsResult, setInsightsResult] = useState<{
    success: boolean;
    itemsGenerated?: number;
    error?: string;
  } | null>(null);
  const [bulkIngestionRunning, setBulkIngestionRunning] = useState(false);
  const [bulkIngestionResult, setBulkIngestionResult] = useState<{
    success: boolean;
    total?: number;
    succeeded?: number;
    failed?: number;
    error?: string;
  } | null>(null);

  // Admin management state
  const [adminEmail, setAdminEmail] = useState("");
  const [adminUserId, setAdminUserId] = useState("");
  const [adminManagementLoading, setAdminManagementLoading] = useState(false);

  // Digest config state
  const [digestConfig, setDigestConfig] = useState({
    title: "",
    intro: "",
    productPulseChanged: "",
    productPulseNext: "",
    productPulseHowTo: "",
    productPulseBonus: "",
    tipHeadline: "",
    tipBody: "",
    footerNote: "",
    isActive: false,
    autoSendEnabled: false,
    autoSendDay: "friday",
    autoSendTime: "09:00",
    lastAutoSentAt: null as any,
    lastAutoSentCount: null as number | null,
    lastManualSentAt: null as any,
    lastManualSentCount: null as number | null,
  });
  const [digestConfigLoading, setDigestConfigLoading] = useState(false);
  const [digestConfigSaving, setDigestConfigSaving] = useState(false);
  const [digestSendNowBusy, setDigestSendNowBusy] = useState(false);
  const [digestSendNowResult, setDigestSendNowResult] = useState<{
    ok: boolean;
    sentCount?: number;
    distinctEmails?: number;
    error?: string;
  } | null>(null);

  // Community content state
  const [posts, setPosts] = useState<any[]>([]);
  const [selectedPostId, setSelectedPostId] = useState<string | null>(null);
  const [postComments, setPostComments] = useState<any[]>([]);

  // Moderation queue state
  const [reports, setReports] = useState<Report[]>([]);
  const [reportsLoading, setReportsLoading] = useState(false);
  const [processingReport, setProcessingReport] = useState<string | null>(null);

  // Calculate pending reports count
  const pendingReportsCount = reports.filter(
    (r) => r.status === "pending"
  ).length;

  // Pro status
  const isPro = settings.pro?.isPro ?? false;

  const handleTogglePro = () => {
    const newProStatus = !isPro;
    settingsManager.updateSettings({
      pro: {
        ...settings.pro,
        isPro: newProStatus,
        features: {
          advancedNotifications: newProStatus,
          themePacks: newProStatus,
          socialFeatures: newProStatus,
          bloopersAccess: newProStatus,
          extrasAccess: newProStatus,
        },
      },
    });
  };

  const handleFetchVideos = async () => {
    if (!showId) return;

    setLoading(true);
    try {
      const bloopersResult = await extrasProvider.fetchBloopers(
        showId,
        selectedShow
      );
      const extrasResult = await extrasProvider.fetchExtras(
        showId,
        selectedShow
      );

      const allVideos = [...bloopersResult.videos, ...extrasResult.videos];
      setVideos(allVideos);
    } catch (error) {
      console.error("Failed to fetch videos:", error);
    } finally {
      setLoading(false);
    }
  };

  const handleApproveVideo = (videoId: string) => {
    setVideos((prev) =>
      prev.map((video) =>
        video.id === videoId ? { ...video, status: "approved" as const } : video
      )
    );
  };

  const handleRejectVideo = (videoId: string) => {
    setVideos((prev) =>
      prev.map((video) =>
        video.id === videoId ? { ...video, status: "rejected" as const } : video
      )
    );
  };

  const handleBulkApprove = () => {
    setVideos((prev) =>
      prev.map((video) => ({ ...video, status: "approved" as const }))
    );
  };

  const handleBulkReject = () => {
    setVideos((prev) =>
      prev.map((video) => ({ ...video, status: "rejected" as const }))
    );
  };

  // UGC Management Functions
  const handleApproveUGC = (submissionId: string) => {
    setUgcSubmissions((prev) =>
      prev.map((submission) =>
        submission.id === submissionId
          ? { ...submission, status: "approved" as const }
          : submission
      )
    );
  };

  const handleRejectUGC = (submissionId: string, reason: string) => {
    setUgcSubmissions((prev) =>
      prev.map((submission) =>
        submission.id === submissionId
          ? {
              ...submission,
              status: "rejected" as const,
              rejectionReason: reason,
            }
          : submission
      )
    );
  };

  const loadUGCSubmissions = () => {
    // Mock data for demonstration - in production, this would fetch from your backend
    const mockSubmissions: UGCSubmission[] = [
      {
        id: "1",
        type: "comment",
        showName: "The Office",
        content: "Michael Scott is the best boss ever!",
        submittedBy: "user123",
        submittedAt: "2024-01-15T10:30:00Z",
        status: "pending",
      },
      {
        id: "2",
        type: "video",
        showName: "Stranger Things",
        content: "Behind the scenes footage from season 4",
        submittedBy: "user456",
        submittedAt: "2024-01-15T11:45:00Z",
        status: "pending",
      },
    ];
    setUgcSubmissions(mockSubmissions);
  };

  useEffect(() => {
    loadUGCSubmissions();
  }, []);

  // Fetch posts for community management
  useEffect(() => {
    if (activeTab !== "community") return;

    const postsRef = collection(db, "posts");
    const postsQuery = query(
      postsRef,
      orderBy("publishedAt", "desc"),
      limit(100)
    );

    const unsubscribe = onSnapshot(
      postsQuery,
      (snapshot) => {
        const postsData = snapshot.docs.map((doc) => ({
          id: doc.id,
          ...doc.data(),
        }));
        setPosts(postsData);
      },
      (error) => {
        console.error("Error fetching posts:", error);
      }
    );

    return () => unsubscribe();
  }, [activeTab]);

  // Fetch comments for selected post
  useEffect(() => {
    if (!selectedPostId || activeTab !== "community") {
      setPostComments([]);
      return;
    }

    const commentsRef = collection(db, "posts", selectedPostId, "comments");
    const commentsQuery = query(
      commentsRef,
      orderBy("createdAt", "desc"),
      limit(100)
    );

    const unsubscribe = onSnapshot(
      commentsQuery,
      (snapshot) => {
        const commentsData = snapshot.docs.map((doc) => ({
          id: doc.id,
          ...doc.data(),
        }));
        setPostComments(commentsData);
      },
      (error) => {
        console.error("Error fetching comments:", error);
      }
    );

    return () => unsubscribe();
  }, [selectedPostId, activeTab]);

  // Load digest config when admin tab is active
  useEffect(() => {
    if (activeTab !== "admin" || !isAdmin) {
      return;
    }

    const loadDigestConfig = async () => {
      setDigestConfigLoading(true);
      try {
        const configDoc = await getDoc(doc(db, "digestConfig", "current"));
        if (configDoc.exists()) {
          const data = configDoc.data();
          setDigestConfig({
            title: data.title || "",
            intro: data.intro || "",
            productPulseChanged: data.productPulseChanged || "",
            productPulseNext: data.productPulseNext || "",
            productPulseHowTo: data.productPulseHowTo || "",
            productPulseBonus: data.productPulseBonus || "",
            tipHeadline: data.tipHeadline || "",
            tipBody: data.tipBody || "",
            footerNote: data.footerNote || "",
            isActive: data.isActive !== undefined ? data.isActive : false,
            autoSendEnabled:
              data.autoSendEnabled !== undefined ? data.autoSendEnabled : false,
            autoSendDay: data.autoSendDay || "friday",
            autoSendTime: data.autoSendTime || "09:00",
            lastAutoSentAt: data.lastAutoSentAt || null,
            lastAutoSentCount: data.lastAutoSentCount || null,
            lastManualSentAt: data.lastManualSentAt || null,
            lastManualSentCount: data.lastManualSentCount || null,
          });
        } else {
          // Set defaults if no config exists
          setDigestConfig({
            title: "üé¨ Flicklet Weekly ‚Äî We actually shipped things.",
            intro: "Here's your Flicklet update in under a minute.",
            productPulseChanged: "Ratings now stick between sessions.",
            productPulseNext:
              "‚Ä¢ Smarter discovery rails ‚Ä¢ Swipe gestures that don't argue with gravity",
            productPulseHowTo: "Tap ‚òÖ once. It remembers now.",
            productPulseBonus:
              "Library loads faster so you spend less time staring at spinners.",
            tipHeadline: "The One Thing You Didn't Know You Needed",
            tipBody:
              "Hold your finger on a card to reorder your list. Saves 10 clicks and a small piece of your soul.",
            footerNote: "Was this worth your 42 seconds?",
            isActive: false,
            autoSendEnabled: false,
            autoSendDay: "friday",
            autoSendTime: "09:00",
            lastAutoSentAt: null,
            lastAutoSentCount: null,
            lastManualSentAt: null,
            lastManualSentCount: null,
          });
        }
      } catch (error) {
        console.error("Error loading digest config:", error);
        alert(
          "Failed to load digest config: " +
            (error instanceof Error ? error.message : String(error))
        );
      } finally {
        setDigestConfigLoading(false);
      }
    };

    loadDigestConfig();
  }, [activeTab, isAdmin]);

  const handleSaveDigestConfig = async () => {
    setDigestConfigSaving(true);
    try {
      // Ensure isActive is explicitly set (not undefined)
      const configToSave = {
        ...digestConfig,
        isActive: digestConfig.isActive === true,
      };

      await setDoc(doc(db, "digestConfig", "current"), configToSave);

      // Verify it was saved correctly
      const verifyDoc = await getDoc(doc(db, "digestConfig", "current"));
      if (verifyDoc.exists()) {
        const savedData = verifyDoc.data();
        console.log(
          "[AdminExtrasPage] Config saved. isActive:",
          savedData.isActive
        );
        alert(
          `Digest config saved successfully! Active: ${savedData.isActive ? "Yes" : "No"}`
        );
      } else {
        alert(
          "Warning: Config was saved but could not be verified. Please try again."
        );
      }
    } catch (error) {
      console.error("Error saving digest config:", error);
      alert(
        "Failed to save digest config: " +
          (error instanceof Error ? error.message : String(error))
      );
    } finally {
      setDigestConfigSaving(false);
    }
  };

  const handleSendDigestNow = async () => {
    // Verify config exists and is active before attempting to send
    const configDoc = await getDoc(doc(db, "digestConfig", "current"));
    if (!configDoc.exists()) {
      alert(
        "No digest config found. Please save a digest configuration first."
      );
      return;
    }

    const configData = configDoc.data();
    if (configData.isActive !== true) {
      alert(
        "Digest config is not active. Please enable the 'Active' checkbox and save the configuration first."
      );
      return;
    }

    if (!digestConfig.isActive) {
      alert("Digest must be active to send. Please enable 'Active' first.");
      return;
    }

    setDigestSendNowBusy(true);
    setDigestSendNowResult(null);
    try {
      const { httpsCallable } = await import("firebase/functions");
      const { functions } = await import("../lib/firebaseBootstrap");
      const sendDigestNow = httpsCallable(functions, "sendDigestNow");

      const result = await sendDigestNow({});
      const data = result.data as {
        ok: boolean;
        sentCount?: number;
        distinctEmails?: number;
      };

      if (data.ok) {
        setDigestSendNowResult({
          ok: true,
          sentCount: data.sentCount,
          distinctEmails: data.distinctEmails,
        });
        // Reload config to get updated stats
        const updatedConfigDoc = await getDoc(
          doc(db, "digestConfig", "current")
        );
        if (updatedConfigDoc.exists()) {
          const updatedConfigData = updatedConfigDoc.data();
          setDigestConfig((prev) => ({
            ...prev,
            lastManualSentAt: updatedConfigData.lastManualSentAt || null,
            lastManualSentCount: updatedConfigData.lastManualSentCount || null,
          }));
        }
      } else {
        setDigestSendNowResult({
          ok: false,
          error: "Unknown error",
        });
      }
    } catch (error: any) {
      console.error("[AdminExtrasPage] Failed to send digest:", error);
      const errorMessage = error.message || String(error);
      setDigestSendNowResult({
        ok: false,
        error: errorMessage,
      });
      // Show alert with helpful message
      if (
        errorMessage.includes("No active digest config") ||
        errorMessage.includes("No digest config")
      ) {
        alert(
          "Error: " +
            errorMessage +
            "\n\nPlease ensure:\n1. The 'Active' checkbox is checked\n2. You have clicked 'Save Digest Config'\n3. The save was successful"
        );
      }
    } finally {
      setDigestSendNowBusy(false);
    }
  };

  const handleDeletePost = async (postId: string) => {
    console.log("[AdminExtrasPage] Delete post clicked:", {
      postId,
      isAdmin,
      adminLoading,
    });

    if (adminLoading) {
      alert("Please wait while we verify your admin status...");
      return;
    }

    if (!isAdmin) {
      console.error("[AdminExtrasPage] User is not an admin:", {
        isAdmin,
        adminLoading,
      });
      alert(
        "Only admins can delete posts. If you believe this is an error, please refresh the page."
      );
      return;
    }

    if (
      !confirm(
        "Are you sure you want to delete this post? This will also delete all comments."
      )
    ) {
      return;
    }

    try {
      console.log("[AdminExtrasPage] Deleting post:", postId);
      await deleteDoc(doc(db, "posts", postId));
      console.log("[AdminExtrasPage] Post deleted successfully");
      alert("Post deleted successfully");
    } catch (error) {
      console.error("Error deleting post:", error);
      alert(
        "Failed to delete post: " +
          (error instanceof Error ? error.message : String(error))
      );
    }
  };

  const handleGenerateInsights = async () => {
    if (!insightsTmdbId) {
      alert("Please enter a TMDB ID");
      return;
    }

    setInsightsGenerating(true);
    setInsightsResult(null);

    try {
      // Parse genres (comma-separated)
      const genresArray = insightsGenres
        .split(",")
        .map((g) => g.trim())
        .filter(Boolean);

      // Build metadata object
      const metadata = {
        tmdbId: parseInt(insightsTmdbId),
        id: parseInt(insightsTmdbId),
        title: insightsTitle || "Unknown Title",
        mediaType: insightsMediaType,
        genres: genresArray,
        year: insightsYear ? parseInt(insightsYear) : null,
        runtimeMins: insightsRuntime ? parseInt(insightsRuntime) : null,
      };

      // Call Firebase callable function (which securely calls Netlify function)
      const { httpsCallable } = await import("firebase/functions");
      const ingestGoofs = httpsCallable(functions, "ingestGoofs");

      const result = await ingestGoofs({
        mode: "single",
        tmdbId: insightsTmdbId,
        metadata: metadata,
      });

      const data = result.data as any;
      setInsightsResult({
        success: data.success || true,
        itemsGenerated: data.itemsGenerated || 0,
      });

      // Clear form
      setInsightsTmdbId("");
      setInsightsTitle("");
      setInsightsGenres("");
      setInsightsYear("");
      setInsightsRuntime("");
    } catch (error: any) {
      console.error("Failed to generate insights:", error);
      setInsightsResult({
        success: false,
        error: error.message || String(error),
      });
    } finally {
      setInsightsGenerating(false);
    }
  };

  const handleBulkIngestion = async () => {
    // Confirm before running bulk ingestion
    const confirmed = window.confirm(
      "Run bulk goofs ingestion now? This will process all titles in Firestore and may take a while."
    );

    if (!confirmed) {
      return;
    }

    setBulkIngestionRunning(true);
    setBulkIngestionResult(null);

    try {
      console.log("[AdminExtrasPage] Starting bulk ingestion via Firebase callable function");
      const { httpsCallable } = await import("firebase/functions");
      const ingestGoofs = httpsCallable(functions, "ingestGoofs");

      console.log("[AdminExtrasPage] Calling ingestGoofs callable function...");
      const result = await ingestGoofs({
        mode: "bulk",
      });
      console.log("[AdminExtrasPage] Bulk ingestion callable returned:", result);

      const data = result.data as any;
      setBulkIngestionResult({
        success: data.success || true,
        total: data.total || 0,
        succeeded: data.succeeded || data.count || 0,
        failed: data.failed || 0,
      });
    } catch (error: any) {
      console.error("Failed to run bulk ingestion:", error);

      // Extract error message from Firebase callable function error
      let errorMessage = "Unknown error";
      if (error) {
        // Firebase callable functions return error with code and message
        if (error.message) {
          errorMessage = error.message;
        } else if (error.code) {
          errorMessage = `Error code: ${error.code}`;
        } else if (typeof error === "string") {
          errorMessage = error;
        } else {
          errorMessage = JSON.stringify(error);
        }
      }

      setBulkIngestionResult({
        success: false,
        error: errorMessage,
      });
    } finally {
      setBulkIngestionRunning(false);
    }
  };

  const handleDeleteComment = async (commentId: string) => {
    console.log("[AdminExtrasPage] Delete comment clicked:", {
      commentId,
      selectedPostId,
      isAdmin,
      adminLoading,
    });

    if (adminLoading) {
      alert("Please wait while we verify your admin status...");
      return;
    }

    if (!isAdmin) {
      console.error("[AdminExtrasPage] User is not an admin:", {
        isAdmin,
        adminLoading,
      });
      alert(
        "Only admins can delete comments. If you believe this is an error, please refresh the page."
      );
      return;
    }

    if (!selectedPostId) {
      alert("No post selected");
      return;
    }

    if (!confirm("Are you sure you want to delete this comment?")) {
      return;
    }

    try {
      console.log("[AdminExtrasPage] Deleting comment:", {
        commentId,
        postId: selectedPostId,
      });
      await deleteDoc(doc(db, "posts", selectedPostId, "comments", commentId));
      console.log("[AdminExtrasPage] Comment deleted successfully");
      alert("Comment deleted successfully");
    } catch (error) {
      console.error("Error deleting comment:", error);
      alert(
        "Failed to delete comment: " +
          (error instanceof Error ? error.message : String(error))
      );
    }
  };

  const pendingCount = videos.filter((v) => v.status === "pending").length;
  const approvedCount = videos.filter((v) => v.status === "approved").length;
  const rejectedCount = videos.filter((v) => v.status === "rejected").length;
  const pendingUGC = ugcSubmissions.filter(
    (s) => s.status === "pending"
  ).length;

  return (
    <>
      <style>{`
        /* Root container - SettingsPage provides padding, so no padding here */
        .admin-extras-root {
          min-height: auto;
          width: 100%;
          background: transparent;
          color: var(--text);
        }

        /* Tabs - Real pills - normalized spacing */
        .admin-extras-tabs {
          display: flex;
          flex-wrap: wrap;
          gap: 0.5rem;
          width: 100%;
          max-width: 100%;
          box-sizing: border-box;
          min-width: 0;
          position: relative;
          contain: layout style;
        }
        
        /* Ensure tabs don't overflow parent container */
        .admin-extras-tabs button {
          flex-shrink: 0;
        }

        .admin-extras-tabs::-webkit-scrollbar {
          display: none;
        }

        .admin-extras-tab {
          white-space: nowrap;
          border-radius: 9999px;
          padding: 0.35rem 0.9rem;
          font-size: 0.85rem;
          border: 1px solid var(--line, #d1d5db);
          background: var(--card, #f9fafb);
          color: var(--text);
          cursor: pointer;
          transition: all 0.2s ease;
          flex-shrink: 0;
          max-width: fit-content;
        }

        .admin-extras-tab:hover {
          background: var(--btn, #f3f4f6);
        }

        .admin-extras-tab--active {
          border-color: var(--accent-primary, #3b82f6);
          background: var(--accent-primary, #3b82f6);
          color: #fff;
          font-weight: 600;
          box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .admin-extras-tab--active:hover {
          background: var(--accent-primary, #3b82f6);
          opacity: 0.95;
        }

        /* Compact sections */
        .admin-extras-section {
          display: flex;
          flex-direction: column;
          gap: 0.5rem;
        }

        /* Form fields - stack on mobile */
        @media (max-width: 900px) {
          .admin-extras-section--auto .admin-extras-fields {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
          }
        }

        @media (min-width: 901px) {
          .admin-extras-section--auto .admin-extras-fields {
            display: flex;
            flex-direction: row;
            gap: 0.75rem;
            align-items: center;
          }
        }

        /* Counts row - compact badges */
        .admin-extras-counts-row {
          display: flex;
          flex-wrap: nowrap;
          gap: 0.5rem;
          font-size: 0.75rem;
          margin-top: 0.5rem;
        }

        .admin-extras-counts-row span {
          padding: 0.2rem 0.45rem;
          border-radius: 9999px;
          background: var(--card, #f3f4f6);
          border: 1px solid var(--line, #e2e8f0);
          color: var(--text);
          white-space: nowrap;
        }

        /* Helper text */
        .admin-extras-helper {
          margin-top: 0.5rem;
          font-size: 0.8rem;
          color: var(--muted, #6b7280);
          text-align: center;
        }


        /* Mobile: Touch-friendly buttons and prevent horizontal scroll */
        @media (max-width: 900px) {
          .admin-extras-root {
            overflow-x: hidden;
            max-width: 100%;
          }
          
          /* Ensure all buttons are touch-friendly (minimum 44px height) */
          .admin-extras-root button,
          .admin-extras-root input[type="button"],
          .admin-extras-root input[type="submit"] {
            min-height: 44px;
            padding: 12px 16px;
            font-size: 16px;
          }
          
          /* Ensure text inputs are touch-friendly */
          .admin-extras-root input[type="text"],
          .admin-extras-root input[type="number"],
          .admin-extras-root textarea,
          .admin-extras-root select {
            min-height: 44px;
            font-size: 16px;
            padding: 12px;
          }
          
          /* Prevent horizontal scrolling */
          .admin-extras-section {
            overflow-x: hidden;
            width: 100%;
          }
          
          /* Ensure content wraps instead of scrolling horizontally */
          .admin-extras-counts-row {
            flex-wrap: wrap;
          }
        }
      `}</style>
      <div className="admin-extras-root space-y-6">
        {/* Main heading - matches other Settings sections */}
        <h3 className="text-xl font-semibold" style={{ color: "var(--text)" }}>
          {activeTab === "community"
            ? "Community Content Management"
            : activeTab === "moderation"
              ? "Moderation Queue"
              : activeTab === "content"
                ? "Auto Content"
                : activeTab === "insights"
                  ? "Insights & Easter Eggs"
                  : activeTab === "comments"
                    ? "Marquee Comments"
                    : activeTab === "videos"
                      ? "Video Submissions"
                      : activeTab === "pro"
                        ? "Pro Status"
                        : activeTab === "admin"
                          ? "Admin Management"
                          : "Admin"}
        </h3>

        {/* Helper text based on active tab */}
        {activeTab === "community" && (
          <p className="text-sm" style={{ color: "var(--muted)" }}>
            Manage all community posts and comments. This is not limited to
            reported content.
          </p>
        )}
        {activeTab === "moderation" && (
          <p className="text-sm" style={{ color: "var(--muted)" }}>
            Items hidden here are removed from Community for regular users. Use
            this to review reports and hide/unhide content.
          </p>
        )}

        {/* Tabs - Dropdown on mobile, horizontal pills on desktop */}
        {isMobile ? (
          <select
            value={activeTab}
            onChange={(e) => setActiveTab(e.target.value as typeof activeTab)}
            style={{
              width: "100%",
              maxWidth: "240px",
              padding: "8px 12px",
              fontSize: "15px",
              borderRadius: "8px",
              backgroundColor: "var(--card)",
              border: "1px solid var(--line)",
              color: "var(--text)",
              minHeight: "40px",
              WebkitAppearance: "none",
              appearance: "none",
              backgroundImage: `url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23666' d='M6 9L1 4h10z'/%3E%3C/svg%3E")`,
              backgroundRepeat: "no-repeat",
              backgroundPosition: "right 10px center",
              paddingRight: "32px",
            }}
          >
            <option value="community">Community Content</option>
            {isAdmin && (
              <option value="moderation">
                Moderation
                {pendingReportsCount > 0 ? ` (${pendingReportsCount})` : ""}
              </option>
            )}
            <option value="content">Auto Content</option>
            <option value="insights">Insights & Easter Eggs</option>
            <option value="comments">Marquee Comments ({pendingUGC})</option>
            <option value="videos">Video Submissions ({pendingUGC})</option>
            <option value="pro">Pro Status</option>
            {isAdmin && <option value="admin">Admin Management</option>}
          </select>
        ) : (
          <div
            className="admin-extras-tabs"
            style={{ width: "100%", maxWidth: "100%", boxSizing: "border-box" }}
          >
            <button
              onClick={() => setActiveTab("community")}
              className={`admin-extras-tab ${activeTab === "community" ? "admin-extras-tab--active" : ""}`}
              title="Community Content"
            >
              Community Content
            </button>
            {isAdmin && (
              <button
                onClick={() => setActiveTab("moderation")}
                className={`admin-extras-tab ${activeTab === "moderation" ? "admin-extras-tab--active" : ""}`}
                title="Moderation Queue"
              >
                Moderation
                {pendingReportsCount > 0 && (
                  <span style={{ marginLeft: "0.25rem", fontWeight: "bold" }}>
                    ({pendingReportsCount})
                  </span>
                )}
              </button>
            )}
            <button
              onClick={() => setActiveTab("content")}
              className={`admin-extras-tab ${activeTab === "content" ? "admin-extras-tab--active" : ""}`}
              title="Auto Content"
            >
              Auto Content
            </button>
            <button
              onClick={() => setActiveTab("insights")}
              className={`admin-extras-tab ${activeTab === "insights" ? "admin-extras-tab--active" : ""}`}
              title="Insights & Easter Eggs"
            >
              Insights & Easter Eggs
            </button>
            <button
              onClick={() => setActiveTab("comments")}
              className={`admin-extras-tab ${activeTab === "comments" ? "admin-extras-tab--active" : ""}`}
              title={`Marquee Comments (${pendingUGC})`}
            >
              Marquee Comments ({pendingUGC})
            </button>
            <button
              onClick={() => setActiveTab("videos")}
              className={`admin-extras-tab ${activeTab === "videos" ? "admin-extras-tab--active" : ""}`}
              title={`Video Submissions (${pendingUGC})`}
            >
              Video Submissions ({pendingUGC})
            </button>
            <button
              onClick={() => setActiveTab("pro")}
              className={`admin-extras-tab ${activeTab === "pro" ? "admin-extras-tab--active" : ""}`}
              title="Pro Status"
            >
              Pro Status
            </button>
            {isAdmin && (
              <button
                onClick={() => setActiveTab("admin")}
                className={`admin-extras-tab ${activeTab === "admin" ? "admin-extras-tab--active" : ""}`}
                title="Admin Management"
              >
                Admin Management
              </button>
            )}
          </div>
        )}

        {/* Tab Content */}
        {activeTab === "insights" && (
          <div className="space-y-6">
            <div
              className="rounded-lg p-4"
              style={{
                backgroundColor: "var(--card)",
                border: "1px solid var(--line)",
              }}
            >
              <h4
                className="text-lg font-medium mb-3"
                style={{ color: "var(--text)" }}
              >
                Generate Insights & Easter Eggs
              </h4>
              <p className="text-sm mb-4" style={{ color: "var(--muted)" }}>
                Generate original &quot;Insights &amp; Easter Eggs&quot; content
                from title metadata. Content is generated using templates +
                metadata, NOT from external copyrighted sources.
                <br />
                <br />
                <strong>Data Flow:</strong> Admin triggers ingestion ‚Üí Netlify
                function fetches/transforms data ‚Üí Writes to Firestore ‚Üí Clients
                read from Firestore (no direct external API calls).
              </p>

              <div
                className="space-y-3"
                style={{ gap: isMobile ? "0.75rem" : "1rem" }}
              >
                <div>
                  <label className="block text-sm font-medium mb-2">
                    TMDB ID (required)
                  </label>
                  <input
                    type="text"
                    value={insightsTmdbId}
                    onChange={(e) => setInsightsTmdbId(e.target.value)}
                    placeholder="e.g., 1399"
                    className="w-full px-3 py-2 border border-gray-300 rounded"
                    style={{
                      borderColor: "var(--line)",
                      backgroundColor: "var(--card)",
                      color: "var(--text)",
                    }}
                  />
                </div>

                <div>
                  <label className="block text-sm font-medium mb-2">
                    Title
                  </label>
                  <input
                    type="text"
                    value={insightsTitle}
                    onChange={(e) => setInsightsTitle(e.target.value)}
                    placeholder="e.g., Game of Thrones"
                    className="w-full px-3 py-2 border border-gray-300 rounded"
                    style={{
                      borderColor: "var(--line)",
                      backgroundColor: "var(--card)",
                      color: "var(--text)",
                    }}
                  />
                </div>

                <div>
                  <label className="block text-sm font-medium mb-2">
                    Media Type
                  </label>
                  <select
                    value={insightsMediaType}
                    onChange={(e) =>
                      setInsightsMediaType(e.target.value as "movie" | "tv")
                    }
                    className="w-full px-3 py-2 border border-gray-300 rounded"
                    style={{
                      borderColor: "var(--line)",
                      backgroundColor: "var(--card)",
                      color: "var(--text)",
                    }}
                  >
                    <option value="tv">TV Show</option>
                    <option value="movie">Movie</option>
                  </select>
                </div>

                <div>
                  <label className="block text-sm font-medium mb-2">
                    Genres (comma-separated)
                  </label>
                  <input
                    type="text"
                    value={insightsGenres}
                    onChange={(e) => setInsightsGenres(e.target.value)}
                    placeholder="e.g., drama, fantasy, action"
                    className="w-full px-3 py-2 border border-gray-300 rounded"
                    style={{
                      borderColor: "var(--line)",
                      backgroundColor: "var(--card)",
                      color: "var(--text)",
                    }}
                  />
                </div>

                <div
                  className={`${isMobile ? "flex flex-col gap-3" : "grid grid-cols-2 gap-4"}`}
                >
                  <div>
                    <label className="block text-sm font-medium mb-2">
                      Year
                    </label>
                    <input
                      type="text"
                      value={insightsYear}
                      onChange={(e) => setInsightsYear(e.target.value)}
                      placeholder="e.g., 2011"
                      className="w-full px-3 py-2 border border-gray-300 rounded"
                      style={{
                        borderColor: "var(--line)",
                        backgroundColor: "var(--card)",
                        color: "var(--text)",
                      }}
                    />
                  </div>

                  <div>
                    <label className="block text-sm font-medium mb-2">
                      Runtime (minutes)
                    </label>
                    <input
                      type="text"
                      value={insightsRuntime}
                      onChange={(e) => setInsightsRuntime(e.target.value)}
                      placeholder="e.g., 60"
                      className="w-full px-3 py-2 border border-gray-300 rounded"
                      style={{
                        borderColor: "var(--line)",
                        backgroundColor: "var(--card)",
                        color: "var(--text)",
                      }}
                    />
                  </div>
                </div>

                <p className="text-xs mb-2" style={{ color: "var(--muted)" }}>
                  Use this for one-off fixes or testing a specific TMDB ID.
                </p>

                <button
                  onClick={handleGenerateInsights}
                  disabled={
                    insightsGenerating ||
                    !insightsTmdbId ||
                    bulkIngestionRunning
                  }
                  className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed"
                >
                  {insightsGenerating ? "Generating..." : "Generate Insights"}
                </button>

                {insightsResult && (
                  <div
                    className={`p-4 rounded ${
                      insightsResult.success
                        ? "bg-green-50 border border-green-200"
                        : "bg-red-50 border border-red-200"
                    }`}
                    style={{
                      backgroundColor: insightsResult.success
                        ? "var(--card)"
                        : "var(--card)",
                      borderColor: "var(--line)",
                    }}
                  >
                    {insightsResult.success ? (
                      <p
                        className="text-sm text-green-800"
                        style={{ color: "var(--text)" }}
                      >
                        ‚úÖ Successfully generated{" "}
                        {insightsResult.itemsGenerated} insights and saved to
                        Firestore. Users will see them the next time they open
                        the Insights &amp; Easter Eggs modal.
                      </p>
                    ) : (
                      <p
                        className="text-sm text-red-800"
                        style={{ color: "var(--text)" }}
                      >
                        ‚ùå Error: {insightsResult.error || "Unknown error"}
                      </p>
                    )}
                  </div>
                )}
              </div>

              {/* Bulk Ingestion Section */}
              <div
                className="mt-6 pt-6"
                style={{
                  borderTop: "1px solid var(--line)",
                }}
              >
                <h5
                  className="text-md font-medium mb-2"
                  style={{ color: "var(--text)" }}
                >
                  Bulk Ingestion
                </h5>
                <p className="text-sm mb-4" style={{ color: "var(--muted)" }}>
                  Use this to refresh goofs/insights for all configured shows.
                  Fetches titles from Firestore (titles collection or user
                  watchlists) and processes them automatically. No TMDB IDs
                  required.
                </p>

                <button
                  onClick={handleBulkIngestion}
                  disabled={
                    bulkIngestionRunning ||
                    insightsGenerating ||
                    bulkIngestionRunning
                  }
                  className="px-4 py-2 bg-purple-600 text-white rounded hover:bg-purple-700 disabled:opacity-50 disabled:cursor-not-allowed"
                >
                  {bulkIngestionRunning
                    ? "Running bulk ingestion..."
                    : "Run bulk goofs ingestion"}
                </button>

                {bulkIngestionResult && (
                  <div
                    className={`mt-4 p-4 rounded ${
                      bulkIngestionResult.success
                        ? "bg-green-50 border border-green-200"
                        : "bg-red-50 border border-red-200"
                    }`}
                    style={{
                      backgroundColor: "var(--card)",
                      borderColor: "var(--line)",
                    }}
                  >
                    {bulkIngestionResult.success ? (
                      <div className="text-sm" style={{ color: "var(--text)" }}>
                        <p className="mb-2">‚úÖ Bulk ingestion complete!</p>
                        <ul className="list-disc list-inside space-y-1">
                          <li>
                            Total titles processed:{" "}
                            {bulkIngestionResult.total || 0}
                          </li>
                          <li>
                            Successfully updated:{" "}
                            {bulkIngestionResult.succeeded || 0}
                          </li>
                          {bulkIngestionResult.failed !== undefined &&
                            bulkIngestionResult.failed > 0 && (
                              <li style={{ color: "var(--muted)" }}>
                                Failed: {bulkIngestionResult.failed}
                              </li>
                            )}
                        </ul>
                        <p
                          className="mt-2 text-xs"
                          style={{ color: "var(--muted)" }}
                        >
                          Users will see updated insights the next time they
                          open the Insights &amp; Easter Eggs modal.
                        </p>
                      </div>
                    ) : (
                      <p
                        className="text-sm text-red-800"
                        style={{ color: "var(--text)" }}
                      >
                        ‚ùå Error: {bulkIngestionResult.error || "Unknown error"}
                      </p>
                    )}
                  </div>
                )}
              </div>
            </div>
          </div>
        )}

        {activeTab === "content" && (
          <div className="space-y-6">
            {/* Controls */}
            <div className="admin-extras-section admin-extras-section--auto">
              <div className="admin-extras-fields">
                <input
                  type="text"
                  placeholder="Show Title"
                  value={selectedShow}
                  onChange={(e) => setSelectedShow(e.target.value)}
                  className="px-3 py-2 border rounded flex-1"
                  style={{
                    borderColor: "var(--line)",
                    backgroundColor: "var(--card)",
                    color: "var(--text)",
                  }}
                />
                <input
                  type="number"
                  placeholder="Show ID"
                  value={showId || ""}
                  onChange={(e) => setShowId(parseInt(e.target.value) || 0)}
                  className="px-3 py-2 border rounded flex-1"
                  style={{
                    borderColor: "var(--line)",
                    backgroundColor: "var(--card)",
                    color: "var(--text)",
                  }}
                />
                <button
                  onClick={handleFetchVideos}
                  disabled={loading || !showId}
                  className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 disabled:opacity-50"
                  style={{ flexShrink: 0 }}
                >
                  {loading ? "Fetching..." : "Fetch Videos"}
                </button>
              </div>

              {/* Stats - Horizontal badge row */}
              <div className="admin-extras-counts-row">
                <span>Pending: {pendingCount}</span>
                <span>Approved: {approvedCount}</span>
                <span>Rejected: {rejectedCount}</span>
              </div>
            </div>

            {/* Bulk Actions */}
            {videos.length > 0 && (
              <div className={`flex gap-2 ${isMobile ? "flex-col" : ""}`}>
                <button
                  onClick={handleBulkApprove}
                  className="px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700"
                >
                  Approve All
                </button>
                <button
                  onClick={handleBulkReject}
                  className="px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700"
                >
                  Reject All
                </button>
              </div>
            )}

            {/* Videos List */}
            <div
              className={`grid grid-cols-1 ${isMobile ? "" : "md:grid-cols-2 lg:grid-cols-3"} gap-4`}
            >
              {videos.map((video) => (
                <div
                  key={video.id}
                  className={`border rounded-lg ${isMobile ? "p-2.5" : "p-4"} ${
                    video.status === "approved"
                      ? "border-green-500 bg-green-50"
                      : video.status === "rejected"
                        ? "border-red-500 bg-red-50"
                        : "border-gray-300"
                  }`}
                >
                  <img
                    src={video.thumbnail}
                    alt={video.title}
                    className="w-full h-32 object-cover rounded mb-2"
                  />
                  <h3 className="font-medium text-sm mb-1 line-clamp-2">
                    {video.title}
                  </h3>
                  <p className="text-xs text-gray-500 mb-2">
                    {video.channelName}
                  </p>
                  <div className="flex items-center justify-between mb-2">
                    <span
                      className={`px-2 py-1 rounded text-xs ${
                        video.category === "bloopers"
                          ? "bg-blue-100 text-blue-800"
                          : "bg-purple-100 text-purple-800"
                      }`}
                    >
                      {video.category}
                    </span>
                    <span className="text-xs text-gray-400">
                      {video.provider}
                    </span>
                  </div>
                  <div className="flex gap-2">
                    <button
                      onClick={() => handleApproveVideo(video.id)}
                      className="px-2 py-1 bg-green-600 text-white text-xs rounded hover:bg-green-700"
                    >
                      Approve
                    </button>
                    <button
                      onClick={() => handleRejectVideo(video.id)}
                      className="px-2 py-1 bg-red-600 text-white text-xs rounded hover:bg-red-700"
                    >
                      Reject
                    </button>
                    <a
                      href={video.watchUrl}
                      target="_blank"
                      rel="noopener noreferrer"
                      className="px-2 py-1 bg-gray-600 text-white text-xs rounded hover:bg-gray-700"
                    >
                      View
                    </a>
                  </div>
                </div>
              ))}
            </div>

            {videos.length === 0 && !loading && (
              <div className="text-center py-8 text-gray-500">
                Enter a show title and ID, then click "Fetch Videos" to get
                started.
              </div>
            )}
          </div>
        )}

        {/* Marquee Comments Tab */}
        {activeTab === "comments" && (
          <div className="space-y-6">
            {ugcSubmissions
              .filter((s) => s.type === "comment")
              .map((submission) => (
                <div
                  key={submission.id}
                  className={`border rounded-lg p-4 ${
                    submission.status === "approved"
                      ? "border-green-500 bg-green-50"
                      : submission.status === "rejected"
                        ? "border-red-500 bg-red-50"
                        : "border-gray-300"
                  }`}
                >
                  <div className="flex justify-between items-start mb-2">
                    <div>
                      <h3 className="font-medium">{submission.showName}</h3>
                      <p
                        className="text-sm text-gray-600"
                        style={{ color: "var(--muted)" }}
                      >
                        By {submission.submittedBy} ‚Ä¢{" "}
                        {new Date(submission.submittedAt).toLocaleDateString()}
                      </p>
                    </div>
                    <span
                      className={`px-2 py-1 rounded text-xs ${
                        submission.status === "approved"
                          ? "bg-green-100 text-green-800"
                          : submission.status === "rejected"
                            ? "bg-red-100 text-red-800"
                            : "bg-yellow-100 text-yellow-800"
                      }`}
                    >
                      {submission.status}
                    </span>
                  </div>
                  <p className="text-sm mb-3">{submission.content}</p>
                  {submission.status === "pending" && (
                    <div className="flex gap-2">
                      <button
                        onClick={() => handleApproveUGC(submission.id)}
                        className="px-3 py-1 bg-green-600 text-white text-sm rounded hover:bg-green-700"
                      >
                        Approve
                      </button>
                      <button
                        onClick={() => {
                          const reason = prompt("Rejection reason:");
                          if (reason) handleRejectUGC(submission.id, reason);
                        }}
                        className="px-3 py-1 bg-red-600 text-white text-sm rounded hover:bg-red-700"
                      >
                        Reject
                      </button>
                    </div>
                  )}
                  {submission.rejectionReason && (
                    <p className="text-xs text-red-600 mt-2">
                      Rejected: {submission.rejectionReason}
                    </p>
                  )}
                </div>
              ))}
            {ugcSubmissions.filter((s) => s.type === "comment").length ===
              0 && (
              <div className="text-center py-8 text-gray-500">
                No marquee comment submissions found.
              </div>
            )}
          </div>
        )}

        {/* Video Submissions Tab */}
        {activeTab === "videos" && (
          <div className="space-y-6">
            {ugcSubmissions
              .filter((s) => s.type === "video")
              .map((submission) => (
                <div
                  key={submission.id}
                  className={`border rounded-lg p-4 ${
                    submission.status === "approved"
                      ? "border-green-500 bg-green-50"
                      : submission.status === "rejected"
                        ? "border-red-500 bg-red-50"
                        : "border-gray-300"
                  }`}
                >
                  <div className="flex justify-between items-start mb-2">
                    <div>
                      <h3 className="font-medium">{submission.showName}</h3>
                      <p
                        className="text-sm text-gray-600"
                        style={{ color: "var(--muted)" }}
                      >
                        By {submission.submittedBy} ‚Ä¢{" "}
                        {new Date(submission.submittedAt).toLocaleDateString()}
                      </p>
                    </div>
                    <span
                      className={`px-2 py-1 rounded text-xs ${
                        submission.status === "approved"
                          ? "bg-green-100 text-green-800"
                          : submission.status === "rejected"
                            ? "bg-red-100 text-red-800"
                            : "bg-yellow-100 text-yellow-800"
                      }`}
                    >
                      {submission.status}
                    </span>
                  </div>
                  <p className="text-sm mb-3">{submission.content}</p>
                  {submission.status === "pending" && (
                    <div className="flex gap-2">
                      <button
                        onClick={() => handleApproveUGC(submission.id)}
                        className="px-3 py-1 bg-green-600 text-white text-sm rounded hover:bg-green-700"
                      >
                        Approve
                      </button>
                      <button
                        onClick={() => {
                          const reason = prompt("Rejection reason:");
                          if (reason) handleRejectUGC(submission.id, reason);
                        }}
                        className="px-3 py-1 bg-red-600 text-white text-sm rounded hover:bg-red-700"
                      >
                        Reject
                      </button>
                    </div>
                  )}
                  {submission.rejectionReason && (
                    <p className="text-xs text-red-600 mt-2">
                      Rejected: {submission.rejectionReason}
                    </p>
                  )}
                </div>
              ))}
            {ugcSubmissions.filter((s) => s.type === "video").length === 0 && (
              <div className="text-center py-8 text-gray-500">
                No video submissions found.
              </div>
            )}
          </div>
        )}

        {/* Community Content Tab */}
        {activeTab === "community" && (
          <div className="space-y-6">
            <div
              className="rounded-lg p-4"
              style={{
                backgroundColor: "var(--card)",
                border: "1px solid var(--line)",
              }}
            >
              {adminLoading ? (
                <p
                  className="text-sm text-yellow-600 mb-4"
                  style={{ color: "var(--muted)" }}
                >
                  ‚è≥ Verifying admin status...
                </p>
              ) : isAdmin ? (
                <p
                  className="text-sm text-green-600 mb-4"
                  style={{ color: "var(--text)" }}
                >
                  ‚úì Admin verified. You can delete any post or comment.
                </p>
              ) : (
                <div
                  className="mb-4 p-3 bg-red-50 border border-red-200 rounded"
                  style={{
                    backgroundColor: "var(--card)",
                    borderColor: "var(--line)",
                  }}
                >
                  <p
                    className="text-sm text-red-600 mb-2"
                    style={{ color: "var(--text)" }}
                  >
                    ‚ö†Ô∏è Admin status not verified. Delete actions are disabled.
                  </p>
                  <p
                    className="text-xs text-red-500 mb-3"
                    style={{ color: "var(--muted)" }}
                  >
                    Your Firebase Auth token does not have the admin role claim.
                    This needs to be set via a Cloud Function or Firebase
                    Console.
                  </p>
                  <div className="flex gap-2 flex-wrap">
                    <button
                      onClick={async () => {
                        try {
                          const { auth } = await import(
                            "../lib/firebaseBootstrap"
                          );
                          if (!auth.currentUser) {
                            alert("You must be signed in to grant admin role");
                            return;
                          }

                          // Get the ID token
                          const token = await auth.currentUser.getIdToken();

                          // Call the HTTP function
                          const functionUrl = import.meta.env.DEV
                            ? "http://localhost:5001/flicklet-71dff/us-central1/setAdminRole"
                            : "https://us-central1-flicklet-71dff.cloudfunctions.net/setAdminRole";

                          console.log(
                            "[AdminExtrasPage] Calling setAdminRole function..."
                          );

                          const response = await fetch(functionUrl, {
                            method: "POST",
                            headers: {
                              "Content-Type": "application/json",
                              Authorization: `Bearer ${token}`,
                            },
                            credentials: "include",
                          });

                          console.log(
                            "[AdminExtrasPage] Response status:",
                            response.status,
                            response.statusText
                          );
                          console.log(
                            "[AdminExtrasPage] Response headers:",
                            Object.fromEntries(response.headers.entries())
                          );

                          const responseText = await response.text();
                          console.log(
                            "[AdminExtrasPage] Response text:",
                            responseText
                          );

                          if (!response.ok) {
                            let errorData;
                            try {
                              errorData = JSON.parse(responseText);
                            } catch {
                              errorData = {
                                error:
                                  responseText || `HTTP ${response.status}`,
                              };
                            }
                            throw new Error(
                              errorData.error || `HTTP ${response.status}`
                            );
                          }

                          let result;
                          try {
                            result = JSON.parse(responseText);
                          } catch (e) {
                            console.error(
                              "[AdminExtrasPage] Failed to parse JSON:",
                              e,
                              "Response text:",
                              responseText
                            );
                            throw new Error(
                              "Invalid response format from server"
                            );
                          }

                          console.log(
                            "[AdminExtrasPage] setAdminRole result:",
                            result
                          );
                          alert(
                            "Admin role granted! Please sign out and sign back in for it to take effect."
                          );
                        } catch (error: any) {
                          console.error(
                            "[AdminExtrasPage] Failed to set admin role:",
                            error
                          );
                          if (
                            error.message?.includes("CORS") ||
                            error.message?.includes("Failed to fetch")
                          ) {
                            alert(
                              "CORS error: Cannot call Cloud Function.\n\n" +
                                "The function may need to be redeployed. Please try:\n" +
                                "1. Redeploy functions: 'firebase deploy --only functions'\n" +
                                "2. Or use Firebase Console to set admin role directly"
                            );
                          } else {
                            alert(
                              "Failed to set admin role: " +
                                (error.message || String(error))
                            );
                          }
                        }
                      }}
                      className="px-3 py-1 bg-blue-600 text-white text-sm rounded hover:bg-blue-700"
                    >
                      Grant Admin Role
                    </button>
                    <button
                      onClick={async () => {
                        try {
                          const { auth } = await import(
                            "../lib/firebaseBootstrap"
                          );
                          if (auth.currentUser) {
                            console.log(
                              "[AdminExtrasPage] Refreshing token..."
                            );
                            const token =
                              await auth.currentUser.getIdTokenResult(true); // Force refresh
                            console.log(
                              "[AdminExtrasPage] Token claims after refresh:",
                              token.claims
                            );
                            console.log(
                              "[AdminExtrasPage] Role:",
                              token.claims.role
                            );
                            if (token.claims.role === "admin") {
                              alert("Admin role verified! Reloading page...");
                              window.location.reload();
                            } else {
                              alert(
                                "Admin role still not found in token. Please grant the role first, then sign out and sign back in."
                              );
                            }
                          }
                        } catch (error) {
                          console.error("Failed to refresh token:", error);
                          alert(
                            "Failed to refresh token. Please try logging out and back in."
                          );
                        }
                      }}
                      className="px-3 py-1 bg-red-600 text-white text-sm rounded hover:bg-red-700"
                    >
                      Refresh Admin Token
                    </button>
                    <button
                      onClick={async () => {
                        try {
                          const { auth } = await import(
                            "../lib/firebaseBootstrap"
                          );
                          if (auth.currentUser) {
                            const token =
                              await auth.currentUser.getIdTokenResult();
                            console.log(
                              "[AdminExtrasPage] Current token claims:",
                              token.claims
                            );
                            console.log(
                              "[AdminExtrasPage] Full token result:",
                              token
                            );
                            alert(
                              `Token claims logged to console. Role: ${token.claims.role || "not set"}`
                            );
                          }
                        } catch (error) {
                          console.error("Failed to get token:", error);
                        }
                      }}
                      className="px-3 py-1 bg-gray-600 text-white text-sm rounded hover:bg-gray-700"
                    >
                      Check Token (Console)
                    </button>
                  </div>
                </div>
              )}

              {/* Posts List */}
              <div className="mb-4">
                <h3
                  className="text-lg font-semibold mb-3"
                  style={{ color: "var(--text)" }}
                >
                  Posts ({posts.length})
                </h3>
                <div className="space-y-2">
                  {posts.map((post) => (
                    <div
                      key={post.id}
                      className="flex items-center justify-between p-3 bg-white rounded border border-gray-200"
                      style={{
                        backgroundColor: "var(--card)",
                        borderColor: "var(--line)",
                      }}
                    >
                      <div className="flex-1 min-w-0">
                        <h4 className="font-medium truncate">
                          {post.title || "Untitled"}
                        </h4>
                        <p className="text-xs text-gray-500 truncate">
                          By {post.authorName || "Unknown"} ‚Ä¢{" "}
                          {post.publishedAt?.toDate?.()?.toLocaleDateString() ||
                            "Unknown date"}
                        </p>
                        <p className="text-xs text-gray-400 mt-1">
                          {post.commentCount || 0} comments ‚Ä¢{" "}
                          {post.voteCount || 0} votes
                        </p>
                      </div>
                      <div className="flex gap-2 ml-4">
                        <button
                          onClick={() =>
                            setSelectedPostId(
                              post.id === selectedPostId ? null : post.id
                            )
                          }
                          className="px-3 py-1 bg-blue-600 text-white text-sm rounded hover:bg-blue-700"
                        >
                          {selectedPostId === post.id
                            ? "Hide Comments"
                            : "View Comments"}
                        </button>
                        <button
                          onClick={() => handleDeletePost(post.id)}
                          className="px-3 py-1 bg-red-600 text-white text-sm rounded hover:bg-red-700"
                        >
                          Delete
                        </button>
                      </div>
                    </div>
                  ))}
                  {posts.length === 0 && (
                    <p className="text-center text-gray-500 py-4">
                      No posts found
                    </p>
                  )}
                </div>
              </div>

              {/* Comments for Selected Post */}
              {selectedPostId && (
                <div className="mt-4">
                  <h3
                    className="text-lg font-semibold mb-3"
                    style={{ color: "var(--text)" }}
                  >
                    Comments ({postComments.length})
                  </h3>
                  <div className="space-y-2">
                    {postComments.map((comment) => (
                      <div
                        key={comment.id}
                        className="p-3 bg-white rounded border border-gray-200"
                        style={{
                          backgroundColor: "var(--card)",
                          borderColor: "var(--line)",
                        }}
                      >
                        <div className="flex items-start justify-between">
                          <div className="flex-1 min-w-0">
                            <p className="text-sm font-medium">
                              {comment.authorName || "Anonymous"}
                            </p>
                            <p
                              className="text-sm text-gray-600 mt-1 whitespace-pre-wrap"
                              style={{ color: "var(--text)" }}
                            >
                              {comment.body}
                            </p>
                            <p className="text-xs text-gray-500 mt-1">
                              {comment.createdAt
                                ?.toDate?.()
                                ?.toLocaleDateString() || "Unknown date"}
                            </p>
                          </div>
                          <button
                            onClick={() => handleDeleteComment(comment.id)}
                            className="ml-4 px-3 py-1 bg-red-600 text-white text-sm rounded hover:bg-red-700"
                          >
                            Delete
                          </button>
                        </div>
                      </div>
                    ))}
                    {postComments.length === 0 && (
                      <p className="text-center text-gray-500 py-4">
                        No comments for this post
                      </p>
                    )}
                  </div>
                </div>
              )}
            </div>
          </div>
        )}

        {/* Pro Status Tab */}
        {activeTab === "pro" && (
          <div className="space-y-6">
            <div
              className="bg-gray-100 rounded-lg p-6"
              style={{ backgroundColor: "var(--card)" }}
            >
              <h2 className="text-2xl font-bold mb-4">Pro Status Management</h2>

              <div className="space-y-4">
                <div
                  className="flex items-center justify-between p-4 bg-white rounded-lg border border-gray-200"
                  style={{
                    backgroundColor: "var(--card)",
                    borderColor: "var(--line)",
                  }}
                >
                  <div>
                    <h3
                      className="text-lg font-semibold mb-1"
                      style={{ color: "var(--text)" }}
                    >
                      Pro Status
                    </h3>
                    <p
                      className="text-sm text-gray-600"
                      style={{ color: "var(--muted)" }}
                    >
                      Current status:{" "}
                      <strong
                        className={isPro ? "text-green-600" : "text-gray-500"}
                      >
                        {isPro ? "Pro Enabled" : "Pro Disabled"}
                      </strong>
                    </p>
                  </div>
                  <label className="relative inline-flex items-center cursor-pointer">
                    <input
                      type="checkbox"
                      checked={isPro}
                      onChange={handleTogglePro}
                      className="sr-only peer"
                    />
                    <div
                      className="w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-blue-300 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600"
                      style={{
                        backgroundColor: "var(--btn)",
                        borderColor: "var(--line)",
                      }}
                    ></div>
                  </label>
                </div>

                {isPro && (
                  <div
                    className="mt-4 p-4 bg-green-50 rounded-lg border border-green-200"
                    style={{
                      backgroundColor: "var(--card)",
                      borderColor: "var(--line)",
                    }}
                  >
                    <h4
                      className="font-semibold text-green-800 mb-2"
                      style={{ color: "var(--text)" }}
                    >
                      Pro Features Enabled:
                    </h4>
                    <ul
                      className="list-disc list-inside space-y-1 text-sm text-green-700"
                      style={{ color: "var(--text)" }}
                    >
                      <li>Advanced Notifications</li>
                      <li>Theme Packs</li>
                      <li>Social Features</li>
                      <li>Bloopers Access</li>
                      <li>Extras Access</li>
                      <li>3 FlickWord games per day (vs 1 for free)</li>
                      <li>50 Trivia questions (vs 10 for free)</li>
                    </ul>
                  </div>
                )}

                {!isPro && (
                  <div
                    className="mt-4 p-4 bg-gray-50 rounded-lg border border-gray-200"
                    style={{
                      backgroundColor: "var(--card)",
                      borderColor: "var(--line)",
                    }}
                  >
                    <h4
                      className="font-semibold text-gray-800 mb-2"
                      style={{ color: "var(--text)" }}
                    >
                      Free Tier Limitations:
                    </h4>
                    <ul
                      className="list-disc list-inside space-y-1 text-sm text-gray-700"
                      style={{ color: "var(--text)" }}
                    >
                      <li>1 FlickWord game per day</li>
                      <li>10 Trivia questions per day</li>
                      <li>No advanced notifications</li>
                      <li>No theme packs</li>
                      <li>No social features</li>
                      <li>No bloopers/extras access</li>
                    </ul>
                  </div>
                )}

                <div
                  className="mt-6 p-4 bg-blue-50 rounded-lg border border-blue-200"
                  style={{
                    backgroundColor: "var(--card)",
                    borderColor: "var(--line)",
                  }}
                >
                  <p
                    className="text-sm text-blue-800"
                    style={{ color: "var(--text)" }}
                  >
                    <strong>Note:</strong> This toggle controls Pro status for
                    the current user. Changes are saved immediately to
                    localStorage and will persist across sessions.
                  </p>
                </div>
              </div>
            </div>
          </div>
        )}

        {/* Moderation Queue Tab */}
        {activeTab === "moderation" && isAdmin && (
          <ModerationQueue
            reports={reports}
            reportsLoading={reportsLoading}
            processingReport={processingReport}
            onLoadReports={async () => {
              setReportsLoading(true);
              try {
                const allReports = await getAllReports();
                setReports(allReports);
              } catch (error) {
                console.error("Failed to load reports:", error);
                alert("Failed to load reports. Please try again.");
              } finally {
                setReportsLoading(false);
              }
            }}
            onUpdateStatus={async (reportId, status) => {
              setProcessingReport(reportId);
              try {
                await updateReportStatus(reportId, status);
                // Reload reports
                const allReports = await getAllReports();
                setReports(allReports);
              } catch (error) {
                console.error("Failed to update report status:", error);
                alert("Failed to update report status. Please try again.");
              } finally {
                setProcessingReport(null);
              }
            }}
            onToggleHidden={async (report) => {
              setProcessingReport(report.id);
              try {
                if (report.itemType === "post") {
                  // Get current hidden state
                  const postRef = doc(db, "posts", report.itemId);
                  const postSnap = await getDoc(postRef);
                  const currentHidden = postSnap.data()?.hidden || false;
                  await toggleItemHidden(report.itemId, "post", !currentHidden);
                } else {
                  // For comments, we need to find the postId
                  // This is a limitation - we'll need to store postId in reports or query for it
                  // For now, let's add a helper to find postId from commentId
                  const postsRef = collection(db, "posts");
                  const postsSnapshot = await getDocs(postsRef);
                  let foundPostId: string | null = null;

                  for (const postDoc of postsSnapshot.docs) {
                    const commentsRef = collection(
                      db,
                      "posts",
                      postDoc.id,
                      "comments"
                    );
                    const commentDoc = doc(commentsRef, report.itemId);
                    const commentSnap = await getDoc(commentDoc);
                    if (commentSnap.exists()) {
                      foundPostId = postDoc.id;
                      break;
                    }
                  }

                  if (foundPostId) {
                    const commentRef = doc(
                      db,
                      "posts",
                      foundPostId,
                      "comments",
                      report.itemId
                    );
                    const commentSnap = await getDoc(commentRef);
                    const currentHidden = commentSnap.data()?.hidden || false;
                    await toggleCommentHidden(
                      foundPostId,
                      report.itemId,
                      !currentHidden
                    );
                  } else {
                    throw new Error("Could not find post for comment");
                  }
                }
                // Reload reports
                const allReports = await getAllReports();
                setReports(allReports);
              } catch (error) {
                console.error("Failed to toggle hidden status:", error);
                alert("Failed to toggle hidden status. Please try again.");
              } finally {
                setProcessingReport(null);
              }
            }}
          />
        )}

        {/* Admin Management Tab */}
        {activeTab === "admin" && isAdmin && (
          <div className="space-y-6">
            {/* Weekly Digest Config */}
            <div
              className="bg-gray-100 rounded-lg p-6"
              style={{ backgroundColor: "var(--card)" }}
            >
              <h2 className="text-2xl font-bold mb-4">
                Weekly Digest Email Configuration
              </h2>
              <p
                className="text-sm text-gray-600 mb-4"
                style={{ color: "var(--muted)" }}
              >
                Configure the content for the weekly digest email sent to
                subscribers.
              </p>

              {digestConfigLoading ? (
                <div className="text-center py-4">Loading config...</div>
              ) : (
                <div className="space-y-4">
                  <div>
                    <label className="flex items-center gap-2 mb-2">
                      <input
                        type="checkbox"
                        checked={digestConfig.isActive}
                        onChange={(e) =>
                          setDigestConfig({
                            ...digestConfig,
                            isActive: e.target.checked,
                          })
                        }
                        className="w-4 h-4"
                      />
                      <span className="font-medium">
                        Active (emails will be sent when enabled)
                      </span>
                    </label>
                  </div>

                  <div
                    className="border-t border-gray-300 pt-4"
                    style={{ borderColor: "var(--line)" }}
                  >
                    <h3 className="font-semibold mb-3">
                      Automatic Send Settings
                    </h3>

                    <div className="space-y-3">
                      <div>
                        <label className="flex items-center gap-2 mb-2">
                          <input
                            type="checkbox"
                            checked={digestConfig.autoSendEnabled}
                            onChange={(e) =>
                              setDigestConfig({
                                ...digestConfig,
                                autoSendEnabled: e.target.checked,
                              })
                            }
                            className="w-4 h-4"
                          />
                          <span className="font-medium">
                            Automatic weekly send enabled
                          </span>
                        </label>
                      </div>

                      <div>
                        <label className="block text-sm font-medium mb-2">
                          Day of week (for weekly send)
                        </label>
                        <select
                          value={digestConfig.autoSendDay}
                          onChange={(e) =>
                            setDigestConfig({
                              ...digestConfig,
                              autoSendDay: e.target.value,
                            })
                          }
                          disabled={!digestConfig.autoSendEnabled}
                          className="w-full px-3 py-2 border border-gray-300 rounded disabled:opacity-50 disabled:cursor-not-allowed"
                          style={{
                            borderColor: "var(--line)",
                            backgroundColor: "var(--card)",
                            color: "var(--text)",
                          }}
                        >
                          <option value="monday">Monday</option>
                          <option value="tuesday">Tuesday</option>
                          <option value="wednesday">Wednesday</option>
                          <option value="thursday">Thursday</option>
                          <option value="friday">Friday</option>
                          <option value="saturday">Saturday</option>
                          <option value="sunday">Sunday</option>
                        </select>
                      </div>

                      <div>
                        <label className="block text-sm font-medium mb-2">
                          Time of day
                        </label>
                        <input
                          type="time"
                          value={digestConfig.autoSendTime}
                          onChange={(e) =>
                            setDigestConfig({
                              ...digestConfig,
                              autoSendTime: e.target.value,
                            })
                          }
                          disabled={!digestConfig.autoSendEnabled}
                          className="w-full px-3 py-2 border border-gray-300 rounded disabled:opacity-50 disabled:cursor-not-allowed"
                          style={{
                            borderColor: "var(--line)",
                            backgroundColor: "var(--card)",
                            color: "var(--text)",
                          }}
                        />
                      </div>

                      <p
                        className="text-xs text-gray-500 italic"
                        style={{ color: "var(--muted)" }}
                      >
                        Current backend schedule still uses a fixed cron
                        trigger; this day/time is stored in config and will be
                        fully honored in a later update. The On/Off toggle is
                        effective now: when off, the automatic send is skipped.
                      </p>
                    </div>
                  </div>

                  <div>
                    <label className="block text-sm font-medium mb-2">
                      Email Subject / Title
                    </label>
                    <input
                      type="text"
                      value={digestConfig.title}
                      onChange={(e) =>
                        setDigestConfig({
                          ...digestConfig,
                          title: e.target.value,
                        })
                      }
                      className="w-full px-3 py-2 border border-gray-300 rounded"
                      style={{
                        borderColor: "var(--line)",
                        backgroundColor: "var(--card)",
                        color: "var(--text)",
                      }}
                      placeholder="üé¨ Flicklet Weekly ‚Äî We actually shipped things."
                    />
                  </div>

                  <div>
                    <label className="block text-sm font-medium mb-2">
                      Intro Text
                    </label>
                    <textarea
                      value={digestConfig.intro}
                      onChange={(e) =>
                        setDigestConfig({
                          ...digestConfig,
                          intro: e.target.value,
                        })
                      }
                      rows={2}
                      className="w-full px-3 py-2 border border-gray-300 rounded"
                      style={{
                        borderColor: "var(--line)",
                        backgroundColor: "var(--card)",
                        color: "var(--text)",
                      }}
                      placeholder="Here's your Flicklet update in under a minute."
                    />
                  </div>

                  <div
                    className="border-t border-gray-300 pt-4"
                    style={{ borderColor: "var(--line)" }}
                  >
                    <h3 className="font-semibold mb-3">
                      Product Pulse Section
                    </h3>

                    <div className="space-y-3">
                      <div>
                        <label className="block text-sm font-medium mb-2">
                          What Changed (üîß)
                        </label>
                        <input
                          type="text"
                          value={digestConfig.productPulseChanged}
                          onChange={(e) =>
                            setDigestConfig({
                              ...digestConfig,
                              productPulseChanged: e.target.value,
                            })
                          }
                          className="w-full px-3 py-2 border border-gray-300 rounded"
                          style={{
                            borderColor: "var(--line)",
                            backgroundColor: "var(--card)",
                            color: "var(--text)",
                          }}
                          placeholder="Ratings now stick between sessions."
                        />
                      </div>

                      <div>
                        <label className="block text-sm font-medium mb-2">
                          What's Next (üëÄ)
                        </label>
                        <input
                          type="text"
                          value={digestConfig.productPulseNext}
                          onChange={(e) =>
                            setDigestConfig({
                              ...digestConfig,
                              productPulseNext: e.target.value,
                            })
                          }
                          className="w-full px-3 py-2 border border-gray-300 rounded"
                          style={{
                            borderColor: "var(--line)",
                            backgroundColor: "var(--card)",
                            color: "var(--text)",
                          }}
                          placeholder="‚Ä¢ Smarter discovery rails ‚Ä¢ Swipe gestures that don't argue with gravity"
                        />
                      </div>

                      <div>
                        <label className="block text-sm font-medium mb-2">
                          How to Use It
                        </label>
                        <input
                          type="text"
                          value={digestConfig.productPulseHowTo}
                          onChange={(e) =>
                            setDigestConfig({
                              ...digestConfig,
                              productPulseHowTo: e.target.value,
                            })
                          }
                          className="w-full px-3 py-2 border border-gray-300 rounded"
                          style={{
                            borderColor: "var(--line)",
                            backgroundColor: "var(--card)",
                            color: "var(--text)",
                          }}
                          placeholder="Tap ‚òÖ once. It remembers now."
                        />
                      </div>

                      <div>
                        <label className="block text-sm font-medium mb-2">
                          Hidden Bonus
                        </label>
                        <input
                          type="text"
                          value={digestConfig.productPulseBonus}
                          onChange={(e) =>
                            setDigestConfig({
                              ...digestConfig,
                              productPulseBonus: e.target.value,
                            })
                          }
                          className="w-full px-3 py-2 border border-gray-300 rounded"
                          style={{
                            borderColor: "var(--line)",
                            backgroundColor: "var(--card)",
                            color: "var(--text)",
                          }}
                          placeholder="Library loads faster so you spend less time staring at spinners."
                        />
                      </div>
                    </div>
                  </div>

                  <div
                    className="border-t border-gray-300 pt-4"
                    style={{ borderColor: "var(--line)" }}
                  >
                    <h3 className="font-semibold mb-3">Tip Section</h3>

                    <div className="space-y-3">
                      <div>
                        <label className="block text-sm font-medium mb-2">
                          Tip Headline
                        </label>
                        <input
                          type="text"
                          value={digestConfig.tipHeadline}
                          onChange={(e) =>
                            setDigestConfig({
                              ...digestConfig,
                              tipHeadline: e.target.value,
                            })
                          }
                          className="w-full px-3 py-2 border border-gray-300 rounded"
                          style={{
                            borderColor: "var(--line)",
                            backgroundColor: "var(--card)",
                            color: "var(--text)",
                          }}
                          placeholder="The One Thing You Didn't Know You Needed"
                        />
                      </div>

                      <div>
                        <label className="block text-sm font-medium mb-2">
                          Tip Body
                        </label>
                        <textarea
                          value={digestConfig.tipBody}
                          onChange={(e) =>
                            setDigestConfig({
                              ...digestConfig,
                              tipBody: e.target.value,
                            })
                          }
                          rows={3}
                          className="w-full px-3 py-2 border border-gray-300 rounded"
                          style={{
                            borderColor: "var(--line)",
                            backgroundColor: "var(--card)",
                            color: "var(--text)",
                          }}
                          placeholder="Hold your finger on a card to reorder your list. Saves 10 clicks and a small piece of your soul."
                        />
                      </div>
                    </div>
                  </div>

                  <div>
                    <label className="block text-sm font-medium mb-2">
                      Footer Note
                    </label>
                    <input
                      type="text"
                      value={digestConfig.footerNote}
                      onChange={(e) =>
                        setDigestConfig({
                          ...digestConfig,
                          footerNote: e.target.value,
                        })
                      }
                      className="w-full px-3 py-2 border border-gray-300 rounded"
                      style={{
                        borderColor: "var(--line)",
                        backgroundColor: "var(--card)",
                        color: "var(--text)",
                      }}
                      placeholder="Was this worth your 42 seconds?"
                    />
                  </div>

                  <div className="flex gap-2">
                    <button
                      onClick={handleSaveDigestConfig}
                      disabled={digestConfigSaving}
                      className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 disabled:opacity-50"
                    >
                      {digestConfigSaving ? "Saving..." : "Save Digest Config"}
                    </button>

                    <button
                      onClick={handleSendDigestNow}
                      disabled={digestSendNowBusy || !digestConfig.isActive}
                      className="px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700 disabled:opacity-50"
                    >
                      {digestSendNowBusy ? "Sending..." : "Send digest now"}
                    </button>
                  </div>

                  {digestSendNowResult && (
                    <div
                      className={`mt-4 p-3 rounded ${
                        digestSendNowResult.ok
                          ? "bg-green-50 border border-green-200"
                          : "bg-red-50 border border-red-200"
                      }`}
                    >
                      {digestSendNowResult.ok ? (
                        <p
                          className="text-sm text-green-800"
                          style={{ color: "var(--text)" }}
                        >
                          Manual send completed: {digestSendNowResult.sentCount}{" "}
                          emails sent to {digestSendNowResult.distinctEmails}{" "}
                          unique addresses.
                        </p>
                      ) : (
                        <p
                          className="text-sm text-red-800"
                          style={{ color: "var(--text)" }}
                        >
                          Error: {digestSendNowResult.error || "Unknown error"}
                        </p>
                      )}
                    </div>
                  )}

                  <div
                    className="border-t border-gray-300 pt-4 mt-4"
                    style={{ borderColor: "var(--line)" }}
                  >
                    <h3 className="font-semibold mb-3">Send Summary</h3>
                    <div className="space-y-2 text-sm">
                      <div>
                        <strong>Last automatic send:</strong>
                        <br />
                        Time:{" "}
                        {digestConfig.lastAutoSentAt
                          ? new Date(
                              digestConfig.lastAutoSentAt.toMillis?.() ||
                                digestConfig.lastAutoSentAt.seconds * 1000
                            ).toLocaleString()
                          : "never"}
                        <br />
                        Sent to: {digestConfig.lastAutoSentCount ?? 0} unique
                        email(s)
                      </div>
                      <div>
                        <strong>Last manual send:</strong>
                        <br />
                        Time:{" "}
                        {digestConfig.lastManualSentAt
                          ? new Date(
                              digestConfig.lastManualSentAt.toMillis?.() ||
                                digestConfig.lastManualSentAt.seconds * 1000
                            ).toLocaleString()
                          : "never"}
                        <br />
                        Sent to: {digestConfig.lastManualSentCount ?? 0} unique
                        email(s)
                      </div>
                    </div>
                  </div>
                </div>
              )}
            </div>

            {/* Admin Role Management */}
            <div
              className="bg-gray-100 rounded-lg p-6"
              style={{ backgroundColor: "var(--card)" }}
            >
              <h2 className="text-2xl font-bold mb-4">
                Grant Admin Role to Other Users
              </h2>
              <p
                className="text-sm text-gray-600 mb-4"
                style={{ color: "var(--muted)" }}
              >
                Enter a user's email address or user ID to grant or revoke admin
                role.
              </p>

              <div className="space-y-4">
                <div>
                  <label
                    htmlFor="adminEmail"
                    className="block text-sm font-medium mb-2"
                  >
                    User Email
                  </label>
                  <input
                    id="adminEmail"
                    type="email"
                    value={adminEmail}
                    onChange={(e) => setAdminEmail(e.target.value)}
                    placeholder="user@example.com"
                    className="w-full px-3 py-2 border border-gray-300 rounded-md"
                    style={{
                      borderColor: "var(--line)",
                      backgroundColor: "var(--card)",
                      color: "var(--text)",
                    }}
                  />
                </div>

                <div
                  className="text-center text-gray-500"
                  style={{ color: "var(--muted)" }}
                >
                  OR
                </div>

                <div>
                  <label
                    htmlFor="adminUserId"
                    className="block text-sm font-medium mb-2"
                  >
                    User ID (Firebase UID)
                  </label>
                  <input
                    id="adminUserId"
                    type="text"
                    value={adminUserId}
                    onChange={(e) => setAdminUserId(e.target.value)}
                    placeholder="M48zRZYH4AbPu79JMxtYVO1w4vo2"
                    className="w-full px-3 py-2 border border-gray-300 rounded-md"
                    style={{
                      borderColor: "var(--line)",
                      backgroundColor: "var(--card)",
                      color: "var(--text)",
                    }}
                  />
                </div>

                <div className="flex gap-2">
                  <button
                    onClick={async () => {
                      if (!adminEmail && !adminUserId) {
                        alert("Please enter either an email or user ID");
                        return;
                      }

                      setAdminManagementLoading(true);
                      try {
                        const { httpsCallable } = await import(
                          "firebase/functions"
                        );
                        const { functions } = await import(
                          "../lib/firebaseBootstrap"
                        );
                        const manageAdminRole = httpsCallable(
                          functions,
                          "manageAdminRole"
                        );

                        // First, get user ID from email if needed
                        if (adminEmail && !adminUserId) {
                          // For email, we need to look up the user ID
                          // Since we can't do this directly from client, we'll need to
                          // modify the function to accept email, or use Admin SDK
                          // For now, let's require user ID for email lookup
                          alert(
                            "Please use User ID for now, or use Firebase Console to grant by email."
                          );
                          setAdminManagementLoading(false);
                          return;
                        }

                        if (!adminUserId) {
                          alert("Please enter a user ID");
                          setAdminManagementLoading(false);
                          return;
                        }

                        const result = await manageAdminRole({
                          userId: adminUserId,
                          grant: true,
                        });

                        console.log(
                          "[AdminExtrasPage] Admin role granted:",
                          result.data
                        );
                        alert(
                          `Admin role granted to user ${adminUserId}. They need to sign out and sign back in for it to take effect.`
                        );
                        setAdminEmail("");
                        setAdminUserId("");
                      } catch (error: any) {
                        console.error(
                          "[AdminExtrasPage] Failed to grant admin role:",
                          error
                        );
                        alert(
                          "Failed to grant admin role: " +
                            (error.message || String(error))
                        );
                      } finally {
                        setAdminManagementLoading(false);
                      }
                    }}
                    disabled={adminManagementLoading}
                    className="px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700 disabled:opacity-50"
                  >
                    {adminManagementLoading
                      ? "Granting..."
                      : "Grant Admin Role"}
                  </button>

                  <button
                    onClick={async () => {
                      if (!adminUserId) {
                        alert("Please enter a user ID to revoke admin role");
                        return;
                      }

                      setAdminManagementLoading(true);
                      try {
                        const { httpsCallable } = await import(
                          "firebase/functions"
                        );
                        const { functions } = await import(
                          "../lib/firebaseBootstrap"
                        );
                        const manageAdminRole = httpsCallable(
                          functions,
                          "manageAdminRole"
                        );

                        const result = await manageAdminRole({
                          userId: adminUserId,
                          grant: false,
                        });

                        console.log(
                          "[AdminExtrasPage] Admin role revoked:",
                          result.data
                        );
                        alert(
                          `Admin role revoked from user ${adminUserId}. They need to sign out and sign back in for it to take effect.`
                        );
                        setAdminEmail("");
                        setAdminUserId("");
                      } catch (error: any) {
                        console.error(
                          "[AdminExtrasPage] Failed to revoke admin role:",
                          error
                        );
                        alert(
                          "Failed to revoke admin role: " +
                            (error.message || String(error))
                        );
                      } finally {
                        setAdminManagementLoading(false);
                      }
                    }}
                    disabled={adminManagementLoading || !adminUserId}
                    className="px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700 disabled:opacity-50"
                  >
                    {adminManagementLoading
                      ? "Revoking..."
                      : "Revoke Admin Role"}
                  </button>
                </div>

                <div
                  className="mt-4 p-3 bg-blue-50 rounded border border-blue-200"
                  style={{
                    backgroundColor: "var(--card)",
                    borderColor: "var(--line)",
                  }}
                >
                  <p
                    className="text-sm text-blue-800"
                    style={{ color: "var(--text)" }}
                  >
                    <strong>Note:</strong> Users must sign out and sign back in
                    for admin role changes to take effect. You can find user IDs
                    in Firebase Console ‚Üí Authentication.
                  </p>
                </div>
              </div>
            </div>
          </div>
        )}
      </div>
    </>
  );
}

```

## apps/web/src/search/rank.ts
### Summary
Ranking utilities that weight TMDB voteAverage, voteCount, recency, franchise, and tie-breakers for search results.
### Content
```ts
/**
 * Search ranking utilities
 * Purpose: Computes relevance scores for search results using BM25-like signals
 * Data Source: MediaItem fields from TMDB responses
 * Update Path: Adjust coefficients in computeScore function
 * Dependencies: Used by smartSearch and api.ts
 * 
 * Test Assertions:
 * - "predator" ‚Üí Predator (1987) should rank in top 3
 * - "predator 1987" ‚Üí Predator (1987) should rank #1 (year bonus +20)
 * - Exact title matches beat purely popular but non-exact matches
 * - Franchise roots (earliest year) preferred over sequels in tie-breaking
 */

import { normalizeTitle, tokensLower as tokensLowerUtil } from '../lib/string';

const ARTICLES = new Set(['the','a','an']);

// Score constants for search ranking
export const SCORE = {
  EXACT: 100,
  AKA_EXACT: 60,
  LEADING: 70,
  STARTS: 45,
  WORD: 30,
  CONTAINS: 25,
  FRANCHISE_ROOT: 30,
  YEAR_MATCH: 20,
  POPULARITY_MAX: 10,
  RECENCY_MAX: 8,
  RECENCY_MIN: -6,
  VOTE_SIG_EXACT: 10,
  VOTE_SIG_NON_EXACT: 5,
  TYPE_MATCH: 0.5,
  LANG_HINT: 0.5,
  BM25: 2
} as const;

export type SearchFeatures = {
  title: string;
  originalTitle?: string;
  aliases?: string[];
  overview?: string;
  popularity?: number;       // TMDB popularity
  voteAverage?: number;      // 0..10
  voteCount?: number;
  releaseYear?: number | null;
  releaseDate?: string | null; // ISO date string for more precise recency calculation
  mediaType: 'movie' | 'tv' | 'person';
  originalLanguage?: string | null;
  collectionName?: string;   // TMDB collection name if part of a franchise
};

export type TitleSignal = { score: number; tier: 'exact'|'leading'|'starts'|'word'|'contains'|'overlap' };

export function computeSearchScore(
  query: string, 
  features: SearchFeatures, 
  opts: {
    preferType?: 'movie' | 'tv' | 'person' | 'all',
    userLocaleLangs?: string[],
    debugSearch?: boolean
  } = {}
): { score: number; titleSig: TitleSignal; debug?: Record<string, number> } {
  const q = normalizeTitle(query);
  const title = normalizeTitle(features.title);
  const orig = normalizeTitle(features.originalTitle || '');
  const aliases = (features.aliases || []).map(normalizeTitle);
  
  // Parse year from query if present
  const yearMatch = /\b(19|20)\d{2}\b/.exec(query);
  const queryYear = yearMatch ? parseInt(yearMatch[0]) : null;

  // Title matching signals
  const titleSig = titleSignal(q, [title, orig, ...aliases]);
  const titleExact = titleSig.tier === 'exact' ? 1 : 0;
  const titleLeading = titleSig.tier === 'leading' ? 1 : 0; // "House of Cards" for query "house"
  const titlePrefix = titleSig.tier === 'starts' ? 1 : 0;
  const titleWord = titleSig.tier === 'word' ? 1 : 0; // Contains query as whole word
  const titleContains = titleSig.tier === 'contains' ? 1 : 0;
  
  // Check AKA exact match
  const akaExact = aliases.some(a => a === q) ? 1 : 0;
  
  // Franchise root detection
  const franchiseRoot = features.collectionName ? 
    (normalizeTitle(features.collectionName).includes(q) ? 1 : 0) : 0;

  // Year match bonus
  const yearBonus = (queryYear && features.releaseYear === queryYear) ? SCORE.YEAR_MATCH : 0;

  // Skip overview BM25 for single-token queries
  const isSingleToken = tokensLowerUtil(query).length === 1;
  const bm25 = isSingleToken 
    ? bm25Like(q, [title, orig, ...aliases])
    : bm25Like(q, [title, orig, ...(features.overview ? [normalizeTitle(features.overview)] : [])]);

  // Capped popularity bonus: min(10, 10 * log1p(pop_norm * 100))
  const popRaw = features.popularity ?? 0;
  const popNorm = clamp(popRaw / 200, 0, 1);
  const popLog = Math.log1p(popNorm * 100);
  const popularityBonus = Math.min(10 * popLog / 3.0, 10);

  // Recency bonus: small positive if ‚â§5yrs, soft negative after, capped [-6, +8]
  // Newer titles get higher bonus inside the window.
  let age: number;
  if (features.releaseDate) {
    const ageDays = (Date.now() - new Date(features.releaseDate).getTime()) / 864e5;
    age = ageDays / 365.25;
  } else if (features.releaseYear) {
    const now = new Date().getFullYear();
    age = now - features.releaseYear;
  } else {
    age = 50;
  }

  let recencyBonus: number;
  if (!features.releaseYear && !features.releaseDate) {
    // Unknown date ‚Üí stay neutral
    recencyBonus = 0;
  } else if (age <= 5) {
    // age = 0 ‚Üí ~SCORE.RECENCY_MAX
    // age = 5 ‚Üí ~0
    recencyBonus = SCORE.RECENCY_MAX - (SCORE.RECENCY_MAX / 5) * age;
  } else {
    // Soft negative after 5 years
    const extra = age - 5;
    recencyBonus = Math.max(
      SCORE.RECENCY_MIN,
      -extra * 0.3
    );
  }

  // Test patch: don't halve bonuses for exact matches
  const finalPopBonus = popularityBonus;
  const finalRecencyBonus = recencyBonus;

  const voteAvgNorm = clamp((features.voteAverage ?? 0) / 10, 0, 1);
  const voteCntSig = 1 - Math.exp(-(features.voteCount ?? 0) / 5000);
  const voteSig = voteCntSig * voteAvgNorm;

  const typeMatch = opts.preferType && opts.preferType !== 'all'
    ? (features.mediaType === opts.preferType ? 1 : 0)
    : 0;

  const langHint = langBoost(features.originalLanguage, opts.userLocaleLangs || []);

  // For exact matches, increase vote signal weight to better differentiate popular items
  // This ensures popular shows/movies rank higher than obscure ones with same title
  const voteSigWeight = (titleExact || akaExact) ? SCORE.VOTE_SIG_EXACT : SCORE.VOTE_SIG_NON_EXACT;

  // New scoring formula with proper weights using SCORE constants
  // Leading tier (e.g., "House of Cards" for "house") should rank high, between exact and starts
  const score = SCORE.EXACT * titleExact
              + SCORE.AKA_EXACT * akaExact
              + SCORE.LEADING * titleLeading  // Higher than starts since it's a better match
              + SCORE.STARTS * titlePrefix
              + SCORE.WORD * titleWord  // Contains query as whole word (better than partial contains)
              + SCORE.CONTAINS * titleContains
              + SCORE.FRANCHISE_ROOT * franchiseRoot
              + yearBonus
              + finalPopBonus
              + finalRecencyBonus
              + voteSigWeight * voteSig
              + SCORE.TYPE_MATCH * typeMatch
              + SCORE.LANG_HINT * langHint
              + SCORE.BM25 * bm25;

  const debug = opts.debugSearch ? {
    titleExact,
    titleLeading,
    akaExact,
    titlePrefix,
    titleWord,
    titleContains,
    franchiseRoot,
    yearMatch: yearBonus,
    popBonus: finalPopBonus,
    recencyBonus: finalRecencyBonus,
    voteSig,
    bm25,
    total: score
  } : undefined;

  return {
    score,
    titleSig,
    debug
  };
}

// normalize is now normalizeTitle from '../lib/string'

function stripLeadingArticlesTokens(s: string): string[] {
  const t = tokensLowerUtil(s);
  while (t.length && ARTICLES.has(t[0])) t.shift();
  return t;
}

function titleTier(qTok: string, field: string) {
  // returns a tier label and numeric strength to help ties later
  const fTokens = tokensLowerUtil(field).join(' ');  // lowercase for comparison
  const fNoArt  = stripLeadingArticlesTokens(field).join(' ');  // already lowercased

  // Special case: if fTokens (with article) = qTok exactly, it's exact
  // if fNoArt (without article) = qTok, it's leading (not exact)
  if (fTokens === qTok) return { tier: 'exact' as const, strength: 1.0 };
  if (fNoArt === qTok) return { tier: 'leading' as const, strength: 0.98 };
  if (fNoArt.startsWith(qTok + ' '))       return { tier: 'leading' as const,   strength: 0.98 };
  if (new RegExp(`^${escapeReg(qTok)}\\b`).test(fNoArt))
                                            return { tier: 'starts' as const,    strength: 0.93 };
  if (new RegExp(`\\b${escapeReg(qTok)}\\b`).test(fTokens))
                                            return { tier: 'word' as const,      strength: 0.90 };
  if (fTokens.includes(qTok))              return { tier: 'contains' as const,  strength: 0.78 };
  return { tier: 'overlap' as const, strength: 0 }; // will get jaccard later
}

export function titleSignal(query: string, fields: string[]): TitleSignal {
  const qTok = tokensLowerUtil(query).join(' '); // lowercase for comparison
  let bestScore = 0;
  let bestTier: TitleSignal['tier'] = 'overlap';

  for (const f of fields) {
    if (!f) continue;
    const { tier, strength } = titleTier(qTok, f);
    if (strength > bestScore) { bestScore = strength; bestTier = tier; }

    // token overlap is only a weak tail signal
    const jac = jaccard(tokensLowerUtil(query), tokensLowerUtil(f)) * 0.85;
    if (bestScore < 0.80 && jac > bestScore) { bestScore = jac; bestTier = 'overlap'; }
  }
  return { score: bestScore, tier: bestTier };
}

function bm25Like(query: string, texts: string[]): number {
  const t = texts.join(' ');
  // crude proxy: token overlap weighted by log length
  const tq = tokensLowerUtil(query);
  const tt = tokensLowerUtil(t);
  const overlap = jaccard(tq, tt);
  const len = Math.max(tt.length, 1);
  const lengthPenalty = Math.log10(Math.min(len, 200) + 10) / 2.3; // ~0.2..1
  return clamp(overlap * lengthPenalty, 0, 1);
}

// Export tokensLower for backward compatibility (re-export from lib/string)
export { tokensLowerUtil as tokensLower };

function jaccard(a: string[] | Set<string>, b: string[] | Set<string>): number {
  const A = a instanceof Set ? a : new Set(a);
  const B = b instanceof Set ? b : new Set(b);
  let inter = 0;
  for (const x of A) if (B.has(x)) inter++;
  return A.size + B.size === 0 ? 0 : inter / (A.size + B.size - inter);
}

function escapeReg(s: string): string {
  return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

function clamp(n: number, a: number, b: number): number {
  return Math.max(a, Math.min(b, n));
}

function langBoost(orig: string | null | undefined, locales: string[]): number {
  if (!orig || locales.length === 0) return 0;
  const lc = new Set(locales.map(l => l.slice(0,2)));
  return lc.has(orig.slice(0,2)) ? 1 : 0;
}

function isFranchiseQuery(q: string): boolean {
  return tokensLowerUtil(q).length === 1;
}

function startsWithBase(itemTitle: string, q: string): boolean {
  const base = stripLeadingArticlesTokens(itemTitle).join(' ');
  const qTok = tokensLowerUtil(q).join(' ');
  return base === qTok || base.startsWith(qTok + ' ');
}

export function tieBreak(
  aMeta: { tier: string; voteCount?: number; voteAverage?: number; releaseYear?: number; title?: string },
  bMeta: { tier: string; voteCount?: number; voteAverage?: number; releaseYear?: number; title?: string },
  query: string
): number {
  const order = ['exact','leading','starts','word','contains','overlap'];

  const franchiseMode = isFranchiseQuery(query)
    && aMeta.title && bMeta.title
    && startsWithBase(aMeta.title, query)
    && startsWithBase(bMeta.title, query);

  if (franchiseMode) {
    // Franchise head strategy: prefer the ORIGINAL/earliest title
    // Not the most popular or highest rated
    const yearDiff = (aMeta.releaseYear ?? 9999) - (bMeta.releaseYear ?? 9999);
    if (yearDiff !== 0) return yearDiff; // Earliest year wins
    
    // Only as tie-breaker if same year: prefer more votes
    const vc = (bMeta.voteCount ?? 0) - (aMeta.voteCount ?? 0);
    if (vc) return vc;
    
    // Final tie-breaker: preference order
    const va = (aMeta.voteAverage ?? 0) - (bMeta.voteAverage ?? 0);
    if (va) return va;
  }

  const t = order.indexOf(aMeta.tier) - order.indexOf(bMeta.tier);
  if (t) return -t; // higher tier first
  
  // Standard tie-breaking: prefer more votes, then higher rating, then newer year
  const vc = (bMeta.voteCount ?? 0) - (aMeta.voteCount ?? 0);
  if (vc) return vc;
  const va = (bMeta.voteAverage ?? 0) - (aMeta.voteAverage ?? 0);
  if (va) return va;
  return (bMeta.releaseYear ?? 0) - (aMeta.releaseYear ?? 0);
}



```

## apps/web/src/components/cards/StarRating.tsx
### Summary
Interactive 1‚Äì5 star widget used across cards and list rows for user ratings.
### Content
```tsx
import { useState } from 'react';

export type StarRatingProps = {
  value: number; // 0-5 stars
  onChange?: (rating: number) => void;
  readOnly?: boolean;
  size?: 'sm' | 'md' | 'lg';
  className?: string;
};

/**
 * Interactive star rating component
 * - Shows 5 stars with half-star support
 * - Clickable when not read-only
 * - Hover effects for better UX
 */
export default function StarRating({ 
  value = 0, 
  onChange, 
  readOnly = false, 
  size = 'md',
  className = ''
}: StarRatingProps) {
  const [hoverValue, setHoverValue] = useState<number | null>(null);
  
  const sizeClasses = {
    sm: 'w-6 h-6',
    md: 'w-7 h-7', 
    lg: 'w-8 h-8'
  };
  
  const handleClick = (rating: number) => {
    if (!readOnly && onChange) {
      // Ensure rating is 1-5 integer (consistent scale)
      const normalizedRating = Math.max(1, Math.min(5, Math.round(rating)));
      onChange(normalizedRating);
    }
  };
  
  const handleMouseEnter = (rating: number) => {
    if (!readOnly) {
      setHoverValue(rating);
    }
  };
  
  const handleMouseLeave = () => {
    if (!readOnly) {
      setHoverValue(null);
    }
  };
  
  const displayValue = hoverValue !== null ? hoverValue : value;
  
  return (
    <div className={`flex items-center gap-1.5 ${className}`}>
      {[1, 2, 3, 4, 5].map((star) => {
        const isFilled = star <= displayValue;
        const isHalfFilled = star === Math.ceil(displayValue) && displayValue % 1 !== 0;
        
        return (
          <button
            key={star}
            type="button"
            onClick={() => handleClick(star)}
            onMouseEnter={() => handleMouseEnter(star)}
            onMouseLeave={handleMouseLeave}
            disabled={readOnly}
            className={`
              ${sizeClasses[size]} 
              ${readOnly ? 'cursor-default' : 'cursor-pointer'} 
              transition-all duration-200
              focus:outline-none focus:ring-2 focus:ring-accent focus:ring-opacity-50 rounded
              ${!readOnly ? 'hover:scale-110' : ''}
            `}
            style={{
              color: isFilled ? 'var(--accent)' : 'var(--muted)',
              opacity: isHalfFilled ? 0.5 : 1
            }}
            aria-label={`Rate ${star} star${star !== 1 ? 's' : ''}`}
          >
            <svg
              viewBox="0 0 24 24"
              className="w-full h-full"
              stroke={isFilled ? 'none' : 'currentColor'}
              strokeWidth={isFilled ? '0' : '1.5'}
              fill={isFilled ? 'currentColor' : 'none'}
            >
              {/* Empty star outline */}
              {!isFilled && (
                <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z" />
              )}
              {/* Filled star */}
              {isFilled && (
                <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z" />
              )}
            </svg>
          </button>
        );
      })}
      
      {/* Rating text */}
      <span 
        className="text-sm ml-2 font-medium" 
        style={{ color: 'var(--muted)' }}
      >
        ({displayValue}/5)
      </span>
    </div>
  );
}


```

## apps/web/src/pages/DiscoveryPage.tsx
### Summary
Discovery tab that wires search, smart discovery rows, and rating-based filters via the smart hook.
### Content
```tsx
import { useMemo, useState, useEffect } from 'react';
import { useSearch } from '@/hooks/useSearch';
import { useSmartDiscovery } from '@/hooks/useSmartDiscovery';
import { useAuth } from '@/hooks/useAuth';
import CardV2 from '@/components/cards/CardV2';
import type { MediaItem } from '@/components/cards/card.types';
import { Library } from '@/lib/storage';
import ErrorBoundary from '@/components/ErrorBoundary';

export default function DiscoveryPage({ query, genreId }:{ query: string; genreId: number | null }) {
  const searchResults = useSearch({ queryText: query });
  const { recommendations, isLoading: discoveryLoading, error: discoveryError } = useSmartDiscovery();
  const { isAuthenticated } = useAuth();
  
  // Track library changes to filter items immediately
  const [libraryVersion, setLibraryVersion] = useState(0);
  
  useEffect(() => {
    const handleLibraryChange = () => {
      setLibraryVersion(prev => prev + 1);
    };
    
    window.addEventListener('library:changed', handleLibraryChange);
    return () => window.removeEventListener('library:changed', handleLibraryChange);
  }, []);

  const items = useMemo(() => {
    // If user is searching, use search results
    if (query.trim()) {
      const all = searchResults.results ?? [];
      const filtered = !genreId 
        ? all 
        : all.filter((it: any) => Array.isArray(it.genre_ids) && it.genre_ids.includes(genreId));
      
      // Filter out items already in library
      return filtered.filter((it: any) => {
        const mediaType = it.kind || it.mediaType;
        const id = it.id;
        return !Library.has(id, mediaType);
      });
    }
    
    // For discovery without search, only show recommendations if authenticated
    if (!isAuthenticated) {
      return [];
    }
    
    // For authenticated users, use smart recommendations
    // Filter out items already in library (should already be filtered by hook, but double-check)
    return recommendations
      .map(rec => ({
        id: rec.item.id,
        mediaType: rec.item.kind,
        title: rec.item.title,
        posterUrl: rec.item.poster,
        year: rec.item.year?.toString(),
        genre_ids: [], // Will be populated by TMDB data
        score: rec.score,
        reasons: rec.reasons
      }))
      .filter((it: any) => !Library.has(it.id, it.mediaType));
  }, [query, genreId, searchResults.results, recommendations, isAuthenticated, libraryVersion]);

  const isLoading = query.trim() ? searchResults.loading : discoveryLoading;
  const hasError = query.trim() ? searchResults.error : discoveryError;

  // Action handlers using Library.upsert
  const actions = {
    onWant: (item: MediaItem) => {
      console.log('üé¨ Discovery onWant called:', item);
      if (item.id && item.mediaType) {
        // Get existing entry to preserve rating if it exists
        const existing = Library.getEntry(item.id, item.mediaType);
        Library.upsert({ 
          id: item.id, 
          mediaType: item.mediaType, 
          title: item.title,
          posterUrl: item.posterUrl,
          year: item.year,
          voteAverage: item.voteAverage,
          showStatus: item.showStatus,
          lastAirDate: item.lastAirDate,
          synopsis: item.synopsis,
          userRating: existing?.userRating || item.userRating // Preserve existing rating
        }, 'wishlist');
        // Trigger library change to update UI immediately
        setLibraryVersion(prev => prev + 1);
        console.log('‚úÖ Item added to wishlist, libraryVersion updated');
      } else {
        console.warn('‚ö†Ô∏è onWant: missing id or mediaType', item);
      }
    },
    onWatching: (item: MediaItem) => {
      if (item.id && item.mediaType) {
        // Get existing entry to preserve rating if it exists
        const existing = Library.getEntry(item.id, item.mediaType);
        Library.upsert({ 
          id: item.id, 
          mediaType: item.mediaType, 
          title: item.title,
          posterUrl: item.posterUrl,
          year: item.year,
          voteAverage: item.voteAverage,
          showStatus: item.showStatus,
          lastAirDate: item.lastAirDate,
          synopsis: item.synopsis,
          userRating: existing?.userRating || item.userRating // Preserve existing rating
        }, 'watching');
        // Trigger library change to update UI immediately
        setLibraryVersion(prev => prev + 1);
      }
    },
    onWatched: (item: MediaItem) => {
      console.log('üé¨ Discovery onWatched called:', item);
      if (item.id && item.mediaType) {
        // Get existing entry to preserve rating if it exists
        const existing = Library.getEntry(item.id, item.mediaType);
        Library.upsert({ 
          id: item.id, 
          mediaType: item.mediaType, 
          title: item.title,
          posterUrl: item.posterUrl,
          year: item.year,
          voteAverage: item.voteAverage,
          showStatus: item.showStatus,
          lastAirDate: item.lastAirDate,
          synopsis: item.synopsis,
          userRating: existing?.userRating || item.userRating // Preserve existing rating
        }, 'watched');
        // Trigger library change to update UI immediately
        setLibraryVersion(prev => prev + 1);
        console.log('‚úÖ Item added to watched, libraryVersion updated');
      } else {
        console.warn('‚ö†Ô∏è onWatched: missing id or mediaType', item);
      }
    },
    onNotInterested: (item: MediaItem) => {
      if (item.id && item.mediaType) {
        // Get existing entry to preserve rating if it exists
        const existing = Library.getEntry(item.id, item.mediaType);
        Library.upsert({ 
          id: item.id, 
          mediaType: item.mediaType, 
          title: item.title,
          posterUrl: item.posterUrl,
          year: item.year,
          voteAverage: item.voteAverage,
          showStatus: item.showStatus,
          lastAirDate: item.lastAirDate,
          synopsis: item.synopsis,
          userRating: existing?.userRating || item.userRating // Preserve existing rating
        }, 'not');
        // Trigger library change to update UI immediately
        setLibraryVersion(prev => prev + 1);
      }
    }
  };

  return (
    <section className="px-4 py-4">
      <div className="max-w-screen-2xl mx-auto">
        {!query && (
          <div className="mb-4">
            <h2 className="text-lg font-semibold text-neutral-200 mb-2">
              üéØ Personalized Recommendations
            </h2>
            <p className="text-sm text-neutral-400">
              Based on your ratings and preferences
            </p>
          </div>
        )}
        
        {!query && !items.length && !isLoading && !isAuthenticated && (
          <div className="text-center py-8">
            <div className="text-4xl mb-4">üîê</div>
            <h3 className="text-lg font-medium text-neutral-200 mb-2">
              Sign In to Discover Content
            </h3>
            <p className="text-sm text-neutral-400 mb-4">
              Sign in to get personalized recommendations based on your ratings and preferences.
            </p>
          </div>
        )}
        
        {!query && !items.length && !isLoading && isAuthenticated && (
          <div className="text-center py-8">
            <div className="text-4xl mb-4">üé¨</div>
            <h3 className="text-lg font-medium text-neutral-200 mb-2">
              Building Your Recommendations
            </h3>
            <p className="text-sm text-neutral-400 mb-4">
              Rate some movies and TV shows to get personalized recommendations, or use the search bar to find specific content.
            </p>
          </div>
        )}
        
        {query && !query.trim() && <div className="text-xs text-neutral-500 mb-3">Type a search above.</div>}
        {isLoading && (
          <div className="text-xs text-neutral-500 mb-3">
            {query.trim() ? 'Loading search results...' : 'Loading personalized recommendations...'}
          </div>
        )}
        
        {hasError && (
          <div className="text-center py-8">
            <div className="text-4xl mb-4">‚ùå</div>
            <h3 className="text-lg font-medium text-neutral-200 mb-2">
              Failed to Load Search Results
            </h3>
            <p className="text-sm text-neutral-400">
              Please try again later.
            </p>
          </div>
        )}
        
        {items.length > 0 && (
          <ErrorBoundary name="DiscoveryResults" onReset={() => {
            // Refetch search results if searching, otherwise discovery will auto-refetch
            if (query.trim()) {
              // Search results update automatically via Firestore listener
            }
          }}>
            <div className="grid grid-cols-[repeat(auto-fill,154px)] gap-3">
              {items.map((it: any, index: number) => {
                // Normalize mediaType - ensure it's 'movie' or 'tv'
                const mediaType = (it.kind || it.mediaType || 'movie') as 'movie' | 'tv';
                const normalizedMediaType = mediaType === 'tv' ? 'tv' : 'movie';
                
                const mediaItem: MediaItem = {
                  id: String(it.id), // Ensure id is string
                  mediaType: normalizedMediaType,
                  title: it.title || 'Untitled',
                  posterUrl: it.posterUrl || it.poster, // Use posterUrl if available, fallback to poster
                  year: it.year,
                  voteAverage: it.voteAverage,
                };
                
                console.log('üé¨ Rendering discovery card:', { 
                  id: mediaItem.id, 
                  mediaType: mediaItem.mediaType, 
                  title: mediaItem.title,
                  hasActions: !!actions 
                });
                
                return (
                  <div key={`${normalizedMediaType}-${it.id}-${index}`} className="relative">
                    <CardV2 
                      item={mediaItem} 
                      context="tab-foryou"
                      actions={actions}
                    />
                  </div>
                );
              })}
            </div>
          </ErrorBoundary>
        )}
        
      </div>
    </section>
  );
}

```

## apps/web/src/lib/tmdb.ts
### Summary
Thin TMDB proxy helper that fetches metadata consumed by ranking/discovery features.
### Content
```ts
import { getOptimalImageSize } from '../hooks/useImageOptimization';
import { makeGeoResolver } from '../utils/geoClient';

// const BASE = 'https://api.themoviedb.org/3'; // Unused

// Optimized image URL generation
const img = (p?: string | null, context: 'poster' | 'backdrop' = 'poster') => {
  if (!p) return '';
  const baseUrl = `https://image.tmdb.org/t/p/w342${p}`;
  return getOptimalImageSize(baseUrl, context);
};

type Raw = { 
  id: number; 
  title?: string; 
  name?: string; 
  poster_path?: string | null; 
  media_type?: 'movie' | 'tv' | string;
  release_date?: string;
  first_air_date?: string;
};
export type CardData = { id: string; kind: 'movie' | 'tv'; title: string; poster: string; year?: number };

export type Theater = {
  id: string;
  name: string;
  address: string;
  distance?: number;
  showtimes?: Showtime[];
  website?: string;
  phone?: string;
};

export type Showtime = {
  time: string;
  format: string; // '2D', '3D', 'IMAX', etc.
  language: string;
  available: boolean;
};

const map = (r: Raw): CardData => {
  // Ensure title is properly extracted and validated
  const rawTitle = r.title || r.name;
  const safeTitle = (() => {
    if (typeof rawTitle === 'string' && rawTitle.trim() && rawTitle !== String(r.id)) {
      return rawTitle.trim();
    }
    return 'Untitled';
  })();
  
  // Extract year from release_date (movies) or first_air_date (TV shows)
  const extractYear = (dateString?: string): number | undefined => {
    if (!dateString) return undefined;
    try {
      const year = new Date(dateString).getFullYear();
      return isNaN(year) ? undefined : year;
    } catch {
      return undefined;
    }
  };
  
  const year = extractYear(r.release_date || r.first_air_date);
  
  return {
    id: String(r.id),
    kind: (r.media_type as 'movie' | 'tv') || (r.title ? 'movie' : 'tv'),
    title: safeTitle,
    poster: img(r.poster_path),
    year
  };
};

let lastSource: 'proxy' | 'error' = 'proxy';
export function debugTmdbSource() {
  return lastSource;
}

export async function get(endpoint: string, params: Record<string, string | number> = {}) {
  // Kill switch: API client disabled
  const { isOff } = await import('../runtime/switches');
  if (isOff('iapiclient')) {
    console.info('[TMDB] Disabled via kill switch (iapiclient:off)');
    // Return empty response
    return { results: [] };
  }
  
  // Use /api/tmdb-proxy which redirects to /.netlify/functions/tmdb-proxy
  // This works in both dev (netlify dev) and production
  const proxyURL = '/api/tmdb-proxy?' + new URLSearchParams({ endpoint, ...params } as Record<string, string>);
  const pr = await fetch(proxyURL);
  if (!pr.ok) {
    const txt = await pr.text().catch(() => '');
    console.error('[TMDB proxy] HTTP', pr.status, proxyURL, txt.slice(0, 200));
    lastSource = 'error';
    throw new Error(`tmdb-proxy ${pr.status}`);
  }
  lastSource = 'proxy';
  return pr.json();
}

export async function trendingForYou() {
  const data = await get('/trending/all/week');
  return (data.results ?? []).filter((r: Raw) => r.poster_path).map(map).slice(0, 24);
}

export async function nowPlayingMovies() {
  const data = await get('/movie/now_playing', { page: 1, region: 'US' });
  return (data.results ?? []).filter((r: Raw) => r.poster_path).map(map).slice(0, 24);
}

const backdrop = (p?: string | null) => (p ? `https://image.tmdb.org/t/p/w1280${p}` : '');

export async function featuredTrendingMovie() {
  const data = await get('/trending/movie/day');
  const r = (data.results ?? []).find((x: any) => x.backdrop_path || x.poster_path) || (data.results ?? [])[0];
  if (!r) return null;
  return {
    id: String(r.id),
    kind: 'movie' as const,
    title: r.title || 'Untitled',
    poster: img(r.poster_path),
    backdrop: backdrop(r.backdrop_path),
    overview: r.overview || ''
  };
}

export async function searchMulti(query: string) {
  if (!query?.trim()) return [];
  const data = await get('/search/multi', { query });
  return (data.results ?? [])
    .filter((r: any) => (r.media_type === 'movie' || r.media_type === 'tv') && r.poster_path)
    .map((r: any) => ({
      id: String(r.id),
      kind: r.media_type as 'movie' | 'tv',
      title: r.title || r.name || 'Untitled',
      poster: img(r.poster_path),
      genre_ids: r.genre_ids || []
    }))
    .slice(0, 40);
}

// Genre mapping from our custom genres to TMDB genre IDs
const GENRE_MAPPING: Record<string, { movie: number[]; tv: number[] }> = {
  anime: {
    movie: [16], // Animation
    tv: [16] // Animation
  },
  horror: {
    movie: [27], // Horror
    tv: [27] // Horror
  },
  comedy: {
    movie: [35], // Comedy
    tv: [35] // Comedy
  },
  drama: {
    movie: [18], // Drama
    tv: [18] // Drama
  },
  action: {
    movie: [28], // Action
    tv: [28] // Action
  },
  'science-fiction': {
    movie: [878], // Science Fiction
    tv: [878] // Science Fiction
  },
  fantasy: {
    movie: [14], // Fantasy
    tv: [14] // Fantasy
  },
  thriller: {
    movie: [53], // Thriller
    tv: [53] // Thriller
  },
  romance: {
    movie: [10749], // Romance
    tv: [10749] // Romance
  },
  documentary: {
    movie: [99], // Documentary
    tv: [99] // Documentary
  }
};

// Subgenre mapping to additional TMDB genre IDs
const SUBGENRE_MAPPING: Record<string, number[]> = {
  action: [28], // Action
  romance: [10749], // Romance
  fantasy: [14], // Fantasy
  'slice-of-life': [18], // Drama
  thriller: [53], // Thriller
  comedy: [35], // Comedy
  psychological: [18], // Drama
  supernatural: [27], // Horror
  'slasher': [27], // Horror
  'gothic': [27], // Horror
  'found-footage': [27], // Horror
  'body-horror': [27], // Horror
  romantic: [10749], // Romance
  dark: [18], // Drama
  satirical: [35], // Comedy
  slapstick: [35], // Comedy
  parody: [35], // Comedy
  'stand-up': [35], // Comedy
  period: [18], // Drama
  legal: [18], // Drama
  medical: [18], // Drama
  family: [10751], // Family
  political: [18], // Drama
  crime: [80], // Crime
  'martial-arts': [28], // Action
  spy: [28], // Action
  war: [10752], // War
  adventure: [12], // Adventure
  superhero: [28], // Action
  'space-opera': [878], // Science Fiction
  cyberpunk: [878], // Science Fiction
  dystopian: [878], // Science Fiction
  'time-travel': [878], // Science Fiction
  alien: [878], // Science Fiction
  'post-apocalyptic': [878], // Science Fiction
  'high-fantasy': [14], // Fantasy
  'urban-fantasy': [14], // Fantasy
  'dark-fantasy': [14], // Fantasy
  'fairy-tale': [14], // Fantasy
  mythology: [14], // Fantasy
  magic: [14], // Fantasy
  mystery: [9648], // Mystery
  espionage: [28], // Action
  'young-adult': [10749], // Romance
  erotic: [10749], // Romance
  lgbtq: [10749], // Romance
  historical: [36], // History
  nature: [99], // Documentary
  biographical: [99], // Documentary
  social: [99], // Documentary
  scientific: [99], // Documentary
  'true-crime': [99] // Documentary
};

export async function fetchGenreContent(mainGenre: string, subGenre: string) {
  if (!mainGenre || !subGenre) return [];

  console.log(`üé¨ Fetching content for ${mainGenre}/${subGenre}`);

  const mainGenreIds = GENRE_MAPPING[mainGenre];
  const subGenreIds = SUBGENRE_MAPPING[subGenre];

  if (!mainGenreIds || !subGenreIds) {
    console.log(`‚ùå No genre mapping found for ${mainGenre}/${subGenre}`);
    return [];
  }

  console.log(`üìã Genre IDs: Main=${mainGenreIds.movie.join(',')}, Sub=${subGenreIds.join(',')}`);

  try {
    let combined: CardData[] = [];

    // For anime, use a different approach since TMDB doesn't have great anime categorization
    if (mainGenre === 'anime') {
      // Try to get animation content first
      const animationData = await get('/discover/tv', {
        with_genres: '16', // Animation
        sort_by: 'popularity.desc',
        page: 1
      });

      const animationShows = (animationData.results ?? [])
        .filter((r: Raw) => r.poster_path)
        .map((r: Raw) => ({ ...map(r), kind: 'tv' as const }));

      console.log(`üì∫ Found ${animationShows.length} animation TV shows`);
      combined = [...animationShows];

      // If we don't have enough, try movies too
      if (combined.length < 12) {
        const animationMovies = await get('/discover/movie', {
          with_genres: '16', // Animation
          sort_by: 'popularity.desc',
          page: 1
        });

        const movies = (animationMovies.results ?? [])
          .filter((r: Raw) => r.poster_path)
          .map((r: Raw) => ({ ...map(r), kind: 'movie' as const }));

        combined = [...combined, ...movies];
      }
    } else {
      // For other genres, use the original approach
      // Try movies first
      const movieData = await get('/discover/movie', {
        with_genres: [...mainGenreIds.movie, ...subGenreIds].join(','),
        sort_by: 'popularity.desc',
        page: 1
      });

      const movies = (movieData.results ?? [])
        .filter((r: Raw) => r.poster_path)
        .map((r: Raw) => ({ ...map(r), kind: 'movie' as const }));

      // Try TV shows
      const tvData = await get('/discover/tv', {
        with_genres: [...mainGenreIds.tv, ...subGenreIds].join(','),
        sort_by: 'popularity.desc',
        page: 1
      });

      const tvShows = (tvData.results ?? [])
        .filter((r: Raw) => r.poster_path)
        .map((r: Raw) => ({ ...map(r), kind: 'tv' as const }));

      combined = [...movies, ...tvShows];
    }

    // If we still don't have enough content, try with just the main genre
    if (combined.length < 12) {
      console.log(`Not enough content for ${mainGenre}/${subGenre}, trying main genre only`);

      const fallbackMovies = await get('/discover/movie', {
        with_genres: mainGenreIds.movie.join(','),
        sort_by: 'popularity.desc',
        page: 1
      });

      const fallbackTv = await get('/discover/tv', {
        with_genres: mainGenreIds.tv.join(','),
        sort_by: 'popularity.desc',
        page: 1
      });

      const fallbackMoviesList = (fallbackMovies.results ?? [])
        .filter((r: Raw) => r.poster_path)
        .map((r: Raw) => ({ ...map(r), kind: 'movie' as const }));

      const fallbackTvList = (fallbackTv.results ?? [])
        .filter((r: Raw) => r.poster_path)
        .map((r: Raw) => ({ ...map(r), kind: 'tv' as const }));

      combined = [...combined, ...fallbackMoviesList, ...fallbackTvList];
    }

    console.log(`‚úÖ Returning ${combined.length} items for ${mainGenre}/${subGenre}`);
    return combined.slice(0, 24);
  } catch (error) {
    console.error(`Failed to fetch ${mainGenre}/${subGenre} content:`, error);
    return [];
  }
}

// Theater and showtime functions - TMDB Only Implementation
export async function getTheatersNearLocation(latitude: number, longitude: number, radius: number = 10) {
  try {
    console.log(`üé¨ Generating realistic theaters near ${latitude}, ${longitude} within ${radius}km using TMDB data`);

    // Generate realistic theaters based on common theater chains and locations
    const theaters = await generateRealisticTheaters(latitude, longitude, radius);

    console.log(`üé≠ Generated ${theaters.length} realistic theaters nearby`);
    return theaters;
  } catch (error) {
    console.error('Failed to generate theaters:', error);
    return [];
  }
}

async function generateRealisticTheaters(latitude: number, longitude: number, radius: number): Promise<Theater[]> {
  try {
    // Get current movies from TMDB to make theaters more realistic
    const moviesResponse = await get('/movie/now_playing', { page: 1, region: 'US' });
    const movies = moviesResponse.results || [];

    if (movies.length === 0) {
      console.warn('No current movies found, using fallback theater generation');
      return generateFallbackTheaters();
    }

    // Generate realistic theaters based on common patterns
    const theaterChains = ['AMC', 'Regal Cinemas', 'Cinemark', 'Marcus Theatres', 'Landmark Theatres', 'Alamo Drafthouse', 'ArcLight Cinemas'];

    const theaters: Theater[] = [];
    const numTheaters = Math.min(Math.floor(Math.random() * 4) + 3, 6); // 3-6 theaters

    // Generate all theaters in parallel for better performance
    const theaterPromises = Array.from({ length: numTheaters }, async (_, i) => {
      const chain = theaterChains[Math.floor(Math.random() * theaterChains.length)];
      const theaterName = generateTheaterName(chain, i);
      const address = await generateRealisticAddress(latitude, longitude, i);
      const distance = generateRealisticDistance(radius, i);
      const website = generateTheaterWebsite(chain);
      const phone = generateTheaterPhone();

      // Generate showtimes based on current movies
      const showtimes = await generateMovieBasedShowtimes();

      const theater = {
        id: `tmdb_theater_${i}`,
        name: theaterName,
        address: address,
        distance: distance,
        showtimes: showtimes,
        website: website,
        phone: phone
      };

      console.log(`üé≠ Generated theater:`, theater);
      return theater;
    });

    const generatedTheaters = await Promise.all(theaterPromises);
    theaters.push(...generatedTheaters);

    return theaters.sort((a, b) => (a.distance || 0) - (b.distance || 0));
  } catch (error) {
    console.error('Failed to generate realistic theaters:', error);
    return generateFallbackTheaters();
  }
}

function generateTheaterName(chain: string, index: number): string {
  const suffixes = ['Downtown', 'Mall', 'Plaza', 'Center', 'Square', 'Commons', 'Crossing', 'Station', 'Marketplace', 'Town Center'];

  const suffix = suffixes[index % suffixes.length];
  return `${chain} ${suffix}`;
}

// Module-level resolver cache for generateRealisticAddress
const geoResolverCache = new Map<string, () => Promise<any>>();

async function generateRealisticAddress(latitude: number, longitude: number, index: number): Promise<string> {
  try {
    // Use single-flight + cache for reverse geocoding
    const cacheKey = `${latitude.toFixed(3)},${longitude.toFixed(3)}`;
    let resolver = geoResolverCache.get(cacheKey);
    if (!resolver) {
      resolver = makeGeoResolver(latitude, longitude);
      geoResolverCache.set(cacheKey, resolver);
    }
    
    const data = await resolver();
    
    if (data) {
      const city = data.city || 'Unknown City';
      const region = data.principalSubdivision || 'Unknown State';

      // Generate realistic addresses in the user's actual area
      const streetNumbers = [100, 200, 300, 400, 500, 600, 700, 800, 900];
      const streetNames = [
        'Main St',
        'Oak Ave',
        'Pine St',
        'Elm St',
        'Maple Ave',
        'Cedar Blvd',
        'Park Ave',
        'Broadway',
        'First St',
        'Second Ave',
        'Theater Way',
        'Cinema Blvd',
        'Movie St',
        'Entertainment Ave'
      ];

      const streetNumber = streetNumbers[index % streetNumbers.length];
      const streetName = streetNames[index % streetNames.length];

      // Add some variation to make addresses feel more realistic
      const variations = ['', 'Suite 100', 'Building A', 'Unit 1'];
      const variation = variations[index % variations.length];

      return `${streetNumber} ${streetName}${variation ? ', ' + variation : ''}, ${city}, ${region}`;
    }
  } catch (error) {
    console.warn('Failed to get real address data, using fallback:', error);
  }

  // Fallback to generic addresses
  const streetNumbers = [100, 200, 300, 400, 500, 600, 700, 800, 900];
  const streetNames = ['Main St', 'Oak Ave', 'Pine St', 'Elm St', 'Maple Ave', 'Cedar Blvd', 'Park Ave', 'Broadway', 'First St', 'Second Ave'];

  const streetNumber = streetNumbers[index % streetNumbers.length];
  const streetName = streetNames[index % streetNames.length];

  const variations = ['', 'Suite 100', 'Building A', 'Unit 1'];
  const variation = variations[index % variations.length];

  return `${streetNumber} ${streetName}${variation ? ', ' + variation : ''}`;
}

function generateRealisticDistance(radius: number, index: number): number {
  // Generate distances that feel realistic and varied
  const baseDistance = (index + 1) * 0.8; // Start closer, get further
  const variation = Math.random() * 0.5; // Add some randomness
  const distance = baseDistance + variation;

  return Math.round(Math.min(distance, radius) * 10) / 10; // Round to 1 decimal, cap at radius
}

async function generateMovieBasedShowtimes(): Promise<Showtime[]> {
  try {
    const showtimes: Showtime[] = [];

    // Common showtime patterns
    const timeSlots = ['11:00 AM', '12:30 PM', '2:00 PM', '3:30 PM', '5:00 PM', '6:30 PM', '8:00 PM', '9:30 PM', '11:00 PM'];

    const formats = ['2D', '3D', 'IMAX', 'Dolby Cinema'];

    // Generate 4-7 showtimes per day
    const numShowtimes = Math.floor(Math.random() * 4) + 4;

    for (let i = 0; i < numShowtimes; i++) {
      const time = timeSlots[i] || timeSlots[Math.floor(Math.random() * timeSlots.length)];
      const format = formats[Math.floor(Math.random() * formats.length)];

      // More realistic availability based on time
      const hour = parseInt(time.split(':')[0]);
      const isPM = time.includes('PM');
      const hour24 = isPM ? (hour === 12 ? 12 : hour + 12) : (hour === 12 ? 0 : hour);

      // Evening shows more likely to be sold out, matinees more available
      let availability;
      if (hour24 >= 19) {
        // Evening (7 PM+)
        availability = Math.random() > 0.25; // 75% chance available
      } else if (hour24 >= 14) {
        // Afternoon (2 PM+)
        availability = Math.random() > 0.15; // 85% chance available
      } else {
        // Morning/early afternoon
        availability = Math.random() > 0.05; // 95% chance available
      }

      showtimes.push({
        time,
        format,
        language: 'English',
        available: availability
      });
    }

    return showtimes.sort((a, b) => a.time.localeCompare(b.time));
  } catch (error) {
    console.warn('Failed to generate movie-based showtimes:', error);
    return generateBasicShowtimes();
  }
}

function generateBasicShowtimes(): Showtime[] {
  // Fallback showtimes if movie data fails
  return [
    { time: '2:30 PM', format: '2D', language: 'English', available: true },
    { time: '5:15 PM', format: '2D', language: 'English', available: true },
    { time: '8:00 PM', format: 'IMAX', language: 'English', available: false },
    { time: '10:45 PM', format: '2D', language: 'English', available: true }
  ];
}

function generateTheaterWebsite(chain: string): string {
  // Generate realistic theater websites based on chain
  const websites: { [key: string]: string } = {
    AMC: 'https://www.amctheatres.com',
    'Regal Cinemas': 'https://www.regmovies.com',
    Cinemark: 'https://www.cinemark.com',
    'Marcus Theatres': 'https://www.marcustheatres.com',
    'Landmark Theatres': 'https://www.landmarktheatres.com',
    'Alamo Drafthouse': 'https://drafthouse.com',
    'ArcLight Cinemas': 'https://www.arclightcinemas.com'
  };

  return websites[chain] || 'https://www.fandango.com';
}

function generateTheaterPhone(): string {
  // Generate realistic phone numbers
  const areaCodes = ['555', '123', '456', '789', '321', '654', '987'];
  const areaCode = areaCodes[Math.floor(Math.random() * areaCodes.length)];
  const exchange = Math.floor(Math.random() * 900) + 100;
  const number = Math.floor(Math.random() * 9000) + 1000;

  return `(${areaCode}) ${exchange}-${number}`;
}

function generateFallbackTheaters(): Theater[] {
  // Fallback theaters if TMDB data fails
  return [
    {
      id: 'fallback_1',
      name: 'AMC Downtown',
      address: '123 Main St, Downtown',
      distance: 0.8,
      showtimes: generateBasicShowtimes(),
      website: 'https://www.amctheatres.com',
      phone: '(555) 123-4567'
    },
    {
      id: 'fallback_2',
      name: 'Regal Cinemas',
      address: '456 Oak Ave, Midtown',
      distance: 1.2,
      showtimes: generateBasicShowtimes(),
      website: 'https://www.regmovies.com',
      phone: '(555) 234-5678'
    },
    {
      id: 'fallback_3',
      name: 'Cinemark Theater',
      address: '789 Pine St, Uptown',
      distance: 2.1,
      showtimes: generateBasicShowtimes(),
      website: 'https://www.cinemark.com',
      phone: '(555) 345-6789'
    }
  ];
}

export async function getShowtimesForMovie(movieId: string, theaterId: string) {
  try {
    console.log(`üé¨ Generating realistic showtimes for movie ${movieId} at theater ${theaterId} using TMDB data`);

    // Generate realistic showtimes based on TMDB movie data
    const showtimes = await generateMovieBasedShowtimesFromTMDB(movieId);

    console.log(`üé≠ Generated ${showtimes.length} realistic showtimes for movie ${movieId}`);
    return showtimes;
  } catch (error) {
    console.error('Failed to generate showtimes:', error);
    return generateBasicShowtimes();
  }
}

async function generateMovieBasedShowtimesFromTMDB(movieId: string): Promise<Showtime[]> {
  try {
    // Get movie details from TMDB to make showtimes more realistic
    const movieResponse = await get(`/movie/${movieId}`);
    const movie = movieResponse;

    if (!movie) {
      console.warn('Movie not found, using basic showtimes');
      return generateBasicShowtimes();
    }

    // Generate realistic showtimes based on movie properties
    // const runtime = movie.runtime || 120; // Default 2 hours - Unused
    const popularity = movie.popularity || 5;
    const voteAverage = movie.vote_average || 6;

    const showtimes: Showtime[] = [];

    // More popular/highly rated movies get more showtimes
    const popularityFactor = Math.min(popularity / 10, 1); // Normalize popularity
    const ratingFactor = Math.min(voteAverage / 10, 1); // Normalize rating
    const baseShowtimes = 4;
    const numShowtimes = Math.min(Math.floor(baseShowtimes + (popularityFactor + ratingFactor) * 3), 8);

    // Common showtime patterns
    const timeSlots = ['11:00 AM', '12:30 PM', '2:00 PM', '3:30 PM', '5:00 PM', '6:30 PM', '8:00 PM', '9:30 PM', '11:00 PM'];

    const formats = ['2D', '3D', 'IMAX', 'Dolby Cinema'];

    for (let i = 0; i < numShowtimes; i++) {
      const time = timeSlots[i] || timeSlots[Math.floor(Math.random() * timeSlots.length)];
      const format = formats[Math.floor(Math.random() * formats.length)];

      // More realistic availability based on time and movie popularity
      const hour = parseInt(time.split(':')[0]);
      const isPM = time.includes('PM');
      const hour24 = isPM ? (hour === 12 ? 12 : hour + 12) : (hour === 12 ? 0 : hour);

      let availability;
      if (hour24 >= 19) {
        // Evening (7 PM+)
        // Popular movies more likely to be sold out in evening
        availability = Math.random() > (0.2 + popularityFactor * 0.3);
      } else if (hour24 >= 14) {
        // Afternoon (2 PM+)
        availability = Math.random() > (0.1 + popularityFactor * 0.2);
      } else {
        // Morning/early afternoon
        availability = Math.random() > 0.05; // 95% chance available
      }

      showtimes.push({
        time,
        format,
        language: 'English',
        available: availability
      });
    }

    return showtimes.sort((a, b) => a.time.localeCompare(b.time));
  } catch (error) {
    console.warn('Failed to generate TMDB-based showtimes:', error);
    return generateBasicShowtimes();
  }
}

export async function getLocationFromIP() {
  try {
    // Use a free IP geolocation service
    const response = await fetch('https://ipapi.co/json/');
    const data = await response.json();

    if (data.latitude && data.longitude) {
      return {
        latitude: data.latitude,
        longitude: data.longitude,
        city: data.city,
        region: data.region,
        country: data.country
      };
    }

    throw new Error('Unable to get location from IP');
  } catch (error) {
    console.error('Failed to get location from IP:', error);
    // Fallback to a default location (New York City)
    return {
      latitude: 40.7128,
      longitude: -74.006,
      city: 'New York',
      region: 'NY',
      country: 'US'
    };
  }
}

// Episode tracking types
export interface Episode {
  id: number;
  name: string;
  episode_number: number;
  season_number: number;
  air_date: string;
  overview: string;
  still_path?: string | null;
  vote_average?: number;
}

export interface Season {
  id: number;
  season_number: number;
  episode_count: number;
  name: string;
  overview: string;
  air_date: string;
  poster_path?: string | null;
  episodes: Episode[];
}

export interface TVShowDetails {
  id: number;
  name: string;
  number_of_seasons: number;
  number_of_episodes: number;
  seasons: Season[];
}

/**
 * Fetch TV show details including all seasons and episodes
 */
export async function getTVShowDetails(tvId: number): Promise<TVShowDetails> {
  const data = await get(`/tv/${tvId}`);
  
  // Fetch detailed season data for each season
  const seasonsWithEpisodes: Season[] = [];
  
  for (const season of data.seasons || []) {
    try {
      const seasonData = await get(`/tv/${tvId}/season/${season.season_number}`);
      seasonsWithEpisodes.push({
        id: seasonData.id,
        season_number: seasonData.season_number,
        episode_count: seasonData.episodes?.length || 0,
        name: seasonData.name,
        overview: seasonData.overview,
        air_date: seasonData.air_date,
        poster_path: seasonData.poster_path,
        episodes: (seasonData.episodes || []).map((ep: any) => ({
          id: ep.id,
          name: ep.name,
          episode_number: ep.episode_number,
          season_number: ep.season_number,
          air_date: ep.air_date,
          overview: ep.overview,
          still_path: ep.still_path,
          vote_average: ep.vote_average
        }))
      });
    } catch (error) {
      console.error(`Failed to fetch season ${season.season_number}:`, error);
      // Add season without episodes if API call fails
      seasonsWithEpisodes.push({
        id: season.id,
        season_number: season.season_number,
        episode_count: season.episode_count,
        name: season.name,
        overview: season.overview,
        air_date: season.air_date,
        poster_path: season.poster_path,
        episodes: []
      });
    }
  }
  
  return {
    id: data.id,
    name: data.name,
    number_of_seasons: data.number_of_seasons,
    number_of_episodes: data.number_of_episodes,
    seasons: seasonsWithEpisodes
  };
}

/**
 * Fetch a specific season's episodes
 */
export async function getSeasonEpisodes(tvId: number, seasonNumber: number): Promise<Episode[]> {
  const data = await get(`/tv/${tvId}/season/${seasonNumber}`);
  
  return (data.episodes || []).map((ep: any) => ({
    id: ep.id,
    name: ep.name,
    episode_number: ep.episode_number,
    season_number: ep.season_number,
    air_date: ep.air_date,
    overview: ep.overview,
    still_path: ep.still_path,
    vote_average: ep.vote_average
  }));
}

```

## apps/web/src/lib/storage.ts
### Summary
Local library store that keeps `userRating`/`ratingUpdatedAt`, persists to localStorage, emits events, and deduplicates writes.
### Content
```ts
import React from "react";
import type { MediaItem, MediaType } from "../components/cards/card.types";
import type { ListName } from "../state/library.types";
import { customListManager } from "./customLists";
import { authManager } from "./auth";
import { debounce } from "./debounce";

const KEY = "flicklet.library.v2";
const OLD_KEY = "flicklet:v2:saved";

// Helper function to get current Firebase user
function getCurrentFirebaseUser() {
  try {
    // Use the imported auth manager
    const currentUser = authManager.getCurrentUser();
    if (currentUser) {
      return currentUser;
    }

    // Fallback to window auth manager (for compatibility)
    const windowAuthManager = (window as any).authManager;
    if (windowAuthManager?.getCurrentUser) {
      return windowAuthManager.getCurrentUser();
    }

    // Fallback to Firebase auth directly
    const firebaseAuth = (window as any).firebase?.auth();
    if (firebaseAuth?.currentUser) {
      return firebaseAuth.currentUser;
    }

    return null;
  } catch (error) {
    console.warn("Error getting current user:", error);
    return null;
  }
}

export interface LibraryEntry extends MediaItem {
  list: ListName;
  addedAt: number; // epoch ms
  ratingUpdatedAt?: number; // epoch ms - timestamp when userRating was last updated (for conflict resolution)
}

// Migration function to convert old data format
function migrateOldData(): State {
  try {
    const oldData = JSON.parse(localStorage.getItem(OLD_KEY) || "[]");
    if (!Array.isArray(oldData) || oldData.length === 0) return {};

    const newState: State = {};
    oldData.forEach((item: any) => {
      if (item.id && item.kind && item.status) {
        const key = `${item.kind}:${item.id}`;
        const listName =
          item.status === "want" ? "wishlist" : (item.status as ListName);
        newState[key] = {
          id: item.id,
          mediaType: item.kind,
          title: item.title || "Untitled",
          posterUrl: item.poster,
          list: listName,
          addedAt: item.updatedAt || Date.now(),
        };
      }
    });

    // Save migrated data and clear old data
    if (Object.keys(newState).length > 0) {
      localStorage.setItem(KEY, JSON.stringify(newState));
      localStorage.removeItem(OLD_KEY);
    }

    return newState;
  } catch {
    return {};
  }
}

type State = Record<string, LibraryEntry>;
const state: State = (() => {
  try {
    const existing = JSON.parse(localStorage.getItem(KEY) || "{}");
    if (Object.keys(existing).length > 0) return existing;
    return migrateOldData();
  } catch {
    return migrateOldData();
  }
})();

const subs = new Set<() => void>();

// Listen for library cleared events (when user signs out)
window.addEventListener("library:cleared", () => {
  // Clear the state object
  Object.keys(state).forEach((key) => delete state[key]);

  // Clear localStorage
  localStorage.removeItem(KEY);

  // Notify all subscribers
  emit();

  console.log("üßπ Library state cleared for privacy");
});

function k(id: string | number, mediaType: MediaType) {
  return `${mediaType}:${id}`;
}

function save(s: State) {
  localStorage.setItem(KEY, JSON.stringify(s));
}

function emit() {
  // React 18+ auto-batches state updates automatically.
  // Keep emit() synchronous for immediate updates - React will batch all setState calls.
  // The batching in notifyUpdate() handles the library:updated event separately.
  subs.forEach((fn) => fn());
}

// Debounced persistence with flush capability
// Track pending writes for idempotency
let isSaving = false;
let pendingCustomOrder: { tabKey: string; orderIds: string[] } | null = null;

// Idempotent save function (guarantees one write per burst)
function performSave() {
  if (isSaving) {
    // Already saving, skip to prevent duplicate writes
    if (import.meta.env.DEV) {
      console.info("[reorder] skip: save already in progress");
    }
    return;
  }

  isSaving = true;

  try {
    // Save library state
    save(state);
    emit();

    // Save custom order if pending
    if (pendingCustomOrder) {
      try {
        localStorage.setItem(
          `flk.tab.${pendingCustomOrder.tabKey}.order.custom`,
          JSON.stringify(pendingCustomOrder.orderIds)
        );
        pendingCustomOrder = null;
      } catch (e) {
        console.warn("Failed to save custom order to localStorage:", e);
      }
    }

    if (import.meta.env.DEV) {
      console.info("[reorder] flushed: save + emit + localStorage");
    }
  } catch (error) {
    console.error("[reorder] save failed:", error);
  } finally {
    isSaving = false;
  }
}

// Debounced save function
const debouncedSave = debounce(performSave, 150);

// Queue a custom order save (debounced)
function queueCustomOrderSave(tabKey: string, orderIds: string[]) {
  pendingCustomOrder = { tabKey, orderIds };
  debouncedSave();
}

// Export flush function for external use (e.g., on drop completion, beforeunload)
export function flushPendingSaves() {
  debouncedSave.flush();
}

// Flush on page unload to ensure data is saved
if (typeof window !== "undefined") {
  window.addEventListener("beforeunload", () => {
    flushPendingSaves();
  });
}

// Helper function to get human-readable list name
export function getListDisplayName(listName: ListName): string {
  switch (listName) {
    case "watching":
      return "Currently Watching";
    case "wishlist":
      return "Want to Watch";
    case "watched":
      return "Watched";
    case "not":
      return "Not Interested";
    default:
      if (listName.startsWith("custom:")) {
        const listId = listName.replace("custom:", "");
        const list = customListManager.getListById(listId);
        return list ? list.name : "Custom List";
      }
      return "Unknown List";
  }
}

// Helper function to safely add item to list with duplicate detection
export function addToListWithConfirmation(
  item: MediaItem,
  targetList: ListName,
  onConfirm?: () => void
): boolean {
  const currentList = Library.getCurrentList(item.id, item.mediaType);

  // Check if this is the first show being added (for onboarding completion)
  const wasEmpty = Library.getAll().length === 0;

  if (currentList && currentList !== targetList) {
    const currentListName = getListDisplayName(currentList);
    const targetListName = getListDisplayName(targetList);

    const confirmed = window.confirm(
      `${item.title} is already in ${currentListName}.\n\nDo you want to move it to ${targetListName}?`
    );

    if (confirmed) {
      Library.upsert(item, targetList);
      onConfirm?.();

      // Check if this was the first show added
      if (wasEmpty && targetList === "watching") {
        window.dispatchEvent(new CustomEvent("onboarding:firstShowAdded"));
      }

      return true;
    }
    return false;
  } else {
    // No existing item or same list, proceed normally
    Library.upsert(item, targetList);
    onConfirm?.();

    // Check if this was the first show added (for onboarding) - only for "watching" list
    if (wasEmpty && targetList === "watching") {
      window.dispatchEvent(new CustomEvent("onboarding:firstShowAdded"));
    }

    return true;
  }
}

export const Library = {
  getAll(): LibraryEntry[] {
    return Object.values(state);
  },
  upsert(item: MediaItem, list: ListName) {
    const key = k(item.id, item.mediaType);
    const oldEntry = state[key];

    // Filter out undefined values from item to preserve existing data
    // This ensures synopsis, notes, tags etc. aren't accidentally cleared
    const filteredItem = Object.fromEntries(
      Object.entries(item).filter(([_, value]) => value !== undefined)
    ) as Partial<MediaItem>;

    // User data fields that should always be preserved from oldEntry if they exist
    // These are user-generated content that shouldn't be overwritten by metadata refresh
    const userDataFields: (keyof MediaItem)[] = [
      "userRating",
      "userNotes",
      "tags",
    ];

    // Preserve user data from oldEntry
    const preservedUserData: Partial<MediaItem> = {};
    if (oldEntry) {
      for (const field of userDataFields) {
        if (oldEntry[field] !== undefined) {
          preservedUserData[field] = oldEntry[field] as any;
        }
      }
      // Preserve nextAirDate if it was already set (user might have tracking data)
      if (oldEntry.nextAirDate && !filteredItem.nextAirDate) {
        preservedUserData.nextAirDate = oldEntry.nextAirDate;
      }
    }

    // Merge: new metadata first, then preserved user data, then always-set fields
    state[key] = {
      ...(oldEntry || {}), // Start with old entry for any fields we don't explicitly set
      ...filteredItem, // Apply new metadata (this will overwrite old metadata)
      ...preservedUserData, // Restore preserved user data (this overwrites any conflicts)
      id: item.id, // Always use current id and mediaType
      mediaType: item.mediaType,
      list,
      addedAt: oldEntry?.addedAt ?? Date.now(),
    };

    console.log(`üì¶ Library.upsert stored:`, {
      id: item.id,
      title: item.title,
      year: item.year,
      posterUrl: item.posterUrl,
      synopsis: state[key].synopsis ? "present" : "missing",
      hasUserRating: !!state[key].userRating,
      hasUserNotes: !!state[key].userNotes,
      list: list,
    });

    // Update custom list item counts
    if (oldEntry && oldEntry.list !== list) {
      // Moving from one list to another
      if (oldEntry.list.startsWith("custom:")) {
        const oldListId = oldEntry.list.replace("custom:", "");
        customListManager.updateItemCount(oldListId, -1);
      }
      if (list.startsWith("custom:")) {
        const newListId = list.replace("custom:", "");
        customListManager.updateItemCount(newListId, 1);
      }
    } else if (!oldEntry && list.startsWith("custom:")) {
      // Adding new item to custom list
      const listId = list.replace("custom:", "");
      customListManager.updateItemCount(listId, 1);
    }

    save(state);
    emit();

    // Trigger Firebase sync via event (avoids circular import)
    const currentUser = getCurrentFirebaseUser();
    console.log("üîÑ Library upsert - currentUser:", currentUser?.uid || "none");
    if (currentUser) {
      console.log("üì° Dispatching library:changed event for Firebase sync");
      window.dispatchEvent(
        new CustomEvent("library:changed", {
          detail: { uid: currentUser.uid, operation: "upsert" },
        })
      );
    } else {
      console.log("‚ö†Ô∏è No current user found, skipping Firebase sync");
    }
  },
  move(id: string | number, mediaType: MediaType, list: ListName) {
    const key = k(id, mediaType);
    const curr = state[key];
    if (!curr) return;

    const oldList = curr.list;
    // Preserve ALL existing data including synopsis, notes, tags, etc. when moving
    state[key] = {
      ...curr, // All existing fields preserved
      list, // Only update the list property
    };

    // Update custom list item counts
    if (oldList !== list) {
      if (oldList.startsWith("custom:")) {
        const oldListId = oldList.replace("custom:", "");
        customListManager.updateItemCount(oldListId, -1);
      }
      if (list.startsWith("custom:")) {
        const newListId = list.replace("custom:", "");
        customListManager.updateItemCount(newListId, 1);
      }
    }

    save(state);
    emit();

    // Trigger Firebase sync via event (avoids circular import)
    const currentUser = getCurrentFirebaseUser();
    if (currentUser) {
      window.dispatchEvent(
        new CustomEvent("library:changed", {
          detail: { uid: currentUser.uid, operation: "move" },
        })
      );
    }
  },
  reorder(list: ListName, fromIndex: number, toIndex: number) {
    const items = Library.getByList(list);
    if (
      fromIndex < 0 ||
      fromIndex >= items.length ||
      toIndex < 0 ||
      toIndex >= items.length
    ) {
      console.warn("üîÑ Invalid reorder indices:", {
        fromIndex,
        toIndex,
        listLength: items.length,
      });
      return;
    }

    if (fromIndex === toIndex) return;

    // Create a copy of the items array
    const reorderedItems = [...items];

    // Remove item from fromIndex
    const [movedItem] = reorderedItems.splice(fromIndex, 1);

    // Insert item at toIndex
    reorderedItems.splice(toIndex, 0, movedItem);

    // Update the order by modifying the addedAt timestamps
    // This ensures the items maintain their new order
    const now = Date.now();
    reorderedItems.forEach((item, index) => {
      const key = k(item.id, item.mediaType);
      if (state[key]) {
        // Use a small offset to maintain order
        state[key] = {
          ...state[key],
          addedAt: now + index,
        };
      }
    });

    // Queue debounced save for rapid reorders (performance optimization)
    if (import.meta.env.DEV) {
      console.info("[reorder] queued: save + emit");
    }
    debouncedSave();

    // Queue custom order save (debounced, idempotent)
    try {
      const tabKey = list === "wishlist" ? "want" : list;
      const orderIds = reorderedItems.map(
        (item) => `${item.id}:${item.mediaType}`
      );
      queueCustomOrderSave(tabKey, orderIds);
    } catch (e) {
      console.warn("Failed to queue custom order save:", e);
    }

    console.log(
      `üîÑ Reordered ${list} list: moved item from ${fromIndex} to ${toIndex}`
    );

    // Trigger Firebase sync via event
    const currentUser = getCurrentFirebaseUser();
    if (currentUser) {
      window.dispatchEvent(
        new CustomEvent("library:changed", {
          detail: { uid: currentUser.uid, operation: "reorder" },
        })
      );
    }
  },

  // Reset custom order for a tab
  resetCustomOrder(list: ListName) {
    try {
      const tabKey = list === "wishlist" ? "want" : list;
      localStorage.removeItem(`flk.tab.${tabKey}.order.custom`);
      console.log(`üîÑ Reset custom order for ${tabKey} tab`);
    } catch (e) {
      console.warn("Failed to reset custom order:", e);
    }
  },
  remove(id: string | number, mediaType: MediaType) {
    const key = k(id, mediaType);
    const entry = state[key];
    if (entry) {
      // Update custom list item count
      if (entry.list.startsWith("custom:")) {
        const listId = entry.list.replace("custom:", "");
        customListManager.updateItemCount(listId, -1);
      }
      delete state[key];
      save(state);
      emit();

      // Trigger Firebase sync via event (avoids circular import)
      const currentUser = getCurrentFirebaseUser();
      if (currentUser) {
        window.dispatchEvent(
          new CustomEvent("library:changed", {
            detail: { uid: currentUser.uid, operation: "remove" },
          })
        );
      }
    }
  },

  updateNotesAndTags(
    id: string | number,
    mediaType: MediaType,
    notes: string,
    tags: string[]
  ) {
    const key = k(id, mediaType);
    if (state[key]) {
      state[key] = {
        ...state[key],
        userNotes: notes,
        tags: tags,
      };
      save(state);
      emit();

      console.log(`üìù Updated notes and tags for ${id}:`, { notes, tags });

      // Trigger Firebase sync via event
      const currentUser = getCurrentFirebaseUser();
      if (currentUser) {
        window.dispatchEvent(
          new CustomEvent("library:changed", {
            detail: { uid: currentUser.uid, operation: "updateNotesAndTags" },
          })
        );
      }
    }
  },

  getByList(list: ListName): LibraryEntry[] {
    return Object.values(state)
      .filter((x) => x.list === list)
      .sort((a, b) => a.addedAt - b.addedAt);
  },
  has(id: string | number, mediaType: MediaType) {
    return !!state[k(id, mediaType)];
  },
  getCurrentList(id: string | number, mediaType: MediaType): ListName | null {
    const entry = state[k(id, mediaType)];
    return entry ? entry.list : null;
  },
  getEntry(id: string | number, mediaType: MediaType): LibraryEntry | null {
    return state[k(id, mediaType)] || null;
  },
  updateRating(
    id: string | number,
    mediaType: MediaType,
    rating: number,
    origin: "user" | "sync" | "discovery" = "user"
  ) {
    const key = k(id, mediaType);
    const entry = state[key];
    if (!entry) return;

    // Normalize rating to 1-5 integer (consistent scale)
    const normalizedRating = Math.max(1, Math.min(5, Math.round(rating)));

    // Check if rating actually changed
    if (entry.userRating === normalizedRating) {
      // Rating unchanged, but update timestamp if this is a sync (for conflict resolution)
      if (origin === "sync") {
        const now = Date.now();
        const existingTimestamp = entry.ratingUpdatedAt || 0;
        // Only update if this sync is newer
        if (now > existingTimestamp) {
          state[key] = { ...entry, ratingUpdatedAt: now };
          save(state);
        }
      }
      return; // No change, skip event
    }

    const now = Date.now();
    const existingTimestamp = entry.ratingUpdatedAt || 0;

    // Last-write-wins: only update if this is newer or from user action
    if (origin === "user" || now > existingTimestamp) {
      state[key] = {
        ...entry,
        userRating: normalizedRating,
        ratingUpdatedAt: now,
      };
      save(state);
      emit();

      // Send event right away
      const currentUser = getCurrentFirebaseUser();
      if (currentUser && origin !== "sync") {
        window.dispatchEvent(
          new CustomEvent("library:changed", {
            detail: {
              uid: currentUser.uid,
              operation: "rating",
              origin: "storage", // Mark as coming from storage, not discovery
              itemId: id,
              mediaType,
              rating: normalizedRating,
            },
          })
        );
      }
    }
  },

  // Reload Library state from localStorage (used after Firebase merge)
  reloadFromStorage(skipEmit = false) {
    try {
      const stored = JSON.parse(localStorage.getItem(KEY) || "{}");
      console.log(
        "üîÑ Library.reloadFromStorage - before:",
        Object.keys(state).length,
        "items"
      );
      console.log(
        "üîÑ Library.reloadFromStorage - localStorage:",
        Object.keys(stored).length,
        "items"
      );

      // Clear existing state
      Object.keys(state).forEach((key) => delete state[key]);

      // Load new state
      Object.assign(state, stored);

      console.log(
        "üîÑ Library.reloadFromStorage - after:",
        Object.keys(state).length,
        "items"
      );

      // Emit to notify all subscribers (unless caller wants to handle it)
      if (!skipEmit) {
        emit();
        console.log(
          "‚úÖ Library state reloaded from localStorage and subscribers notified"
        );
      } else {
        console.log(
          "‚úÖ Library state reloaded from localStorage (emit skipped, caller will handle)"
        );
      }
    } catch (error) {
      console.error("‚ùå Failed to reload Library from localStorage:", error);
    }
  },

  // Batch notify both Library subscribers and window event listeners together
  // This prevents cascading re-renders by ensuring all updates happen in one frame
  notifyUpdate() {
    // Use requestAnimationFrame to batch both emit() and event dispatch
    // This ensures all state updates and event listeners run in the same frame
    requestAnimationFrame(() => {
      emit(); // Notify Library subscribers (React will batch these state updates)
      window.dispatchEvent(new CustomEvent("library:updated")); // Notify window listeners
    });
  },
  subscribe(fn: () => void) {
    subs.add(fn);
    return () => subs.delete(fn);
  },
};

export function useLibrary(list: ListName) {
  // ‚ö†Ô∏è REMOVED: Diagnostics disabled

  const [items, setItems] = React.useState(() => {
    const initialItems = Library.getByList(list);
    console.log(
      `üîç useLibrary(${list}) initial state:`,
      initialItems.length,
      "items"
    );
    // ‚ö†Ô∏è REMOVED: Diagnostics disabled
    return initialItems;
  });

  // Use ref to track previous items to avoid unnecessary setState calls
  const prevItemsRef = React.useRef(items);

  React.useEffect(() => {
    // Only set items on mount if they differ from initial state (shouldn't happen, but safety check)
    const newItems = Library.getByList(list);
    const itemsChanged =
      newItems.length !== prevItemsRef.current.length ||
      newItems.some((item, idx) => item.id !== prevItemsRef.current[idx]?.id);

    if (itemsChanged) {
      console.log(
        `üîç useLibrary(${list}) effect - current items:`,
        newItems.length,
        "items"
      );
      if (newItems.length > 0) {
        console.log(`üîç First item:`, {
          title: newItems[0].title,
          list: newItems[0].list,
        });
      }
      // ‚ö†Ô∏è REMOVED: Diagnostics disabled
      prevItemsRef.current = newItems;
      setItems(newItems);
    }

    const unsub = Library.subscribe(() => {
      const updatedItems = Library.getByList(list);

      // Only update state if items actually changed (prevents unnecessary re-renders)
      const hasChanged =
        updatedItems.length !== prevItemsRef.current.length ||
        updatedItems.some(
          (item, idx) => item.id !== prevItemsRef.current[idx]?.id
        );

      if (hasChanged) {
        console.log(
          `üîî Library.subscribe(${list}) triggered:`,
          updatedItems.length,
          "items"
        );
        // ‚ö†Ô∏è REMOVED: Diagnostics disabled
        if (updatedItems.length > 0) {
          console.log(`üîî First item:`, {
            title: updatedItems[0].title,
            list: updatedItems[0].list,
          });
        }
        prevItemsRef.current = updatedItems;
        // React 18+ auto-batches state updates, so this will be batched with other updates
        setItems(updatedItems);
      }
    });

    return () => {
      unsub();
    };
  }, [list]);

  // ‚ö†Ô∏è FIXED: Removed render logging - was causing console noise
  // Only log when items actually change (handled in subscription callback)
  return items;
}

```

## apps/web/src/components/cards/card.types.ts
### Summary
Defines `MediaItem` including `voteAverage` and `userRating`, plus the card action handler signatures.
### Content
```ts
export type MediaType = 'movie' | 'tv' | 'person';

export interface MediaItem {
  id: string | number;
  mediaType: MediaType;
  title: string;         // movie title or TV name
  year?: string;         // release year
  releaseDate?: string;  // ISO date string (release_date or first_air_date) for precise recency calculation
  posterUrl?: string;    // 2:3 image url; can be undefined
  voteAverage?: number;  // 0..10 (TMDB rating)
  voteCount?: number;    // Number of votes (TMDB vote_count)
  userRating?: number;   // 0..5 (user's personal rating)
  runtimeMins?: number;  // optional
  synopsis?: string;     // plot overview from TMDB
  nextAirDate?: string | null; // ISO date for TV next episode (watching only)
  showStatus?: 'Ended' | 'Returning Series' | 'In Production' | 'Canceled' | 'Planned'; // TV show status
  lastAirDate?: string;  // ISO date for TV last episode
  userNotes?: string;    // user's personal notes/review
  tags?: string[];       // user-defined tags
  networks?: string[];   // TV networks or streaming services
  productionCompanies?: string[]; // Movie production companies
}

export type CardContext =
  | 'home'
  | 'tab-watching'      // Your Shows / Currently Watching
  | 'tab-want'          // Want to Watch / Wishlist
  | 'tab-watched'       // Watched
  | 'tab-not'           // Not Interested
  | 'tab-foryou'        // For You / Discovery
  | 'search'
  | 'holiday';

export interface CardActionHandlers {
  onWant?: (item: MediaItem) => void;
  onWatching?: (item: MediaItem) => void;     // add to currently watching list
  onWatched?: (item: MediaItem) => void;
  onNotInterested?: (item: MediaItem) => void;
  onDelete?: (item: MediaItem) => void;
  onOpen?: (item: MediaItem) => void;        // open details
  onHolidayAdd?: (item: MediaItem) => void;   // open list picker
  onRatingChange?: (item: MediaItem, rating: number) => void; // user rating change
  onNotesEdit?: (item: MediaItem) => void;    // open notes editor
  onTagsEdit?: (item: MediaItem) => void;     // open tags editor
  onEpisodeTracking?: (item: MediaItem) => void; // open episode tracking modal
  onNotificationToggle?: (item: MediaItem) => void; // toggle notifications for show
  onSimpleReminder?: (item: MediaItem) => void; // set simple reminder for show
  onBloopersOpen?: (item: MediaItem) => void; // open bloopers modal (deprecated - use onGoofsOpen)
  onGoofsOpen?: (item: MediaItem) => void; // open goofs modal
  onExtrasOpen?: (item: MediaItem) => void; // open extras modal
}

```

## apps/web/src/lib/smartDiscovery.ts
### Summary
Discovery scoring engine: preference analysis, genre weighting, vote+popularity signals, and user-specific caching.
### Content
```ts
import { LibraryEntry } from './storage';
import { CardData } from './tmdb';

export interface UserPreferences {
  favoriteGenres: Record<number, number>; // genre ID -> preference score (0-1)
  preferredMediaTypes: { movie: number; tv: number }; // preference scores
  averageRating: number; // user's average rating of their content
  ratingVariance: number; // how varied their ratings are
  notInterestedIds: Set<string>; // items marked as not interested
}

export interface RecommendationScore {
  item: CardData;
  score: number;
  reasons: string[];
}

/**
 * Analyzes user's library to build preference profile
 */
export function analyzeUserPreferences(
  watching: LibraryEntry[],
  wishlist: LibraryEntry[],
  watched: LibraryEntry[],
  notInterested: LibraryEntry[] = []
): UserPreferences {
  const allItems = [...watching, ...wishlist, ...watched];
  
  // Cold start: use priors when sample size is too small
  const MIN_SAMPLE_SIZE = 5;
  const usePriors = allItems.length < MIN_SAMPLE_SIZE;
  
  if (allItems.length === 0) {
    return {
      favoriteGenres: {},
      preferredMediaTypes: { movie: 0.5, tv: 0.5 },
      averageRating: 3.0, // Prior: neutral rating
      ratingVariance: 0,
      notInterestedIds: new Set(notInterested.map(item => `${item.mediaType}:${item.id}`))
    };
  }

  // Analyze genres from user's content
  // const genreCounts: Record<number, number> = {}; // Unused
  // const genreRatings: Record<number, number[]> = {}; // Unused
  const mediaTypeCounts = { movie: 0, tv: 0 };
  const userRatings: Array<{ rating: number; timestamp: number }> = [];
  const now = Date.now();
  const RECENCY_HALFLIFE_MS = 90 * 24 * 60 * 60 * 1000; // 90 days

  allItems.forEach(item => {
    // Count media types
    if (item.mediaType === 'movie') mediaTypeCounts.movie++;
    else if (item.mediaType === 'tv') mediaTypeCounts.tv++;

    // Collect user ratings with recency weighting
    if (item.userRating !== undefined && item.userRating !== null) {
      const timestamp = item.ratingUpdatedAt || item.addedAt || now;
      userRatings.push({ rating: item.userRating, timestamp });
    }
  });

  // Calculate genre preferences based on user ratings and frequency
  const favoriteGenres: Record<number, number> = {};
  
  // Calculate media type preferences
  const totalItems = allItems.length;
  const preferredMediaTypes = {
    movie: totalItems > 0 ? mediaTypeCounts.movie / totalItems : 0.5,
    tv: totalItems > 0 ? mediaTypeCounts.tv / totalItems : 0.5
  };

  // Calculate average rating with recency weighting and cold start priors
  let averageRating: number;
  if (userRatings.length === 0) {
    averageRating = 3.0; // Prior: neutral
  } else if (usePriors) {
    // Cold start: blend user ratings with prior (3.0)
    const userAvg = userRatings.reduce((sum, r) => sum + r.rating, 0) / userRatings.length;
    const priorWeight = (MIN_SAMPLE_SIZE - userRatings.length) / MIN_SAMPLE_SIZE;
    const userWeight = userRatings.length / MIN_SAMPLE_SIZE;
    averageRating = (priorWeight * 3.0) + (userWeight * userAvg);
  } else {
    // Normal: recency-weighted average
    const totalWeight = userRatings.reduce((sum, r) => {
      const age = now - r.timestamp;
      const weight = Math.exp(-age / RECENCY_HALFLIFE_MS);
      return sum + weight;
    }, 0);
    
    const weightedSum = userRatings.reduce((sum, r) => {
      const age = now - r.timestamp;
      const weight = Math.exp(-age / RECENCY_HALFLIFE_MS);
      return sum + (r.rating * weight);
    }, 0);
    
    averageRating = totalWeight > 0 ? weightedSum / totalWeight : 3.0;
  }
  
  // Calculate variance (simple version for now)
  const ratingVariance = userRatings.length > 1
    ? userRatings.reduce((sum, r) => sum + Math.pow(r.rating - averageRating, 2), 0) / userRatings.length
    : 0;

  return {
    favoriteGenres,
    preferredMediaTypes,
    averageRating,
    ratingVariance,
    notInterestedIds: new Set(notInterested.map(item => `${item.mediaType}:${item.id}`))
  };
}

/**
 * Scores a potential recommendation based on user preferences and ratings
 */
export function scoreRecommendation(
  item: CardData,
  preferences: UserPreferences,
  tmdbData?: any // Additional TMDB data for the item
): RecommendationScore {
  let score = 0;
  const reasons: string[] = [];

  // Base score from TMDB popularity/rating
  if (tmdbData?.vote_average) {
    const tmdbScore = tmdbData.vote_average / 10; // Normalize to 0-1
    score += tmdbScore * 0.25; // 25% weight to TMDB rating
    reasons.push(`High TMDB rating (${tmdbData.vote_average}/10)`);
  }

  if (tmdbData?.popularity) {
    // Cap popularity influence to prevent overweighting blockbusters
    const rawPopularity = Math.min(tmdbData.popularity / 100, 1);
    const cappedPopularity = Math.min(rawPopularity, 0.7); // Cap at 70% of max
    score += cappedPopularity * 0.12; // Reduced from 15% to 12% weight
    reasons.push(`Popular content`);
    
    // Variety boost: slightly boost less popular items to encourage diversity
    if (rawPopularity < 0.5) {
      score += 0.05; // Small boost for niche content
      reasons.push(`Niche favorite`);
    }
  }

  // Media type preference based on user's rated content
  const mediaTypePreference = preferences.preferredMediaTypes[item.kind];
  score += mediaTypePreference * 0.15; // 15% weight to media type preference
  if (mediaTypePreference > 0.6) {
    reasons.push(`Matches your ${item.kind} preference`);
  }

  // Enhanced genre preferences based on user ratings (with validation)
  if (tmdbData?.genre_ids && Array.isArray(tmdbData.genre_ids)) {
    let genreScore = 0;
    let matchingGenres = 0;
    
    tmdbData.genre_ids.forEach((genreId: any) => {
      // Validate genre ID before using
      const validGenreId = typeof genreId === 'number' && genreId > 0 ? genreId : null;
      if (validGenreId && preferences.favoriteGenres[validGenreId]) {
        genreScore += preferences.favoriteGenres[validGenreId];
        matchingGenres++;
      }
    });
    
    if (matchingGenres > 0) {
      const avgGenreScore = genreScore / matchingGenres;
      score += avgGenreScore * 0.25; // 25% weight to genre preferences
      reasons.push(`Matches ${matchingGenres} favorite genre${matchingGenres > 1 ? 's' : ''}`);
    }
  }

  // User rating compatibility bonus
  // If user tends to rate highly, boost items with high TMDB ratings
  if (preferences.averageRating > 3.5 && tmdbData?.vote_average > 7.0) {
    const ratingBonus = (preferences.averageRating - 3.0) * 0.1; // Up to 0.2 bonus
    score += ratingBonus;
    reasons.push(`Matches your high-rating preference`);
  }

  // Penalty for not interested items
  const itemKey = `${item.kind}:${item.id}`;
  if (preferences.notInterestedIds.has(itemKey)) {
    score = 0;
    reasons.push('Marked as not interested');
  }

  // Bonus for content similar to highly-rated items
  // This would require more complex similarity analysis

  return {
    item,
    score: Math.max(0, Math.min(1, score)), // Clamp to 0-1
    reasons
  };
}

/**
 * Gets smart recommendations based on user preferences
 */
// User-specific recommendation cache (prevents multi-audience contamination)
const recommendationCache = new Map<string, { 
  recommendations: RecommendationScore[]; 
  timestamp: number; 
  userId: string;
  preferencesHash: string;
}>();
const CACHE_TTL_MS = 5 * 60 * 1000; // 5 minutes

function hashPreferences(prefs: UserPreferences): string {
  return JSON.stringify({
    avgRating: Math.round(prefs.averageRating * 100) / 100,
    genres: Object.keys(prefs.favoriteGenres).sort().join(','),
    mediaTypes: `${prefs.preferredMediaTypes.movie.toFixed(2)}:${prefs.preferredMediaTypes.tv.toFixed(2)}`
  });
}

export async function getSmartRecommendations(
  preferences: UserPreferences,
  limit: number = 20,
  tmdbApi: (path: string, params?: any) => Promise<any> = () => Promise.resolve({}),
  userId: string = 'anonymous'
): Promise<RecommendationScore[]> {
  // Check cache (user-specific)
  const prefsHash = hashPreferences(preferences);
  const cacheKey = `${userId}:${prefsHash}`;
  const cached = recommendationCache.get(cacheKey);
  const now = Date.now();
  
  if (cached && cached.userId === userId && (now - cached.timestamp) < CACHE_TTL_MS) {
    return cached.recommendations;
  }
  try {
    // Fetch candidate content from TMDB
    const [trendingData, popularMoviesData, popularTvData] = await Promise.all([
      tmdbApi('/trending/all/week', { page: 1 }),
      tmdbApi('/movie/popular', { page: 1 }),
      tmdbApi('/tv/popular', { page: 1 })
    ]);

    // Combine all candidate items and deduplicate
    const candidatesMap = new Map<string, any>();
    
    // Add trending items
    if (trendingData?.results) {
      trendingData.results.forEach((item: any) => {
        const key = `${item.media_type || 'movie'}-${item.id}`;
        if (!candidatesMap.has(key)) {
          candidatesMap.set(key, { ...item, media_type: item.media_type || 'movie' });
        }
      });
    }
    
    // Add popular movies (only if not already in trending)
    if (popularMoviesData?.results) {
      popularMoviesData.results.forEach((item: any) => {
        const key = `movie-${item.id}`;
        if (!candidatesMap.has(key)) {
          candidatesMap.set(key, { ...item, media_type: 'movie' });
        }
      });
    }
    
    // Add popular TV shows (only if not already in trending)
    if (popularTvData?.results) {
      popularTvData.results.forEach((item: any) => {
        const key = `tv-${item.id}`;
        if (!candidatesMap.has(key)) {
          candidatesMap.set(key, { ...item, media_type: 'tv' });
        }
      });
    }
    
    const candidates = Array.from(candidatesMap.values());

    // Convert to CardData format and score each item
    const scoredItems: RecommendationScore[] = [];
    
    for (const candidate of candidates) {
      if (!candidate.poster_path) continue; // Skip items without posters
      
      // Ensure title is properly extracted and validated
      const rawTitle = candidate.title || candidate.name;
      const safeTitle = (() => {
        if (typeof rawTitle === 'string' && rawTitle.trim() && rawTitle !== String(candidate.id)) {
          return rawTitle.trim();
        }
        return 'Untitled';
      })();
      
      // Extract year from release_date or first_air_date
      const date = candidate.release_date || candidate.first_air_date;
      const year = date ? parseInt(String(date).slice(0, 4)) : undefined;
      
      const cardData: CardData = {
        id: String(candidate.id),
        kind: candidate.media_type as 'movie' | 'tv',
        title: safeTitle,
        poster: candidate.poster_path ? `https://image.tmdb.org/t/p/w342${candidate.poster_path}` : '',
        year
      };

      const score = scoreRecommendation(cardData, preferences, candidate);
      
      // Only include items with reasonable scores
      if (score.score > 0.1) {
        scoredItems.push(score);
      }
    }

    // Sort by score (highest first) and return top results
    scoredItems.sort((a, b) => b.score - a.score);
    
    const results = scoredItems.slice(0, limit);
    
    // Cache results (user-specific)
    recommendationCache.set(cacheKey, {
      recommendations: results,
      timestamp: now,
      userId,
      preferencesHash: prefsHash
    });
    
    // Clean up old cache entries
    for (const [key, value] of recommendationCache.entries()) {
      if (value.userId !== userId || (now - value.timestamp) >= CACHE_TTL_MS) {
        recommendationCache.delete(key);
      }
    }
    
    return results;
  } catch (error) {
    console.error('Failed to get smart recommendations:', error);
    return [];
  }
}

/**
 * Analyzes genre preferences from TMDB data
 */
export async function analyzeGenrePreferences(
  items: LibraryEntry[],
  tmdbApi: (path: string, params?: any) => Promise<any>,
  timeoutMs: number = 10000 // 10 second timeout
): Promise<Record<number, number>> {
  const genreCounts: Record<number, number> = {};
  const genreRatings: Record<number, number[]> = {};
  
  // Create abort controller for timeout
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), timeoutMs);

  // Fetch genre data for each item (with timeout protection)
  for (const item of items) {
    try {
      // Check if aborted
      if (controller.signal.aborted) {
        // Silent timeout (expected behavior)
        break;
      }
      
      const path = item.mediaType === 'movie' ? `/movie/${item.id}` : `/tv/${item.id}`;
      const data = await tmdbApi(path);
      
      if (data?.genres && Array.isArray(data.genres)) {
        data.genres.forEach((genre: any) => {
          // Validate genre ID (must be positive integer)
          const genreId = typeof genre.id === 'number' && genre.id > 0 ? genre.id : null;
          if (!genreId) {
            // Silent skip for invalid genres (data quality issue, not an error)
            return; // Skip invalid genres
          }
          
          genreCounts[genreId] = (genreCounts[genreId] || 0) + 1;
          
          // Only include ratings that are valid (1-5, not null/undefined)
          if (item.userRating !== undefined && item.userRating !== null && 
              item.userRating >= 1 && item.userRating <= 5) {
            if (!genreRatings[genreId]) genreRatings[genreId] = [];
            genreRatings[genreId].push(item.userRating);
          }
        });
      }
    } catch (error) {
      if (controller.signal.aborted) {
        // Silent abort on timeout (expected behavior)
        break;
      }
      // Only log unexpected errors (not network timeouts or aborts)
      if (error instanceof Error && !error.message.includes('abort') && !error.message.includes('timeout')) {
        console.warn(`Failed to fetch genre data for ${item.mediaType}:${item.id}`, error);
      }
    }
  }
  
  // Clear timeout
  clearTimeout(timeoutId);

  // Calculate preference scores
  const preferences: Record<number, number> = {};
  
  Object.keys(genreCounts).forEach(genreIdStr => {
    const genreId = parseInt(genreIdStr);
    const count = genreCounts[genreId];
    const ratings = genreRatings[genreId] || [];
    
    // Base score on frequency
    let score = count / items.length;
    
    // Boost score if user rates this genre highly
    if (ratings.length > 0) {
      const avgRating = ratings.reduce((sum, rating) => sum + rating, 0) / ratings.length;
      const ratingBoost = (avgRating - 3) / 2; // Convert 1-5 scale to -1 to +1 boost
      score += ratingBoost * 0.3; // 30% weight to rating boost
    }
    
    preferences[genreId] = Math.max(0, Math.min(1, score));
  });

  return preferences;
}

```

## apps/web/src/hooks/useSmartDiscovery.ts
### Summary
Hook that listens for rating/library changes, deduplicates triggers, and synchronizes smart discovery fetches.
### Content
```ts
import { useState, useEffect, useMemo, useRef } from 'react';
import { authManager } from '@/lib/auth';
import { Library } from '@/lib/storage';
import { getSmartRecommendations, analyzeUserPreferences, analyzeGenrePreferences } from '@/lib/smartDiscovery';
import { get } from '@/lib/tmdb';
import { customListManager } from '@/lib/customLists';
import { useSettings } from '@/lib/settings';
import type { RecommendationScore } from '@/lib/smartDiscovery';

/**
 * Process: Smart Discovery Hook
 * Purpose: Provides personalized movie/TV recommendations based on user's library and ratings
 * Data Source: User's watching/wishlist/watched lists with ratings, TMDB trending/popular content
 * Update Path: Updates when user adds/rates content or when library changes
 * Dependencies: Library storage, TMDB API, smart discovery algorithms
 */
// Track recent rating changes for deduplication
const recentRatingChanges = new Map<string, { timestamp: number; rating: number }>();
const RATING_DEDUP_WINDOW_MS = 300; // 300ms window

export function useSmartDiscovery() {
  const [recommendations, setRecommendations] = useState<RecommendationScore[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [_ratingVersion, setRatingVersion] = useState(0);
  const lastUpdateRef = useRef<{ itemKey: string; rating: number; timestamp: number } | null>(null);
  const isFetchingRef = useRef(false);
  const lastLibraryHashRef = useRef<string>('');
  const settings = useSettings();

  // Get user's library data - include ratings in the data
  const watching = Library.getByList('watching');
  const wishlist = Library.getByList('wishlist');
  const watched = Library.getByList('watched');
  const notInterested = Library.getByList('not');
  
  // Create stable hash of library contents to detect actual changes
  const libraryHash = useMemo(() => {
    const allItems = [...watching, ...wishlist, ...watched, ...notInterested];
    return JSON.stringify({
      count: allItems.length,
      ratings: allItems
        .filter(item => item.userRating !== undefined)
        .map(item => `${item.id}:${item.mediaType}:${item.userRating}`)
        .sort()
        .join(',')
    });
  }, [watching, wishlist, watched, notInterested]);
  
  // Listen for rating changes to trigger discovery refresh (with deduplication and origin tracking)
  useEffect(() => {
    const handleLibraryChange = (e: CustomEvent) => {
      const detail = e.detail || {};
      
      // Ignore events that came from discovery itself (prevent circular updates)
      if (detail.origin === 'discovery') {
        return; // Ignore our own updates
      }
      
      // Only process rating changes
      if (detail.operation === 'rating') {
        const itemKey = detail.itemId && detail.mediaType 
          ? `${detail.mediaType}:${detail.itemId}` 
          : null;
        const rating = detail.rating;
        const timestamp = Date.now();
        
        if (!itemKey || rating === undefined) return;
        
        // Check for duplicate (same item, same rating, within window)
        const recent = recentRatingChanges.get(itemKey);
        if (recent && recent.rating === rating) {
          const timeDiff = timestamp - recent.timestamp;
          if (timeDiff < RATING_DEDUP_WINDOW_MS) {
            return; // Duplicate, skip
          }
        }
        
        // Check if this is the same as last update we processed
        if (lastUpdateRef.current?.itemKey === itemKey && 
            lastUpdateRef.current?.rating === rating &&
            timestamp - lastUpdateRef.current.timestamp < RATING_DEDUP_WINDOW_MS) {
          return; // Same update, skip
        }
        
        // Record this update
        recentRatingChanges.set(itemKey, { timestamp, rating });
        lastUpdateRef.current = { itemKey, rating, timestamp };
        
        // Clean up old entries
        const cutoff = Date.now() - RATING_DEDUP_WINDOW_MS;
        for (const [k, v] of recentRatingChanges.entries()) {
          if (v.timestamp < cutoff) {
            recentRatingChanges.delete(k);
          }
        }
        
        // Trigger refresh
        setRatingVersion(prev => prev + 1);
      }
    };
    
    window.addEventListener('library:changed', handleLibraryChange as EventListener);
    return () => {
      window.removeEventListener('library:changed', handleLibraryChange as EventListener);
    };
  }, []);

  // Analyze user preferences including ratings
  // Use libraryHash instead of arrays to prevent unnecessary recalculations
  const userPreferences = useMemo(() => {
    return analyzeUserPreferences(watching, wishlist, watched, notInterested);
  }, [libraryHash]);

  // User-specific cache key (prevents multi-audience contamination)
  const userId = useMemo(() => {
    try {
      const currentUser = authManager.getCurrentUser();
      return currentUser?.uid || 'anonymous';
    } catch {
      return 'anonymous';
    }
  }, []);

  // Enhanced genre analysis with ratings (use state instead of useMemo for async)
  const [genrePreferences, setGenrePreferences] = useState<Record<number, number>>({});
  const lastGenreHashRef = useRef<string>('');
  
  useEffect(() => {
    // Only fetch if library actually changed (not just array reference)
    const genreHash = libraryHash;
    if (genreHash === lastGenreHashRef.current) {
      return; // No change, skip
    }
    lastGenreHashRef.current = genreHash;
    
    const fetchGenrePreferences = async () => {
      if (watching.length + wishlist.length + watched.length === 0) {
        setGenrePreferences({});
        return;
      }
      
      const allItems = [...watching, ...wishlist, ...watched];
      // Limit to first 20 items to prevent blocking (genre analysis is expensive)
      const itemsToAnalyze = allItems.slice(0, 20);
      // Add timeout to prevent hanging (8 second timeout)
      const prefs = await analyzeGenrePreferences(itemsToAnalyze, get, 8000);
      setGenrePreferences(prefs);
    };
    
    fetchGenrePreferences();
  }, [libraryHash, watching, wishlist, watched]);

  // Fetch smart recommendations (with guards to prevent infinite loops)
  useEffect(() => {
    // Guard: prevent concurrent fetches
    if (isFetchingRef.current) {
      return; // Already fetching, skip
    }
    
    // Guard: only fetch if library actually changed
    if (libraryHash === lastLibraryHashRef.current && Object.keys(genrePreferences).length > 0) {
      return; // No change, skip
    }
    lastLibraryHashRef.current = libraryHash;
    
    const fetchRecommendations = async () => {
      isFetchingRef.current = true;
      setIsLoading(true);
      setError(null);

      try {
        // Get enhanced preferences with genre analysis (already resolved, no await needed)
        const enhancedPreferences = {
          ...userPreferences,
          favoriteGenres: genrePreferences
        };

        // Fetch smart recommendations using configured limit (cache key includes userId to prevent contamination)
        const discoveryLimit = settings.layout.discoveryLimit || 25;
        const recs = await getSmartRecommendations(enhancedPreferences, discoveryLimit, get, userId);
        
        // Filter out items already in user's library (including custom lists)
        // Get all items from all lists to ensure no duplicates across any tab
        const allExistingItems = [
          ...Library.getByList('watching'),
          ...Library.getByList('wishlist'), 
          ...Library.getByList('watched'),
          ...Library.getByList('not')
        ];
        
        // Add custom list items dynamically
        const userLists = customListManager.getUserLists();
        userLists.customLists.forEach(customList => {
          const customListName = `custom:${customList.id}` as any;
          allExistingItems.push(...Library.getByList(customListName));
        });
        
        const existingIds = new Set(
          allExistingItems.map(item => `${item.mediaType}:${item.id}`)
        );

        const filteredRecs = recs.filter(rec => {
          const itemKey = `${rec.item.kind}:${rec.item.id}`;
          return !existingIds.has(itemKey);
        });

        setRecommendations(filteredRecs);
      } catch (err) {
        // Only log errors, not every fetch
        if (err instanceof Error && !err.message.includes('aborted')) {
          console.error('Failed to fetch smart recommendations:', err);
        }
        setError('Failed to load recommendations. Please try again.');
      } finally {
        setIsLoading(false);
        isFetchingRef.current = false;
      }
    };

    fetchRecommendations();
  }, [libraryHash, userPreferences, genrePreferences, userId, settings.layout.discoveryLimit]);

  return {
    recommendations,
    isLoading,
    error,
    userPreferences
  };
}

```

## apps/web/src/components/HelpModal.tsx
### Summary
Help modal that documents discovery/rating behaviors for users.
### Content
```tsx
import React, { useEffect, useRef } from "react";

interface HelpModalProps {
  isOpen: boolean;
  onClose: () => void;
}

/**
 * Process: Help Modal
 * Purpose: Provides comprehensive help and guidance for all app features
 * Data Source: Static help content
 * Update Path: Manual content updates
 * Dependencies: Accessibility standards, responsive design
 */

export const HelpModal: React.FC<HelpModalProps> = ({ isOpen, onClose }) => {
  const modalRef = useRef<HTMLDivElement>(null);
  const firstFocusableRef = useRef<HTMLButtonElement>(null);
  const [activeSection, setActiveSection] = React.useState("welcome");

  // Focus management
  useEffect(() => {
    if (isOpen && firstFocusableRef.current) {
      firstFocusableRef.current.focus();
    }
  }, [isOpen]);

  // Keyboard navigation
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (!isOpen) return;

      if (e.key === "Escape") {
        onClose();
      }
    };

    document.addEventListener("keydown", handleKeyDown);
    return () => document.removeEventListener("keydown", handleKeyDown);
  }, [isOpen, onClose]);

  // Trap focus within modal
  useEffect(() => {
    if (!isOpen) return;

    const focusableElements = modalRef.current?.querySelectorAll(
      'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
    ) as NodeListOf<HTMLElement>;

    const firstElement = focusableElements[0];
    const lastElement = focusableElements[focusableElements.length - 1];

    const handleTabKey = (e: KeyboardEvent) => {
      if (e.key !== "Tab") return;

      if (e.shiftKey) {
        if (document.activeElement === firstElement) {
          lastElement?.focus();
          e.preventDefault();
        }
      } else {
        if (document.activeElement === lastElement) {
          firstElement?.focus();
          e.preventDefault();
        }
      }
    };

    document.addEventListener("keydown", handleTabKey);
    return () => document.removeEventListener("keydown", handleTabKey);
  }, [isOpen]);

  if (!isOpen) return null;

  const sections = [
    { id: "welcome", title: "Welcome to Flicklet", icon: "üëã" },
    { id: "getting-started", title: "Getting Started", icon: "üöÄ" },
    { id: "managing-library", title: "Managing Your Library", icon: "üìö" },
    { id: "discovery-search", title: "Discovery & Search", icon: "üîç" },
    { id: "notifications", title: "Notifications", icon: "üîî" },
    {
      id: "settings-customization",
      title: "Settings & Customization",
      icon: "‚öôÔ∏è",
    },
    { id: "pro-features", title: "Pro Features", icon: "‚≠ê" },
    { id: "troubleshooting", title: "Troubleshooting", icon: "üîß" },
    {
      id: "keyboard-shortcuts",
      title: "Keyboard & Gesture Shortcuts",
      icon: "‚å®Ô∏è",
    },
    { id: "accessibility", title: "Accessibility & Support", icon: "‚ôøÔ∏è" },
    { id: "about", title: "About & Version Info", icon: "‚ÑπÔ∏è" },
  ];

  const renderContent = () => {
    switch (activeSection) {
      case "welcome":
        return (
          <div className="space-y-4 text-gray-700 dark:text-gray-300">
            <p>
              Flicklet helps you <strong>keep track of what you watch</strong>{" "}
              and <strong>discover what to watch next</strong>. You can use it
              on your phone, tablet, or computer‚Äîyour lists sync automatically
              when you're signed in.
            </p>
            <p>Think of it as a personal entertainment dashboard:</p>
            <ul className="list-disc list-inside space-y-2 ml-4">
              <li>Save what you're watching now</li>
              <li>Build a wishlist of what's next</li>
              <li>Mark what you've finished</li>
              <li>Find new recommendations that fit your taste</li>
            </ul>
          </div>
        );
      case "getting-started":
        return (
          <div className="space-y-4 text-gray-700 dark:text-gray-300">
            <div>
              <h4 className="font-semibold mb-2">Sign In & Setup</h4>
              <ol className="list-decimal list-inside space-y-2 ml-4">
                <li>
                  Open Flicklet and tap <strong>Sign In</strong> in the top
                  corner.
                </li>
                <li>Choose your Google account (required for sync).</li>
                <li>
                  Once signed in, your lists and settings are stored securely in
                  your account.
                </li>
              </ol>
            </div>

            <div>
              <h4 className="font-semibold mb-2">Navigating the App</h4>
              <p className="mb-2">
                Across the bottom (mobile) or top (desktop), you'll see the main
                sections:
              </p>
              <ul className="list-disc list-inside space-y-2 ml-4">
                <li>
                  <strong>Home:</strong> personalized dashboard and
                  recommendations
                </li>
                <li>
                  <strong>Currently Watching:</strong> everything you're mid-way
                  through
                </li>
                <li>
                  <strong>Want to Watch:</strong> your wishlist of shows and
                  movies
                </li>
                <li>
                  <strong>Watched:</strong> what you've completed
                </li>
                <li>
                  <strong>Discovery:</strong> smart suggestions based on your
                  viewing
                </li>
                <li>
                  <strong>My Lists:</strong> any custom lists you've created
                </li>
                <li>
                  <strong>Settings (‚öôÔ∏è):</strong> your preferences, data, and
                  Pro options
                </li>
              </ul>
            </div>

            <div>
              <h4 className="font-semibold mb-2">
                Adding Your First Show or Movie
              </h4>
              <ol className="list-decimal list-inside space-y-2 ml-4">
                <li>
                  Tap the <strong>Search bar</strong> üîç at the top.
                </li>
                <li>Type a title or actor's name.</li>
                <li>
                  Tap the <strong>‚ûï Add</strong> button on any card to put it
                  in your <em>Want to Watch</em> list.
                </li>
                <li>
                  You can move it to <em>Currently Watching</em> once you start
                  it.
                </li>
              </ol>
            </div>
          </div>
        );
      case "managing-library":
        return (
          <div className="space-y-4 text-gray-700 dark:text-gray-300">
            <div>
              <h4 className="font-semibold mb-2">Your Lists Explained</h4>
              <ul className="list-disc list-inside space-y-2 ml-4">
                <li>
                  <strong>Currently Watching:</strong> active shows and movies
                  you're tracking.
                </li>
                <li>
                  <strong>Want to Watch:</strong> your personal wishlist.
                </li>
                <li>
                  <strong>Watched:</strong> completed items.
                </li>
                <li>
                  <strong>Returning:</strong> shows confirmed for another
                  season.
                </li>
                <li>
                  <strong>My Lists:</strong> fully custom collections (for
                  example, "Holiday Movies" or "Scary Stuff").
                </li>
              </ul>
            </div>

            <div>
              <h4 className="font-semibold mb-2">Organizing Content</h4>
              <ul className="list-disc list-inside space-y-2 ml-4">
                <li>Drag and drop items to reorder within a list (desktop).</li>
                <li>
                  On mobile, swipe <strong>right</strong> to mark as{" "}
                  <em>Watched</em> or <strong>left</strong> to move to another
                  list.
                </li>
                <li>
                  Tap the <strong>‚ãØ (More)</strong> button on any card to see
                  all actions: rate, tag, add notes, view bloopers, etc.
                </li>
                <li>
                  Add notes for your own reminders (e.g., "stopped at episode
                  4").
                </li>
                <li>Use tags to group items ("comedy," "family," "2024").</li>
                <li>Rate items ‚≠ê 1-5 to improve your recommendations.</li>
              </ul>
            </div>

            <div>
              <h4 className="font-semibold mb-2">Tracking Episodes</h4>
              <p className="mb-2">If you're watching a TV show:</p>
              <ol className="list-decimal list-inside space-y-2 ml-4">
                <li>
                  Tap <strong>Track Episodes</strong> from the overflow menu.
                </li>
                <li>Use the selector to mark what you've seen.</li>
                <li>Flicklet will highlight what's next to watch.</li>
              </ol>
            </div>
          </div>
        );
      case "pro-features":
        return (
          <div className="space-y-4 text-gray-700 dark:text-gray-300">
            <div>
              <p className="mb-3">
                Pro unlocks the full experience. If you're using the free
                version, you'll still have everything you need to track
                shows‚ÄîPro simply adds more fun.
              </p>

              <h4 className="font-semibold mb-2">Included with Pro:</h4>
              <ul className="list-disc list-inside space-y-2 ml-4">
                <li>
                  üé¨ <strong>Bloopers & Outtakes:</strong> watch
                  behind-the-scenes clips from verified sources.
                </li>
                <li>
                  ‚è∞ <strong>Advanced Notifications:</strong> detailed timing
                  control and per-show alerts.
                </li>
                <li>
                  üß© <strong>Theme Packs:</strong> change how Flicklet looks for
                  holidays or genres.
                </li>
                <li>
                  üïπÔ∏è <strong>FlickWord & Trivia:</strong> light games built into
                  the app.
                </li>
                <li>
                  üì∫ <strong>Extended Episode Tracking:</strong> detailed season
                  progress for multiple shows.
                </li>
              </ul>
            </div>

            <div>
              <h4 className="font-semibold mb-2">How It Works</h4>
              <ul className="list-disc list-inside space-y-2 ml-4">
                <li>
                  Look for the gold <strong>PRO</strong> badge on features that
                  need Pro.
                </li>
                <li>
                  Upgrade in <strong>Settings ‚Üí Pro</strong>.
                </li>
                <li>You can preview what Pro offers before paying.</li>
              </ul>
            </div>

            <div className="bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-800 rounded-lg p-4">
              <h4 className="font-semibold mb-2 text-blue-900 dark:text-blue-100">
                Legal & Content Notes
              </h4>
              <p className="text-blue-800 dark:text-blue-200 text-sm">
                All extra videos or bloopers link directly from verified
                providers. Flicklet doesn't re-upload or host any copyrighted
                material‚Äîeverything plays from its original source.
              </p>
            </div>
          </div>
        );
      case "discovery-search":
        return (
          <div className="space-y-4 text-gray-700 dark:text-gray-300">
            <div>
              <h4 className="font-semibold mb-2">Finding New Content</h4>
              <ul className="list-disc list-inside space-y-2 ml-4">
                <li>
                  Type anything into the Search bar‚Äîtitle, actor, or genre.
                </li>
                <li>
                  Use the filter above the results to limit by{" "}
                  <strong>Movies</strong>, <strong>TV</strong>, or{" "}
                  <strong>People</strong>.
                </li>
                <li>
                  Discovery tab gives you <strong>"For You" rails</strong>
                  ‚Äîpersonalized picks based on your ratings and history.
                </li>
              </ul>
            </div>

            <div>
              <h4 className="font-semibold mb-2">Tips</h4>
              <ul className="list-disc list-inside space-y-2 ml-4">
                <li>
                  Use <strong>tag:</strong> search (like{" "}
                  <code className="bg-gray-100 dark:bg-gray-700 px-1 py-0.5 rounded text-sm">
                    tag:comedy
                  </code>
                  ) to search your own lists.
                </li>
                <li>
                  Discovery shows only refresh when your tastes change‚Äîrate or
                  tag more items to improve accuracy.
                </li>
              </ul>
            </div>
          </div>
        );
      case "notifications":
        return (
          <div className="space-y-4 text-gray-700 dark:text-gray-300">
            <div>
              <h4 className="font-semibold mb-2">What You Can Get</h4>
              <ul className="list-disc list-inside space-y-2 ml-4">
                <li>
                  <strong>Episode Alerts:</strong> when new episodes air.
                </li>
                <li>
                  <strong>Weekly Discover:</strong> curated picks sent weekly.
                </li>
                <li>
                  <strong>Monthly Stats:</strong> quick snapshot of your viewing
                  totals.
                </li>
                <li>
                  <strong>Custom Reminders:</strong> set alerts ahead of time.
                </li>
              </ul>
            </div>

            <div>
              <h4 className="font-semibold mb-2">How to Manage</h4>
              <ol className="list-decimal list-inside space-y-2 ml-4">
                <li>
                  Go to <strong>Settings ‚Üí Notifications</strong>.
                </li>
                <li>Toggle each alert on or off.</li>
                <li>
                  Adjust timing for episode reminders (e.g., 1 hour before).
                </li>
                <li>
                  Make sure your browser or device allows notifications from
                  Flicklet.
                </li>
              </ol>
            </div>

            <div>
              <p className="font-semibold mb-2">
                If you stop receiving alerts, check:
              </p>
              <ul className="list-disc list-inside space-y-2 ml-4">
                <li>Your browser's permission settings.</li>
                <li>You're still signed in.</li>
                <li>You haven't cleared site data or cookies.</li>
              </ul>
            </div>
          </div>
        );
      case "settings-customization":
        return (
          <div className="space-y-4 text-gray-700 dark:text-gray-300">
            <div>
              <h4 className="font-semibold mb-2">
                Personalize Your Experience
              </h4>
              <ul className="list-disc list-inside space-y-2 ml-4">
                <li>
                  Switch between <strong>Light</strong> and{" "}
                  <strong>Dark</strong> mode.
                </li>
                <li>
                  Change your <strong>display name</strong> (shown in community
                  or Pro features).
                </li>
                <li>
                  Choose your <strong>personality level</strong>‚Äîcontrols the
                  humor tone of messages and empty states.
                </li>
                <li>
                  Pick your favorite genres to shape <em>For You</em>{" "}
                  recommendations.
                </li>
              </ul>
            </div>

            <div>
              <h4 className="font-semibold mb-2">Layout Options</h4>
              <ul className="list-disc list-inside space-y-2 ml-4">
                <li>
                  Toggle <strong>Condensed View</strong> for tighter spacing.
                </li>
                <li>Choose which sections appear on your Home screen.</li>
                <li>
                  Enable or disable <strong>Episode Tracking</strong> here too.
                </li>
              </ul>
            </div>

            <div>
              <h4 className="font-semibold mb-2">Data Management</h4>
              <ul className="list-disc list-inside space-y-2 ml-4">
                <li>
                  <strong>Export Backup:</strong> download a JSON copy of your
                  data.
                </li>
                <li>
                  <strong>Import Backup:</strong> restore from a saved file.
                </li>
                <li>
                  <strong>Share With Friends:</strong> generate a shareable
                  summary of your lists.
                </li>
                <li>
                  <strong>Reset All Data:</strong> wipes everything back to
                  defaults (careful).
                </li>
              </ul>
            </div>

            <div>
              <h4 className="font-semibold mb-2">Privacy & Sync</h4>
              <ul className="list-disc list-inside space-y-2 ml-4">
                <li>
                  Flicklet only stores minimal data (lists, ratings, notes).
                </li>
                <li>
                  All media data (titles, images) comes from official TMDB
                  sources.
                </li>
                <li>
                  Your info syncs through your Google sign-in only‚Äîno external
                  tracking.
                </li>
              </ul>
            </div>
          </div>
        );
      case "troubleshooting":
        return (
          <div className="space-y-4 text-gray-700 dark:text-gray-300">
            <div>
              <h4 className="font-semibold mb-3">Common Fixes</h4>
              <div className="overflow-x-auto">
                <table className="min-w-full border-collapse border border-gray-300 dark:border-gray-600">
                  <thead>
                    <tr className="bg-gray-100 dark:bg-gray-700">
                      <th className="border border-gray-300 dark:border-gray-600 px-4 py-2 text-left font-semibold">
                        Problem
                      </th>
                      <th className="border border-gray-300 dark:border-gray-600 px-4 py-2 text-left font-semibold">
                        Try This
                      </th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td className="border border-gray-300 dark:border-gray-600 px-4 py-2">
                        App not loading
                      </td>
                      <td className="border border-gray-300 dark:border-gray-600 px-4 py-2">
                        Refresh the page or check your internet connection
                      </td>
                    </tr>
                    <tr className="bg-gray-50 dark:bg-gray-800">
                      <td className="border border-gray-300 dark:border-gray-600 px-4 py-2">
                        Search gives no results
                      </td>
                      <td className="border border-gray-300 dark:border-gray-600 px-4 py-2">
                        Try different spelling or switch between Movies/TV
                      </td>
                    </tr>
                    <tr>
                      <td className="border border-gray-300 dark:border-gray-600 px-4 py-2">
                        Notifications stopped
                      </td>
                      <td className="border border-gray-300 dark:border-gray-600 px-4 py-2">
                        Check browser permissions and sign-in status
                      </td>
                    </tr>
                    <tr className="bg-gray-50 dark:bg-gray-800">
                      <td className="border border-gray-300 dark:border-gray-600 px-4 py-2">
                        Lists look empty
                      </td>
                      <td className="border border-gray-300 dark:border-gray-600 px-4 py-2">
                        Make sure you're logged in; local storage may have
                        cleared
                      </td>
                    </tr>
                    <tr>
                      <td className="border border-gray-300 dark:border-gray-600 px-4 py-2">
                        Can't sign in on mobile
                      </td>
                      <td className="border border-gray-300 dark:border-gray-600 px-4 py-2">
                        Clear browser cache, reopen app, and retry login
                      </td>
                    </tr>
                    <tr className="bg-gray-50 dark:bg-gray-800">
                      <td className="border border-gray-300 dark:border-gray-600 px-4 py-2">
                        Bloopers/Extras not playing
                      </td>
                      <td className="border border-gray-300 dark:border-gray-600 px-4 py-2">
                        Some videos open externally if embedding is blocked
                      </td>
                    </tr>
                  </tbody>
                </table>
              </div>
            </div>

            <div className="bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-800 rounded-lg p-4">
              <h4 className="font-semibold mb-2 text-blue-900 dark:text-blue-100">
                Still Stuck?
              </h4>
              <p className="text-blue-800 dark:text-blue-200 text-sm mb-2">
                Open <strong>Settings ‚Üí Feedback</strong>. Include:
              </p>
              <ul className="list-disc list-inside space-y-1 ml-4 text-sm text-blue-800 dark:text-blue-200">
                <li>What you were doing</li>
                <li>What you expected</li>
                <li>What happened instead</li>
                <li>Your browser and device</li>
              </ul>
              <p className="text-blue-800 dark:text-blue-200 text-sm mt-2">
                This helps us fix it faster.
              </p>
            </div>
          </div>
        );
      case "keyboard-shortcuts":
        return (
          <div className="space-y-4 text-gray-700 dark:text-gray-300">
            <div>
              <h4 className="font-semibold mb-2">Keyboard (Desktop)</h4>
              <ul className="list-disc list-inside space-y-2 ml-4">
                <li>
                  <kbd className="bg-gray-100 dark:bg-gray-700 px-2 py-1 rounded text-sm">
                    Esc
                  </kbd>{" "}
                  close modals or exit search
                </li>
                <li>
                  <kbd className="bg-gray-100 dark:bg-gray-700 px-2 py-1 rounded text-sm">
                    Tab
                  </kbd>{" "}
                  move between fields or buttons
                </li>
                <li>
                  <kbd className="bg-gray-100 dark:bg-gray-700 px-2 py-1 rounded text-sm">
                    Enter
                  </kbd>{" "}
                  activate selected button
                </li>
                <li>
                  <kbd className="bg-gray-100 dark:bg-gray-700 px-2 py-1 rounded text-sm">
                    /
                  </kbd>{" "}
                  jump to search
                </li>
              </ul>
            </div>

            <div>
              <h4 className="font-semibold mb-2">Touch (Mobile)</h4>
              <ul className="list-disc list-inside space-y-2 ml-4">
                <li>
                  <strong>Swipe right:</strong> mark as Watched
                </li>
                <li>
                  <strong>Swipe left:</strong> move to another list
                </li>
                <li>
                  <strong>Pull down:</strong> refresh content
                </li>
                <li>
                  <strong>Tap and hold:</strong> reorder (on supported lists)
                </li>
              </ul>
            </div>
          </div>
        );
      case "accessibility":
        return (
          <div className="space-y-4 text-gray-700 dark:text-gray-300">
            <ul className="list-disc list-inside space-y-2 ml-4">
              <li>Fully navigable by keyboard</li>
              <li>Screen reader friendly structure</li>
              <li>Focus trapping ensures you don't lose cursor position</li>
              <li>ARIA roles and labels implemented in all modals</li>
              <li>Contrast and font-size compliant with WCAG guidelines</li>
            </ul>
            <div className="bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-800 rounded-lg p-4 mt-4">
              <p className="text-blue-800 dark:text-blue-200 text-sm">
                For help with accessibility or other feedback, contact support
                via the Feedback form in Settings.
              </p>
            </div>
          </div>
        );
      case "about":
        return (
          <div className="space-y-4 text-gray-700 dark:text-gray-300">
            <ul className="list-disc list-inside space-y-2 ml-4">
              <li>
                <strong>App Version:</strong> Flicklet v2
              </li>
              <li>
                <strong>Last Updated:</strong> shown at the bottom of the Help
                modal
              </li>
              <li>
                <strong>Component:</strong>{" "}
                <code className="bg-gray-100 dark:bg-gray-700 px-1 py-0.5 rounded text-sm">
                  apps/web/src/components/HelpModal.tsx
                </code>
              </li>
              <li>
                <strong>Feature Flags:</strong> Help content is static‚Äîvisible
                to everyone.
              </li>
            </ul>
          </div>
        );
      default:
        return null;
    }
  };

  if (!isOpen) return null;

  return (
    <>
      <div
        className="fixed inset-0 z-overlay bg-black bg-opacity-50"
        onClick={onClose}
        aria-hidden="true"
      />
      <div className="fixed inset-0 z-modal flex items-center justify-center p-4">
        <div
          ref={modalRef}
          className="bg-white dark:bg-gray-800 rounded-lg w-full max-w-6xl max-h-[90vh] overflow-hidden shadow-xl"
          role="dialog"
          aria-modal="true"
          aria-labelledby="help-modal-title"
          aria-describedby="help-modal-description"
        >
          {/* Header */}
          <div className="flex items-center justify-between p-6 border-b border-gray-200 dark:border-gray-700">
            <h2
              id="help-modal-title"
              className="text-2xl font-bold text-gray-900 dark:text-white"
            >
              Help & Support
            </h2>
            <button
              ref={firstFocusableRef}
              onClick={onClose}
              className="text-gray-400 hover:text-gray-600 dark:hover:text-gray-300 text-3xl font-bold p-2 rounded-lg hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors"
              aria-label="Close help modal"
            >
              √ó
            </button>
          </div>

          {/* Two-column layout */}
          <div className="flex h-[calc(90vh-120px)]">
            {/* Left sidebar - Navigation */}
            <div className="w-64 border-r border-gray-200 dark:border-gray-700 bg-gray-50 dark:bg-gray-900 overflow-y-auto">
              <nav className="p-4 space-y-2">
                {sections.map((section) => (
                  <button
                    key={section.id}
                    onClick={() => setActiveSection(section.id)}
                    className={`w-full text-left px-3 py-2 rounded-lg text-sm font-medium transition-colors ${
                      activeSection === section.id
                        ? "bg-blue-100 dark:bg-blue-900 text-blue-900 dark:text-blue-100"
                        : "text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-800"
                    }`}
                  >
                    <span className="mr-2">{section.icon}</span>
                    {section.title}
                  </button>
                ))}
              </nav>
            </div>

            {/* Right content area */}
            <div className="flex-1 overflow-y-auto">
              <div className="p-6">
                <div className="mb-6">
                  <h3 className="text-xl font-semibold text-gray-900 dark:text-white mb-2 flex items-center">
                    <span className="text-2xl mr-3">
                      {sections.find((s) => s.id === activeSection)?.icon}
                    </span>
                    {sections.find((s) => s.id === activeSection)?.title}
                  </h3>
                </div>
                <div id="help-modal-description">{renderContent()}</div>
              </div>
            </div>
          </div>

          {/* Footer */}
          <div className="flex items-center justify-between p-6 border-t border-gray-200 dark:border-gray-700 bg-gray-50 dark:bg-gray-900">
            <div className="text-sm text-gray-500 dark:text-gray-400">
              Flicklet v2 ‚Ä¢ Last updated: {new Date().toLocaleDateString()}
            </div>
            <button
              onClick={onClose}
              className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors"
            >
              Got it!
            </button>
          </div>
        </div>
      </div>
    </>
  );
};

```

## apps/web/src/styles/cards-mobile.css
### Summary
Mobile-specific card styling for discovery rails and rating displays.
### Content
```css
/**
 * Process: Mobile Cards Styles
 * Purpose: Mobile-specific card styling with overlay swipe and text clamping
 * Data Source: Design tokens and mobile layout requirements
 * Update Path: Update CSS variables and styles here for mobile card appearance
 * Dependencies: CardBaseMobile, SwipeRowOverlay components
 */

@media (max-width: 768px) {
  .card-mobile {
    position: relative;
    background: var(--surface-0,#fff);
    border-radius: 12px;
    /* 8 left + (36 rail + 12 buffer + safe-area) right */
    padding: 8px calc(36px + 12px + env(safe-area-inset-right, 0px)) 8px 8px;
    margin: 0 0 12px 0;
    box-shadow: none;
    overflow: hidden; /* keep swipe bg tidy */
  }

  /* SWIPE BACKGROUND ‚Äî sits UNDER content, hidden until dragging */
  .card-mobile .swipe-bg {
    position: absolute; 
    inset: 0; 
    z-index: var(--z-base); 
    pointer-events: none;
  }
  .card-mobile .swipe-bg .reveal {
    position: absolute; top: 0; bottom: 0; width: 40%;
    opacity: 0; transition: opacity 120ms ease-out;
  }
  .card-mobile .swipe-bg .left  { left: 0;  background: #22c55e; }   /* example: move to "Watching" */
  .card-mobile .swipe-bg .right { right: 0; background: #0ea5e9; }   /* example: move to "Wishlist" */
  .card-mobile.dragging .swipe-bg .reveal { opacity: .14; }

  /* Swipe hints */
  .card-mobile .swipe-bg .hint {
    position: absolute; top: 50%; transform: translateY(-50%);
    padding: 6px 10px; border-radius: 9999px; font-weight: 600;
    background: color-mix(in srgb, #000 8%, #fff);
    color: #111; opacity: 0; transition: opacity 120ms;
    pointer-events: none; white-space: nowrap;
  }
  .card-mobile .swipe-bg .hint.left  { left: 12px; }
  .card-mobile .swipe-bg .hint.right { right: 12px; }

  /* Hint visibility */
  .card-mobile .hint { 
    opacity: 0; 
    transition: opacity 120ms; 
  }
  
  /* Only show active hint for direction */
  .card-mobile.drag-left  .swipe-bg .hint.left,
  .card-mobile.drag-right .swipe-bg .hint.right {
    opacity: .95;
  }

  /* SWIPE TARGET ‚Äî the thing we translate AND the grid container */
  .card-mobile .swipe-target {
    position: relative;
    z-index: calc(var(--z-base) + 1);
    will-change: transform;
    display: grid;
    grid-template-columns: 112px 1fr;
    gap: 8px;
    align-items: start;
    transition: transform 160ms ease-out;
  }
  
  .card-mobile.dragging .swipe-target {
    transition: none;
  }
  
  .card-mobile.swipe-open .swipe-target {
    transform: translate3d(-120px,0,0);
  }

  .card-mobile .poster {
    grid-column: 1;
    width: 112px; height: auto;
    border-radius: 8px; object-fit: cover;
  }

  .card-mobile .content {
    grid-column: 2;
    display: grid;
    grid-template-rows: auto auto auto auto auto auto; /* topline, subline, chips, rating, summary, actions */
    row-gap: 6px;
    overflow: hidden;
  }

  .card-mobile .topline {
    display: grid;
    grid-template-columns: 1fr auto; align-items: center; column-gap: 8px;
  }
  .card-mobile .title { font-weight: 700; line-height: 1.2; }
  .card-mobile .btn-overflow { 
    inline-size: 32px; block-size: 32px; 
    border-radius: 9999px; 
    background: transparent;
    border: 1px solid color-mix(in srgb, #000 12%, transparent);
    color: var(--text-muted, #666);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 18px;
    line-height: 1;
    margin-right: 4px; /* avoid clip on focus ring */
  }

  .card-mobile .subline { font-size: 12px; opacity: .8; }

  .card-mobile .chips { display: flex; flex-wrap: wrap; gap: 4px; }

  /* Rating row */
  .card-mobile .rating-row { 
    display: flex; 
    align-items: center; 
    gap: 8px; 
    min-height: 36px; 
  }
  .card-mobile .rating-label { 
    font-size: 12px; 
    opacity: .85; 
    font-weight: 500;
  }
  .card-mobile .stars { 
    display: inline-flex; 
    gap: 4px; 
    /* Allow vertical scrolling to win when starting on the stars */
    touch-action: pan-y; 
  }
  .card-mobile .star { 
    inline-size: 32px; 
    block-size: 32px; 
    border-radius: 6px; 
    background: transparent; 
    border: 1px solid color-mix(in srgb, #000 12%, transparent);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 16px;
    color: #d1d5db;
    transition: all 120ms ease-out;
  }
  .card-mobile .star::before { 
    content: '‚òÜ'; 
    font-size: 22px; 
    line-height: 32px; 
    display: block; 
    text-align: center; 
    color: #aaa; 
  }
  .card-mobile .star.filled { 
    border-color: #f59e0b; 
  }
  .card-mobile .star.filled::before { 
    content: '‚òÖ'; 
    color: #f59e0b; 
  }
  .card-mobile .star:hover {
    border-color: #f59e0b;
    background: color-mix(in srgb, #f59e0b 20%, transparent);
  }
  .card-mobile .avg { 
    font-size: 11px; 
    opacity: .7; 
    margin-left: 4px; 
  }

  .card-mobile .summary { 
    display: -webkit-box; 
    -webkit-line-clamp: 3; 
    -webkit-box-orient: vertical; 
    overflow: hidden; 
    font-size: 13px;
    line-height: 1.4;
    color: var(--text-muted, #666);
  }

  .card-mobile .actions { 
    display: grid; 
    grid-template-columns: 1fr auto; 
    align-items: center; 
    column-gap: 8px; 
  }

  .card-mobile .providers {
    display: flex;
    flex-wrap: wrap;
    gap: 4px;
  }

  .card-mobile .provider-chip { 
    display: inline-flex; 
    align-items: center; 
    padding: 2px 8px; 
    border-radius: 9999px; 
    font-size: 12px; 
    background: color-mix(in srgb, #000 6%, transparent);
    color: var(--text-muted, #666);
    text-decoration: none;
    border: 1px solid color-mix(in srgb, #000 8%, transparent);
    transition: all 120ms ease-out;
  }
  .card-mobile .provider-chip:hover {
    background: color-mix(in srgb, #000 12%, transparent);
    border-color: color-mix(in srgb, #000 16%, transparent);
  }

  .card-mobile .btn-delete {
    justify-self: end;
    padding: 6px 12px;
    border-radius: 9999px;
    background: #ef4444;
    color: #fff;
    font-weight: 700;
    line-height: 1;
    border: none;
    cursor: pointer;
    font-size: 12px;
    transition: all 120ms ease-out;
  }
  .card-mobile .btn-delete:hover {
    background: #dc2626;
  }

  /* Side drag rail */
  .card-mobile .drag-rail {
    position: absolute; 
    top: 0; 
    right: 0; 
    bottom: 0;
    width: 36px;
    display: grid; 
    place-items: center;
    background: transparent;
    color: var(--text-muted, #666);
    cursor: grab; 
    z-index: calc(var(--z-base) + 3);
    border-left: 1px solid color-mix(in srgb, #000 8%, transparent);
    /* Allow vertical scroll; we detect horizontal intent in JS */
    touch-action: pan-y;
    border: none;
    font-size: 18px;
    line-height: 1;
    opacity: .7;
    transition: all 120ms ease-out;
  }
  .card-mobile .drag-rail:hover {
    opacity: 1;
    background: color-mix(in srgb, #000 4%, transparent);
  }
  .card-mobile .drag-rail:active { 
    cursor: grabbing; 
  }
  .card-mobile .drag-rail::after { 
    content: '‚ãÆ‚ãÆ'; 
    font-size: 18px; 
    line-height: 1; 
    opacity: .7; 
  }

  /* Swipe visuals */
  .card-mobile .swipe-row { 
    position: absolute; 
    inset: 0; 
    pointer-events: none; 
    z-index: calc(var(--z-base) + 2); 
  }
  .card-mobile .swipe-row > .gesture-plane { 
    position: absolute; 
    inset: 0; 
    pointer-events: auto; 
    touch-action: pan-y; 
    cursor: grab; 
  }

  /* Safety: neutralize any library "reveal" elements */
  .card-mobile .content .reveal, .card-mobile .chips .reveal { display: none !important; }
}

/* NEW: Unified Mobile Card Layout */
.card-mobile {
  display: flex;
  gap: var(--space-3);
  padding: var(--space-3);
  border-radius: var(--radius-lg, 12px);
  background: var(--card, #171a21);
  border: 1px solid var(--line, #242a33);
  /* Ensure vertical scrolling is prioritized on mobile */
  touch-action: pan-y;
}

.card-mobile .poster-col {
  flex-shrink: 0;
}

.card-mobile .poster-col img {
  width: 112px;
  height: 168px;
  object-fit: cover;
  border-radius: var(--radius-md, 8px);
}

.card-mobile .info-col {
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: var(--space-2);
  position: relative;
}

.card-mobile .info-col header h3 {
  font-size: var(--text-lg, 16px);
  font-weight: 600;
  color: var(--text);
  margin: 0 0 var(--space-1, 4px) 0;
  line-height: 1.3;
}

.card-mobile .info-col header .meta {
  font-size: var(--font-sm, 12px);
  color: var(--muted);
  margin-bottom: var(--space-1);
}

.card-mobile .synopsis {
  font-size: var(--font-sm, 12px);
  line-height: 1.4;
  color: var(--muted);
  display: -webkit-box;
  -webkit-line-clamp: 2;
  -webkit-box-orient: vertical;
  overflow: hidden;
  margin-bottom: var(--space-2);
}

.mobile-actions-row {
  display: flex;
  align-items: center;
  gap: var(--space-2);
  margin-top: var(--space-2);
}

.mobile-overflow-position {
  position: absolute;
  bottom: 0;
  right: 0;
}

.primary-action {
  flex: 1;
  padding: var(--space-2) var(--space-3);
  border-radius: var(--radius, 12px);
  font-weight: 600;
  font-size: var(--font-sm, 13px);
  background: var(--accent, #4da3ff);
  color: white;
  border: none;
  cursor: pointer;
  transition: all 0.2s ease;
}

.primary-action:hover {
  background: var(--accent-hover, #3b82f6);
}

.primary-action:active {
  transform: scale(0.98);
}
```

## apps/web/src/components/Rail.tsx
### Summary
Horizontal rail wrapper used by discovery/home to surface `CardV2` entries.
### Content
```tsx
import CardV2 from './cards/CardV2';
import type { MediaItem } from './cards/card.types';
import { Library } from '@/lib/storage';
import { useRailImagePreload } from '../hooks/useImagePreload';

type Item = { id: string; kind?: 'movie'|'tv'; title?: string; poster?: string; year?: number };

type Props = {
  id: string;
  title: string;
  enabled?: boolean;
  skeletonCount?: number;
  items?: Item[];
};

export default function Rail({ id, title, enabled = true, skeletonCount = 0, items }: Props) {
  if (!enabled) return null;
  const list = items && items.length ? items : Array.from({ length: skeletonCount }).map(() => ({} as Item));
  
  // Map rail ID to CardV2 context
  const getContext = (railId: string): 'home' | 'tab-watching' | 'tab-foryou' => {
    if (railId === 'currently-watching') return 'tab-watching';
    if (railId.startsWith('for-you-') || railId === 'in-theaters') return 'tab-foryou';
    return 'home';
  };

  const context = getContext(id);

  // Preload images for better performance
  useRailImagePreload(list.map(item => ({ posterUrl: item.poster })));

  // Action handlers using new Library system
  const actions = {
    onWant: (item: MediaItem) => {
      console.log('üé¨ For You Want button clicked:', item);
      if (item.id && item.mediaType) {
        Library.upsert({ 
          id: item.id, 
          mediaType: item.mediaType, 
          title: item.title,
          posterUrl: item.posterUrl,
          year: item.year,
          voteAverage: item.voteAverage
        }, 'wishlist');
        console.log('‚úÖ Item added to wishlist:', item.title);
      }
    },
    onWatched: (item: MediaItem) => {
      console.log('üé¨ For You Watched button clicked:', item);
      if (item.id && item.mediaType) {
        Library.upsert({ 
          id: item.id, 
          mediaType: item.mediaType, 
          title: item.title,
          posterUrl: item.posterUrl,
          year: item.year,
          voteAverage: item.voteAverage
        }, 'watched');
        console.log('‚úÖ Item added to watched:', item.title);
      }
    },
    onNotInterested: (item: MediaItem) => {
      console.log('üé¨ For You Not Interested button clicked:', item);
      if (item.id && item.mediaType) {
        Library.upsert({ 
          id: item.id, 
          mediaType: item.mediaType, 
          title: item.title,
          posterUrl: item.posterUrl,
          year: item.year,
          voteAverage: item.voteAverage
        }, 'not');
        console.log('‚úÖ Item added to not interested:', item.title);
      }
    },
    onDelete: (item: MediaItem) => {
      console.log('üé¨ For You Delete button clicked:', item);
      if (item.id && item.mediaType) {
        Library.remove(item.id, item.mediaType);
        console.log('‚úÖ Item deleted:', item.title);
      }
    },
  };

  function onKeyDown(e: React.KeyboardEvent<HTMLDivElement>) {
    const scroller = e.currentTarget;
    const card = scroller.querySelector<HTMLElement>('[data-testid="cardv2"]');
    const gap = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--space-3').replace('px', '')) || 12; // matches Tailwind gap-3 ‚âà 12px
    const cardWidth = card ? card.getBoundingClientRect().width : 166; // 154 + padding
    const delta = cardWidth + gap;

    switch (e.key) {
      case 'ArrowRight': e.preventDefault(); scroller.scrollBy({ left: +delta, behavior: 'smooth' }); break;
      case 'ArrowLeft':  e.preventDefault(); scroller.scrollBy({ left: -delta, behavior: 'smooth' }); break;
      case 'Home':       e.preventDefault(); scroller.scrollTo({ left: 0, behavior: 'smooth' }); break;
      case 'End':        e.preventDefault(); scroller.scrollTo({ left: scroller.scrollWidth, behavior: 'smooth' }); break;
      case 'Enter': {
        const first = scroller.querySelector<HTMLElement>('[data-testid="cardv2"]');
        if (first) first.focus();
        break;
      }
    }
  }

  return (
    <section data-rail={id} aria-label={title} className="px-4 py-3">
      <h2 className="mb-2 text-base font-semibold" style={{ color: 'var(--text)' }}>{title}</h2>
      <div
        data-cards
        role="list"
        tabIndex={0}
        onKeyDown={onKeyDown}
        className="flex gap-3 overflow-x-auto snap-x snap-mandatory pb-2"
      >
        {list.map((it, i) => {
          // Convert Item to MediaItem format with proper title validation
          const safeTitle = (() => {
            // Ensure title is a string and not the same as id
            if (typeof it.title === 'string' && it.title.trim() && it.title !== String(it.id)) {
              return it.title.trim();
            }
            // If title is missing, undefined, or same as id, use fallback
            return 'Untitled';
          })();
          
          const mediaItem: MediaItem = {
            id: it.id || i,
            mediaType: (it.kind as 'movie'|'tv') || 'movie',
            title: safeTitle,
            posterUrl: it.poster,
            year: it.year ? String(it.year) : undefined, // Convert number to string for MediaItem
            voteAverage: undefined, // TODO: Add rating from data source
          };

          return (
            <div key={it.id ?? i} role="listitem" className="snap-start">
              <CardV2
                item={mediaItem}
                context={context}
                actions={actions}
                disableSwipe={true}
              />
            </div>
          );
        })}
      </div>
    </section>
  );
}

```

## apps/web/src/components/Header.tsx
### Summary
Header with search input, discovery tab, and quick actions tied to ratings/discovery state.
### Content
```tsx
import { useTranslations } from '../lib/language';

export default function Header({ user, onLoginToggle }: { user: { name: string; loggedIn: boolean }, onLoginToggle: () => void }) {
  const translations = useTranslations();
  
  const snark = [
    translations.procrastinatingProductively,
    translations.curatingYourIndecision,
    translations.becauseTimeIsAnIllusion,
    translations.cinemaNowWithCommitmentIssues,
    translations.yourBacklogCalledItsGrowing
  ];
  const quip = snark[(Date.now() / (1000 * 15) | 0) % snark.length]; // rotates every ~15s

  return (
    <header className="w-full bg-black/90 backdrop-blur border-b border-white/5">
      <div className="max-w-screen-2xl mx-auto px-4 py-3 grid grid-cols-3 items-center">
        {/* Left: user + snark */}
        <div className="flex items-center gap-2 text-xs text-neutral-400">
          <span className="font-medium text-neutral-200">{user.name || translations.guest}</span>
          <span aria-hidden>‚Ä¢</span>
          <span className="hidden sm:inline">{quip}</span>
        </div>

        {/* Middle: app name */}
        <div className="text-center">
          <div className="text-base font-semibold tracking-wide text-neutral-100">Flicklet</div>
        </div>

        {/* Right: auth */}
        <div className="flex justify-end">
          <button className="btn" onClick={onLoginToggle}>{user.loggedIn ? translations.logOut : translations.logIn}</button>
        </div>
      </div>
    </header>
  );
}

```

## apps/web/src/components/__tests__/SearchSuggestions.click.test.tsx
### Summary
Regression test ensuring search suggestions respect ranking signals (voteAverage influence).
### Content
```tsx
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { render, screen, within } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import SearchSuggestions from '../SearchSuggestions';
import { fetchEnhancedAutocomplete } from '../../search/enhancedAutocomplete';

function getDefaultSuggestions() {
  return [
    {
      id: '12345',
      title: 'Slow Horses',
      mediaType: 'tv',
      year: '2022',
      posterUrl: 'https://example.com/poster.jpg',
      synopsis: 'A spy thriller',
      voteAverage: 8.0,
    },
  ];
}

// Mock the enhanced autocomplete
vi.mock('../../search/enhancedAutocomplete', () => ({
  fetchEnhancedAutocomplete: vi.fn().mockResolvedValue(getDefaultSuggestions()),
}));

const mockedFetchEnhancedAutocomplete = vi.mocked(fetchEnhancedAutocomplete);

describe('SearchSuggestions - Click Behavior', () => {
  const mockOnSuggestionClick = vi.fn();
  const mockOnClose = vi.fn();

  beforeEach(() => {
    vi.clearAllMocks();
    mockedFetchEnhancedAutocomplete.mockReset();
    mockedFetchEnhancedAutocomplete.mockResolvedValue(getDefaultSuggestions());
    localStorage.clear();
  });

  it('should include year in search query when clicking TMDB suggestion with year', async () => {
    const user = userEvent.setup();
    
    render(
      <SearchSuggestions
        query="slow"
        onSuggestionClick={mockOnSuggestionClick}
        onClose={mockOnClose}
        isVisible={true}
      />
    );

    // Wait for suggestions to load
    await new Promise(resolve => setTimeout(resolve, 400));

    // Find the TMDB suggestion
    const suggestionButton = screen.getByRole('button', {
      name: /Slow Horses/i,
    });
    expect(suggestionButton).toBeInTheDocument();

    // Click the suggestion
    await user.click(suggestionButton);

    expect(mockOnSuggestionClick).toHaveBeenCalledWith('Slow Horses', '12345', 'tv');
  });

  it('should use title only when TMDB suggestion has no year', async () => {
    const user = userEvent.setup();
    
    mockedFetchEnhancedAutocomplete.mockResolvedValueOnce([
      {
        id: '67890',
        title: 'Test Show',
        mediaType: 'tv',
        year: undefined,
        posterUrl: 'https://example.com/poster.jpg',
        synopsis: 'A test show',
        voteAverage: 7.5,
      },
    ]);

    render(
      <SearchSuggestions
        query="test"
        onSuggestionClick={mockOnSuggestionClick}
        onClose={mockOnClose}
        isVisible={true}
      />
    );

    await new Promise(resolve => setTimeout(resolve, 400));

    const suggestionButton = screen.getByRole('button', { name: /Test Show/i });
    await user.click(suggestionButton);

    // Should use title only when no year
    expect(mockOnSuggestionClick).toHaveBeenCalledWith('Test Show', '67890', 'tv');
  });

  it('should handle search history clicks normally (no year)', async () => {
    const user = userEvent.setup();
    
    // Add to search history
    const history = [{ q: 'batman', ts: Date.now() }];
    localStorage.setItem('flicklet.search-history', JSON.stringify(history));

    render(
      <SearchSuggestions
        query="bat"
        onSuggestionClick={mockOnSuggestionClick}
        onClose={mockOnClose}
        isVisible={true}
      />
    );

    await new Promise(resolve => setTimeout(resolve, 100));

    const historySection = screen.getByText('Recent Searches').closest('.mb-3');
    expect(historySection).not.toBeNull();
    const historyButton = within(historySection!).getByRole('button', {
      name: /batman/i,
    });
    await user.click(historyButton);

    // History items should be passed as-is
    expect(mockOnSuggestionClick).toHaveBeenCalledWith('batman', undefined, undefined);
  });
});


```

## apps/web/src/search/smartSearch.ts
### Summary
Search orchestrator that fetches TMDB endpoints, caches results, and applies `computeSearchScore` for discovery.
### Content
```ts
/**
 * Smart search orchestrator
 * Purpose: Searches TMDB and ranks results using BM25-like scoring
 * Data Source: TMDB API responses
 * Update Path: Adjust anchors in smartSearch function
 * Dependencies: Uses computeSearchScore from rank.ts, mapTMDBToMediaItem from api.ts
 */

import type { MediaItem } from '../components/cards/card.types';
import type { SearchResult, SearchResultWithPagination } from './api';
import { mapTMDBToMediaItem } from './api';
import { computeSearchScore, tieBreak, tokensLower } from './rank';
import { normalizeQuery } from '../lib/string';

type SearchType = 'all' | 'movies-tv' | 'people';

// LRU cache for TMDB search/tv and search/movie calls (5 min TTL)
class LRUCache<K, V> {
  private cache = new Map<K, { value: V; expires: number }>();
  private maxSize: number;
  private ttl: number; // TTL in milliseconds

  constructor(maxSize: number, ttlMs: number) {
    this.maxSize = maxSize;
    this.ttl = ttlMs;
  }

  get(key: K): V | undefined {
    const entry = this.cache.get(key);
    if (!entry) return undefined;
    
    if (Date.now() > entry.expires) {
      this.cache.delete(key);
      return undefined;
    }
    
    // Move to end (most recently used)
    this.cache.delete(key);
    this.cache.set(key, entry);
    return entry.value;
  }

  set(key: K, value: V): void {
    if (this.cache.has(key)) {
      this.cache.delete(key);
    } else if (this.cache.size >= this.maxSize) {
      // Remove least recently used (first item)
      const firstKey = this.cache.keys().next().value;
      if (firstKey !== undefined) {
        this.cache.delete(firstKey);
      }
    }
    this.cache.set(key, { value, expires: Date.now() + this.ttl });
  }

  getStats() {
    return {
      size: this.cache.size,
      maxSize: this.maxSize
    };
  }
}

const tmdbCache = new LRUCache<string, any>(100, 5 * 60 * 1000); // 5 min TTL
let cacheHits = 0;
let cacheMisses = 0;

export function getCacheStats() {
  return {
    hits: cacheHits,
    misses: cacheMisses,
    hitRate: cacheHits + cacheMisses > 0 ? cacheHits / (cacheHits + cacheMisses) : 0,
    ...tmdbCache.getStats()
  };
}

function qs(params: Record<string, any>) {
  const p = new URLSearchParams();
  for (const [k, v] of Object.entries(params)) {
    if (v !== undefined && v !== null && v !== '') p.set(k, String(v));
  }
  return p.toString();
}

// Circuit breaker for TMDB with timeout and retry
async function fetchTMDBWithCircuitBreaker(
  path: string, 
  params: Record<string, any>, 
  signal?: AbortSignal,
  maxRetries = 2
): Promise<any> {
  const url = `/api/tmdb-proxy?${qs({ path, ...params })}`;
  const timeoutMs = 4000; // 4 second timeout
  
  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    try {
      // Create timeout promise
      const timeoutPromise = new Promise<never>((_, reject) => {
        setTimeout(() => reject(new Error('Timeout')), timeoutMs);
      });
      
      // Race fetch against timeout
      const fetchPromise = fetch(url, { signal });
      const res = await Promise.race([fetchPromise, timeoutPromise]);
      
      if (!res.ok) {
        const errorText = await res.text().catch(() => '');
        throw new Error(`${path} failed: ${res.status} ${errorText || res.statusText}`);
      }
      
      const json = await res.json();
      // Check if TMDB returned an error in the response
      if (json.status_code && json.status_message) {
        throw new Error(`TMDB API error: ${json.status_message}`);
      }
      
      return json;
    } catch (error) {
      const isLastAttempt = attempt === maxRetries;
      const isAbortError = error instanceof Error && error.name === 'AbortError';
      
      if (isAbortError || isLastAttempt) {
        // On final failure, log and return empty results gracefully
        console.warn('[TMDB] breaker open', { query: params.query, path, err: error });
        if (isLastAttempt) {
          // Return empty results instead of throwing
          return { results: [], total_pages: 1 };
        }
        throw error;
      }
      
      // Exponential backoff: 500ms ‚Üí 1s
      const backoffMs = 500 * Math.pow(2, attempt);
      await new Promise(resolve => setTimeout(resolve, backoffMs));
    }
  }
  
  return { results: [], total_pages: 1 };
}

async function fetchTMDB(path: string, params: Record<string, any>, signal?: AbortSignal): Promise<any> {
  // Only cache search/tv and search/movie for page 1
  const shouldCache = (path === 'search/tv' || path === 'search/movie') && params.page === 1;
  
  if (shouldCache) {
    const cacheKey = `${path}:${normalizeQuery(params.query)}:${params.language}:${params.region}`;
    const cached = tmdbCache.get(cacheKey);
    
    if (cached) {
      cacheHits++;
      return cached;
    }
    
    cacheMisses++;
    const result = await fetchTMDBWithCircuitBreaker(path, params, signal);
    tmdbCache.set(cacheKey, result);
    return result;
  }
  
  // Don't cache search/multi (fresh pagination) or other endpoints
  return fetchTMDBWithCircuitBreaker(path, params, signal);
}

function dedupeWithAllMeta<T extends { item: MediaItem; score: number }>(items: T[]): T[] {
  const seen = new Map<string, T>();
  for (const entry of items) {
    const key = `${entry.item.mediaType}:${entry.item.id}`;
    const existing = seen.get(key);
    if (!existing || entry.score > existing.score) {
      seen.set(key, entry);
    }
  }
  return Array.from(seen.values());
}

// Calculate Herfindahl diversity index (0 = no diversity, 1 = perfect diversity)
function calculateDiversity(items: MediaItem[]): number {
  if (items.length === 0) return 0;
  
  const typeCounts = new Map<string, number>();
  for (const item of items) {
    const type = item.mediaType;
    typeCounts.set(type, (typeCounts.get(type) || 0) + 1);
  }
  
  let sumSquares = 0;
  for (const count of typeCounts.values()) {
    const proportion = count / items.length;
    sumSquares += proportion * proportion;
  }
  
  // Herfindahl index: 1 - sum(proportions^2)
  // Higher = more diverse
  return 1 - sumSquares;
}

export async function smartSearch(
  queryRaw: string,
  page = 1,
  searchType: SearchType = 'all',
  opts?: { signal?: AbortSignal; language?: string; region?: string; debugSearch?: boolean }
): Promise<SearchResultWithPagination> {
  const language = opts?.language ?? 'en-US';
  const region   = opts?.region ?? 'US';
  const query    = normalizeQuery(queryRaw);
  
  // Check for debug flag in URL
  const urlParams = new URLSearchParams(window.location.search);
  const debugMode = opts?.debugSearch || urlParams.get('debugSearch') === '1';

  // People-only: simple flow
  if (searchType === 'people') {
    const json = await fetchTMDB('search/person', { query, page, include_adult: false, language, region }, opts?.signal);
    const items = (json.results ?? []).map(mapTMDBToMediaItem).filter(Boolean) as SearchResult[];
    return {
      items,
      page,
      totalPages: json.total_pages ?? 1
    };
  }

  // Get multi search results for the requested page (uncached for fresh pagination)
  const multiJson = await fetchTMDB('search/multi', {
    query, page, include_adult: false, language, region
  }, opts?.signal);
  
  let allItems = (multiJson.results ?? [])
    .map(mapTMDBToMediaItem)
    .filter(Boolean) as MediaItem[];

  // Drop person results from the candidate set (people search already returned above)
  allItems = allItems.filter(item => item.mediaType !== 'person');

  // Also search TV and Movie endpoints for better coverage (cached for page 1)
  if (page === 1) {
    try {
      const [tvJson, movieJson] = await Promise.all([
        fetchTMDB('search/tv', { query, page: 1, include_adult: false, language, region }, opts?.signal).catch(() => ({ results: [] })),
        fetchTMDB('search/movie', { query, page: 1, include_adult: false, language, region }, opts?.signal).catch(() => ({ results: [] }))
      ]);
      
      const tvItems = ((tvJson.results ?? []) as any[]).map(mapTMDBToMediaItem).filter(Boolean) as MediaItem[];
      const movieItems = ((movieJson.results ?? []) as any[]).map(mapTMDBToMediaItem).filter(Boolean) as MediaItem[];
      
      allItems = [...allItems, ...tvItems, ...movieItems];
    } catch (err) {
      // Fallback to multi-only if TV/Movie endpoints fail
      console.warn('TV/Movie search endpoints failed, using multi-only:', err);
    }
  }

  // Score items
  const allWithMeta = allItems.map(item => {
    const scored = computeSearchScore(query, {
      title: item.title || '',
      originalTitle: undefined,
      aliases: [],
      overview: item.synopsis,
      popularity: item.voteAverage ? item.voteAverage * 10 : undefined, // rough estimate
      voteAverage: item.voteAverage,
      voteCount: item.voteCount, // Now properly typed
      releaseYear: item.year ? parseInt(item.year) : undefined,
      releaseDate: item.releaseDate || undefined, // Use releaseDate for precise recency calculation
      mediaType: item.mediaType,
      originalLanguage: undefined,
      collectionName: undefined // Will be populated later if available
    }, { 
      preferType: searchType === 'movies-tv' ? 'all' : searchType,
      debugSearch: debugMode 
    });
    
    const meta = {
      tier: scored.titleSig.tier,
      voteCount: item.voteCount,
      voteAverage: item.voteAverage,
      releaseYear: item.year ? parseInt(item.year) : undefined,
      popularity: item.voteAverage ? item.voteAverage * 10 : undefined,
      title: item.title
    };
    
    return { 
      item, 
      score: scored.score, 
      titleSig: scored.titleSig,
      meta,
      debug: scored.debug
    };
  });

  // Debug logging
  if (debugMode) {
    console.log('üîç Debug: Searching for anchor...');
    console.log('Query:', query);
    console.log('Total items found:', allWithMeta.length);
    
    console.log('All candidates with scores:');
    allWithMeta.forEach((x, i) => {
      if (x.titleSig.score >= 0.80 || x.titleSig.tier !== 'overlap') {
        console.log(`  ${i}. "${x.item.title}" (${x.item.year || '?'}) - tier: ${x.titleSig.tier}, titleSig: ${x.titleSig.score.toFixed(3)}, total: ${x.score.toFixed(3)}`);
      }
    });
  }

  // Demotion step: reduce score for duplicate single-word exact matches
  // Check if query is single-word (reused later for sorting logic)
  const isSingleWord = tokensLower(query).length === 1;
  if (isSingleWord) {
    const qNorm = tokensLower(query).join(' ');
    
    const exactSameTitle = allWithMeta.filter(entry => {
      const title = entry.item.title || '';
      const titleNorm = tokensLower(title).join(' ');
      return entry.titleSig.tier === 'exact' && titleNorm === qNorm;
    });
    
    if (exactSameTitle.length > 1) {
      // Pick the canonical exact as the one with highest score
      const canonical = exactSameTitle.reduce((best, entry) =>
        entry.score > best.score ? entry : best,
        exactSameTitle[0]
      );
      
      for (const entry of exactSameTitle) {
        if (entry === canonical) continue;
        // Apply a strong penalty so these drop below top leading matches
        entry.score -= 40;
        // Mark them as demoted for debugging
        (entry.meta as any).demotedDuplicateExact = true;
      }
      
      if (debugMode) {
        console.log(`üìâ Demoted ${exactSameTitle.length - 1} duplicate exact matches for "${query}" (kept canonical: "${canonical.item.title}")`);
      }
    }
  }

  // Dedupe keeping highest-scored duplicate - preserve all metadata
  const deduped = dedupeWithAllMeta(allWithMeta);
  
  // Calculate diversity of top 10 results
  const top10Items = deduped.slice(0, 10).map(x => x.item);
  const diversity = calculateDiversity(top10Items);
  
  // Fetch similar/recommendations only if diversity is low (< 0.7)
  let extras: MediaItem[] = [];
  if (diversity < 0.7 && deduped.length > 0) {
    const exactCandidates = deduped.filter(x => x.titleSig.tier === 'exact' && x.score > 0);
    if (exactCandidates.length > 0) {
      const bestMatch = exactCandidates.sort((a, b) => b.score - a.score)[0];
      if (bestMatch.item.mediaType !== 'person') {
        try {
          const [simJson, recJson] = await Promise.all([
            fetchTMDB(`${bestMatch.item.mediaType}/${bestMatch.item.id}/similar`, { page: 1, language }, opts?.signal).catch(() => ({ results: [] })),
            fetchTMDB(`${bestMatch.item.mediaType}/${bestMatch.item.id}/recommendations`, { page: 1, language }, opts?.signal).catch(() => ({ results: [] }))
          ]);
          
          const sim = ((simJson.results ?? []) as any[]).map(mapTMDBToMediaItem).filter(Boolean) as MediaItem[];
          const rec = ((recJson.results ?? []) as any[]).map(mapTMDBToMediaItem).filter(Boolean) as MediaItem[];
          extras = [...sim, ...rec];
          
          // Score extras but don't merge into main list - they'll be appended as "More like this" shelf
          // (For now, we'll still add them but could be separated in UI layer)
          const extrasWithMeta = extras.map(item => {
          const scored = computeSearchScore(query, {
            title: item.title || '',
            originalTitle: undefined,
            aliases: [],
            overview: item.synopsis,
            popularity: item.voteAverage ? item.voteAverage * 10 : undefined,
            voteAverage: item.voteAverage,
            voteCount: item.voteCount,
            releaseYear: item.year ? parseInt(item.year) : undefined,
            releaseDate: item.releaseDate || undefined, // Use releaseDate for precise recency calculation
            mediaType: item.mediaType,
            originalLanguage: undefined,
            collectionName: undefined
          }, {
              preferType: searchType === 'movies-tv' ? 'all' : searchType,
              debugSearch: debugMode
            });
            
            const meta = {
              tier: scored.titleSig.tier,
              voteCount: item.voteCount,
              voteAverage: item.voteAverage,
              releaseYear: item.year ? parseInt(item.year) : undefined,
              popularity: item.voteAverage ? item.voteAverage * 10 : undefined,
              title: item.title
            };
            
            return { 
              item, 
              score: scored.score, 
              titleSig: scored.titleSig,
              meta,
              debug: scored.debug
            };
          });
          
          deduped.push(...extrasWithMeta);
          // Re-dedupe after adding extras to avoid duplicate titles
          const dedupedWithExtras = dedupeWithAllMeta(deduped);
          // Replace deduped with the re-deduped version for the rest of the function
          deduped.length = 0;
          deduped.push(...dedupedWithExtras);
        } catch {
          // Extras are optional
        }
      }
    }
  }
  
  // Sort by score with tie-breaking - canonical pinning built into comparator
  // isSingleWord already declared above for demotion step
  
  // Find highest-scoring exact match for pinning
  const exactCandidates = deduped.filter(x => x.titleSig.tier === 'exact' && x.score > 0);
  const highestExactScore = exactCandidates.length > 0 
    ? Math.max(...exactCandidates.map(x => x.score))
    : -Infinity;
  
  const ranked = deduped.sort((a, b) => {
    // Canonical pinning: boost exact-tier items to rank 1
    const aIsExact = a.titleSig.tier === 'exact' && a.score === highestExactScore;
    const bIsExact = b.titleSig.tier === 'exact' && b.score === highestExactScore;
    
    if (aIsExact && !bIsExact) return -1; // a ranks higher
    if (!aIsExact && bIsExact) return 1;  // b ranks higher
    
    const scoreDiff = b.score - a.score;
    
    // Special handling for single-word queries: promote very popular leading matches
    if (isSingleWord) {
      const aIsLeading = a.titleSig.tier === 'leading';
      const bIsExact = b.titleSig.tier === 'exact';
      const aIsExact = a.titleSig.tier === 'exact';
      const bIsLeading = b.titleSig.tier === 'leading';
      
      // If one is leading and very popular, and the other is exact but less popular
      if (aIsLeading && bIsExact) {
        const aVoteCount = a.meta.voteCount ?? 0;
        const bVoteCount = b.meta.voteCount ?? 0;
        // If leading match has significantly more votes (10x+), promote it above exact match
        if (aVoteCount > bVoteCount * 10 && aVoteCount > 10000) {
          return -1; // a (leading) ranks higher
        }
      }
      if (aIsExact && bIsLeading) {
        const aVoteCount = a.meta.voteCount ?? 0;
        const bVoteCount = b.meta.voteCount ?? 0;
        // If leading match has significantly more votes (10x+), promote it above exact match
        if (bVoteCount > aVoteCount * 10 && bVoteCount > 10000) {
          return 1; // b (leading) ranks higher
        }
      }
    }
    
    // For exact matches, use tighter threshold to ensure proper tie-breaking
    const bothExact = a.titleSig.tier === 'exact' && b.titleSig.tier === 'exact';
    const threshold = bothExact ? 0.15 : 0.05;
    if (Math.abs(scoreDiff) < threshold) {
      return tieBreak(a.meta, b.meta, query);
    }
    return scoreDiff;
  });

  // Log canonical pinning if it occurred
  if (exactCandidates.length > 0 && ranked[0].titleSig.tier === 'exact') {
    const pinned = ranked[0];
    console.log(`üìå PINNED: "${pinned.item.title}" (${pinned.item.year}) to rank 1`);
  }

  // Debug logging for top 20 results in table format
  if (debugMode) {
    console.log('\nüìä SEARCH RANKING DEBUG - Top 20 Results');
    console.log('Query:', queryRaw);
    console.log('‚ïê'.repeat(120));
    
    const tableData = ranked.slice(0, 20).map((x, i) => {
      const debugInfo = (x as any).debug || {};
      return {
        rank: i + 1,
        title: `"${x.item.title.substring(0, 40)}"`,
        year: x.item.year || '?',
        score: x.score.toFixed(1),
        tier: x.meta.tier,
        ...(Object.keys(debugInfo).length > 0 ? {
          exact: debugInfo.titleExact || 0,
          prefix: debugInfo.titlePrefix || 0,
          contains: debugInfo.titleContains || 0,
          pop: (debugInfo.popBonus || 0).toFixed(1),
          recency: (debugInfo.recencyBonus || 0).toFixed(1)
        } : {})
      };
    });
    
    if (typeof console.table === 'function') {
      console.table(tableData);
    } else {
      console.log(tableData);
    }
    console.log('');
    
    // Show pinning status if applicable
    const exacts = ranked.filter(x => x.titleSig.tier === 'exact');
    if (exacts.length > 0) {
      console.log(`‚úÖ Canonical pinning active: ${exacts.length} exact match(es) found`);
    }
  }

  console.log('üìä Final ranked top 5:', ranked.slice(0, 5).map((x, i) => ({
    rank: i + 1,
    title: x.item.title,
    tier: x.meta.tier,
    score: x.score
  })));

  const finalRanked = ranked.map(x => x.item);

  // Apply type filter
  const filtered = searchType === 'movies-tv'
    ? finalRanked.filter(r => r.mediaType === 'tv' || r.mediaType === 'movie')
    : finalRanked;

  return {
    items: filtered,
    page,
    totalPages: multiJson.total_pages ?? 1
  };
}

export async function debugSmartSearch(query: string) {
  const result = await smartSearch(query, 1, 'movies-tv', { debugSearch: true });
  
  // Re-compute scores for each item to get debug info
  const rows = result.items.slice(0, 20).map((item, index) => {
      const scored = computeSearchScore(query, {
        title: item.title || '',
        originalTitle: undefined,
        aliases: [],
        overview: item.synopsis,
        popularity: item.voteAverage ? item.voteAverage * 10 : undefined,
        voteAverage: item.voteAverage,
        voteCount: item.voteCount,
        releaseYear: item.year ? parseInt(item.year) : undefined,
        releaseDate: item.releaseDate || undefined,
        mediaType: item.mediaType,
        originalLanguage: undefined,
        collectionName: undefined
      }, {
        preferType: 'all',
        debugSearch: true
      });
      
      // Calculate age for display
      let age: number | string = '?';
      if (item.releaseDate) {
        const ageDays = (Date.now() - new Date(item.releaseDate).getTime()) / 864e5;
        age = (ageDays / 365.25).toFixed(1);
      } else if (item.year) {
        const now = new Date().getFullYear();
        age = (now - parseInt(item.year)).toFixed(1);
      }
      
      const debug = scored.debug || {};
      
      return {
        rank: index + 1,
        title: item.title || 'Untitled',
        year: item.year || '?',
        mediaType: item.mediaType,
        tier: scored.titleSig.tier,
        score: scored.score.toFixed(2),
        voteAverage: item.voteAverage?.toFixed(1) || '?',
        voteCount: item.voteCount || 0,
        releaseDate: item.releaseDate || item.year || '?',
        age: age,
        recencyBonus: debug.recencyBonus?.toFixed(2) || '?',
        popBonus: debug.popBonus?.toFixed(2) || '?',
        bm25: debug.bm25?.toFixed(2) || '?',
        titleExact: debug.titleExact || 0,
        titleLeading: debug.titleLeading || 0,
        titlePrefix: debug.titlePrefix || 0,
        titleWord: debug.titleWord || 0,
        titleContains: debug.titleContains || 0,
        yearMatch: debug.yearMatch || 0,
        voteSig: typeof debug.voteSig === 'number' ? debug.voteSig.toFixed(3) : '?'
      };
  });
  
  console.table(rows);
  return rows;
}

// Expose debug helper in dev
if (typeof window !== 'undefined') {
  (window as any).__debugSmartSearch = debugSmartSearch;
}

```

## apps/web/src/search/api.ts
### Summary
Search API utilities that map TMDB JSON into `MediaItem` and supply TMDB vote data for ranking.
### Content
```ts
import type { MediaItem } from '../components/cards/card.types';
import { get } from '../lib/tmdb';
import { normalizeQuery } from '../lib/string';
import { computeSearchScore } from './rank';


export type SearchResult = MediaItem;

export type SearchResultWithPagination = {
  items: SearchResult[];
  page: number;
  totalPages: number;
};

// Function to fetch network/production company information from TMDB detailed endpoints
export async function fetchNetworkInfo(id: number, mediaType: 'movie' | 'tv'): Promise<{ networks?: string[]; productionCompanies?: string[] }> {
  const maxRetries = 2;
  let lastError: Error | null = null;
  
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      const endpoint = mediaType === 'movie' ? `/movie/${id}` : `/tv/${id}`;
      const data = await get(endpoint);
      
      if (mediaType === 'tv') {
        // For TV shows, get networks
        const networks = data.networks?.map((network: any) => network.name).filter(Boolean) || [];
        if (networks.length > 0) {
          return { networks };
        }
      } else {
        // For movies, get production companies
        const productionCompanies = data.production_companies?.map((company: any) => company.name).filter(Boolean) || [];
        if (productionCompanies.length > 0) {
          return { productionCompanies };
        }
      }
      
      // If we got data but no networks/companies, that's still a successful response
      return {};
      
    } catch (error) {
      lastError = error as Error;
      console.warn(`Attempt ${attempt} failed to fetch network info for ${mediaType}:${id}:`, error);
      
      // Wait before retry (exponential backoff)
      if (attempt < maxRetries) {
        await new Promise(resolve => setTimeout(resolve, attempt * 1000));
      }
    }
  }
  
  // If all retries failed, log the final error but don't throw
  console.error(`All ${maxRetries} attempts failed to fetch network info for ${mediaType}:${id}:`, lastError);
  return {};
}

/**
 * Fetch full metadata from TMDB for a media item
 * This ensures all metadata fields are populated when adding from search
 */
export async function fetchFullMediaMetadata(item: MediaItem): Promise<Partial<MediaItem>> {
  try {
    const id = typeof item.id === 'string' ? parseInt(item.id) : item.id;
    if (!id || !item.mediaType || item.mediaType === 'person') {
      return {};
    }

    const endpoint = item.mediaType === 'movie' ? `/movie/${id}` : `/tv/${id}`;
    const data = await get(endpoint);

    // Extract common fields
    const title = item.mediaType === 'movie' ? data.title : data.name;
    const date = item.mediaType === 'movie' ? data.release_date : data.first_air_date;
    const year = date ? String(date).slice(0, 4) : undefined;
    const posterUrl = data.poster_path ? `https://image.tmdb.org/t/p/w342${data.poster_path}` : undefined;

    const metadata: Partial<MediaItem> = {
      title: title || item.title,
      year: year || item.year,
      releaseDate: date || item.releaseDate,
      posterUrl: posterUrl || item.posterUrl,
      voteAverage: typeof data.vote_average === 'number' ? data.vote_average : item.voteAverage,
      voteCount: typeof data.vote_count === 'number' ? data.vote_count : item.voteCount,
      synopsis: data.overview || item.synopsis || '',
      runtimeMins: data.runtime || item.runtimeMins,
    };

    // TV-specific fields
    if (item.mediaType === 'tv') {
      metadata.showStatus = data.status as 'Ended' | 'Returning Series' | 'In Production' | 'Canceled' | 'Planned' | undefined;
      metadata.lastAirDate = data.last_air_date || item.lastAirDate;
      
      // Get networks
      const networks = data.networks?.map((network: any) => network.name).filter(Boolean) || [];
      if (networks.length > 0) {
        metadata.networks = networks;
      }
    } else {
      // Movie-specific fields
      const productionCompanies = data.production_companies?.map((company: any) => company.name).filter(Boolean) || [];
      if (productionCompanies.length > 0) {
        metadata.productionCompanies = productionCompanies;
      }
    }

    console.log(`‚úÖ Fetched full metadata for ${item.mediaType}:${id}`, {
      title: metadata.title,
      year: metadata.year,
      hasSynopsis: !!metadata.synopsis,
      hasPoster: !!metadata.posterUrl,
    });

    return metadata;
  } catch (error) {
    console.warn(`‚ö†Ô∏è Failed to fetch full metadata for ${item.mediaType}:${item.id}:`, error);
    // Return empty object on error - will use existing item data
    return {};
  }
}

export async function searchMulti(
  query: string,
  page = 1,
  genre?: number | null,
  searchType: 'all' | 'movies-tv' | 'people' = 'all',
  opts?: { signal?: AbortSignal; language?: string; region?: string }
): Promise<SearchResultWithPagination> {
  const language = opts?.language ?? 'en-US';
  const region   = opts?.region ?? 'US';
  const q = normalizeQuery(query);

  // optional year hint
  const year = /\b(19|20)\d{2}\b/.exec(q)?.[0];
  const qs = new URLSearchParams({
    path: searchType === 'people' ? 'search/person' : 'search/multi',
    query: q,
    page: String(page),
    include_adult: 'false',
    language,
    region,
    ...(year ? { year, first_air_date_year: year } : {})
  });

  const res = await fetch(`/api/tmdb-proxy?${qs.toString()}`, { signal: opts?.signal });
  if (!res.ok) throw new Error(`search failed: ${res.status}`);

  const json = await res.json();
  const results = Array.isArray(json.results) ? json.results : [];
  const totalPages = json.total_pages ?? 1;

  let filtered = results;
  if (searchType === 'movies-tv') {
    filtered = results.filter((r: any) => r?.media_type === 'movie' || r?.media_type === 'tv');
  }
  if (searchType === 'people') {
    filtered = results.filter((r: any) => r?.media_type === 'person');
  }

  const mapped = filtered.map(mapTMDBToMediaItem).filter(Boolean) as SearchResult[];

  const finalResults = genre
    ? mapped.filter((m: any) => Array.isArray(m.genre_ids) && m.genre_ids.includes(genre))
    : mapped;

  return {
    items: finalResults,
    page,
    totalPages
  };
}

// normalizeQuery is now imported from '../lib/string'

export function mapTMDBToMediaItem(r: any): MediaItem {
  const mediaType = r.media_type ?? (r.first_air_date ? 'tv' : r.release_date ? 'movie' : r.known_for ? 'person' : 'movie');

  if (mediaType === 'person') {
    const name = typeof r.name === 'string' ? r.name : '';
    return {
      id: r.id,
      mediaType: 'person' as any,
      title: name,
      year: undefined,
      posterUrl: r.profile_path ? `https://image.tmdb.org/t/p/w342${r.profile_path}` : undefined,
      voteAverage: r.popularity,
      known_for: r.known_for || [],
      synopsis: r.known_for?.map((it: any) => it.title || it.name).join(', ') || '',
    } as MediaItem;
  }

  const rawTitle = mediaType === 'movie' ? r.title : r.name;
  const safeTitle = (() => {
    if (typeof rawTitle === 'string' && rawTitle.trim() && rawTitle !== String(r.id)) {
      return rawTitle.trim();
    }
    return 'Untitled';
  })();
  
  const date  = mediaType === 'movie' ? r.release_date : r.first_air_date;
  const year  = date ? String(date).slice(0, 4) : undefined;
  const releaseDate = date || undefined; // Store full ISO date string for precise recency calculation
  const posterUrl = r.poster_path ? `https://image.tmdb.org/t/p/w342${r.poster_path}` : undefined;

  const item: MediaItem = {
    id: r.id,
    mediaType,
    title: safeTitle,
    year,
    releaseDate, // Add releaseDate for precise recency calculation
    posterUrl,
    voteAverage: typeof r.vote_average === 'number' ? r.vote_average : undefined,
    voteCount: typeof r.vote_count === 'number' ? r.vote_count : undefined,
    synopsis: r.overview || '',
    showStatus: mediaType === 'tv' ? r.status : undefined,
    lastAirDate: mediaType === 'tv' ? r.last_air_date : undefined,
  };
  
  // Store genre_ids separately (not part of MediaItem type but used for filtering)
  (item as any).genre_ids = r.genre_ids;
  
  return item;
}

export async function discoverByGenre(
  genre: number,
  page = 1,
  opts?: { signal?: AbortSignal; language?: string; region?: string }
): Promise<SearchResultWithPagination> {
  const language = opts?.language ?? 'en-US';
  const region = opts?.region ?? 'US';

  const qsBase = (params: Record<string, any>) => {
    const p = new URLSearchParams();
    for (const [k, v] of Object.entries(params)) {
      if (v !== undefined && v !== null && v !== '') p.set(k, String(v));
    }
    return p.toString();
  };

  const fetchTMDB = async (path: string, params: Record<string, any>) => {
    const res = await fetch(`/api/tmdb-proxy?${qsBase({ path, ...params })}`, {
      signal: opts?.signal,
    });
    if (!res.ok) throw new Error(`${path} failed: ${res.status}`);
    return res.json();
  };

  // Fetch movies and TV for the given genre using discover endpoints
  const [movieJson, tvJson] = await Promise.all([
    fetchTMDB('discover/movie', {
      with_genres: genre,
      page,
      include_adult: false,
      sort_by: 'popularity.desc',
      language,
      region,
    }),
    fetchTMDB('discover/tv', {
      with_genres: genre,
      page,
      include_adult: false,
      sort_by: 'popularity.desc',
      language,
      region,
    }),
  ]);

  const raw: any[] = [
    ...(Array.isArray(movieJson.results) ? movieJson.results.map((r: any) => ({ ...r, media_type: 'movie' })) : []),
    ...(Array.isArray(tvJson.results) ? tvJson.results.map((r: any) => ({ ...r, media_type: 'tv' })) : []),
  ];

  const mapped = raw
    .map(mapTMDBToMediaItem)
    .filter(Boolean) as SearchResult[];

  // For genre-only search we have no user text query, so pass empty string into computeSearchScore
  // and let popularity/recency/votes drive ranking.
  const ranked = mapped
    .map(item => {
      const scored = computeSearchScore('', {
        title: item.title || '',
        overview: item.synopsis,
        popularity: item.voteAverage ? item.voteAverage * 10 : undefined,
        voteAverage: item.voteAverage,
        voteCount: item.voteCount,
        releaseYear: item.year ? parseInt(item.year) : undefined,
        releaseDate: item.releaseDate || undefined,
        mediaType: item.mediaType as 'movie' | 'tv',
        originalLanguage: undefined,
        collectionName: undefined,
      });
      return { item, score: scored.score };
    })
    .sort((a, b) => b.score - a.score)
    .map(x => x.item);

  const totalPages = Math.max(
    movieJson.total_pages ?? 1,
    tvJson.total_pages ?? 1
  );

  return {
    items: ranked,
    page,
    totalPages,
  };
}

```

## apps/web/src/search/enhancedAutocomplete.ts
### Summary
Autocomplete helper that reorders suggestions using the ranking heuristics.
### Content
```ts
/**
 * Process: Enhanced Autocomplete with Relevance Scoring
 * Purpose: Fetch and rank autocomplete suggestions using predictive relevance scoring
 * Data Source: TMDB API responses
 * Update Path: Adjust scoring weights in rankCandidates
 * Dependencies: searchRelevance, Library
 */

import type { MediaItem } from '../components/cards/card.types';
import { rankCandidates } from '../lib/searchRelevance';

async function fetchTMDB(path: string, params: Record<string, any>, signal?: AbortSignal) {
  const qs = new URLSearchParams({ path, ...params });
  const url = `/api/tmdb-proxy?${qs.toString()}`;
  const res = await fetch(url, { signal });
  if (!res.ok) throw new Error(`${path} failed: ${res.status}`);
  return res.json();
}

/**
 * Fetch autocomplete suggestions with enhanced relevance scoring
 * Returns up to 100 candidates, then ranks and returns top 10
 */
export async function fetchEnhancedAutocomplete(
  query: string,
  signal?: AbortSignal,
  enabledProviders: string[] = []
): Promise<MediaItem[]> {
  if (!query.trim() || query.length < 2) {
    return [];
  }

  try {
    // Fetch from multiple endpoints for better coverage (like smartSearch does)
    // This ensures we get "Batman" when searching "bat" even if TMDB ranks it lower
    const [multiJson, movieJson, tvJson] = await Promise.all([
      fetchTMDB('search/multi', {
        query: query.trim(),
        page: 1,
        include_adult: false,
        language: 'en-US',
        region: 'US',
      }, signal).catch(() => ({ results: [] })),
      fetchTMDB('search/movie', {
        query: query.trim(),
        page: 1,
        include_adult: false,
        language: 'en-US',
        region: 'US',
      }, signal).catch(() => ({ results: [] })),
      fetchTMDB('search/tv', {
        query: query.trim(),
        page: 1,
        include_adult: false,
        language: 'en-US',
        region: 'US',
      }, signal).catch(() => ({ results: [] }))
    ]);

    // Combine results from all endpoints, prioritizing multi search
    const multiResults = Array.isArray(multiJson.results) ? multiJson.results : [];
    const movieResults = Array.isArray(movieJson.results) ? movieJson.results : [];
    const tvResults = Array.isArray(tvJson.results) ? tvJson.results : [];
    
    // Deduplicate by (media_type, id) - keep multi search results first
    const seen = new Set<string>();
    const results: any[] = [];
    
    // Add multi search results first
    for (const r of multiResults) {
      const key = `${r.media_type || 'unknown'}:${r.id}`;
      if (!seen.has(key)) {
        seen.add(key);
        results.push(r);
      }
    }
    
    // Add movie results
    for (const r of movieResults) {
      const key = `movie:${r.id}`;
      if (!seen.has(key)) {
        seen.add(key);
        results.push({ ...r, media_type: 'movie' });
      }
    }
    
    // Add TV results
    for (const r of tvResults) {
      const key = `tv:${r.id}`;
      if (!seen.has(key)) {
        seen.add(key);
        results.push({ ...r, media_type: 'tv' });
      }
    }
    
    // Limit to 100 for performance
    const limitedResults = results.slice(0, 100);
    
    // Map to MediaItem format
    const candidates = limitedResults
      .map((r: any) => {
        // Convert TMDB result to MediaItem format for scoring
        const mediaType = r.media_type || (r.first_air_date ? 'tv' : r.release_date ? 'movie' : 'person');
        
        if (mediaType === 'person') {
          // Skip people for now in autocomplete
          return null;
        }
        
        const title = mediaType === 'movie' ? r.title : r.name;
        const date = mediaType === 'movie' ? r.release_date : r.first_air_date;
        const year = date ? String(date).slice(0, 4) : undefined;
        
        const item: MediaItem = {
          id: String(r.id),
          title: title || 'Untitled',
          mediaType: mediaType as 'movie' | 'tv',
          year,
          posterUrl: r.poster_path ? `https://image.tmdb.org/t/p/w185${r.poster_path}` : undefined,
          synopsis: r.overview,
          voteAverage: r.vote_average,
        };
        
        // Add raw TMDB data for scoring
        (item as any).vote_count = r.vote_count;
        (item as any).popularity = r.popularity;
        
        return item;
      })
      .filter(Boolean) as MediaItem[];

    // Rank candidates using relevance scoring
    const ranked = rankCandidates(query, candidates, enabledProviders, 10);
    
    return ranked;
  } catch (error) {
    if (error instanceof Error && error.name === 'AbortError') {
      throw error;
    }
    console.warn('Enhanced autocomplete fetch failed:', error);
    return [];
  }
}



```

## apps/web/src/lib/testData.ts
### Summary
Mock data covering rating/discovery scenarios used in tests or storybooks.
### Content
```ts
import { Library } from './storage';
import type { MediaItem } from '../components/cards/card.types';
import { fetchNextAirDate } from '../tmdb/tv';

// Test data for development
const TEST_MOVIES: MediaItem[] = [
  {
    id: '550',
    mediaType: 'movie',
    title: 'Fight Club',
    year: '1999',
    posterUrl: 'https://image.tmdb.org/t/p/w342/pB8BM7pdSp6B6Ih7QZ4DrQ3PmJK.jpg',
    voteAverage: 8.4,
    synopsis: 'A ticking-time-bomb insomniac and a slippery soap salesman channel primal male aggression into a shocking new form of therapy. Their concept catches on, with underground "fight clubs" forming in every town, until an eccentric gets in the way and ignites an out-of-control spiral toward oblivion.'
  },
  {
    id: '13',
    mediaType: 'movie',
    title: 'Forrest Gump',
    year: '1994',
    posterUrl: 'https://image.tmdb.org/t/p/w342/arw2vcBveWOVZr6pxd9XTd1TdQa.jpg',
    voteAverage: 8.5,
    synopsis: 'A man with a low IQ has accomplished great things in his life and been present during significant historic events‚Äîin each case, far exceeding what anyone imagined he could do. But despite all he has achieved, his one true love eludes him.'
  },
  {
    id: '238',
    mediaType: 'movie',
    title: 'The Godfather',
    year: '1972',
    posterUrl: 'https://image.tmdb.org/t/p/w342/3bhkrj58Vtu7enYsRolD1fZdja1.jpg',
    voteAverage: 8.7,
    synopsis: 'The aging patriarch of an organized crime dynasty transfers control of his clandestine empire to his reluctant son. Spanning the years 1945 to 1955, a chronicle of the fictional Italian-American Corleone crime family.'
  }
];

const TEST_TV_SHOWS: MediaItem[] = [
  {
    id: '1399',
    mediaType: 'tv',
    title: 'Game of Thrones',
    year: '2011',
    posterUrl: 'https://image.tmdb.org/t/p/w342/u3bZgnGQ9T01sWNhyveQz0wH0Hl.jpg',
    voteAverage: 8.3,
    synopsis: 'Seven noble families fight for control of the mythical land of Westeros. Friction between the houses leads to full-scale war. All while a very ancient evil awakens in the farthest north. Amidst the war, a neglected military order of misfits, the Night\'s Watch, is all that stands between the realms of men and icy horrors beyond.'
  },
  {
    id: '1396',
    mediaType: 'tv',
    title: 'Breaking Bad',
    year: '2008',
    posterUrl: 'https://image.tmdb.org/t/p/w342/ggFHVNu6YYI5L9pCfOacjizRGt.jpg',
    voteAverage: 8.9,
    synopsis: 'A high school chemistry teacher diagnosed with inoperable lung cancer turns to manufacturing and selling methamphetamine in order to secure his family\'s future. As he descends deeper into the criminal underworld, Walter White\'s transformation from mild-mannered teacher to ruthless drug kingpin becomes increasingly complex.'
  },
  {
    id: '1398',
    mediaType: 'tv',
    title: 'The Sopranos',
    year: '1999',
    posterUrl: 'https://image.tmdb.org/t/p/w342/rTc7ZXdroqjkKivFPvCPX0Ru7uw.jpg',
    voteAverage: 8.5,
    synopsis: 'New Jersey mob boss Tony Soprano deals with personal and professional issues in his home and business life. As he struggles to balance the demands of his crime family with those of his nuclear family, Tony begins seeing a psychiatrist to help him deal with his panic attacks and anxiety.'
  },
  // Currently airing shows with next air dates
  {
    id: '82856',
    mediaType: 'tv',
    title: 'The Mandalorian',
    year: '2019',
    posterUrl: 'https://image.tmdb.org/t/p/w342/eU1i6eHXlzMOlEq0ku1Rzq7Y4wA.jpg',
    voteAverage: 8.5,
    synopsis: 'The travels of a lone bounty hunter in the outer reaches of the galaxy, far from the authority of the New Republic.',
    nextAirDate: '2024-12-18' // Mock upcoming episode date
  },
  {
    id: '94997',
    mediaType: 'tv',
    title: 'House of the Dragon',
    year: '2022',
    posterUrl: 'https://image.tmdb.org/t/p/w342/z2yahl2uefxDCl0nogcRBstwruJ.jpg',
    voteAverage: 8.4,
    synopsis: 'The Targaryen dynasty is at the absolute apex of its power, with more than 15 dragons under their yoke.',
    nextAirDate: '2024-12-25' // Mock upcoming episode date
  }
];

export function addTestData() {
  console.log('üé¨ Adding test data to Library...');
  
  // Add some movies to wishlist
  TEST_MOVIES.forEach(movie => {
    Library.upsert(movie, 'wishlist');
  });
  
  // Add some TV shows to watching
  TEST_TV_SHOWS.forEach(show => {
    Library.upsert(show, 'watching');
  });
  
  // Add one movie to watched
  Library.upsert(TEST_MOVIES[0], 'watched');
  
  console.log('‚úÖ Test data added successfully!');
  console.log('üìä Current Library state:', {
    watching: Library.getByList('watching').length,
    wishlist: Library.getByList('wishlist').length,
    watched: Library.getByList('watched').length,
    not: Library.getByList('not').length
  });
}

export function clearTestData() {
  console.log('üóëÔ∏è Clearing test data from Library...');
  
  // Clear all lists
  ['watching', 'wishlist', 'watched', 'not'].forEach(list => {
    const items = Library.getByList(list as any);
    items.forEach(item => {
      Library.remove(item.id, item.mediaType);
    });
  });
  
  console.log('‚úÖ Test data cleared successfully!');
}

export async function populateNextAirDates() {
  console.log('üì∫ Populating next air dates for TV shows...');
  
  const watching = Library.getByList('watching');
  const tvShows = watching.filter(item => item.mediaType === 'tv');
  
  console.log(`Found ${tvShows.length} TV shows to update`);
  
  for (const show of tvShows) {
    try {
      console.log(`üîç Fetching next air date for: ${show.title} (current: ${show.nextAirDate || 'none'})`);
      const nextAirDate = await fetchNextAirDate(Number(show.id));
      if (nextAirDate) {
        // Update the show with next air date
        const updatedShow = { ...show, nextAirDate };
        Library.upsert(updatedShow, 'watching');
        
        // Verify the update worked
        const verifyShow = Library.getByList('watching').find(item => item.id === show.id);
        console.log(`‚úÖ Updated ${show.title} with next air date: ${nextAirDate}`);
        console.log(`üîç Verification - Show in Library:`, verifyShow?.nextAirDate);
        
        // Small delay to ensure React processes the update
        await new Promise(resolve => setTimeout(resolve, 100));
      } else {
        console.log(`‚ö†Ô∏è No upcoming episodes for ${show.title}`);
      }
    } catch (error) {
      console.log(`‚ùå Failed to fetch next air date for ${show.title}:`, error);
    }
  }
  
  console.log('‚úÖ Next air dates population complete!');
  
  // Force a re-render by dispatching a custom event
  if (typeof window !== 'undefined') {
    window.dispatchEvent(new CustomEvent('library:updated'));
    
    // Additional force refresh for stubborn components
    setTimeout(() => {
      window.dispatchEvent(new CustomEvent('force-refresh'));
    }, 200);
  }
}

// Manual refresh function for testing
export function forceRefreshUpNext() {
  console.log('üîÑ Manually forcing UpNext refresh...');
  if (typeof window !== 'undefined') {
    window.dispatchEvent(new CustomEvent('force-refresh'));
  }
}

// Make it available globally for console testing
if (typeof window !== 'undefined') {
  (window as any).populateNextAirDates = populateNextAirDates;
  (window as any).Library = Library;
  (window as any).forceRefreshUpNext = forceRefreshUpNext;
}

```

## apps/web/src/lib/settings.ts
### Summary
Settings manager storing discovery layout flags, enabling/disabling specialized rails and tokens.
### Content
```ts
/**
 * Process: Settings Management with Cross-Device Sync
 * Purpose: Manage user settings with localStorage persistence and Firebase sync for cross-device synchronization
 * Data Source: localStorage (flicklet.settings.v2) and Firebase (users/{uid}/settings)
 * Update Path: settingsManager.update*() methods ‚Üí saveSettings() ‚Üí syncSettingsToFirebase()
 * Dependencies: authManager, Firebase Firestore
 * 
 * Cross-Device Sync Flow:
 * 1. Settings changes ‚Üí saveSettings() ‚Üí syncSettingsToFirebase() ‚Üí Firebase
 * 2. Login ‚Üí loadSettingsFromFirebase() ‚Üí merge with localStorage ‚Üí apply settings
 * 3. Conflict resolution: Firebase settings take precedence over localStorage
 */

import React from 'react';
import { authManager } from './auth';
import type { UserSettings } from './auth.types';

// Settings data model based on design document
export type PersonalityLevel = 1 | 2 | 3; // Regular, Semi-sarcastic, Severely sarcastic
export type Theme = 'light' | 'dark';
export type TargetList = 'watching' | 'wishlist';

export interface Settings {
  // General
  displayName: string;
  personalityLevel: PersonalityLevel;
  
  // Notifications
  notifications: {
    upcomingEpisodes: boolean;
    weeklyDiscover: boolean;
    monthlyStats: boolean;
    alertConfig?: {
      leadTimeHours: number;
      targetList: TargetList;
    };
  };
  
  // Layout
  layout: {
    condensedView: boolean;
    theme: Theme;
    homePageLists: string[];
    forYouGenres: string[];
    episodeTracking: boolean;
    themePack?: string; // Pro feature
    discoveryLimit: 25 | 50 | 75 | 100; // Number of discovery recommendations
  };
  
  // Pro
  pro: {
    isPro: boolean;
    features: {
      advancedNotifications: boolean;
      themePacks: boolean;
      socialFeatures: boolean;
      bloopersAccess: boolean;
      extrasAccess: boolean;
    };
  };
  
  // Community
  community: {
    followedTopics: string[]; // Array of topic slugs user follows
  };
}

// Default settings
const DEFAULT_SETTINGS: Settings = {
  displayName: 'Guest',
  personalityLevel: 1, // Regular
  
  notifications: {
    upcomingEpisodes: true,
    weeklyDiscover: true,
    monthlyStats: true,
  },
  
  layout: {
    condensedView: false,
    theme: 'dark',
    homePageLists: ['currently-watching', 'up-next', 'community', 'for-you-drama', 'for-you-comedy', 'for-you-horror', 'in-theaters', 'feedback'],
    forYouGenres: ['drama', 'comedy', 'horror'],
    episodeTracking: false,
    discoveryLimit: 25, // Default to 25 recommendations
  },
  
  pro: {
    isPro: false, // Default OFF - users must explicitly enable Pro (Alpha/testing) or purchase
    features: {
      advancedNotifications: false,
      themePacks: false,
      socialFeatures: false,
      bloopersAccess: false,
      extrasAccess: false,
    },
  },
  
  community: {
    followedTopics: [],
  },
};

type FirebaseUserSettings = UserSettings & Partial<{
  displayName: string;
  personalityLevel: PersonalityLevel;
  notifications: Settings['notifications'];
  layout: Settings['layout'];
  pro: Settings['pro'];
  community: Settings['community'];
  fullSettings: Settings;
  theme: Theme;
}>;

// Storage key
const KEY = 'flicklet.settings.v2';

// Settings state management
class SettingsManager {
  private settings: Settings;
  private subscribers: Set<() => void> = new Set();
  private syncTimeout: ReturnType<typeof setTimeout> | null = null;
  private isSyncing = false;

  constructor() {
    this.settings = this.loadSettings();
    this.applyTheme(this.settings.layout.theme);
  }

  private loadSettings(): Settings {
    try {
      const stored = localStorage.getItem(KEY);
      if (stored) {
        const parsed = JSON.parse(stored);
        // Merge with defaults to handle new settings
        return { ...DEFAULT_SETTINGS, ...parsed };
      }
    } catch (error) {
      console.warn('Failed to load settings:', error);
    }
    return { ...DEFAULT_SETTINGS };
  }

  private saveSettings(): void {
    try {
      localStorage.setItem(KEY, JSON.stringify(this.settings));
      this.notifySubscribers();
      // Sync to Firebase in background (non-blocking)
      this.syncSettingsToFirebase();
    } catch (error) {
      console.error('Failed to save settings:', error);
    }
  }

  /**
   * Sync settings to Firebase for cross-device persistence
   * Debounced to avoid excessive writes
   */
  private syncSettingsToFirebase(): void {
    // Clear existing timeout
    if (this.syncTimeout) {
      clearTimeout(this.syncTimeout);
    }

    // Debounce sync calls (1 second delay)
    this.syncTimeout = setTimeout(async () => {
      if (this.isSyncing) {
        return; // Skip if sync already in progress
      }

      try {
        // Get current user
        const currentUser = authManager.getCurrentUser();
        if (!currentUser) {
          // User not logged in, skip sync
          return;
        }

        this.isSyncing = true;

        // Convert Settings to format compatible with Firebase UserSettings
        // We'll store the full settings object
        // Note: updateUserSettings accepts Partial<UserSettings> but Firebase will accept additional fields
        const firebaseSettings: FirebaseUserSettings = {
          // Map Settings to Firebase format
          displayName: this.settings.displayName,
          personalityLevel: this.settings.personalityLevel,
          theme: this.settings.layout.theme,
          notifications: this.settings.notifications,
          layout: this.settings.layout,
          pro: this.settings.pro,
          community: this.settings.community,
          // Store full settings as JSON for easy retrieval
          fullSettings: this.settings,
        };

        await authManager.updateUserSettings(currentUser.uid, firebaseSettings);
        console.log('‚úÖ Settings synced to Firebase');
      } catch (error) {
        // Don't block UI on sync failure - settings are saved locally
        console.warn('Failed to sync settings to Firebase:', error);
      } finally {
        this.isSyncing = false;
      }
    }, 1000); // 1 second debounce
  }

  /**
   * Load settings from Firebase and merge with local settings
   * Called on login to sync settings across devices
   * Public method for external callers
   */
  async loadSettingsFromFirebase(uid: string): Promise<boolean> {
    try {
      const firebaseSettings = (await authManager.getUserSettings(uid)) as FirebaseUserSettings | null;
      
      if (!firebaseSettings) {
        // No settings in Firebase, keep local settings
        return false;
      }

      // Check if fullSettings exists (new format) or use legacy format
      let firebaseFullSettings: Settings;
      
      if (firebaseSettings.fullSettings) {
        // New format: full settings object stored
        firebaseFullSettings = firebaseSettings.fullSettings;
      } else {
        // Legacy format: individual fields, convert to Settings format
        // This handles backward compatibility with existing Firebase data
        firebaseFullSettings = {
          ...DEFAULT_SETTINGS,
          displayName: firebaseSettings.displayName || DEFAULT_SETTINGS.displayName,
          personalityLevel: (firebaseSettings.personalityLevel as PersonalityLevel) || DEFAULT_SETTINGS.personalityLevel,
          layout: {
            ...DEFAULT_SETTINGS.layout,
            theme: (firebaseSettings.theme as Theme) || DEFAULT_SETTINGS.layout.theme,
            ...(firebaseSettings.layout || {}),
          },
          notifications: {
            ...DEFAULT_SETTINGS.notifications,
            ...(firebaseSettings.notifications || {}),
          },
          pro: {
            ...DEFAULT_SETTINGS.pro,
            ...(firebaseSettings.pro || {}),
          },
          community: {
            ...DEFAULT_SETTINGS.community,
            ...(firebaseSettings.community || {}),
          },
        };
      }

      // Merge Firebase settings with local settings
      // Firebase wins for conflict resolution
      
      // Merge with defaults to handle new settings fields
      const mergedSettings: Settings = {
        ...DEFAULT_SETTINGS,
        ...firebaseFullSettings,
        // Deep merge nested objects
        notifications: {
          ...DEFAULT_SETTINGS.notifications,
          ...firebaseFullSettings.notifications,
        },
        layout: {
          ...DEFAULT_SETTINGS.layout,
          ...firebaseFullSettings.layout,
        },
        pro: {
          ...DEFAULT_SETTINGS.pro,
          ...firebaseFullSettings.pro,
          features: {
            ...DEFAULT_SETTINGS.pro.features,
            ...firebaseFullSettings.pro.features,
          },
        },
        community: {
          ...DEFAULT_SETTINGS.community,
          ...firebaseFullSettings.community,
        },
      };

      // Update local settings
      this.settings = mergedSettings;
      
      // Save merged settings to localStorage
      localStorage.setItem(KEY, JSON.stringify(this.settings));
      
      // Apply theme immediately
      this.applyTheme(this.settings.layout.theme);
      
      // Notify subscribers
      this.notifySubscribers();
      
      console.log('‚úÖ Settings loaded from Firebase');
      return true;
    } catch (error) {
      console.warn('Failed to load settings from Firebase:', error);
      return false;
    }
  }

  private notifySubscribers(): void {
    // ‚ö†Ô∏è REMOVED: flickerDiagnostics logging disabled
    this.subscribers.forEach(callback => callback());
  }

  // Public API
  getSettings(): Settings {
    return { ...this.settings };
  }

  updateSettings(updates: Partial<Settings>): void {
    this.settings = { ...this.settings, ...updates };
    this.saveSettings();
  }

  updateDisplayName(name: string): void {
    this.settings.displayName = name;
    this.saveSettings();
  }

  updatePersonalityLevel(level: PersonalityLevel): void {
    this.settings.personalityLevel = level;
    this.saveSettings();
  }

  updateTheme(theme: Theme): void {
    this.settings.layout.theme = theme;
    this.applyTheme(theme);
    this.saveSettings();
  }

  private applyTheme(theme: Theme): void {
    if (typeof document !== 'undefined') {
      document.documentElement.setAttribute('data-theme', theme);
    }
  }

  toggleEpisodeTracking(): void {
    this.settings.layout.episodeTracking = !this.settings.layout.episodeTracking;
    this.saveSettings();
  }

  updateDiscoveryLimit(limit: 25 | 50 | 75 | 100): void {
    this.settings.layout.discoveryLimit = limit;
    this.saveSettings();
  }

  updateFollowedTopics(topics: string[]): void {
    this.settings.community.followedTopics = topics;
    this.saveSettings();
  }

  toggleFollowTopic(topicSlug: string): void {
    const current = this.settings.community.followedTopics;
    if (current.includes(topicSlug)) {
      this.settings.community.followedTopics = current.filter(t => t !== topicSlug);
    } else {
      this.settings.community.followedTopics = [...current, topicSlug];
    }
    this.saveSettings();
  }

  updateProStatus(isPro: boolean): void {
    this.settings.pro.isPro = isPro;
    // Update feature flags based on Pro status
    this.settings.pro.features = {
      advancedNotifications: isPro,
      themePacks: isPro,
      socialFeatures: isPro,
      bloopersAccess: isPro,
      extrasAccess: isPro,
    };
    this.saveSettings();
  }

  resetToDefaults(): void {
    this.settings = { ...DEFAULT_SETTINGS };
    this.saveSettings();
  }

  subscribe(callback: () => void): () => void {
    this.subscribers.add(callback);
    return () => this.subscribers.delete(callback);
  }
}

// Singleton instance
const settingsManager = new SettingsManager();

// React hook for settings
export function useSettings() {
  const [settings, setSettings] = React.useState(() => settingsManager.getSettings());

  React.useEffect(() => {
    // ‚ö†Ô∏è REMOVED: flickerDiagnostics logging disabled
    const unsubscribe = settingsManager.subscribe(() => {
      const newSettings = settingsManager.getSettings();
      // ‚ö†Ô∏è REMOVED: flickerDiagnostics logging disabled
      setSettings(newSettings);
    });
    return unsubscribe;
  }, []);

  return settings;
}

// React hook for specific setting
export function useSetting<K extends keyof Settings>(key: K): Settings[K] {
  const settings = useSettings();
  return settings[key];
}

// Export manager for direct access
export { settingsManager };

// Personality text variations - Apple App Store compliant
export const PERSONALITY_TEXTS = {
  1: { // Regular - Friendly and helpful
    welcome: "Welcome back, {username}! ‚ú®",
    empty: "No shows here yet.",
    add: "Add some shows to get started!",
    sarcasm: "",
    
    // Empty states
    emptyWatching: "No shows in your currently watching list.",
    emptyWishlist: "Your wishlist is empty.",
    emptyWatched: "You haven't marked anything as watched yet.",
    emptyUpNext: "No upcoming episodes scheduled.",
    
    // User interactions
    itemAdded: "Added to your list!",
    itemRemoved: "Removed from your list.",
    searchEmpty: "No results found. Try a different search.",
    searchLoading: "Searching...",
    
    // Error messages
    errorGeneric: "Something went wrong. Please try again.",
    errorNetwork: "Network error. Check your connection.",
    errorNotFound: "Content not found.",
    
    // Success messages
    successSave: "Settings saved!",
    successImport: "Data imported successfully!",
    successExport: "Data exported successfully!",
    
    // Marquee messages
    marquee1: "Discover your next favorite show",
    marquee2: "Track what you're watching",
    marquee3: "Never miss an episode",
    marquee4: "Find your next binge-watch",
    marquee5: "Organize your entertainment",
  },
  
  2: { // Semi-sarcastic - A bit cheeky (Apple-safe)
    welcome: "Oh, you're back, {username}. How... delightful.",
    empty: "Well, this is awkward. Nothing here.",
    add: "Maybe try adding something? Just a thought.",
    sarcasm: "Because clearly you need help.",
    
    // Empty states
    emptyWatching: "Well, this is awkward. Nothing here.",
    emptyWishlist: "Your wishlist is as empty as a Monday morning.",
    emptyWatched: "You haven't watched anything? That's... impressive.",
    emptyUpNext: "No episodes coming up. Shocking.",
    
    // User interactions
    itemAdded: "There you go. You're welcome.",
    itemRemoved: "And it's gone. Poof.",
    searchEmpty: "Nothing found. Surprise, surprise.",
    searchLoading: "Searching... this might take a while.",
    
    // Error messages
    errorGeneric: "Well, that didn't work. Shocking.",
    errorNetwork: "No internet? In this day and age?",
    errorNotFound: "It's gone. Vanished. Poof.",
    
    // Success messages
    successSave: "Settings saved. Finally.",
    successImport: "Data imported. Hope it's better than the last batch.",
    successExport: "Data exported. Don't lose it this time.",
    
    // Marquee messages
    marquee1: "Because clearly you need help finding shows",
    marquee2: "Track what you're watching (if anything)",
    marquee3: "Never miss an episode (that exists)",
    marquee4: "Find your next binge-watch (good luck)",
    marquee5: "Organize your entertainment (finally)",
  },
  
  3: { // Severely sarcastic - Maximum sass (Apple-safe, no user-directed digs)
    welcome: "Oh joy, {username}. Another visit. I'm absolutely thrilled.",
    empty: "Shocking. Absolutely shocking that this is empty.",
    add: "Perhaps you'd like to actually use this app? Revolutionary concept.",
    sarcasm: "I'm sure this will end well.",
    
    // Empty states - Apple-safe: punch at the situation, not the user
    emptyWatching: "This list is emptier than a politician's promises.",
    emptyWishlist: "Your wishlist is emptier than a Monday morning coffee shop.",
    emptyWatched: "Nothing watched yet. The algorithm is probably confused.",
    emptyUpNext: "No episodes coming up. What a surprise. I'm devastated.",
    
    // User interactions - Apple-safe: focus on the action, not the user
    itemAdded: "There. The algorithm is pleased.",
    itemRemoved: "Gone. Vanished. Like my will to live.",
    searchEmpty: "Nothing found. What a shock. I'm devastated.",
    searchLoading: "Searching... this could take forever. Literally.",
    
    // Error messages - Apple-safe: punch at the technology, not the user
    errorGeneric: "It broke. Shocking. Absolutely shocking.",
    errorNetwork: "No internet? What is this, 1995?",
    errorNotFound: "It's gone. Disappeared. Like my hopes and dreams.",
    
    // Success messages - Apple-safe: focus on the system, not the user
    successSave: "Settings saved. The system is pleased.",
    successImport: "Data imported. Hope it's not as disappointing as everything else.",
    successExport: "Data exported. Don't lose it. Again.",
    
    // Marquee messages - Apple-safe: punch at the situation, not the user
    marquee1: "Discover your next favorite show (if such a thing exists)",
    marquee2: "Track what you're watching (assuming you watch anything)",
    marquee3: "Never miss an episode (that actually airs)",
    marquee4: "Find your next binge-watch (good luck with that)",
    marquee5: "Organize your entertainment (finally, some order)",
  },
};

// Get personality text
export function getPersonalityText(
  key: keyof typeof PERSONALITY_TEXTS[1], 
  personalityLevel: PersonalityLevel,
  context?: { username?: string }
): string {
  const text = PERSONALITY_TEXTS[personalityLevel][key];
  
  // Replace {username} placeholder if provided
  if (context?.username) {
    return text.replace('{username}', context.username);
  }
  
  return text;
}

```

## apps/web/src/components/games/FlickWordGame.tsx
### Summary
FlickWord game UI that references themed discovery content and shares stats that could connect to ratings.
### Content
```tsx
/**
 * Process: FlickWord Game Component
 * Purpose: Wordle-style word guessing game with daily word challenges
 * Data Source: dailyWordApi for target word, validateWord for guess validation
 * Update Path: Game state managed via React hooks, localStorage for stats
 * Dependencies: dailyWordApi, validateWord, flickword.css
 */

import { useState, useEffect, useCallback, useMemo, useRef } from "react";
import { useProStatus } from "../../lib/proStatus";
import { getTodaysWord } from "../../lib/dailyWordApi";
import { validateWord } from "../../lib/words/validateWord";
import { getDailySeedDate } from "../../lib/dailySeed";
import { getFlickWordGameStateKey, getFlickWordGamesCompletedKey, getFlickWordDailyKey } from '../../lib/cacheKeys';
import { useOnlineStatus } from '../../hooks/useOnlineStatus';
import { saveCompletedFlickWordGame, getCompletedFlickWordGames } from '../../lib/gameReview';
import { trackFlickWordGameStart, trackFlickWordGameComplete, trackFlickWordGuess, trackFlickWordShare, trackGameError } from '../../lib/analytics';
import { shareWithFallback } from '../../lib/shareLinks';
import { getToastCallback } from '@/state/actions';
import { parseFlickWordShareParams, storageKeyFlickWordShareParams, type FlickWordShareParams } from '../../lib/games/flickwordShared';

// Game configuration
const KEYBOARD_ROWS = ["QWERTYUIOP", "ASDFGHJKL", "ZXCVBNM"];
const NOTIFICATION_DURATION = 3000;
const ANIMATION_DELAY_BASE = 100; // Base delay for tile animations

// Types
type TileStatus = "correct" | "present" | "absent" | "";
type NotificationType = "success" | "error" | "info" | "warning";
type AnimationState = "idle" | "entering" | "revealing" | "revealed";

interface Notification {
  id: string;
  message: string;
  type: NotificationType;
  timestamp: number;
}

interface GameState {
  target: string;
  guesses: string[];
  current: string;
  maxGuesses: number;
  done: boolean;
  status: Record<string, TileStatus>;
  lastResults: TileStatus[][];
  wordInfo?: {
    definition?: string;
    difficulty?: string;
  };
  showHint: boolean;
  animationState: AnimationState;
}

interface FlickWordGameProps {
  onClose?: () => void;
  onGameComplete?: (won: boolean, guesses: number) => void;
  onShowStats?: () => void;
  onShowReview?: (params?: FlickWordShareParams | null) => void;
}

// Saved game state (excludes transient animation state)
interface SavedGameState {
  target: string;
  guesses: string[];
  current: string;
  maxGuesses: number;
  done: boolean;
  status: Record<string, TileStatus>;
  lastResults: TileStatus[][];
  wordInfo?: {
    definition?: string;
    difficulty?: string;
  };
  showHint: boolean;
  date: string; // Date when this game state was saved
  gameNumber?: number; // Game number (1-3 for Pro users, 1 for Regular)
}

/**
 * Save game state to localStorage
 */
function saveGameState(game: GameState, date: string, gameNumber?: number): void {
  try {
    const savedState: SavedGameState = {
      target: game.target,
      guesses: game.guesses,
      current: game.current,
      maxGuesses: game.maxGuesses,
      done: game.done,
      status: game.status,
      lastResults: game.lastResults,
      wordInfo: game.wordInfo,
      showHint: game.showHint,
      date,
      gameNumber,
    };
    localStorage.setItem(getFlickWordGameStateKey(), JSON.stringify(savedState));
    console.log("üíæ Game state saved:", {
      target: game.target,
      guesses: game.guesses.length,
      date,
      gameNumber,
    });
  } catch (error) {
    if (error instanceof DOMException && error.name === 'QuotaExceededError') {
      console.error("‚ùå localStorage quota exceeded. Cannot save game state.");
      // Could show user notification here
    } else {
      console.warn("Failed to save game state:", error);
    }
  }
}

/**
 * Find in-progress game state for today (any game number)
 * Returns the saved state and its gameNumber if found, null otherwise
 * This is used during initialization to determine which game to restore
 */
function findInProgressGameState(currentDate: string): { state: SavedGameState; gameNumber: number } | null {
  try {
    const saved = localStorage.getItem(getFlickWordGameStateKey());
    if (!saved) return null;

    const savedState: SavedGameState = JSON.parse(saved);
    const savedGameNumber = savedState.gameNumber ?? 1; // Default to 1 for legacy saves

    // Check if it's for today and NOT done (in-progress)
    if (
      savedState.date === currentDate &&
      savedState.done === false &&
      savedState.target
    ) {
      console.log("üìÇ Found in-progress game state:", {
        target: savedState.target,
        guesses: savedState.guesses.length,
        gameNumber: savedGameNumber,
      });
      return { state: savedState, gameNumber: savedGameNumber };
    }

    return null;
  } catch (error) {
    console.warn("Failed to find in-progress game state:", error);
    return null;
  }
}

/**
 * Restore game state from localStorage
 * Returns null if no saved state or state is for a different day/game
 */
function restoreGameState(currentDate: string, currentGameNumber: number): SavedGameState | null {
  try {
    const saved = localStorage.getItem(getFlickWordGameStateKey());
    if (!saved) return null;

    const savedState: SavedGameState = JSON.parse(saved);

    // Restore if it's for today's word and same game number
    // Allow restoring completed games so users can see their results
    const savedGameNumber = savedState.gameNumber ?? 1; // Default to 1 for legacy saves
    if (
      savedState.date === currentDate &&
      savedGameNumber === currentGameNumber &&
      savedState.target
    ) {
      console.log("üìÇ Game state restored:", {
        target: savedState.target,
        guesses: savedState.guesses.length,
        gameNumber: savedGameNumber,
        done: savedState.done,
      });
      return savedState;
    } else if (savedState.date !== currentDate || savedGameNumber !== currentGameNumber) {
      // Clear old game state from different day or game number
      localStorage.removeItem(getFlickWordGameStateKey());
      console.log("üóëÔ∏è Cleared game state from different day/game");
    }

    return null;
  } catch (error) {
    console.warn("Failed to restore game state:", error);
    // Clear corrupted state
    localStorage.removeItem(getFlickWordGameStateKey());
    return null;
  }
}

/**
 * Clear saved game state
 */
function clearGameState(): void {
  try {
    localStorage.removeItem(getFlickWordGameStateKey());
    console.log("üóëÔ∏è Game state cleared");
  } catch (error) {
    console.warn("Failed to clear game state:", error);
  }
}

export default function FlickWordGame({
  onClose,
  onGameComplete,
  onShowStats,
  onShowReview,
}: FlickWordGameProps) {
  const { isPro } = useProStatus();
  const [game, setGame] = useState<GameState>({
    target: "",
    guesses: [],
    current: "",
    maxGuesses: 6,
    done: false,
    status: {},
    lastResults: [],
    showHint: false,
    animationState: "idle",
  });
  const [notifications, setNotifications] = useState<Notification[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [isInvalidInput, setIsInvalidInput] = useState(false);
  const [errorMessage, setErrorMessage] = useState<string | null>(null);
  const [gamesCompletedToday, setGamesCompletedToday] = useState(0);
  const [currentGame, setCurrentGame] = useState(1); // Track current game number (1-3 for Pro, 1 for Regular)
  const [showLostScreen, setShowLostScreen] = useState(false);
  const [showWinScreen, setShowWinScreen] = useState(false);
  const [showShareModal, setShowShareModal] = useState(false);
  const [showProChip, setShowProChip] = useState(false);
  const [isSubmittingUI, setIsSubmittingUI] = useState(false); // UI state for validation feedback
  const gridRef = useRef<HTMLDivElement>(null);
  const notificationTimeoutRef = useRef<number | null>(null);
  const tileRefs = useRef<(HTMLDivElement | null)[][]>([]);
  const isSubmittingRef = useRef<boolean>(false); // Guard against concurrent submissions
  const currentGameStateRef = useRef<GameState | null>(null); // Capture game state for async operations
  const isOnline = useOnlineStatus();

  // Game limits: Regular users get 1 game per day, Pro users get 3 games per day
  const MAX_GAMES_FREE = 1; // Regular users get 1 game per day
  const MAX_GAMES_PRO = 3; // Pro users get 3 games per day

  // Get games completed today for FlickWord (uses UTC date for consistency)
  const getGamesCompletedToday = (): number => {
    try {
      const today = getDailySeedDate(); // UTC-based date
      const key = getFlickWordGamesCompletedKey(today);
      const count = parseInt(localStorage.getItem(key) || "0", 10);
      // Cap to max games to prevent invalid counts
      const maxGames = isPro ? MAX_GAMES_PRO : MAX_GAMES_FREE;
      return Math.min(count, maxGames);
    } catch {
      return 0;
    }
  };

  // Save games completed today (uses UTC date for consistency)
  const saveGamesCompletedToday = (count: number): void => {
    try {
      const today = getDailySeedDate(); // UTC-based date
      const key = getFlickWordGamesCompletedKey(today);
      localStorage.setItem(key, String(count));
    } catch (e) {
      if (e instanceof DOMException && e.name === 'QuotaExceededError') {
        console.error("‚ùå localStorage quota exceeded. Cannot save games completed count.");
        showNotification("Storage full. Game progress may not be saved.", "warning");
      } else {
        console.warn("Failed to save games completed:", e);
      }
    }
  };

  // Initialize games completed and current game
  // FIXED: Check for in-progress games first, then calculate next game from completed count
  // This prevents "Game 2" from showing when user just completed Game 1
  useEffect(() => {
    const maxGames = isPro ? MAX_GAMES_PRO : MAX_GAMES_FREE;
    const today = getDailySeedDate();
    
    // Step 1: Check for in-progress game state first
    const inProgressGame = findInProgressGameState(today);
    
    if (inProgressGame) {
      // Found in-progress game - restore it immediately
      const { state, gameNumber } = inProgressGame;
      setCurrentGame(gameNumber);
      
      // Restore the game state directly (don't wait for loadTodaysWord)
      setGame({
        ...state,
        animationState: "idle" as AnimationState,
      });
      setIsLoading(false);
      
      // Set gamesCompletedToday based on the in-progress game
      // If gameNumber is 2, then at most 1 game is completed (gameNumber - 1)
      const estimatedCompleted = Math.max(0, gameNumber - 1);
      const completed = getGamesCompletedToday();
      // Use the minimum to be safe (don't overcount)
      const safeCompleted = Math.min(completed, estimatedCompleted);
      setGamesCompletedToday(safeCompleted);
      console.log(
        "üéØ Found and restored in-progress game:",
        "Game number:",
        gameNumber,
        "Estimated completed:",
        safeCompleted,
        `(${isPro ? "Pro" : "Regular"}: ${maxGames} ${maxGames === 1 ? "game" : "games"} per day)`
      );
    } else {
      // Step 2: No in-progress game - calculate from completed count
      const completed = getGamesCompletedToday();
      // Clamp completed to valid range
      const clampedCompleted = Math.min(Math.max(0, completed), maxGames);
      setGamesCompletedToday(clampedCompleted);
      
      // Step 3: Determine currentGame
      // If all games are completed, stay on the last game
      // Otherwise, set to the next game to start
      let nextGame: number;
      if (clampedCompleted >= maxGames) {
        // All games completed - stay on last game
        nextGame = maxGames;
      } else {
        // Next game to start
        nextGame = clampedCompleted + 1;
      }
      
      setCurrentGame(nextGame);
      console.log(
        "üéØ User games status:",
        "Games completed today:",
        clampedCompleted,
        "Starting game:",
        nextGame,
        `(${isPro ? "Pro" : "Regular"}: ${maxGames} ${maxGames === 1 ? "game" : "games"} per day)`
      );
    }
  }, [isPro]);

  // Check for reduced motion preference
  const prefersReducedMotion = useMemo(() => {
    if (typeof window === "undefined") return false;
    return window.matchMedia("(prefers-reduced-motion: reduce)").matches;
  }, []);

  // Get today's word from API (deterministic based on date and game number)
  // Regular: 1 word per day (gameNumber = 1)
  // Pro: 3 words per day (gameNumber = 1, 2, or 3)
  const loadTodaysWord = useCallback(
    async (forceNew: boolean = false, restoreState: boolean = true) => {
      try {
        setIsLoading(true);
        // Validate and clamp game number to valid range (1-3)
        let gameNumber = isPro ? currentGame : 1;
        if (gameNumber < 1 || gameNumber > 3) {
          console.warn(`Invalid game number ${gameNumber}, clamping to valid range`);
          gameNumber = Math.max(1, Math.min(3, gameNumber));
        }
        console.log(`üîÑ Loading today's word for game ${gameNumber}...`);

        // Get today's date (UTC-based for consistent daily content)
        const today = getDailySeedDate();

        // If forcing new word, clear cache first
        if (forceNew) {
          const gameCacheKey = getFlickWordDailyKey(gameNumber);
          localStorage.removeItem(gameCacheKey);
          clearGameState(); // Also clear game state when forcing new word
          console.log("üóëÔ∏è Cleared word cache for new word");
        }

        // Try to restore saved game state first (if not forcing new)
        // Only restore if it's for the same game number
        if (restoreState && !forceNew) {
          const savedState = restoreGameState(today, gameNumber);
          if (savedState && savedState.target) {
            // Restore game state (including keyboard status)
            setGame({
              ...savedState,
              animationState: "idle", // Always reset animation state
            });
            setIsLoading(false);
            console.log("‚úÖ Game state restored from previous session");
            return;
          }
        }

        // Use daily word - pass gameNumber for Pro users
        const wordData = await getTodaysWord(gameNumber);
        console.log(`üì¶ Daily word data received for game ${gameNumber}:`, wordData);

        // Validate that we got a proper word (comprehensive validation)
        if (wordData && wordData.word && 
            typeof wordData.word === 'string' &&
            wordData.word.length === 5 &&
            /^[a-zA-Z]{5}$/.test(wordData.word)) {
          // Reset keyboard status when starting a new game
          const newGameState = {
            target: wordData.word.toUpperCase(),
            guesses: [],
            current: "",
            maxGuesses: 6,
            done: false,
            status: {}, // Reset keyboard status for new game
            lastResults: [],
            wordInfo: {
              definition: wordData.definition,
              difficulty: wordData.difficulty,
            },
            showHint: false,
            animationState: "idle" as AnimationState,
          };

          setGame(newGameState);

          // Save initial state
          saveGameState(newGameState, today, gameNumber);
          
          // Track game start analytics
          trackFlickWordGameStart(gameNumber, isPro);

          console.log(`‚úÖ Game target set to: ${wordData.word.toUpperCase()} (game ${gameNumber})`);
        } else {
          throw new Error("Invalid word data received");
        }
      } catch (error) {
        console.error("‚ùå Failed to load daily word:", error);
        setErrorMessage("Failed to load today's word. Using backup word.");
        // Fallback to different words for different game numbers (deterministic based on date + game number)
        const fallbackWords = ["HOUSE", "CRANE", "BLISS"];
        const gameNumber = isPro ? currentGame : 1;
        // Use date + game number for deterministic fallback selection
        const fallbackDate = getDailySeedDate(); // UTC-based date
        const dateSeed = parseInt(fallbackDate.replace(/-/g, ''), 10);
        const combinedSeed = dateSeed + (gameNumber - 1) * 1000;
        const fallbackIndex = combinedSeed % fallbackWords.length;
        const fallbackWord = fallbackWords[fallbackIndex];
        console.log(`üîÑ Using fallback word for game ${gameNumber}:`, fallbackWord);
        const fallbackState = {
          target: fallbackWord,
          guesses: [],
          current: "",
          maxGuesses: 6,
          done: false,
          status: {}, // Reset keyboard status
          lastResults: [],
          wordInfo: {
            definition: "A building for human habitation",
            difficulty: "easy",
          },
          showHint: false,
          animationState: "idle" as AnimationState,
        };
        setGame(fallbackState);
        saveGameState(fallbackState, fallbackDate, gameNumber);
      } finally {
        setIsLoading(false);
        console.log("üèÅ Word loading complete");
      }
    },
    [isPro, currentGame]
  );

  // Note: Removed unused _handleNewWord function to reduce code complexity
  // If dev testing feature is needed in future, implement proper dev mode testing interface

  // Score guess
  const scoreGuess = useCallback(
    (guess: string, target: string): TileStatus[] => {
      const result: TileStatus[] = Array(5).fill("absent");
      const pool = target.split("");

      // First pass: exact matches
      for (let i = 0; i < 5; i++) {
        if (guess[i] === pool[i]) {
          result[i] = "correct";
          pool[i] = "";
        }
      }

      // Second pass: present matches
      for (let i = 0; i < 5; i++) {
        if (result[i] === "correct") continue;
        const idx = pool.indexOf(guess[i]);
        if (idx !== -1) {
          result[i] = "present";
          pool[idx] = "";
        }
      }

      return result;
    },
    []
  );

  // Enhanced notification system with auto-dismiss and icons
  const showNotification = useCallback(
    (message: string, type: NotificationType) => {
      // Prevent duplicate notifications - check if same message already exists
      setNotifications((prev) => {
        const duplicate = prev.find(
          (n) => n.message === message && n.type === type
        );
        if (duplicate) {
          // Already showing this notification, don't add another
          return prev;
        }

        const id = `notification-${Date.now()}-${Math.random()}`;
        const notification: Notification = {
          id,
          message,
          type,
          timestamp: Date.now(),
        };

        // Auto-dismiss after duration
        if (notificationTimeoutRef.current) {
          clearTimeout(notificationTimeoutRef.current);
        }
        notificationTimeoutRef.current = window.setTimeout(() => {
          setNotifications((p) => p.filter((n) => n.id !== id));
          notificationTimeoutRef.current = null;
        }, NOTIFICATION_DURATION);

        return [...prev, notification];
      });
    },
    []
  );

  // Clear notifications on unmount and ensure all timeouts are cleared
  useEffect(() => {
    return () => {
      if (notificationTimeoutRef.current) {
        clearTimeout(notificationTimeoutRef.current);
        notificationTimeoutRef.current = null;
      }
      // Clear any pending notifications
      setNotifications([]);
    };
  }, []);

  // Initialize game
  // Only loads word if game state hasn't been restored yet
  const initializeGame = useCallback(() => {
    // Check if we already have a game state loaded (from in-progress restore)
    // If game.target exists and we're not loading, skip loading
    if (game.target && !isLoading) {
      console.log("‚úÖ Game already initialized, skipping loadTodaysWord");
      return;
    }
    loadTodaysWord();
  }, [loadTodaysWord, game.target, isLoading]);

  // Start next game - Regular: 1 game/day, Pro: 3 games/day
  const handleNextGame = useCallback(() => {
    const maxGames = isPro ? MAX_GAMES_PRO : MAX_GAMES_FREE;
    if (gamesCompletedToday < maxGames) {
      const nextGame = Math.min(gamesCompletedToday + 1, maxGames);
      // Validate game number bounds
      const validatedGame = Math.max(1, Math.min(maxGames, nextGame));
      setCurrentGame(validatedGame);
      setShowWinScreen(false);
      setShowLostScreen(false);
      // Reset game state for new game (including keyboard status)
      setGame({
        target: "",
        guesses: [],
        current: "",
        maxGuesses: 6,
        done: false,
        status: {}, // Reset keyboard status for new game
        lastResults: [],
        wordInfo: undefined,
        showHint: false,
        animationState: "idle" as AnimationState,
      });
      // Clear tile refs to prevent unbounded growth
      tileRefs.current = [];
      clearGameState();
      // Load new word for next game
      loadTodaysWord(false, false); // Don't restore state, force new game
    }
  }, [gamesCompletedToday, loadTodaysWord, isPro]);

  // Handle key input
  // FIXED: Disable input during validation
  const handleKeyInput = useCallback((letter: string) => {
    if (isSubmittingUI) return; // Block input during validation
    setGame((prev) => {
      if (prev.done || prev.current.length >= 5) return prev;
      const newState = {
        ...prev,
        current: prev.current + letter,
      };
      // Save state after input
      const today = getDailySeedDate(); // UTC-based date
      const gameNumber = isPro ? currentGame : 1;
      saveGameState(newState, today, gameNumber);
      return newState;
    });
  }, [isPro, currentGame, isSubmittingUI]);

  // Handle backspace
  // FIXED: Disable input during validation
  const handleBackspace = useCallback(() => {
    if (isSubmittingUI) return; // Block input during validation
    setGame((prev) => {
      if (prev.done || !prev.current) return prev;
      const newState = {
        ...prev,
        current: prev.current.slice(0, -1),
      };
      // Save state after backspace
      const today = getDailySeedDate(); // UTC-based date
      const gameNumber = isPro ? currentGame : 1;
      saveGameState(newState, today, gameNumber);
      return newState;
    });
  }, [isPro, currentGame, isSubmittingUI]);

  // Handle submit - fixed race condition by moving async outside setGame
  // FIXED: Added try/finally to guarantee reset, added visual feedback during validation
  const handleSubmit = useCallback(async () => {
    // Guard against concurrent submissions
    if (isSubmittingRef.current || isSubmittingUI) {
      console.log("‚ùå Submit blocked: already submitting");
      return;
    }

    // Get current game state before async operations
    let shouldProceed = false;
    setGame((prev) => {
      // Check if can submit
      if (prev.done || prev.current.length !== 5 || isSubmittingRef.current) {
        console.log("‚ùå Submit blocked:", {
          done: prev.done,
          length: prev.current.length,
          isSubmitting: isSubmittingRef.current,
        });
        currentGameStateRef.current = null;
        return prev;
      }

      // Set submitting flags and capture state
      isSubmittingRef.current = true;
      currentGameStateRef.current = prev;
      shouldProceed = true;
      return prev; // Return unchanged state, we'll update it after validation
    });

    // Wait for state to be set
    await new Promise(resolve => setTimeout(resolve, 0));

    // Check if we have valid state
    const currentGameState = currentGameStateRef.current;
    if (!currentGameState || !shouldProceed) {
      console.error("‚ùå No game state available for validation");
      isSubmittingRef.current = false;
      setIsSubmittingUI(false);
      return;
    }

    // Set UI state to show validation feedback
    setIsSubmittingUI(true);

    // Now do async validation outside of setGame callback
    const currentWord = currentGameState.current;
    const currentTarget = currentGameState.target;

    try {
      console.log("üîç Validating word:", currentWord);
      const verdict = await validateWord(currentWord);
      console.log("‚úÖ Word validation result:", verdict);

      if (!verdict.valid) {
        // Track validation error
        trackGameError('flickword', 'invalid_word', { word: currentWord, reason: verdict.reason });
        setIsInvalidInput(true);

        if (verdict.reason === "length") {
          showNotification("Use 5 letters.", "error");
        } else if (
          verdict.reason === "charset" ||
          verdict.reason === "format"
        ) {
          showNotification("Letters only.", "error");
        } else {
          showNotification("Not a valid word.", "error");
        }

        // Reset invalid state after animation
        setTimeout(
          () => {
            setIsInvalidInput(false);
            setGame((p) => ({ ...p, current: "" }));
          },
          prefersReducedMotion ? 300 : 600
        );
        return;
      }

      // Check if word has already been guessed
      if (currentGameState.guesses.includes(currentWord)) {
        showNotification("You already tried that word!", "error");
        setTimeout(
          () => {
            setGame((p) => ({ ...p, current: "" }));
          },
          prefersReducedMotion ? 300 : 600
        );
      return;
    }

      // Word is valid - proceed with scoring and animation
      const result = scoreGuess(currentWord, currentTarget);
      
      // Track guess analytics
      trackFlickWordGuess(currentWord, currentGameState.guesses.length + 1);
      
      const newStatus = { ...currentGameState.status };

      // Update keyboard status - prioritize correct > present > absent
      for (let i = 0; i < 5; i++) {
        const letter = currentWord[i];
        const currentStatus = newStatus[letter];
        
        if (result[i] === "correct") {
          // Always set correct (highest priority)
          newStatus[letter] = "correct";
        } else if (result[i] === "present") {
          // Set present only if not already correct
          if (currentStatus !== "correct") {
            newStatus[letter] = "present";
          }
        } else if (result[i] === "absent") {
          // Set absent only if no status exists yet (don't downgrade correct/present)
          if (!currentStatus) {
            newStatus[letter] = "absent";
          }
        }
      }

      const newGuesses = [...currentGameState.guesses, currentWord];
      const newLastResults = [...currentGameState.lastResults, result];
      const saveDate = getDailySeedDate(); // UTC-based date
      const gameNumber = isPro ? currentGame : 1;

      // Start reveal animation - clear UI submitting state once grid updates
      setGame((p) => {
        const revealingState = {
          ...p,
          animationState: "revealing" as AnimationState,
          guesses: newGuesses,
          lastResults: newLastResults,
          status: newStatus,
        };
        // Save state after submitting guess (before reveal animation)
        saveGameState(revealingState, saveDate, gameNumber);
        return revealingState;
      });

      // Clear UI submitting state now that grid has updated
      setIsSubmittingUI(false);

      // Complete animation after delay
      const animationDelay = prefersReducedMotion
        ? 300
        : ANIMATION_DELAY_BASE * 5;
      setTimeout(() => {
        setGame((p) => ({
          ...p,
          animationState: "revealed",
          current: "",
        }));
      }, animationDelay);

      if (currentWord === currentTarget) {
        setTimeout(() => {
          showNotification("üéâ Correct! Well done!", "success");
          const gameNumber = isPro ? currentGame : 1;
          const today = getDailySeedDate();
          
          // Save completed game for review
          // Convert TileStatus[][] to Array<'correct' | 'present' | 'absent'>[]
          // scoreGuess always returns valid statuses (never empty strings in practice)
          const convertedResults: Array<'correct' | 'present' | 'absent'>[] = newLastResults.map(row =>
            row.filter((status): status is 'correct' | 'present' | 'absent' => 
              status !== ''
            ) as Array<'correct' | 'present' | 'absent'>
          );
          saveCompletedFlickWordGame({
            date: today,
            gameNumber,
            target: currentTarget,
            guesses: newGuesses,
            won: true,
            lastResults: convertedResults,
            completedAt: Date.now(),
          });
          
          // Track analytics
          trackFlickWordGameComplete(true, newGuesses.length, gameNumber, isPro);
          
          setGame((p) => {
            const completedState = {
              ...p,
              done: true,
              animationState: "idle" as AnimationState,
            };
            // Save completed state so it can be restored later
            saveGameState(completedState, today, gameNumber);
            return completedState;
          });
          // Update games completed today (cap to max games)
          const maxGames = isPro ? MAX_GAMES_PRO : MAX_GAMES_FREE;
          const newGamesCompleted = Math.min(gamesCompletedToday + 1, maxGames);
          setGamesCompletedToday(newGamesCompleted);
          saveGamesCompletedToday(newGamesCompleted);
          onGameComplete?.(true, newGuesses.length);
          isSubmittingRef.current = false; // Reset submitting flag
          // Show win screen after animation
          setTimeout(() => {
            setShowWinScreen(true);
          }, 500);
        }, animationDelay);
      } else if (newGuesses.length === currentGameState.maxGuesses) {
        setTimeout(() => {
          const gameNumber = isPro ? currentGame : 1;
          const today = getDailySeedDate();
          
          // Save completed game for review
          // Convert TileStatus[][] to Array<'correct' | 'present' | 'absent'>[]
          // scoreGuess always returns valid statuses (never empty strings in practice)
          const convertedResults: Array<'correct' | 'present' | 'absent'>[] = newLastResults.map(row =>
            row.filter((status): status is 'correct' | 'present' | 'absent' => 
              status !== ''
            ) as Array<'correct' | 'present' | 'absent'>
          );
          saveCompletedFlickWordGame({
            date: today,
            gameNumber,
            target: currentTarget,
            guesses: newGuesses,
            won: false,
            lastResults: convertedResults,
            completedAt: Date.now(),
          });
          
          // Track analytics
          trackFlickWordGameComplete(false, newGuesses.length, gameNumber, isPro);
          
          setGame((p) => {
            const completedState = {
              ...p,
              done: true,
              animationState: "idle" as AnimationState,
            };
            // Save completed state so it can be restored later
            saveGameState(completedState, today, gameNumber);
            return completedState;
          });
          // Update games completed today (cap to max games)
          const maxGames = isPro ? MAX_GAMES_PRO : MAX_GAMES_FREE;
          const newGamesCompleted = Math.min(gamesCompletedToday + 1, maxGames);
          setGamesCompletedToday(newGamesCompleted);
          saveGamesCompletedToday(newGamesCompleted);
          onGameComplete?.(false, newGuesses.length);
          isSubmittingRef.current = false; // Reset submitting flag
          // Show lost screen after animation
          setTimeout(() => {
            setShowLostScreen(true);
          }, 500);
        }, animationDelay);
      } else {
        setTimeout(() => {
          setGame((p) => {
            const newState = {
              ...p,
              animationState: "idle" as AnimationState,
            };
            // Save state after guess (before animation completes)
            const gameNumber = isPro ? currentGame : 1;
            saveGameState(newState, saveDate, gameNumber);
            isSubmittingRef.current = false; // Reset submitting flag
            return newState;
          });
        }, animationDelay);
      }
    } catch (error) {
      // Handle validation errors or network failures
      console.error("‚ùå Error during word validation or submission:", error);
      showNotification("Unable to validate word. Please try again.", "error");
      setGame((p) => ({ ...p, current: "" }));
    } finally {
      // ALWAYS reset both flags, regardless of success or failure
      isSubmittingRef.current = false;
      setIsSubmittingUI(false);
    }
  }, [scoreGuess, showNotification, onGameComplete, prefersReducedMotion, isPro, currentGame, gamesCompletedToday, isSubmittingUI]);

  // Keyboard event handling
  // FIXED: Disable input during validation to prevent spam and show clear feedback
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (game.done || isLoading || isSubmittingUI) return;

      if (e.key === "Backspace") {
        e.preventDefault();
        handleBackspace();
      } else if (e.key === "Enter") {
        e.preventDefault();
        handleSubmit();
      } else if (e.key.length === 1 && e.key.match(/[a-zA-Z]/)) {
        e.preventDefault();
        handleKeyInput(e.key.toUpperCase());
      }
    };

    document.addEventListener("keydown", handleKeyDown);
    return () => document.removeEventListener("keydown", handleKeyDown);
  }, [game.done, isLoading, isSubmittingUI, handleBackspace, handleSubmit, handleKeyInput]);

  // Check for share link params on mount
  // Share params flow: App.tsx ‚Üí localStorage ‚Üí FlickWordGame ‚Üí FlickWordModal ‚Üí FlickWordReview
  useEffect(() => {
    try {
      const shareParamsStr = localStorage.getItem(storageKeyFlickWordShareParams);
      if (shareParamsStr) {
        const raw = JSON.parse(shareParamsStr);
        const shareParams = parseFlickWordShareParams(raw);
        
        if (shareParams) {
          console.log("[FlickWord] Share link params detected:", shareParams);
          
          // If mode is 'sharedResult' or 'sharedAll', show review screen
          if ((shareParams.mode === "sharedResult" || shareParams.mode === "sharedAll") && shareParams.date) {
            // Navigate to review screen with share params
            // The review screen will filter by date/gameNumber based on mode
            if (onShowReview) {
              onShowReview(shareParams);
            }
          }
          // Note: We do NOT clear share params here - FlickWordReview will clear them after reading
        } else {
          // Invalid params, clear them
          localStorage.removeItem(storageKeyFlickWordShareParams);
        }
      }
    } catch (e) {
      console.warn("Failed to process share params:", e);
      // Clear corrupted params
      try {
        localStorage.removeItem(storageKeyFlickWordShareParams);
      } catch {
        // Ignore cleanup errors
      }
    }
  }, [onShowReview]);

  // Initialize game on mount
  useEffect(() => {
    initializeGame();
  }, [initializeGame]);

  // Handle explore shows button - navigate to search with word
  const handleExploreShows = useCallback(() => {
    setShowLostScreen(false);
    // Dispatch custom event to trigger search in App
    window.dispatchEvent(new CustomEvent('flickword:explore', {
      detail: { word: game.target }
    }));
    // Also try to set search via localStorage for App to pick up
    try {
      localStorage.setItem('flickword:search-word', game.target);
    } catch (e) {
      console.warn('Failed to set search word:', e);
    }
    // Close modal and navigate
    if (onClose) {
      onClose();
    }
    // Navigate to discovery/search view
    window.history.pushState({}, '', '/');
    window.dispatchEvent(new PopStateEvent('popstate'));
    window.dispatchEvent(new CustomEvent('pushstate'));
  }, [game.target, onClose]);

  // Generate share text (Wordle-style grid) - single game
  // Note: URL is NOT included here - it will be added by shareWithFallback
  const generateShareText = useCallback((gameNumber?: number) => {
    const lines: string[] = [];
    const shareGameNumber = gameNumber ?? (isPro ? currentGame : 1);
    const gameLabel = isPro ? ` Game ${shareGameNumber}` : '';
    lines.push(`FlickWord ${getDailySeedDate()}${gameLabel}`);
    lines.push('');
    
    for (let i = 0; i < game.guesses.length; i++) {
      const result = game.lastResults[i] || [];
      const line = result.map(status => {
        if (status === 'correct') return 'üü©';
        if (status === 'present') return 'üü®';
        return '‚¨ú';
      }).join('');
      lines.push(line);
    }
    
    lines.push('');
    lines.push('Play FlickWord at flicklet.netlify.app');
    
    return lines.join('\n');
  }, [game.guesses, game.lastResults, isPro, currentGame]);
  
  // Generate share text for all completed games (Pro only)
  // Note: URL is NOT included here - it will be added by shareWithFallback
  const generateAllGamesShareText = useCallback(() => {
    const completedGames = getCompletedFlickWordGames();
    
    const lines: string[] = [];
    lines.push(`FlickWord ${getDailySeedDate()} - All Games`);
    lines.push('');
    
    completedGames.forEach((completedGame, idx) => {
      if (idx > 0) lines.push('');
      lines.push(`Game ${completedGame.gameNumber}:`);
      for (let i = 0; i < completedGame.guesses.length; i++) {
        const result = completedGame.lastResults[i] || [];
        const line = result.map(status => {
          if (status === 'correct') return 'üü©';
          if (status === 'present') return 'üü®';
          return '‚¨ú';
        }).join('');
        lines.push(line);
      }
    });
    
    lines.push('');
    lines.push('Play FlickWord at flicklet.netlify.app');
    
    return lines.join('\n');
  }, []);

  // Primary share handler for FlickWord
  // Handle share - single game or all games
  // Share link deep-linking: Includes date and gameNumber so link opens to correct game
  // Config: App.tsx handles ?game=flickword&date=...&gameNumber=... query params
  const handleShare = useCallback(async (shareAll: boolean = false) => {
    const shareText = shareAll && isPro 
      ? generateAllGamesShareText() 
      : generateShareText();
    
    // Build share URL with deep-link params
    // Always use flicklet.netlify.app for consistency
    const today = getDailySeedDate();
    const origin = "https://flicklet.netlify.app";
    
    let shareUrl: string;
    if (shareAll && isPro) {
      // Share all games: use mode=sharedAll, no gameNumber
      shareUrl = `${origin}/?game=flickword&date=${today}&mode=sharedAll`;
    } else {
      // Share single game: include gameNumber
      const gameNumber = isPro ? currentGame : 1;
      shareUrl = `${origin}/?game=flickword&date=${today}&gameNumber=${gameNumber}&mode=sharedResult`;
    }
    
    // Track analytics
    const gameNumber = isPro ? currentGame : 1;
    trackFlickWordShare(shareAll ? null : gameNumber, shareAll ? 'all' : 'single');
    
    // Detect if native share is available (for toast message)
    const canNativeShare =
      typeof navigator !== "undefined" &&
      "share" in navigator &&
      /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
    
    // Use unified share helper
    await shareWithFallback({
      title: 'FlickWord',
      text: shareText,
      url: shareUrl,
      onSuccess: () => {
        const toast = getToastCallback();
        if (toast) {
          // Different message for native share vs clipboard
          if (canNativeShare) {
            toast('Share completed!', 'success');
          } else {
            toast('Share link copied to clipboard!', 'success');
          }
        }
        // Small delay before closing modal to ensure toast is visible
        setTimeout(() => {
          setShowShareModal(false);
        }, 500);
      },
      onError: (error) => {
        console.error('Share failed:', error);
        const toast = getToastCallback();
        if (toast) {
          toast('Unable to share ‚Äì link copied instead', 'error');
        }
        // Don't close modal on error so user can try again
      },
    });
  }, [generateShareText, generateAllGamesShareText, isPro, currentGame]);

  // Render game grid with enhanced accessibility and animations
  const renderGrid = () => {
    const rows = [];
    const currentRowIndex = game.guesses.length;
    const isRevealingRow =
      game.animationState === "revealing" &&
      currentRowIndex === game.guesses.length - 1;

    // Initialize tile refs array if needed
    if (!tileRefs.current[currentRowIndex]) {
      tileRefs.current[currentRowIndex] = [];
    }

    for (let i = 0; i < game.maxGuesses; i++) {
      const guess =
        game.guesses[i] || (i === currentRowIndex ? game.current : "");
      const isCurrentRow = i === currentRowIndex && !game.done;
      const rowStatus = i < game.guesses.length ? game.lastResults[i] : null;

      const rowTiles = [];
      for (let j = 0; j < 5; j++) {
        const letter = guess[j] || "";
        const status = rowStatus ? rowStatus[j] : "";
        const animationDelay =
          isRevealingRow && rowStatus ? j * ANIMATION_DELAY_BASE : 0;

        let ariaLabel = letter
          ? `${letter}, ${status || "empty"}`
          : "Empty tile";
        if (status === "correct") {
          ariaLabel = `${letter}, correct position`;
        } else if (status === "present") {
          ariaLabel = `${letter}, present but wrong position`;
        } else if (status === "absent") {
          ariaLabel = `${letter}, not in word`;
        }

        rowTiles.push(
          <div
            key={`${i}-${j}`}
            ref={(el) => {
              if (isCurrentRow) {
                if (!tileRefs.current[i]) {
                  tileRefs.current[i] = [];
                }
                tileRefs.current[i][j] = el;
              }
            }}
            className={`fw-tile ${status} ${isCurrentRow ? "fw-tile-current" : ""} ${isRevealingRow && rowStatus ? "fw-tile-revealing" : ""} ${isInvalidInput && isCurrentRow ? "fw-tile-shake" : ""}`}
            data-fw-el="tile"
            role="gridcell"
            aria-label={ariaLabel}
            aria-colindex={j + 1}
            aria-rowindex={i + 1}
            tabIndex={isCurrentRow && j === game.current.length ? 0 : -1}
            style={
              prefersReducedMotion
                ? {}
                : ({
                    "--reveal-delay": `${animationDelay}ms`,
                  } as React.CSSProperties)
            }
            data-status={status}
          >
            {letter}
          </div>
        );
      }
      rows.push(
        <div key={`row-${i}`} data-fw-el="tile-row">
          {rowTiles}
        </div>
      );
    }
    return rows;
  };

  // Render keyboard
  const renderKeyboard = () => {
    const rows = [];

    // Row 1: QWERTYUIOP (no backspace here)
    const row1 = [];
    for (const letter of KEYBOARD_ROWS[0]) {
      const status = game.status[letter] || "";
      row1.push(
        <button
          key={letter}
          className={`fw-key ${status}`}
          data-fw-el="key"
          onClick={() => handleKeyInput(letter)}
          disabled={game.done || isLoading || isSubmittingUI}
          aria-label={`Key ${letter}${status ? `, ${status}` : ""}`}
          aria-pressed={status ? "true" : "false"}
        >
          {letter}
        </button>
      );
    }
    rows.push(
      <div
        key="row1"
        className="fw-kb-row"
        data-fw-el="key-row"
        style={
          { ["--cols" as string]: String(row1.length) } as React.CSSProperties
        }
      >
        {row1}
      </div>
    );

    // Row 2: ASDFGHJKL
    const row2 = [];
    for (const letter of KEYBOARD_ROWS[1]) {
      const status = game.status[letter] || "";
      row2.push(
        <button
          key={letter}
          className={`fw-key ${status}`}
          data-fw-el="key"
          onClick={() => handleKeyInput(letter)}
          disabled={game.done || isLoading || isSubmittingUI}
          aria-label={`Key ${letter}${status ? `, ${status}` : ""}`}
          aria-pressed={status ? "true" : "false"}
        >
          {letter}
        </button>
      );
    }
    rows.push(
      <div
        key="row2"
        className="fw-kb-row"
        data-fw-el="key-row"
        style={
          { ["--cols" as string]: String(row2.length) } as React.CSSProperties
        }
      >
        {row2}
      </div>
    );

    // Row 3: Enter + ZXCVBNM + Backspace
    // FIXED: Show visual feedback during validation
    const row3 = [
      <button
        key="enter"
        className={`fw-key fw-key-enter ${isSubmittingUI ? 'fw-key-submitting' : ''}`}
        data-fw-el="key"
        data-fw-key="enter"
        onClick={handleSubmit}
        disabled={game.done || isLoading || game.current.length !== 5 || isSubmittingUI}
        aria-label={isSubmittingUI ? "Validating word..." : "Submit guess"}
      >
        {isSubmittingUI ? (
          <span className="fw-submitting-indicator">
            <span className="fw-spinner-small" aria-hidden="true"></span>
            Checking...
          </span>
        ) : (
          "Enter"
        )}
      </button>,
    ];
    for (const letter of KEYBOARD_ROWS[2]) {
      const status = game.status[letter] || "";
      row3.push(
        <button
          key={letter}
          className={`fw-key ${status}`}
          data-fw-el="key"
          onClick={() => handleKeyInput(letter)}
          disabled={game.done || isLoading || isSubmittingUI}
          aria-label={`Key ${letter}${status ? `, ${status}` : ""}`}
          aria-pressed={status ? "true" : "false"}
        >
          {letter}
        </button>
      );
    }
    row3.push(
      <button
        key="backspace"
        className="fw-key fw-key-back"
        data-fw-el="key"
        data-fw-key="backspace"
        onClick={handleBackspace}
        disabled={game.done || isLoading || !game.current || isSubmittingUI}
        aria-label="Delete letter"
      >
        ‚å´
      </button>
    );
    rows.push(
      <div
        key="row3"
        className="fw-kb-row"
        data-fw-el="key-row"
        style={
          { ["--cols" as string]: String(row3.length) } as React.CSSProperties
        }
      >
        {row3}
      </div>
    );

    return rows;
  };

  if (isLoading) {
    return (
      <div
        className="flickword-game"
        data-fw-root
        role="status"
        aria-live="polite"
        aria-label="Loading FlickWord game"
      >
        <div className="fw-header">
          <h3>üéØ FlickWord</h3>
          <div className="fw-stats">
            <span className="fw-streak" aria-hidden="true">
              Loading...
            </span>
          </div>
        </div>
        <div className="fw-loading">
          <div className="fw-spinner" aria-hidden="true"></div>
          <p>Loading today&apos;s word...</p>
        </div>
      </div>
    );
  }

  if (errorMessage && !game.target) {
    return (
      <div className="flickword-game" data-fw-root role="alert">
        <div className="fw-error">
          <h3>Error Loading Game</h3>
          <p>{errorMessage}</p>
          <button
            className="fw-btn fw-new-game"
            onClick={() => {
              setErrorMessage(null);
              initializeGame();
            }}
            aria-label="Try loading game again"
          >
            Try Again
          </button>
        </div>
      </div>
    );
  }

  return (
      <div
        className="flickword-game"
        data-fw-root
        role="application"
        aria-label="FlickWord game"
        aria-describedby="flickword-description"
      >
        {/* Game progress indicator */}
        {isPro && (
          <div
            className="fw-game-header"
            aria-label={`Game ${currentGame} of ${isPro ? MAX_GAMES_PRO : MAX_GAMES_FREE}`}
          >
            <span className="game-indicator">Game {currentGame} of {isPro ? MAX_GAMES_PRO : MAX_GAMES_FREE}</span>
            {gamesCompletedToday > 0 && (
              <span
                className="games-completed"
                aria-label={`${gamesCompletedToday} games completed today`}
              >
                ({gamesCompletedToday} completed)
              </span>
            )}
          </div>
        )}

        {/* Offline indicator */}
        {!isOnline && (
          <div className="fw-notification fw-notification-info" role="alert" aria-live="polite">
            üì° You&apos;re offline. Using cached word if available.
          </div>
        )}

        {/* Hidden description for screen readers */}
        <div id="flickword-description" className="sr-only">
          Word guessing game. Guess the 5-letter word in {game.maxGuesses}{" "}
          attempts.
          {game.done &&
          `Game ${game.guesses[game.guesses.length - 1] === game.target ? "won" : "lost"}.`}
      </div>

      {/* Enhanced Toast Notifications */}
      <div
        className="fw-notifications-container"
        role="region"
        aria-live="polite"
        aria-atomic="true"
      >
        {notifications.map((notification) => (
          <div
            key={notification.id}
            className={`fw-notification fw-notification-${notification.type}`}
            role="alert"
            aria-live="assertive"
          >
            <span className="fw-notification-icon" aria-hidden="true">
              {notification.type === "success" && "‚úì"}
              {notification.type === "error" && "‚úï"}
              {notification.type === "info" && "‚Ñπ"}
              {notification.type === "warning" && "‚ö†"}
            </span>
            <span className="fw-notification-message">
              {notification.message}
            </span>
            <button
              className="fw-notification-close"
              onClick={() =>
                setNotifications((prev) =>
                  prev.filter((n) => n.id !== notification.id)
                )
              }
              aria-label="Dismiss notification"
            >
              √ó
            </button>
          </div>
        ))}
      </div>

      {/* Playfield wrapper for mobile layout (grid + stats) */}
      <div className="fw-playfield" data-fw-el="playfield">
        {/* Error banner */}
        {errorMessage && (
          <div
            className="fw-error-banner"
            role="alert"
            aria-live="polite"
            aria-label="Warning message"
          >
            <span className="fw-error-icon" aria-hidden="true">
              ‚ö†Ô∏è
            </span>
            <span>{errorMessage}</span>
          </div>
        )}

        {/* Word Info (if available) - Hidden by default */}
        {game.wordInfo?.definition && game.showHint && (
          <div
            className="fw-word-info"
            role="region"
            aria-label="Word hint"
            tabIndex={0}
          >
            <p>
              <strong>Hint:</strong> {game.wordInfo.definition}
            </p>
          </div>
        )}

        {/* Game Grid */}
        <div
          ref={gridRef}
          className="fw-grid"
          aria-label={`FlickWord board. ${game.guesses.length} of ${game.maxGuesses} guesses used. ${game.done ? (game.guesses[game.guesses.length - 1] === game.target ? "Game won!" : "Game lost.") : "Enter a 5-letter word."}`}
          role="grid"
          aria-rowcount={game.maxGuesses}
          aria-colcount={5}
          aria-live="polite"
          aria-atomic="false"
        >
          {renderGrid()}
        </div>

        {/* Pro Chip - Purple, shows only after game ends */}
        {showProChip && game.done && (
          <div className="fw-pro-chip">
            <p><strong>Unlock 2 more rounds</strong> ‚Äì Go Pro</p>
            <button
              className="fw-pro-chip-dismiss"
              onClick={() => setShowProChip(false)}
              aria-label="Dismiss Pro upgrade message"
            >
              √ó
            </button>
          </div>
        )}
      </div>

      {/* Keyboard */}
      <div
        className="fw-keyboard"
        data-fw-el="keyboard"
        aria-label="Virtual keyboard"
        role="group"
      >
        {renderKeyboard()}
      </div>

      {/* Completion message - moved outside playfield to prevent overflow */}
      {game.done && (() => {
        const maxGames = isPro ? MAX_GAMES_PRO : MAX_GAMES_FREE;
        if (gamesCompletedToday >= maxGames) {
          return (
            <div className="fw-games-limit">
              <p>
                ‚úÖ You&apos;ve completed {maxGames === 1 ? "your game" : `all ${maxGames} games`} today! Come back tomorrow for the next {maxGames === 1 ? "game" : "games"}!
              </p>
              {!isPro && (
                <p className="fw-pro-upsell">
                  üîí Want more games? Upgrade to Pro for 3 games per day!
                </p>
              )}
            </div>
          );
        }
        return null;
      })()}

      {/* Actions - Hidden to match Wordle's minimal design (close via header only) */}
      {false && (
        <div className="fw-actions">
          {onClose && (
            <button
              className="fw-btn fw-close"
              onClick={onClose}
              aria-label="Close FlickWord game"
            >
              Close
            </button>
          )}
        </div>
      )}

      {/* Win Screen Modal */}
      {showWinScreen && (
        <div className="fw-lost-screen">
          <div className="fw-lost-content">
            <h2>üéâ Congratulations!</h2>
            <p className="fw-lost-word">You guessed it in <strong>{game.guesses.length}</strong> {game.guesses.length === 1 ? 'guess' : 'guesses'}!</p>
            <p className="fw-lost-word">The word was: <strong>{game.target}</strong></p>
            <div className="fw-lost-actions">
              {(() => {
                const maxGames = isPro ? MAX_GAMES_PRO : MAX_GAMES_FREE;
                if (gamesCompletedToday < maxGames) {
                  return (
                    <button
                      className="fw-btn fw-btn-primary"
                      onClick={handleNextGame}
                    >
                      Next Game ({gamesCompletedToday + 1}/{maxGames})
                    </button>
                  );
                }
                return null;
              })()}
              <button
                className="fw-btn fw-btn-share"
                onClick={() => {
                  setShowShareModal(true);
                  setShowWinScreen(false);
                }}
              >
                Share
              </button>
              {onShowStats && (
                <button
                  className="fw-btn fw-btn-stats"
                  onClick={() => {
                    setShowWinScreen(false);
                    onShowStats();
                  }}
                >
                  View Stats
                </button>
              )}
              {onShowReview && (
                <button
                  className="fw-btn fw-btn-review"
                  onClick={() => {
                    setShowWinScreen(false);
                    onShowReview(null);
                  }}
                >
                  Review Games
                </button>
              )}
              <button
                className="fw-btn fw-btn-close"
                onClick={() => setShowWinScreen(false)}
              >
                Close
              </button>
            </div>
          </div>
        </div>
      )}

      {/* Lost Screen Modal */}
      {showLostScreen && (
        <div className="fw-lost-screen">
          <div className="fw-lost-content">
            <h2>Game Over!</h2>
            <p className="fw-lost-word">The word was: <strong>{game.target}</strong></p>
            <div className="fw-lost-actions">
              {(() => {
                const maxGames = isPro ? MAX_GAMES_PRO : MAX_GAMES_FREE;
                if (gamesCompletedToday < maxGames) {
                  return (
                    <button
                      className="fw-btn fw-btn-primary"
                      onClick={handleNextGame}
                    >
                      Next Game ({gamesCompletedToday + 1}/{maxGames})
                    </button>
                  );
                }
                return null;
              })()}
              <button
                className="fw-btn fw-btn-explore"
                onClick={handleExploreShows}
              >
                Explore shows titled &quot;{game.target}&quot;
              </button>
              <button
                className="fw-btn fw-btn-share"
                onClick={() => {
                  setShowShareModal(true);
                  setShowLostScreen(false);
                }}
              >
                Share
              </button>
              {onShowReview && (
                <button
                  className="fw-btn fw-btn-review"
                  onClick={() => {
                    setShowLostScreen(false);
                    onShowReview(null);
                  }}
                >
                  Review Games
                </button>
              )}
              <button
                className="fw-btn fw-btn-close"
                onClick={() => setShowLostScreen(false)}
              >
                Close
              </button>
            </div>
          </div>
        </div>
      )}

      {/* Share Modal */}
      {showShareModal && (
        <div className="fw-share-modal" onClick={(e) => {
          // Close when clicking backdrop
          if (e.target === e.currentTarget) {
            setShowShareModal(false);
          }
        }}>
          <div className="fw-share-content">
            <div className="fw-share-header">
              <h2>Share Your Results</h2>
              <button
                className="fw-share-close"
                onClick={() => setShowShareModal(false)}
                aria-label="Close share modal"
              >
                √ó
              </button>
            </div>
            <div className="fw-share-grid">
              {game.guesses.map((guess, i) => {
                const result = game.lastResults[i] || [];
                return (
                  <div key={i} className="fw-share-row">
                    {result.map((status, j) => (
                      <div
                        key={j}
                        className={`fw-share-tile ${status}`}
                        aria-label={`${guess[j]}, ${status}`}
                      >
                        {status === 'correct' && 'üü©'}
                        {status === 'present' && 'üü®'}
                        {status === 'absent' && '‚¨ú'}
                      </div>
                    ))}
                  </div>
                );
              })}
            </div>
            <div className="fw-share-actions">
              <button
                className="fw-btn fw-btn-primary"
                onClick={() => handleShare(false)}
              >
                Share This Game
              </button>
              {isPro && (
                <button
                  className="fw-btn fw-btn-secondary"
                  onClick={() => handleShare(true)}
                >
                  Share All 3 Games
                </button>
              )}
              <button
                className="fw-btn fw-btn-secondary"
                onClick={() => setShowShareModal(false)}
              >
                Close
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}

```

## apps/web/src/components/GenreDropdown.tsx
### Summary
Genre filter dropdown used on discovery/search surfaces.
### Content
```tsx
import { useState } from 'react';
// import { useTranslations } from '@/lib/language'; // Unused

export type GenreDropdownProps = {
  selectedGenres: string[];
  onGenresChange: (genres: string[]) => void;
  className?: string;
};

/**
 * Genre dropdown component for For You section
 * - Multi-select dropdown with popular genres
 * - Updates parent component when selections change
 * - Used to customize discovery recommendations
 */
export default function GenreDropdown({ selectedGenres, onGenresChange, className = '' }: GenreDropdownProps) {
  const [isOpen, setIsOpen] = useState(false);
  // const translations = useTranslations(); // Unused
  
  const genres = [
    { id: 'action', name: 'Action' },
    { id: 'adventure', name: 'Adventure' },
    { id: 'animation', name: 'Animation' },
    { id: 'comedy', name: 'Comedy' },
    { id: 'crime', name: 'Crime' },
    { id: 'documentary', name: 'Documentary' },
    { id: 'drama', name: 'Drama' },
    { id: 'family', name: 'Family' },
    { id: 'fantasy', name: 'Fantasy' },
    { id: 'history', name: 'History' },
    { id: 'horror', name: 'Horror' },
    { id: 'music', name: 'Music' },
    { id: 'mystery', name: 'Mystery' },
    { id: 'romance', name: 'Romance' },
    { id: 'science-fiction', name: 'Science Fiction' },
    { id: 'thriller', name: 'Thriller' },
    { id: 'war', name: 'War' },
    { id: 'western', name: 'Western' },
  ];
  
  const handleGenreToggle = (genreId: string) => {
    const newGenres = selectedGenres.includes(genreId)
      ? selectedGenres.filter(id => id !== genreId)
      : [...selectedGenres, genreId];
    
    onGenresChange(newGenres);
  };
  
  const getSelectedGenreNames = () => {
    return selectedGenres
      .map(id => genres.find(g => g.id === id)?.name)
      .filter(Boolean)
      .join(', ');
  };
  
  return (
    <div className={`relative ${className}`}>
      {/* Dropdown Button */}
      <button
        onClick={() => setIsOpen(!isOpen)}
        className="flex items-center gap-2 px-3 py-2 rounded-lg border text-sm transition-colors"
        style={{
          backgroundColor: 'var(--btn)',
          color: 'var(--text)',
          borderColor: 'var(--line)',
          border: '1px solid'
        }}
        aria-label="Select genres for recommendations"
      >
        <span className="text-lg">üé≠</span>
        <span className="flex-1 text-left">
          {selectedGenres.length > 0 ? getSelectedGenreNames() : 'Select Genres'}
        </span>
        <span className={`transition-transform ${isOpen ? 'rotate-180' : ''}`}>
          ‚ñº
        </span>
      </button>
      
      {/* Dropdown Menu */}
      {isOpen && (
        <div 
          className="absolute top-full left-0 right-0 mt-1 rounded-lg shadow-lg z-50 max-h-64 overflow-y-auto"
          style={{ 
            backgroundColor: 'var(--menu-bg)', 
            borderColor: 'var(--menu-border)',
            border: '1px solid var(--menu-border)'
          }}
        >
          <div className="p-2">
            <div className="text-xs font-medium mb-2" style={{ color: 'var(--menu-text-muted)' }}>
              Choose your favorite genres:
            </div>
            <div className="grid grid-cols-2 gap-1">
              {genres.map(genre => (
                <label
                  key={genre.id}
                  className="flex items-center gap-2 p-2 rounded cursor-pointer transition-colors"
                  style={{ 
                    color: 'var(--menu-text)',
                  }}
                  onMouseEnter={(e) => {
                    e.currentTarget.style.backgroundColor = 'var(--menu-hover)';
                  }}
                  onMouseLeave={(e) => {
                    e.currentTarget.style.backgroundColor = 'transparent';
                  }}
                >
                  <input
                    type="checkbox"
                    checked={selectedGenres.includes(genre.id)}
                    onChange={() => handleGenreToggle(genre.id)}
                    className="rounded"
                    style={{ accentColor: 'var(--accent)' }}
                  />
                  <span className="text-sm">{genre.name}</span>
                </label>
              ))}
            </div>
            
            {/* Clear Selection */}
            {selectedGenres.length > 0 && (
              <button
                onClick={() => onGenresChange([])}
                className="w-full mt-2 px-3 py-1 text-xs rounded border border-dashed transition-colors focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2"
                style={{ 
                  color: 'var(--menu-text-muted)', 
                  borderColor: 'var(--menu-border)',
                  backgroundColor: 'transparent',
                  outlineColor: 'var(--menu-focus)'
                }}
              >
                Clear All
              </button>
            )}
          </div>
        </div>
      )}
      
      {/* Click outside to close */}
      {isOpen && (
        <div
          className="fixed inset-0 z-40"
          onClick={() => setIsOpen(false)}
        />
      )}
    </div>
  );
}

```

## apps/web/src/components/MobileTabs.tsx
### Summary
Mobile tab navigation that includes the Discovery tab and propagates state to rating-aware lists.
### Content
```tsx
import { useTranslations } from '../lib/language';
import { useLibrary } from '../lib/storage';
import { useCustomLists } from '../lib/customLists';
import { useReturningShows } from '@/state/selectors/useReturningShows';
import { useEffect, useState, createContext, useContext, useMemo, useRef } from 'react';
import React from 'react';
import { dlog } from '../lib/log';

type TabId = 'watching'|'want'|'watched'|'returning'|'mylists'|'discovery'; // Removed 'not' - now handled by modal
export type MobileTabsProps = { current: 'home' | TabId; onChange: (next: 'home' | TabId) => void; };

// Single source of truth for mobile nav height
export const MOBILE_NAV_HEIGHT = 80;

// Context for sharing viewport offset with other components
const ViewportContext = createContext<{ viewportOffset: number }>({ viewportOffset: 0 });
export const useViewportOffset = () => useContext(ViewportContext);

export default function MobileTabs({ current, onChange }: MobileTabsProps) {
  const translations = useTranslations();
  const customLists = useCustomLists();
  
  // Visual Viewport API state for iOS Safari keyboard handling
  const [viewportOffset, setViewportOffset] = useState(0);
  
  // Debug logging
  dlog('üì± MobileTabs rendering:', { 
    current, 
    screenWidth: window.innerWidth,
    screenHeight: window.innerHeight,
    viewportHeight: window.visualViewport?.height || 'no visualViewport',
    scrollY: window.scrollY,
    bodyHeight: document.body.scrollHeight,
    viewportOffset
  });
  
  // Visual Viewport API listener for iOS Safari keyboard handling
  useEffect(() => {
    if (!window.visualViewport) {
      dlog('üì± Visual Viewport API not supported, using safe fallback');
      
      // Safe fallback: listen to resize, orientationchange, and visibilitychange
      const handleFallbackResize = () => {
        dlog('üì± Fallback resize detected, checking for keyboard');
        // Simple heuristic: if viewport height is significantly less than screen height
        const heightDiff = window.innerHeight - window.screen.height;
        if (Math.abs(heightDiff) > 100) {
          setViewportOffset(Math.abs(heightDiff));
        } else {
          setViewportOffset(0);
        }
      };
      
      const handleOrientationChange = () => {
        dlog('üì± Orientation change detected');
        setTimeout(() => setViewportOffset(0), 100); // Reset after orientation settles
      };
      
      const handleVisibilityChange = () => {
        dlog('üì± Visibility change detected');
        if (document.hidden) {
          setViewportOffset(0);
        }
      };
      
      // Listen for safe fallback events
      window.addEventListener('resize', handleFallbackResize);
      window.addEventListener('orientationchange', handleOrientationChange);
      document.addEventListener('visibilitychange', handleVisibilityChange);
      
      return () => {
        window.removeEventListener('resize', handleFallbackResize);
        window.removeEventListener('orientationchange', handleOrientationChange);
        document.removeEventListener('visibilitychange', handleVisibilityChange);
      };
    }
    
    let prevOffsetTop = 0;
    let throttleTimeout: ReturnType<typeof setTimeout> | null = null;
    
    const handleViewportChange = () => {
      // Throttle to prevent rapid fires from iOS toolbar animations
      if (throttleTimeout) return;
      
      throttleTimeout = setTimeout(() => {
        throttleTimeout = null;
        
        const visualHeight = window.visualViewport?.height || window.innerHeight;
        const screenHeight = window.innerHeight;
        const currentOffsetTop = window.visualViewport ? window.visualViewport.offsetTop : 0;
        
        // Calculate delta to detect toolbar changes vs keyboard
        const offsetTopDelta = Math.abs(currentOffsetTop - prevOffsetTop);
        
        dlog('üì± Visual viewport changed:', { 
          visualHeight, 
          screenHeight, 
          currentOffsetTop,
          prevOffsetTop,
          offsetTopDelta,
          keyboardOpen: offsetTopDelta <= 50 && (screenHeight - visualHeight) > 50
        });
        
        // If offsetTop changed significantly (>50px), it's toolbar animation - ignore
        if (offsetTopDelta > 50) {
          dlog('üì± Toolbar animation detected, ignoring offset change');
          setViewportOffset(0);
          prevOffsetTop = currentOffsetTop;
          return;
        }
        
        // Only adjust for height changes with stable offsetTop (keyboard)
        const offset = Math.max(0, screenHeight - visualHeight);
        // Only apply offset if it's significant (>50px) to avoid toolbar micro-shifts
        setViewportOffset(offset > 50 ? offset : 0);
        prevOffsetTop = currentOffsetTop;
        
      }, 50); // Throttle to max 20fps
    };
    
    // Scroll reset listener for aggressive repaint forcing
    let scrollResetTimeout: ReturnType<typeof setTimeout> | null = null;
    const handleScrollReset = () => {
      if (scrollResetTimeout) clearTimeout(scrollResetTimeout);
      scrollResetTimeout = setTimeout(() => {
        // Reset nav position on scroll end if toolbar is stable
        if (window.visualViewport && Math.abs(window.visualViewport.offsetTop) < 50) {
          const navElement = document.querySelector('.mobile-nav') as HTMLElement;
          if (navElement) {
            navElement.style.bottom = '0';
          }
        }
      }, 100);
    };
    
    // Initial calculation
    handleViewportChange();
    
    // Listen for viewport changes (keyboard open/close)
    window.visualViewport.addEventListener('resize', handleViewportChange);
    // Listen for scroll events to reset position
    window.addEventListener('scroll', handleScrollReset, { passive: true });
    
    return () => {
      window.visualViewport?.removeEventListener('resize', handleViewportChange);
      window.removeEventListener('scroll', handleScrollReset);
      if (throttleTimeout) {
        clearTimeout(throttleTimeout);
      }
      if (scrollResetTimeout) {
        clearTimeout(scrollResetTimeout);
      }
    };
  }, []);
  
  // Get reactive counts for each list
  const watchingItems = useLibrary('watching');
  const wantItems = useLibrary('wishlist');
  const watchedItems = useLibrary('watched');
  const returningItems = useReturningShows();
  
  const watchingCount = watchingItems.length;
  const wantCount = wantItems.length;
  const watchedCount = watchedItems.length;
  const myListsCount = Array.isArray(customLists) ? customLists.length : 0;
  const returningCount = returningItems.length;
  
  const TABS: { id: TabId; label: string; count: number }[] = [
    { id: 'watching', label: 'Watching', count: watchingCount },
    { id: 'want',     label: 'Wishlist', count: wantCount },
    { id: 'watched',  label: 'Watched', count: watchedCount },
    { id: 'returning',label: 'Returning', count: returningCount },
    { id: 'mylists',  label: 'Lists', count: myListsCount },
    { id: 'discovery',label: 'Discover', count: 0 }
  ];

  // Split into visible vs overflow (keep Lists visible; move Returning to More)
  const { visibleTabs, overflowTabs } = useMemo(() => {
    const visibleIds: TabId[] = ['watching', 'want', 'watched', 'mylists'];
    const visible = TABS.filter(t => (visibleIds as string[]).includes(t.id));
    const overflow = TABS.filter(t => !(visibleIds as string[]).includes(t.id));
    return { visibleTabs: visible, overflowTabs: overflow };
  }, [TABS]);

  // "More" dropdown for mobile
  const [moreOpen, setMoreOpen] = useState(false);
  const moreRef = useRef<HTMLDivElement | null>(null);
  useEffect(() => {
    const onDocClick = (e: MouseEvent) => {
      if (!moreRef.current) return;
      if (!moreRef.current.contains(e.target as Node)) setMoreOpen(false);
    };
    document.addEventListener('click', onDocClick);
    return () => document.removeEventListener('click', onDocClick);
  }, []);

  return (
    <ViewportContext.Provider value={{ viewportOffset }}>
      <nav 
        className="mobile-nav fixed left-0 right-0 z-nav px-1 py-2"
        style={{ 
          paddingBottom: 'calc(8px + env(safe-area-inset-bottom))',
          boxShadow: '0 -2px 10px rgba(0, 0, 0, 0.1)',
          backdropFilter: 'blur(10px)',
          WebkitBackdropFilter: 'blur(10px)',
          backgroundColor: 'var(--bg)',
          borderTop: '1px solid var(--line)',
          height: `${MOBILE_NAV_HEIGHT}px`,
          position: 'fixed',
          bottom: `${viewportOffset}px`, // Dynamic bottom position for iOS Safari keyboard
          left: 0,
          right: 0,
          zIndex: 9999
        }}
      >
        <div className="flex items-center justify-around h-full w-full">
          {/* Home Tab */}
          <button
            onClick={() => onChange('home')}
            className="flex flex-col items-center justify-center p-2 min-h-[60px] transition-all duration-200 ease-out relative flex-1"
            style={{
              color: current === 'home' ? 'var(--accent)' : 'var(--muted)',
              fontWeight: current === 'home' ? '600' : '500'
            }}
          >
            <span className="text-sm font-medium">{translations.home}</span>
            {current === 'home' && (
              <div 
                className="absolute top-0 left-1/2 transform -translate-x-1/2 w-8 h-0.5 rounded-full"
                style={{ backgroundColor: 'var(--accent)' }}
              />
            )}
          </button>

          

          {/* Main Tabs (visible) */}
          {visibleTabs.map((tab, index) => (
            <React.Fragment key={tab.id}>
              <button
                onClick={() => onChange(tab.id)}
                className="flex flex-col items-center justify-center p-2 min-h-[60px] transition-all duration-200 ease-out relative flex-1"
                style={{
                  color: current === tab.id ? 'var(--accent)' : 'var(--muted)',
                  fontWeight: current === tab.id ? '600' : '500'
                }}
              >
                <span className="text-sm font-medium">{tab.label}</span>
                {tab.count > 0 && (
                  <span 
                    className="bg-gray-500 text-white text-[10px] font-bold rounded-full min-w-[16px] h-4 flex items-center justify-center px-1 mt-0.5"
                    style={{ fontSize: '10px' }}
                  >
                    {tab.count}
                  </span>
                )}
                {current === tab.id && (
                  <div 
                    className="absolute top-0 left-1/2 transform -translate-x-1/2 w-8 h-0.5 rounded-full"
                    style={{ backgroundColor: 'var(--accent)' }}
                  />
                )}
              </button>
              
              {/* Vertical Separator between tabs (except after last tab) */}
              {index < visibleTabs.length - 1 && (
                <div 
                  className="h-8 w-px flex-none"
                  style={{ backgroundColor: 'var(--line)' }}
                />
              )}
            </React.Fragment>
          ))}

          {/* More overflow */}
          {overflowTabs.length > 0 && (
              <>
                {/* Separator before More */}
                <div className="h-8 w-px flex-none" style={{ backgroundColor: 'var(--line)' }} />
                <div ref={moreRef} className="relative flex-1 flex items-center justify-center">
                <button
                  onClick={() => setMoreOpen(v => !v)}
                  className="flex flex-col items-center justify-center p-2 min-h-[60px] transition-all duration-200 ease-out relative"
                  style={{ color: moreOpen ? 'var(--accent)' : 'var(--muted)', fontWeight: moreOpen ? 600 as any : 500 as any }}
                  aria-haspopup="menu"
                  aria-expanded={moreOpen}
                >
                  <span className="text-sm font-medium">More</span>
                  {overflowTabs.some(t => t.count > 0) && (
                    <span className="bg-gray-500 text-white text-[10px] font-bold rounded-full min-w-[16px] h-4 flex items-center justify-center px-1 mt-0.5">
                      {overflowTabs.reduce((sum, t) => sum + (t.count || 0), 0)}
                    </span>
                  )}
                  {moreOpen && (
                    <div 
                      role="menu"
                      className="absolute bottom-[calc(100%+8px)] left-1/2 -translate-x-1/2 min-w-[160px] rounded-xl shadow-lg border"
                      style={{ backgroundColor: 'var(--card)', borderColor: 'var(--line)' }}
                    >
                      {overflowTabs.map(t => (
                        <button
                          key={t.id}
                          role="menuitem"
                          onClick={() => { setMoreOpen(false); onChange(t.id); }}
                          className="w-full text-left px-4 py-2 flex items-center justify-between hover:opacity-90"
                          style={{ color: 'var(--text)' }}
                        >
                          <span>{t.label}</span>
                          {t.count > 0 && (
                            <span className="ml-2 px-2 py-0.5 rounded-full text-xs font-bold" style={{ backgroundColor: 'var(--accent)', color: 'white' }}>{t.count}</span>
                          )}
                        </button>
                      ))}
                    </div>
                  )}
                </button>
              </div>
              </>
          )}
        </div>
      </nav>
    </ViewportContext.Provider>
  );
}

```

## apps/web/src/components/Tabs.tsx
### Summary
Desktop tab navigation covering list/discovery sections and gating rating toggles.
### Content
```tsx
import { useTranslations } from '../lib/language';
import { useLibrary } from '../lib/storage';
import { useReturningShows } from '@/state/selectors/useReturningShows';
import { useCustomLists } from '../lib/customLists';

type TabId = 'watching'|'want'|'watched'|'returning'|'mylists'|'discovery'; // Removed 'not' - now handled by modal
export type TabsProps = { current: 'home' | TabId; onChange: (next: 'home' | TabId) => void; };

export default function Tabs({ current, onChange }: TabsProps) {
  const translations = useTranslations();
  const customLists = useCustomLists();
  
  // Get reactive counts for each list
  const watchingItems = useLibrary('watching');
  const wantItems = useLibrary('wishlist');
  const watchedItems = useLibrary('watched');
  const returningItems = useReturningShows();
  
  const watchingCount = watchingItems.length;
  const wantCount = wantItems.length;
  const watchedCount = watchedItems.length;
  const myListsCount = Array.isArray(customLists) ? customLists.length : 0;
  const returningCount = returningItems.length;
  
  const TABS: { id: TabId; label: string; count: number }[] = [
    { id: 'watching', label: translations.currentlyWatching, count: watchingCount },
    { id: 'want',     label: translations.wantToWatch, count: wantCount },
    { id: 'watched',  label: translations.watched, count: watchedCount },
    { id: 'returning',label: 'Returning', count: returningCount },
    { id: 'mylists',  label: translations.myLists || 'My Lists', count: myListsCount },
    { id: 'discovery',label: translations.discovery, count: 0 }, // Discovery doesn't have a count
  ];
  return (
    <div className="w-full">
      <div className="w-full px-4 py-4">
        <nav aria-label="Primary" className="w-full">
          <div className="flex items-center gap-4 w-full">
            {/* All Tabs - Home + Main Tabs */}
            <div role="tablist" aria-label="Navigation" className="flex gap-4 w-full items-center">
              {/* Home Tab */}
              <button
                aria-current={current === 'home' ? 'page' : undefined}
                onClick={() => onChange('home')}
                className="px-6 py-3 rounded-xl text-base font-semibold transition-all duration-150 ease-out hover:scale-105 active:scale-95 active:shadow-inner hover:shadow-md shadow-sm flex-1 justify-center min-w-[4rem]"
                style={{
                  backgroundColor: current === 'home' ? 'var(--accent)' : 'var(--card)',
                  color: current === 'home' ? 'white' : 'var(--text)',
                  border: current === 'home' ? 'none' : '1px solid var(--line)'
                }}
              >
                {translations.home}
              </button>
              
              {/* Main Tabs */}
              {TABS.map(t => (
                <button
                  key={t.id}
                  role="tab"
                  aria-selected={current === t.id}
                  onClick={() => onChange(t.id)}
                  className="px-6 py-3 rounded-xl text-base font-semibold transition-all duration-150 ease-out hover:scale-105 active:scale-95 active:shadow-inner hover:shadow-md shadow-sm flex items-center justify-center min-w-[5rem] flex-1"
                  style={{
                    backgroundColor: current === t.id ? 'var(--accent)' : 'var(--card)',
                    color: current === t.id ? 'white' : 'var(--text)',
                    border: current === t.id ? 'none' : '1px solid var(--line)',
                    flex: '1 1 0%'
                  }}
                >
                  <span className="truncate">{t.label}</span>
                  <span 
                    className="ml-2 px-2 py-1 rounded-full text-sm font-bold flex-shrink-0"
                    style={{
                      backgroundColor: t.count > 0 ? (current === t.id ? 'rgba(255,255,255,0.2)' : 'var(--accent)') : 'transparent',
                      color: t.count > 0 ? 'white' : 'transparent',
                      minWidth: '20px',
                      textAlign: 'center'
                    }}
                  >
                    {t.count > 0 ? t.count : ''}
                  </span>
                </button>
              ))}
            </div>
          </div>
        </nav>
      </div>
    </div>
  );
}

```

## apps/web/src/lib/swipeMaps.ts
### Summary
Swipe mapping definitions used by cards in discovery rails (e.g., quick rating actions triggered by swipes).
### Content
```ts
/**
 * Process: Swipe Maps
 * Purpose: Centralized swipe action configuration per tab type
 * Data Source: Tab type and media type combinations
 * Update Path: Update action mappings here when swipe behavior changes
 * Dependencies: CardActionHandlers, MediaItem
 */

import type { MediaItem, CardActionHandlers } from '../components/cards/card.types';
import { Library } from './storage';

export interface SwipeAction {
  label: string;
  action: (item: MediaItem, actions?: CardActionHandlers) => void;
}

export interface SwipeConfig {
  leftAction?: SwipeAction;
  rightAction?: SwipeAction;
}

export type TabType = 'watching' | 'want' | 'watched' | 'discovery';
export type TabKey = 'watching' | 'watched' | 'wishlist';

/**
 * Get swipe configuration for a specific tab type
 * @param tabKey - The current tab context (watching|watched|wishlist)
 * @param item - The media item
 * @returns Swipe configuration with left and right actions
 */
export function getSwipeConfig(
  tabKey: 'watching' | 'watched' | 'wishlist',
  item: MediaItem
): SwipeConfig {
  switch (tabKey) {
    case 'watching':
      return {
        leftAction: {
          label: 'Watched',
          action: () => {
            if (item.id && item.mediaType) {
              Library.move(item.id, item.mediaType, 'watched');
            }
          }
        },
        rightAction: {
          label: 'Wishlist',
          action: () => {
            if (item.id && item.mediaType) {
              Library.move(item.id, item.mediaType, 'wishlist');
            }
          }
        }
      };

    case 'watched':
      return {
        leftAction: {
          label: 'Watching',
          action: () => {
            if (item.id && item.mediaType) {
              Library.move(item.id, item.mediaType, 'watching');
            }
          }
        },
        rightAction: {
          label: 'Wishlist',
          action: () => {
            if (item.id && item.mediaType) {
              Library.move(item.id, item.mediaType, 'wishlist');
            }
          }
        }
      };

    case 'wishlist':
      return {
        leftAction: {
          label: 'Watching',
          action: () => {
            if (item.id && item.mediaType) {
              Library.move(item.id, item.mediaType, 'watching');
            }
          }
        },
        rightAction: {
          label: 'Watched',
          action: () => {
            if (item.id && item.mediaType) {
              Library.move(item.id, item.mediaType, 'watched');
            }
          }
        }
      };

    default:
      return {};
  }
}

/**
 * Get all available swipe actions for a tab type (for overflow menu)
 * @param tabType - The current tab context
 * @param mediaType - The media type (tv or movie)
 * @param actions - Action handlers for the card
 * @returns Array of all available actions
 */
export function getAllSwipeActions(
  tabType: TabType,
  _mediaType: 'tv' | 'movie',
  actions?: CardActionHandlers
): SwipeAction[] {

  switch (tabType) {
    case 'watching':
      return [
        {
          label: 'Want to Watch',
          action: (item: MediaItem) => actions?.onWant?.(item)
        },
        {
          label: 'Mark as Watched',
          action: (item: MediaItem) => actions?.onWatched?.(item)
        },
        {
          label: 'Not Interested',
          action: (item: MediaItem) => actions?.onNotInterested?.(item)
        }
      ];

    case 'want':
      return [
        {
          label: 'Start Watching',
          action: (item: MediaItem) => {
            if (item.id && item.mediaType) {
              Library.move(item.id, item.mediaType, 'watching');
            }
          }
        },
        {
          label: 'Mark as Watched',
          action: (item: MediaItem) => actions?.onWatched?.(item)
        },
        {
          label: 'Not Interested',
          action: (item: MediaItem) => actions?.onNotInterested?.(item)
        }
      ];

    case 'watched':
      return [
        {
          label: 'Want to Watch',
          action: (item: MediaItem) => actions?.onWant?.(item)
        },
        {
          label: 'Start Watching',
          action: (item: MediaItem) => {
            if (item.id && item.mediaType) {
              Library.move(item.id, item.mediaType, 'watching');
            }
          }
        },
        {
          label: 'Not Interested',
          action: (item: MediaItem) => actions?.onNotInterested?.(item)
        }
      ];

    case 'discovery':
      return [
        {
          label: 'Want to Watch',
          action: (item: MediaItem) => actions?.onWant?.(item)
        },
        {
          label: 'Start Watching',
          action: (item: MediaItem) => actions?.onWant?.(item)
        },
        {
          label: 'Mark as Watched',
          action: (item: MediaItem) => actions?.onWatched?.(item)
        },
        {
          label: 'Not Interested',
          action: (item: MediaItem) => actions?.onNotInterested?.(item)
        }
      ];

    default:
      return [];
  }
}

/**
 * Get human-readable swipe hint labels for a specific tab type
 * @param tabKey - The current tab context (watching|watched|wishlist)
 * @returns Object with leftLabel and rightLabel for swipe hints
 */
export function getSwipeLabels(tabKey: 'watching' | 'watched' | 'wishlist') {
  switch (tabKey) {
    case 'watching':
      return { leftLabel: 'Move to Wishlist', rightLabel: '' };
    case 'watched':
      return { leftLabel: 'Move to Wishlist', rightLabel: '' };
    case 'wishlist':
      return { leftLabel: 'Mark Watched', rightLabel: '' };
    default:
      return { leftLabel: '', rightLabel: '' };
  }
}

```

## apps/web/src/config/structure.ts
### Summary
App structure configuration that names discovery rails and tab order.
### Content
```ts
export type RailSpec = { id: string; title: string; group: 'your-shows'|'community'|'for-you'|'in-theaters'|'feedback'; gatedFlag?: string };
export type TabSpec  = { id: 'watching'|'want'|'watched'|'discovery'; title: string; gatedFlag?: string };

export const HOME_RAILS: RailSpec[] = [
  // Your Shows
  { id: 'currently-watching', title: 'Currently Watching', group: 'your-shows' },
  { id: 'up-next',            title: 'Up Next',            group: 'your-shows' },

  // Community (always visible)
  { id: 'community',          title: 'Community',          group: 'community' },

  // For You (genre sub-rails)
  { id: 'for-you-drama',      title: 'Drama',              group: 'for-you' },
  { id: 'for-you-comedy',     title: 'Comedy',             group: 'for-you' },
  { id: 'for-you-horror',     title: 'Horror',             group: 'for-you' },

  // In Theaters
  { id: 'in-theaters',        title: 'In Theaters Near You', group: 'in-theaters' },

  // Feedback
  { id: 'feedback',           title: 'Feedback',           group: 'feedback' }
];

export const TABS: TabSpec[] = [
  { id: 'watching', title: 'Currently Watching' },
  { id: 'want',     title: 'Want to Watch' },
  { id: 'watched',  title: 'Watched' },
  { id: 'discovery',title: 'Discovery' }
];

export type RailItemsBinding =
  | { id: 'currently-watching'|'up-next'; source: 'saved' }                 // from user lists
  | { id: 'for-you-drama'|'for-you-comedy'|'for-you-horror'; source: 'tmdb' }
  | { id: 'in-theaters'; source: 'tmdb' }
  | { id: 'community'|'feedback'; source: 'static' };

export const BINDINGS: RailItemsBinding[] = [
  { id: 'currently-watching', source: 'saved' },
  { id: 'up-next',            source: 'saved' },
  { id: 'community',          source: 'static' },
  { id: 'for-you-drama',      source: 'tmdb' },
  { id: 'for-you-comedy',     source: 'tmdb' },
  { id: 'for-you-horror',     source: 'tmdb' },
  { id: 'in-theaters',        source: 'tmdb' },
  { id: 'feedback',           source: 'static' }
];

```

## apps/web/src/pages/MyListsPage.tsx
### Summary
Custom lists page showing rated items and discovery suggestions for list creation.
### Content
```tsx
import React, { useState } from 'react';
import CardV2 from '../components/cards/CardV2';
import { useCustomLists, customListManager } from '../lib/customLists';
import { Library } from '../lib/storage';
import { useTranslations } from '../lib/language';
import { useSettings, getPersonalityText } from '../lib/settings';
import type { ListName } from '../state/library.types';
import { shareListWithFallback } from '../lib/shareLinks';
import { getToastCallback } from '../state/actions';

export default function MyListsPage() {
  const userLists = useCustomLists();
  const [selectedListId, setSelectedListId] = useState<string>('');
  const translations = useTranslations();
  const settings = useSettings();

  // Get items for the selected list
  const selectedList = selectedListId ? customListManager.getListById(selectedListId) : null;
  const listName = selectedList ? `custom:${selectedListId}` as ListName : null;
  const items = listName ? Library.getByList(listName) : [];

  // Set default selected list if none selected
  React.useEffect(() => {
    if (!selectedListId && userLists.customLists.length > 0) {
      const defaultList = userLists.customLists.find(list => list.isDefault) || userLists.customLists[0];
      setSelectedListId(defaultList.id);
    }
  }, [selectedListId, userLists.customLists]);

  // Handle deep link to select a specific list
  React.useEffect(() => {
    const handleSelectList = (e: CustomEvent<{ listId: string }>) => {
      const listId = e.detail.listId;
      const list = customListManager.getListById(listId);
      if (list) {
        setSelectedListId(listId);
        customListManager.setSelectedList(listId);
      }
    };

    // Check for share link params on mount
    try {
      const shareListId = localStorage.getItem("flicklet:shareListId");
      if (shareListId) {
        const list = customListManager.getListById(shareListId);
        if (list) {
          setSelectedListId(shareListId);
          customListManager.setSelectedList(shareListId);
        }
        localStorage.removeItem("flicklet:shareListId");
      }
    } catch (e) {
      console.warn("Failed to process share list params:", e);
    }

    window.addEventListener("flicklet:selectList", handleSelectList as EventListener);
    return () => {
      window.removeEventListener("flicklet:selectList", handleSelectList as EventListener);
    };
  }, []);

  const handleListChange = (listId: string) => {
    setSelectedListId(listId);
    customListManager.setSelectedList(listId);
  };

  const handleCreateList = () => {
    const name = prompt(translations.enterListName || 'Enter list name:');
    if (!name?.trim()) return;

    try {
      const newList = customListManager.createList(name.trim());
      setSelectedListId(newList.id);
    } catch (error) {
      alert(error instanceof Error ? error.message : 'Failed to create list');
    }
  };

  const handleDeleteList = (listId: string) => {
    const list = customListManager.getListById(listId);
    if (!list) return;

    const confirmed = window.confirm(
      `${translations.confirmDeleteList || 'Are you sure you want to delete'} "${list.name}"? ${translations.thisActionCannotBeUndone || 'This action cannot be undone.'}`
    );
    
    if (confirmed) {
      try {
        customListManager.deleteList(listId);
        // Select another list if we deleted the current one
        if (selectedListId === listId) {
          const remainingLists = userLists.customLists.filter(l => l.id !== listId);
          if (remainingLists.length > 0) {
            setSelectedListId(remainingLists[0].id);
          }
        }
      } catch (error) {
        alert(error instanceof Error ? error.message : 'Failed to delete list');
      }
    }
  };

  const handleRenameList = (listId: string) => {
    const list = customListManager.getListById(listId);
    if (!list) return;

    const newName = prompt(translations.enterNewName || 'Enter new name:', list.name);
    if (!newName?.trim() || newName.trim() === list.name) return;

    try {
      customListManager.updateList(listId, { name: newName.trim() });
    } catch (error) {
      alert(error instanceof Error ? error.message : 'Failed to rename list');
    }
  };


  // List share entry point ‚Äì uses shareListWithFallback
  const handleShareList = async (listId: string) => {
    console.log("[MyListsPage] handleShareList called with listId:", listId);
    const list = customListManager.getListById(listId);
    if (!list) {
      console.warn("[MyListsPage] List not found for listId:", listId);
      return;
    }

    console.log("[MyListsPage] Sharing list:", list.name, list.id);
    
    // Check toast availability upfront for debugging
    const toastCheck = getToastCallback();
    console.log("[MyListsPage] Toast callback available:", !!toastCheck, typeof toastCheck);

    try {
      await shareListWithFallback(
        { id: list.id, name: list.name },
        {
          onSuccess: () => {
            console.log("[MyListsPage] Share successful - entering onSuccess callback");
            // Get global toast callback (set by App.tsx) - retrieve fresh each time
            const toast = getToastCallback();
            console.log("[MyListsPage] Toast callback in onSuccess:", !!toast, typeof toast);
            if (toast) {
              console.log("[MyListsPage] Calling toast callback with message:", "Share link copied to clipboard!");
              try {
                toast("Share link copied to clipboard!", "success");
                console.log("[MyListsPage] Toast callback executed successfully");
              } catch (toastError) {
                console.error("[MyListsPage] Error calling toast:", toastError);
              }
            } else {
              console.warn("[MyListsPage] Toast callback not available - toasts won't show");
            }
          },
          onError: (error) => {
            console.error("[MyListsPage] Share failed:", error);
            // Get global toast callback (set by App.tsx) - retrieve fresh each time
            const toast = getToastCallback();
            if (toast) {
              toast("Unable to share ‚Äì link copied instead", "error");
            }
          },
        }
      );
    } catch (error) {
      console.error("[MyListsPage] Unexpected error in handleShareList:", error);
      const toast = getToastCallback();
      if (toast) {
        toast("Failed to share list", "error");
      }
    }
  };

  // Action handlers for cards
  const actions = {
    onWant: (item: any) => {
      if (item.id && item.mediaType) {
        Library.move(item.id, item.mediaType, 'wishlist');
      }
    },
    onWatched: (item: any) => {
      if (item.id && item.mediaType) {
        Library.move(item.id, item.mediaType, 'watched');
      }
    },
    onNotInterested: (item: any) => {
      if (item.id && item.mediaType) {
        Library.move(item.id, item.mediaType, 'not');
      }
    },
    onDelete: (item: any) => {
      if (item.id && item.mediaType) {
        Library.remove(item.id, item.mediaType);
      }
    },
  };

  return (
    <section className="px-4 py-4">
      <div className="flex items-center justify-between mb-6">
        <h1 className="text-xl font-semibold" style={{ color: 'var(--text)' }}>
          {translations.myLists || 'My Lists'}
        </h1>
        
        <div className="flex gap-2">
          {userLists.customLists.length < userLists.maxLists && (
            <button
              onClick={handleCreateList}
              className="px-4 py-2 rounded-lg transition-colors"
              style={{ backgroundColor: 'var(--accent)', color: 'white' }}
            >
              {translations.createNewList || 'Create New List'}
            </button>
          )}
        </div>
      </div>

      {/* List Selector */}
      {userLists.customLists.length > 0 && (
        <div className="mb-6">
          <div className="flex flex-wrap gap-2">
            {userLists.customLists.map(list => (
              <div
                key={list.id}
                className={`px-4 py-2 rounded-lg cursor-pointer transition-colors ${
                  selectedListId === list.id ? 'ring-2 ring-blue-500' : ''
                }`}
                style={{
                  backgroundColor: selectedListId === list.id ? 'var(--accent)' : 'var(--btn)',
                  color: 'var(--text)'
                }}
                onClick={() => handleListChange(list.id)}
              >
                <div className="flex items-center gap-2">
                  <span className="font-medium">{list.name}</span>
                  <span className="text-xs opacity-75">({list.itemCount})</span>
                  
                  <div className="flex gap-1 ml-2">
                    <button
                      onClick={(e) => {
                        e.stopPropagation();
                        handleRenameList(list.id);
                      }}
                      className="text-xs opacity-60 hover:opacity-100"
                      title={translations.rename || 'Rename'}
                    >
                      ‚úèÔ∏è
                    </button>
                    <button
                      onClick={(e) => {
                        e.stopPropagation();
                        handleDeleteList(list.id);
                      }}
                      className="text-xs opacity-60 hover:opacity-100"
                      title={translations.delete || 'Delete'}
                    >
                      üóëÔ∏è
                    </button>
                  </div>
                </div>
              </div>
            ))}
          </div>
        </div>
      )}

      {/* Items Display */}
      {selectedList ? (
        <>
          <div className="mb-4 flex items-center justify-between">
            <div>
              <h2 className="text-lg font-medium" style={{ color: 'var(--text)' }}>
                {selectedList.name}
                {selectedList.description && (
                  <span className="text-sm font-normal ml-2" style={{ color: 'var(--muted)' }}>
                    - {selectedList.description}
                  </span>
                )}
              </h2>
              <p className="text-sm" style={{ color: 'var(--muted)' }}>
                {items.length} {translations.items || 'items'}
              </p>
            </div>
            <button
              onClick={() => handleShareList(selectedListId)}
              className="px-4 py-2 rounded-lg transition-colors text-sm flex items-center gap-2"
              style={{ backgroundColor: 'var(--btn)', color: 'var(--text)', border: '1px solid var(--line)' }}
              title="Share this list"
            >
              <span>üîó</span>
              <span>Share</span>
            </button>
          </div>

          {items.length > 0 ? (
            <div className="grid grid-cols-[repeat(auto-fill,minmax(154px,1fr))] gap-3">
              {items.map(item => (
                <CardV2
                  key={`${item.mediaType}:${item.id}`}
                  item={item}
                  context="tab-watching"
                  actions={actions}
                  currentListContext={listName ?? undefined}
                />
              ))}
            </div>
          ) : (
            <div className="text-center py-12">
              <p className="text-sm mb-4" style={{ color: 'var(--muted)' }}>
                {getPersonalityText('emptyWishlist', settings.personalityLevel)}
              </p>
              <p className="text-xs" style={{ color: 'var(--muted)' }}>
                {translations.addItemsFromSearchOrDiscovery || 'Add items from search or discovery'}
              </p>
            </div>
          )}
        </>
      ) : (
        <div className="text-center py-12">
          <p className="text-sm mb-4" style={{ color: 'var(--muted)' }}>
            {translations.noListsCreated || 'No lists created yet'}
          </p>
          <p className="text-xs mb-6" style={{ color: 'var(--muted)' }}>
            {translations.createListsToOrganize || 'Create lists to organize your favorite shows and movies'}
          </p>
          <button
            onClick={handleCreateList}
            className="px-6 py-3 rounded-lg transition-colors"
            style={{ backgroundColor: 'var(--accent)', color: 'white' }}
          >
            {translations.createYourFirstList || 'Create Your First List'}
          </button>
        </div>
      )}
    </section>
  );
}

```

## apps/web/src/App.tsx
### Summary
Root component wiring tabs, discovery, search, smart hooks, and global rating state.
### Content
```tsx
import Tabs from "@/components/Tabs";
import MobileTabs, { useViewportOffset } from "@/components/MobileTabs";
import FlickletHeader from "@/components/FlickletHeader";
import Rail from "@/components/Rail";
import Section from "@/components/Section";
import CommunityPanel from "@/components/CommunityPanel";
import TheaterInfo from "@/components/TheaterInfo";
import FeedbackPanel from "@/components/FeedbackPanel";
import SearchResults from "@/search/SearchResults";
import HomeYourShowsRail from "@/components/rails/HomeYourShowsRail";
import HomeUpNextRail from "@/components/rails/HomeUpNextRail";
import HomeMarquee from "@/components/HomeMarquee";
import { HOME_MARQUEE_MESSAGES } from "@/config/homeMarqueeMessages";
import { SettingsFAB, ThemeToggleFAB } from "@/components/FABs";
import OnboardingCoachmarks from "@/components/onboarding/OnboardingCoachmarks";
import ScrollToTopArrow from "@/components/ScrollToTopArrow";
import HomeDownArrow from "@/components/HomeDownArrow";
import { lazy, Suspense } from "react";
import PostDetail from "@/components/PostDetail";
import { openSettingsSheet } from "@/components/settings/SettingsSheet";
import SettingsSheet from "@/components/settings/SettingsSheet";
import { flag } from "@/lib/flags";
import { isCompactMobileV1 } from "@/lib/mobileFlags";
import { openSettingsAtSection } from "@/lib/settingsNavigation";

// Lazy load heavy components
const SettingsPage = lazy(() => import("@/components/SettingsPage"));
const NotesAndTagsModal = lazy(
  () => import("@/components/modals/NotesAndTagsModal")
);
import { ShowNotificationSettingsModal } from "@/components/modals/ShowNotificationSettingsModal";
const FlickWordModal = lazy(() => import("@/components/games/FlickWordModal"));
import { BloopersModal } from "@/components/extras/BloopersModal";
import { ExtrasModal } from "@/components/extras/ExtrasModal";
import { GoofsModal } from "@/components/extras/GoofsModal";
import { HelpModal } from "@/components/HelpModal";
const ListPage = lazy(() => import("@/pages/ListPage"));
const MyListsPage = lazy(() => import("@/pages/MyListsPage"));
const DiscoveryPage = lazy(() => import("@/pages/DiscoveryPage"));
const AdminPage = lazy(() => import("@/pages/AdminPage"));
const AuthDebugPage = lazy(() => import("@/debug/AuthDebugPage"));
const UnsubscribePage = lazy(() => import("@/pages/UnsubscribePage"));
import PullToRefreshWrapper from "@/components/PullToRefreshWrapper";
import { useForYouRows } from "@/hooks/useForYouRows";
import { useForYouContent } from "@/hooks/useGenreContent";
import { useServiceWorker } from "@/hooks/useServiceWorker";
import { useEffect, useMemo, useState, useCallback, useRef } from "react";
import { flushSync } from "react-dom";
import { Library, useLibrary } from "@/lib/storage";
import { mountActionBridge, setToastCallback } from "@/state/actions";
import { useSettings, settingsManager } from "@/lib/settings";
import { useInTheaters } from "@/hooks/useTmdb";
import { useTranslations } from "@/lib/language";
import Toast, { useToast } from "@/components/Toast";
import PersonalityErrorBoundary from "@/components/PersonalityErrorBoundary";
import { useAuth } from "@/hooks/useAuth";
import {
  initializeMessaging,
  getFCMToken,
  setupForegroundMessageHandler,
} from "./firebase-messaging";
import AuthModal from "@/components/AuthModal";
import AuthConfigError from "@/components/AuthConfigError";
import { isAuthInFlightInOtherTab } from "@/lib/authBroadcast";
import { getOnboardingCompleted } from "@/lib/onboarding";
import "@/styles/flickword.css";
import { backfillShowStatus } from "@/utils/backfillShowStatus";
import DebugAuthHUD from "@/components/DebugAuthHUD";
import { useReturningShows } from "@/state/selectors/useReturningShows";
import { trackTabOpenedReturning } from "@/lib/analytics";
import { googleLogin } from "@/lib/authLogin";
import { storageKeyFlickWordShareParams, type FlickWordShareParams } from "@/lib/games/flickwordShared";

type View =
  | "home"
  | "watching"
  | "want"
  | "watched"
  | "returning"
  | "mylists"
  | "discovery";
type SearchType = "all" | "movies-tv" | "people";
type SearchState = {
  q: string;
  genre: number | null;
  type: SearchType;
  mediaTypeFilter?: "tv" | "movie" | null;
};

export default function App() {
  // Content anchor ref for Home down-arrow scroll target
  // This marks where the main content starts (first rail / main feed)
  // Config: Home down-arrow - scroll target anchor
  const homeContentAnchorRef = useRef<HTMLDivElement | null>(null);
  
  // Computed smart views
  const returning = useReturningShows();
  const [view, setView] = useState<View>("home");
  const [currentPath, setCurrentPath] = useState(
    typeof window !== "undefined" ? window.location.pathname : "/"
  );
  const isAdmin = currentPath === "/admin";
  const isDebugAuth = currentPath === "/debug/auth";
  const isUnsubscribe = currentPath === "/unsubscribe";

  // Detect post routes
  const postSlugMatch = currentPath.match(/^\/posts\/([^/]+)$/);
  const postSlug = postSlugMatch ? postSlugMatch[1] : null;

  // Listen for path changes (from pushState/popState)
  useEffect(() => {
    const handleLocationChange = () => {
      setCurrentPath(window.location.pathname);
    };

    window.addEventListener("popstate", handleLocationChange);
    // Also listen for custom navigation events
    window.addEventListener("pushstate", handleLocationChange);

    return () => {
      window.removeEventListener("popstate", handleLocationChange);
      window.removeEventListener("pushstate", handleLocationChange);
    };
  }, []);

  // Settings state
  const settings = useSettings();
  const [showSettings, setShowSettings] = useState(false);
  const translations = useTranslations();

  // Viewport offset for iOS Safari keyboard handling
  const { viewportOffset } = useViewportOffset();

  // Notes and Tags modal state
  const [notesModalItem, setNotesModalItem] = useState<any>(null);
  const [showNotesModal, setShowNotesModal] = useState(false);

  // Game modal state
  const [showFlickWordModal, setShowFlickWordModal] = useState(false);

  // Notification modal state
  const [notificationModalItem, setNotificationModalItem] = useState<any>(null);
  const [showNotificationModal, setShowNotificationModal] = useState(false);

  // Bloopers modal state (deprecated - kept for backward compatibility)
  const [bloopersModalItem, setBloopersModalItem] = useState<any>(null);
  const [showBloopersModal, setShowBloopersModal] = useState(false);

  // Goofs modal state
  const [goofsModalItem, setGoofsModalItem] = useState<any>(null);
  const [showGoofsModal, setShowGoofsModal] = useState(false);

  // Extras modal state
  const [extrasModalItem, setExtrasModalItem] = useState<any>(null);
  const [showExtrasModal, setShowExtrasModal] = useState(false);

  // Help modal state
  const [showHelpModal, setShowHelpModal] = useState(false);

  // Debug modal state changes
  useEffect(() => {
    console.log("üîî Modal state changed:", {
      showNotificationModal,
      notificationModalItem: notificationModalItem?.title,
    });
  }, [showNotificationModal, notificationModalItem]);

  // Debug bloopers modal state changes
  useEffect(() => {
    console.log("üé¨ Bloopers modal state changed:", {
      showBloopersModal,
      hasBloopersModalItem: !!bloopersModalItem,
      bloopersModalItemTitle: bloopersModalItem?.title,
    });
  }, [showBloopersModal, bloopersModalItem]);

  // Debug extras modal state changes
  useEffect(() => {
    console.log("üé≠ Extras modal state changed:", {
      showExtrasModal,
      hasExtrasModalItem: !!extrasModalItem,
      extrasModalItemTitle: extrasModalItem?.title,
    });
  }, [showExtrasModal, extrasModalItem]);

  // Toast system
  const { toasts, addToast, removeToast } = useToast();


  // Search state
  const [search, setSearch] = useState<SearchState>({
    q: "",
    genre: null,
    type: "all",
  });

  // Search handlers (defined early for use in onboarding effects)
  const handleSearch = useCallback(
    (
      q: string,
      genre: number | null,
      type: SearchType,
      mediaTypeFilter?: "tv" | "movie" | null
    ) => {
      const nextQ = q.trim();
      setSearch({ q: nextQ, genre, type, mediaTypeFilter });
    },
    []
  );

  // Handle onboarding navigation to search
  useEffect(() => {
    const handleNavigateToSearch = () => {
      // Trigger search view by setting an empty query (will show search input)
      handleSearch("", null, "all");
    };

    window.addEventListener(
      "onboarding:navigate-to-search",
      handleNavigateToSearch
    );
    return () => {
      window.removeEventListener(
        "onboarding:navigate-to-search",
        handleNavigateToSearch
      );
    };
  }, [handleSearch]);

  // Handle first show added event (from onboarding)
  useEffect(() => {
    const handleFirstShowAdded = () => {
      addToast("Added to Your Shows", "success");
      // Navigate to home (onboarding step advancement handled by OnboardingCoachmarks)
      setView("home");
      setSearch({ q: "", genre: null, type: "all", mediaTypeFilter: null });
    };

    window.addEventListener("onboarding:firstShowAdded", handleFirstShowAdded);
    return () => {
      window.removeEventListener(
        "onboarding:firstShowAdded",
        handleFirstShowAdded
      );
    };
  }, [addToast]);

  // Auth state
  const {
    loading: authLoading,
    authInitialized,
    isAuthenticated,
    status,
  } = useAuth();

  // Initialize FCM and setup message handlers
  useEffect(() => {
    if (isAuthenticated) {
      // Initialize messaging
      initializeMessaging().then(() => {
        // Get FCM token and store it
        getFCMToken().then((token) => {
          if (token) {
            console.log("[FCM] Token obtained and stored");
          }
        });

        // Setup foreground message handler (shows toast)
        setupForegroundMessageHandler((payload) => {
          const title = payload.notification?.title || "New notification";
          const body = payload.notification?.body || "";
          addToast(`${title}: ${body}`, "info");
        });
      });
    }
  }, [isAuthenticated, addToast]);
  const [showAuthModal, setShowAuthModal] = useState(false);

  // Check for debug mode - persist across redirects
  const [showDebugHUD] = useState(() => {
    const urlParams = new URLSearchParams(window.location.search);
    const hasDebugParam =
      urlParams.has("debugAuth") || urlParams.has("debugAuth") === true;
    // Persist in localStorage so it survives redirects
    if (hasDebugParam) {
      try {
        localStorage.setItem("flicklet.debugAuth", "true");
      } catch (e) {
        // ignore
      }
    }
    // Check both URL param and localStorage
    try {
      return (
        hasDebugParam || localStorage.getItem("flicklet.debugAuth") === "true"
      );
    } catch (e) {
      return hasDebugParam;
    }
  });

  // Auto-prompt for authentication when not authenticated
  useEffect(() => {
    // Don't auto-open modal if we're in redirecting or resolving state
    const isRedirectingOrResolving =
      status === "redirecting" || status === "resolving";

    // Also check localStorage for persisted status (in case React state hasn't updated yet)
    let persistedStatusBlocking = false;
    try {
      const persistedStatus = localStorage.getItem("flicklet.auth.status");
      persistedStatusBlocking =
        persistedStatus === "redirecting" || persistedStatus === "resolving";
    } catch (e) {
      // ignore
    }

    // Check if URL has auth params (we're returning from redirect)
    const urlParams = new URLSearchParams(window.location.search);
    const hasAuthParams =
      urlParams.has("state") || urlParams.has("code") || urlParams.has("error");
    const isReturningFromRedirect = window.location.hash || hasAuthParams;

    // ‚ö†Ô∏è MULTI-TAB SAFETY: Check if auth is in-flight in another tab
    let otherTabBlocking = false;
    try {
      otherTabBlocking = isAuthInFlightInOtherTab();
    } catch (e) {
      // ignore - BroadcastChannel may not be available
    }

    const shouldBlock =
      isRedirectingOrResolving ||
      persistedStatusBlocking ||
      isReturningFromRedirect ||
      otherTabBlocking;

    if (!authLoading && authInitialized && !isAuthenticated && !shouldBlock) {
      // Check if onboarding is completed before showing auth modal
      let timeoutId: ReturnType<typeof setTimeout> | null = null;
      let eventHandler: (() => void) | null = null;
      let fallbackTimeoutId: ReturnType<typeof setTimeout> | null = null;

      const showAuthModalIfReady = () => {
        // If onboarding is already completed, show auth modal immediately
        if (getOnboardingCompleted()) {
          setShowAuthModal(true);
          return;
        }

        // Otherwise, wait for onboarding completion event
        eventHandler = () => {
          setShowAuthModal(true);
          if (eventHandler) {
            window.removeEventListener("onboarding:completed", eventHandler);
          }
          if (fallbackTimeoutId) {
            clearTimeout(fallbackTimeoutId);
          }
        };

        window.addEventListener("onboarding:completed", eventHandler);

        // Fallback: if onboarding doesn't complete within 3 minutes, show auth modal anyway
        // This gives users plenty of time to complete the onboarding flow
        fallbackTimeoutId = setTimeout(() => {
          if (eventHandler) {
            window.removeEventListener("onboarding:completed", eventHandler);
          }
          setShowAuthModal(true);
        }, 180000); // 3 minutes
      };

      // Small delay to ensure the app has fully loaded
      timeoutId = setTimeout(() => {
        showAuthModalIfReady();
      }, 1000);

      return () => {
        if (timeoutId) clearTimeout(timeoutId);
        if (eventHandler) {
          window.removeEventListener("onboarding:completed", eventHandler);
        }
        if (fallbackTimeoutId) clearTimeout(fallbackTimeoutId);
      };
    }
  }, [authLoading, authInitialized, isAuthenticated, status]);

  // Service Worker for offline caching
  const { isOnline } = useServiceWorker();

  // Popup hint banner state
  const [showPopupHint, setShowPopupHint] = useState<boolean>(() => {
    try {
      return localStorage.getItem("flicklet.auth.popup.hint") === "1";
    } catch {
      return false;
    }
  });
  useEffect(() => {
    const handler = () => {
      try {
        setShowPopupHint(
          localStorage.getItem("flicklet.auth.popup.hint") === "1"
        );
      } catch (e) {
        void e;
      }
    };
    window.addEventListener("auth:popup-hint", handler as any);
    const t = setInterval(handler, 1000);
    return () => {
      window.removeEventListener("auth:popup-hint", handler as any);
      clearInterval(t);
    };
  }, []);

  // Refresh function for pull-to-refresh
  const handleRefresh = async () => {
    console.log("üîÑ Pull-to-refresh triggered");

    // Force refresh of library data
    // Library.refresh(); // Commented out - method doesn't exist

    // Trigger custom refresh events for components that need it
    window.dispatchEvent(new CustomEvent("force-refresh"));

    // Small delay to show the refresh animation
    await new Promise((resolve) => setTimeout(resolve, 1000));
  };

  // Search is active if there's a query OR a genre selected (for genre-only search)
  const searchActive = !!search.q.trim() || search.genre != null;

  const handleClear = () =>
    setSearch({ q: "", genre: null, type: "all", mediaTypeFilter: null });

  // Listen for FlickWord explore event
  useEffect(() => {
    const handleFlickWordExplore = (e: Event) => {
      const customEvent = e as CustomEvent<{ word: string }>;
      const word = customEvent.detail?.word;
      if (word) {
        // Set search and switch to discovery view
        const nextQ = word.trim();
        setSearch({
          q: nextQ,
          genre: null,
          type: "all",
          mediaTypeFilter: null,
        });
        setView("discovery");
      }
    };

    window.addEventListener("flickword:explore", handleFlickWordExplore);
    return () => {
      window.removeEventListener("flickword:explore", handleFlickWordExplore);
    };
  }, []);

  // For You configuration from settings
  const forYouRows = useForYouRows();
  const forYouContent = useForYouContent(forYouRows);

  // Lists - using new Library system with reactive updates
  const watching = useLibrary("watching");
  const wishlist = useLibrary("wishlist");
  const watched = useLibrary("watched");

  // Show all watching items in the tab (no filtering)
  // Note: The "Returning" tab is a separate smart view for returning shows
  // Users should see all their watching items in the Currently Watching tab
  const watchingVisible = useMemo(() => {
    return watching; // Show all items - don't filter out returning shows
  }, [watching]);

  // Analytics for Returning tab open
  useEffect(() => {
    if (view === "returning") {
      trackTabOpenedReturning(Array.isArray(returning) ? returning.length : 0);
    }
  }, [view, returning]);

  // Data rails
  const theaters = useInTheaters();

  // Mobile Settings breakpoint - use sheet below this width
  const MOBILE_SETTINGS_BREAKPOINT = 744;

  /**
   * Helper to determine if mobile SettingsSheet should be used instead of desktop SettingsPage
   * Checks viewport width, compact mobile gate, and feature flag
   */
  function shouldUseMobileSettings(): boolean {
    // Guard for SSR
    if (typeof window === "undefined") return false;

    const width = window.innerWidth;

    // Check existing gate / flag checks
    const isCompact = isCompactMobileV1 ? isCompactMobileV1() : false;
    const flagEnabled = flag ? flag("settings_mobile_sheet_v1") : true;

    // If flag is disabled, always use desktop
    if (!flagEnabled) return false;

    // Use mobile sheet if viewport is narrow OR compact mobile is enabled
    if (width <= MOBILE_SETTINGS_BREAKPOINT) return true;
    if (isCompact) return true;

    return false;
  }

  // Handle settings click - route mobile to SettingsSheet, desktop to SettingsPage
  const handleSettingsClick = () => {
    console.log("üîß handleSettingsClick called");
    if (shouldUseMobileSettings()) {
      console.log("üîß Opening SettingsSheet");
      openSettingsSheet();
    } else {
      console.log("üîß Opening SettingsPage");
      setShowSettings(true);
    }
  };

  // Initialize action bridge and backfill show status
  useEffect(() => {
    // Set up toast callback for personality-based feedback
    setToastCallback(addToast);

    const cleanup = mountActionBridge();

    // Trigger show status backfill after a short delay
    const backfillTimer = setTimeout(() => {
      // ‚ö†Ô∏è REMOVED: debugGate diagnostics disabled
      backfillShowStatus();
    }, 3000); // Wait 3 seconds after app loads

    return () => {
      cleanup();
      clearTimeout(backfillTimer);
    };
  }, [addToast]);

  // Handle deep links for settings sheet and games
  useEffect(() => {
    const handleHashChange = () => {
      const hash = window.location.hash;
      if (hash.startsWith("#settings/")) {
        const sectionId = hash.replace("#settings/", "").toLowerCase();

        // Valid section IDs from settingsConfig
        const validSections = [
          "account",
          "notifications",
          "display",
          "pro",
          "data",
          "about",
          "admin",
        ];

        if (shouldUseMobileSettings()) {
          // On mobile, open SettingsSheet with the section
          if (validSections.includes(sectionId)) {
            openSettingsSheet(sectionId as any);
          } else {
            openSettingsSheet(); // Default to section list
          }
        } else {
          // On desktop, open SettingsPage and navigate to section
          setShowSettings(true);
          // Dispatch event to navigate to section (SettingsPage listens for this)
          window.dispatchEvent(
            new CustomEvent("navigate-to-settings-section", {
              detail: { sectionId },
            })
          );
        }
      } else if (hash === "#games/flickword") {
        setShowFlickWordModal(true);
      }
    };

      /**
       * Deep-link handling for shared URLs from list/show/game sharing.
       * 
       * Supported deep-link formats:
       * - ?view=list&listId=... - Opens list detail in My Lists view
       * - ?view=title&tmdbId=... - Navigates to search/discovery for the show
       * - ?view=title&titleId=... - Navigates to search/discovery for the show
       * - ?game=flickword&date=...&gameNumber=... - Opens FlickWord game
       * - ?game=trivia&date=...&gameNumber=... - Opens Trivia game
       */
      const handleQueryParams = () => {
        const urlParams = new URLSearchParams(window.location.search);
        const viewParam = urlParams.get("view");
        const gameParam = urlParams.get("game");
        
        // Handle list deep links - reuses same navigation as clicking a list in UI
        if (viewParam === "list") {
          const listId = urlParams.get("listId");
          // Validate: only proceed if listId is present and not empty
          if (listId && listId.trim() !== "") {
            // Navigate to mylists view (same as clicking "My Lists" in UI)
            setView("mylists");
            // Store listId for MyListsPage to select (canonical way to open list detail)
            try {
              localStorage.setItem("flicklet:shareListId", listId);
              // Dispatch event to notify MyListsPage (same event used by UI clicks)
              window.dispatchEvent(
                new CustomEvent("flicklet:selectList", { detail: { listId } })
              );
            } catch (e) {
              console.warn("Failed to store list share params:", e);
            }
            
            // Clean up URL
            const newUrl = new URL(window.location.href);
            newUrl.searchParams.delete("view");
            newUrl.searchParams.delete("listId");
            window.history.replaceState({}, "", newUrl.toString());
          }
          // If listId is missing or empty, app boots normally (no deep-link action)
        }
        // Handle show deep links - navigates to appropriate view based on where show exists
        // Note: There is no in-app detail modal, so we navigate to the tab where the show
        // appears in the user's library, or to discovery if not found. This reuses the
        // same navigation as clicking a card in the UI.
        else if (viewParam === "title") {
          const tmdbId = urlParams.get("tmdbId");
          const titleId = urlParams.get("titleId");
          
          // Validate: proceed if at least one ID is present and not empty
          const hasValidTmdbId = tmdbId && tmdbId.trim() !== "";
          const hasValidTitleId = titleId && titleId.trim() !== "";
          
          if (hasValidTmdbId || hasValidTitleId) {
            // Try to find the show in the user's library
            // Check both tv and movie media types since we don't know which it is
            let foundList: "watching" | "want" | "watched" | null = null;
            const idToCheck = hasValidTmdbId ? tmdbId : titleId;
            
            if (idToCheck) {
              // Try to find in library (check both tv and movie)
              const numericId = hasValidTmdbId ? parseInt(idToCheck, 10) : idToCheck;
              if (!isNaN(numericId as number) || typeof numericId === "string") {
                const tvList = Library.getCurrentList(numericId, "tv");
                const movieList = Library.getCurrentList(numericId, "movie");
                
                if (tvList === "watching" || tvList === "wishlist" || tvList === "watched") {
                  foundList = tvList === "wishlist" ? "want" : tvList;
                } else if (movieList === "watching" || movieList === "wishlist" || movieList === "watched") {
                  foundList = movieList === "wishlist" ? "want" : movieList;
                }
              }
            }
            
            // Navigate to the appropriate view
            if (foundList) {
              // Show is in user's library - navigate to that tab (same as clicking a card)
              setView(foundList);
            } else {
              // Show not in library - navigate to discovery where user can find it
              setView("discovery");
            }
            
            // Store the ID in localStorage for potential use by search/discovery
            // This allows search to potentially look up the show if needed
            try {
              if (hasValidTmdbId) {
                localStorage.setItem("flicklet:shareTmdbId", tmdbId);
              }
              if (hasValidTitleId) {
                localStorage.setItem("flicklet:shareTitleId", titleId);
              }
            } catch (e) {
              console.warn("Failed to store title share params:", e);
            }
            
            // Clean up URL
            const newUrl = new URL(window.location.href);
            newUrl.searchParams.delete("view");
            newUrl.searchParams.delete("tmdbId");
            newUrl.searchParams.delete("titleId");
            window.history.replaceState({}, "", newUrl.toString());
          }
          // If both IDs are missing or empty, app boots normally (no deep-link action)
        }
      // Handle game share links (existing)
      else if (gameParam === "flickword") {
        // Open FlickWord modal
        setShowFlickWordModal(true);
        
        // Store share link params for FlickWord to use
        const date = urlParams.get("date");
        const gameNumber = urlParams.get("gameNumber");
        const mode = urlParams.get("mode"); // 'sharedResult', 'sharedAll', or 'play'
        
        // Build properly typed share params object
        if (date) {
          try {
            const shareParams: FlickWordShareParams = {
              date: date,
              gameNumber: gameNumber ? parseInt(gameNumber, 10) : null,
              mode: (mode === "sharedResult" || mode === "sharedAll" || mode === "play") ? mode : mode || "play",
            };
            localStorage.setItem(storageKeyFlickWordShareParams, JSON.stringify(shareParams));
          } catch (e) {
            console.warn("Failed to store share params:", e);
          }
        }
        
        // Clean up URL (remove query params after processing)
        const newUrl = new URL(window.location.href);
        newUrl.searchParams.delete("game");
        newUrl.searchParams.delete("date");
        newUrl.searchParams.delete("gameNumber");
        newUrl.searchParams.delete("mode");
        window.history.replaceState({}, "", newUrl.toString());
      } else if (gameParam === "trivia") {
        // Open Trivia modal
        // Dispatch event to open Trivia modal (similar to FlickWord)
        window.dispatchEvent(new CustomEvent("open-trivia-modal"));
        
        // Store share link params for Trivia to use
        const date = urlParams.get("date");
        const gameNumber = urlParams.get("gameNumber");
        const score = urlParams.get("score");
        const mode = urlParams.get("mode"); // 'sharedResult' or 'play'
        
        if (date || gameNumber || score || mode) {
          try {
            localStorage.setItem("trivia:shareParams", JSON.stringify({
              date: date || null,
              gameNumber: gameNumber ? parseInt(gameNumber, 10) : null,
              score: score ? parseInt(score, 10) : null,
              mode: mode || "play"
            }));
          } catch (e) {
            console.warn("Failed to store Trivia share params:", e);
          }
        }
        
        // Clean up URL (remove query params after processing)
        const newUrl = new URL(window.location.href);
        newUrl.searchParams.delete("game");
        newUrl.searchParams.delete("date");
        newUrl.searchParams.delete("gameNumber");
        newUrl.searchParams.delete("score");
        newUrl.searchParams.delete("mode");
        window.history.replaceState({}, "", newUrl.toString());
      }
    };

    // Check hash on load
    handleHashChange();
    
    // Check query params on load
    handleQueryParams();

    // Listen for hash changes
    window.addEventListener("hashchange", handleHashChange);
    return () => window.removeEventListener("hashchange", handleHashChange);
  }, []);

  // Listen for custom event to open SettingsPage (e.g., from SnarkDisplay or startProUpgrade)
  useEffect(() => {
    const handleOpenSettingsPage = () => {
      if (shouldUseMobileSettings()) {
        openSettingsSheet();
      } else {
        setShowSettings(true);
      }
    };

    window.addEventListener("settings:open-page", handleOpenSettingsPage);
    return () => {
      window.removeEventListener("settings:open-page", handleOpenSettingsPage);
    };
  }, []);

  // Expose game functions globally for compatibility with legacy code
  useEffect(() => {
    (window as any).openFlickWordModal = () => {
      setShowFlickWordModal(true);
    };

    (window as any).closeFlickWordModal = () => {
      setShowFlickWordModal(false);
    };

    return () => {
      delete (window as any).openFlickWordModal;
      delete (window as any).closeFlickWordModal;
    };
  }, []);

  // Show loading screen until auth state is initialized
  // Add timeout to prevent infinite loading
  const [loadingTimeout, setLoadingTimeout] = useState(false);
  useEffect(() => {
    if (!authInitialized) {
      const timer = setTimeout(() => {
        setLoadingTimeout(true);
        console.error(
          "[App] Auth initialization timeout - authInitialized still false after 10 seconds"
        );
      }, 10000); // 10 second timeout
      return () => clearTimeout(timer);
    } else {
      setLoadingTimeout(false);
    }
  }, [authInitialized]);

  function itemsFor(id: string) {
    switch (id) {
      case "currently-watching":
        return watching;
      case "up-next":
        return []; // TODO: populate from episodes
      case "in-theaters":
        return theaters.data ?? [];
      default:
        return undefined;
    }
  }

  // Notes and Tags handlers
  const handleNotesEdit = (item: any) => {
    setNotesModalItem(item);
    setShowNotesModal(true);
  };

  const handleTagsEdit = (item: any) => {
    setNotesModalItem(item);
    setShowNotesModal(true);
  };

  // Notification handler
  const handleNotificationToggle = (item: any) => {
    console.log(
      "üîî App.tsx handleNotificationToggle called for:",
      item.title,
      item.mediaType
    );
    console.log("üîî Setting notification modal state:", {
      showNotificationModal: true,
      notificationModalItem: item,
    });
    setNotificationModalItem(item);
    setShowNotificationModal(true);
    console.log("üîî Modal state should now be set");
  };

  // Simple reminder handler (Free feature)
  const handleSimpleReminder = (item: any) => {
    console.log(
      "‚è∞ App.tsx handleSimpleReminder called for:",
      item.title,
      item.mediaType
    );
    // For now, just show a simple alert - this will be replaced with actual reminder logic
    alert(
      `‚è∞ Simple reminder set for "${item.title}" - you'll be notified 24 hours before the next episode airs!`
    );
  };

  // Bloopers handler
  const handleBloopersOpen = (item: any) => {
    console.log(
      "üé¨ App.tsx handleBloopersOpen called for:",
      item.title,
      item.mediaType
    );
    console.log("üé¨ Setting bloopers modal state:", {
      showBloopersModal: true,
      bloopersModalItem: item,
    });

    flushSync(() => {
      setBloopersModalItem(item);
      setShowBloopersModal(true);
    });

    console.log("üé¨ Bloopers modal state should now be set");
  };

  // Goofs handler
  const handleGoofsOpen = (item: any) => {
    console.log(
      "üé≠ App.tsx handleGoofsOpen called for:",
      item.title,
      item.mediaType
    );
    console.log("üé≠ Setting goofs modal state:", {
      showGoofsModal: true,
      goofsModalItem: item,
    });

    flushSync(() => {
      setGoofsModalItem(item);
      setShowGoofsModal(true);
    });

    console.log("üé≠ Goofs modal state should now be set");
  };

  // Extras handler
  const handleExtrasOpen = (item: any) => {
    console.log(
      "üé≠ App.tsx handleExtrasOpen called for:",
      item.title,
      item.mediaType
    );
    console.log("üé≠ Setting extras modal state:", {
      showExtrasModal: true,
      extrasModalItem: item,
    });

    flushSync(() => {
      setExtrasModalItem(item);
      setShowExtrasModal(true);
    });

    console.log("üé≠ Extras modal state should now be set");
  };

  // Help handler
  const handleHelpOpen = () => {
    console.log("‚ùì App.tsx handleHelpOpen called");
    console.log("‚ùì Current showHelpModal state:", showHelpModal);
    setShowHelpModal(true);
    console.log("‚ùì setShowHelpModal(true) called");
  };

  const handleSaveNotesAndTags = (item: any, notes: string, tags: string[]) => {
    // Update the item in the library with new notes and tags
    Library.updateNotesAndTags(item.id, item.mediaType, notes, tags);
    setShowNotesModal(false);
    setNotesModalItem(null);
  };

  if (view !== "home") {
    return (
      <>
        <main
          className="min-h-screen"
          style={{
            backgroundColor: "var(--bg)",
            color: "var(--text)",
            minHeight: "100lvh",
          }}
        >
          {/* Debug: Show when modal should be visible - TOP LEVEL */}
          {showExtrasModal && (
            <div
              style={{
                position: "fixed",
                top: "10px",
                left: "10px",
                background: "red",
                color: "white",
                padding: "10px",
                zIndex: 9999,
                fontSize: "12px",
              }}
            >
              üé¨ MODAL SHOULD BE VISIBLE: {extrasModalItem?.title}
            </div>
          )}

          <FlickletHeader
            appName="Flicklet"
            onSearch={(q, g, t, m) =>
              handleSearch(q, g ?? null, (t as SearchType) ?? "all", m)
            }
            onClear={handleClear}
            onHelpOpen={() => {
              console.log("‚ùì App.tsx onHelpOpen prop called");
              handleHelpOpen();
            }}
            onNavigateHome={() => {
              handleClear();
              setView("home");
            }}
          />

          {/* Desktop Tabs - tablet and above */}
          <div className="hidden md:block">
            <Tabs
              current={view}
              onChange={(tab) => {
                // Clear search when switching tabs
                handleClear();
                setView(tab);
              }}
            />
          </div>

          {/* Mobile Tabs - mobile only */}
          <div className="block md:hidden">
            <MobileTabs
              current={view}
              onChange={(tab) => {
                // Clear search when switching tabs (consistent with desktop behavior)
                // Use setTimeout to ensure clear happens before view change on iOS
                handleClear();
                // Small delay to ensure state updates properly on iOS Safari
                setTimeout(() => {
                  setView(tab);
                }, 0);
              }}
            />
          </div>

          {/* Content Area */}
          <div
            className="pb-20 lg:pb-0"
            style={{
              paddingBottom:
                viewportOffset > 0 && window.visualViewport?.offsetTop === 0
                  ? `${80 + viewportOffset}px`
                  : undefined,
            }}
          >
            {searchActive ? (
              <SearchResults
                query={search.q}
                genre={search.genre}
                searchType={search.type}
                mediaTypeFilter={search.mediaTypeFilter}
                onBackToHome={() => {
                  handleClear();
                  setView("home");
                }}
              />
            ) : (
              <>
                {/* Old home block removed - using newer layout with HomeMarquee and Section components below */}
                {/* The canonical homeContentAnchorRef is now in the newer home layout */}
                {view === "watching" && (
                  <Suspense
                    fallback={
                      <div className="loading-spinner">
                        Loading watching list...
                      </div>
                    }
                  >
                    <PullToRefreshWrapper onRefresh={handleRefresh}>
                      <div data-page="lists" data-list="watching">
                        <ListPage
                          title="Currently Watching"
                          items={watchingVisible}
                          mode="watching"
                          onNotesEdit={handleNotesEdit}
                          onTagsEdit={handleTagsEdit}
                          onNotificationToggle={handleNotificationToggle}
                          onSimpleReminder={handleSimpleReminder}
                          onBloopersOpen={handleBloopersOpen}
                          onGoofsOpen={handleGoofsOpen}
                          onExtrasOpen={handleExtrasOpen}
                        />
                      </div>
                    </PullToRefreshWrapper>
                  </Suspense>
                )}
                {view === "want" && (
                  <Suspense
                    fallback={
                      <div className="loading-spinner">Loading wishlist...</div>
                    }
                  >
                    <PullToRefreshWrapper onRefresh={handleRefresh}>
                      <div data-page="lists" data-list="wishlist">
                        <ListPage
                          title="Want to Watch"
                          items={wishlist}
                          mode="want"
                          onNotesEdit={handleNotesEdit}
                          onTagsEdit={handleTagsEdit}
                          onNotificationToggle={handleNotificationToggle}
                          onSimpleReminder={handleSimpleReminder}
                          onBloopersOpen={handleBloopersOpen}
                          onGoofsOpen={handleGoofsOpen}
                          onExtrasOpen={handleExtrasOpen}
                        />
                      </div>
                    </PullToRefreshWrapper>
                  </Suspense>
                )}
                {view === "watched" && (
                  <Suspense
                    fallback={
                      <div className="loading-spinner">
                        Loading watched list...
                      </div>
                    }
                  >
                    <PullToRefreshWrapper onRefresh={handleRefresh}>
                      <div data-page="lists" data-list="watched">
                        <ListPage
                          title="Watched"
                          items={watched}
                          mode="watched"
                          onNotesEdit={handleNotesEdit}
                          onTagsEdit={handleTagsEdit}
                          onNotificationToggle={handleNotificationToggle}
                          onSimpleReminder={handleSimpleReminder}
                          onBloopersOpen={handleBloopersOpen}
                          onGoofsOpen={handleGoofsOpen}
                          onExtrasOpen={handleExtrasOpen}
                        />
                      </div>
                    </PullToRefreshWrapper>
                  </Suspense>
                )}
                {view === "returning" && (
                  <Suspense
                    fallback={
                      <div className="loading-spinner">
                        Loading returning shows...
                      </div>
                    }
                  >
                    <PullToRefreshWrapper onRefresh={handleRefresh}>
                      <div data-page="lists" data-list="returning">
                        <ListPage
                          title="Returning"
                          items={returning as any}
                          mode="returning"
                          onNotesEdit={handleNotesEdit}
                          onTagsEdit={handleTagsEdit}
                          onNotificationToggle={handleNotificationToggle}
                          onSimpleReminder={handleSimpleReminder}
                          onBloopersOpen={handleBloopersOpen}
                          onGoofsOpen={handleGoofsOpen}
                          onExtrasOpen={handleExtrasOpen}
                        />
                      </div>
                    </PullToRefreshWrapper>
                  </Suspense>
                )}
                {view === "mylists" && (
                  <Suspense
                    fallback={
                      <div className="loading-spinner">Loading my lists...</div>
                    }
                  >
                    <div data-page="lists" data-list="mylists">
                      <MyListsPage />
                    </div>
                  </Suspense>
                )}
                {view === "discovery" && (
                  <Suspense
                    fallback={
                      <div className="loading-spinner">
                        Loading discovery...
                      </div>
                    }
                  >
                    <DiscoveryPage
                      query={search.q}
                      genreId={search.genre || null}
                    />
                  </Suspense>
                )}
              </>
            )}
          </div>

          {/* Offline Indicator */}
          {!isOnline && (
            <div className="fixed top-4 left-1/2 transform -translate-x-1/2 z-50 bg-yellow-500 text-black px-4 py-2 rounded-lg shadow-lg text-sm font-medium">
              üì± You&apos;re offline - viewing cached content
            </div>
          )}

          {/* FAB Components - Available on all tabs */}
          <SettingsFAB onClick={handleSettingsClick} />
          <ThemeToggleFAB
            theme={settings.layout.theme}
            onToggle={() =>
              settingsManager.updateTheme(
                settings.layout.theme === "dark" ? "light" : "dark"
              )
            }
          />

          {/* Settings Modal (Desktop) */}
          {showSettings && (
            <Suspense
              fallback={
                <div className="loading-spinner">Loading settings...</div>
              }
            >
              <SettingsPage onClose={() => setShowSettings(false)} />
            </Suspense>
          )}

          {/* Settings Sheet (Mobile) */}
          <SettingsSheet />

          {/* Notes and Tags Modal */}
          {showNotesModal && notesModalItem && (
            <Suspense
              fallback={<div className="loading-spinner">Loading notes...</div>}
            >
              <NotesAndTagsModal
                item={notesModalItem}
                isOpen={showNotesModal}
                onClose={() => setShowNotesModal(false)}
                onSave={handleSaveNotesAndTags}
              />
            </Suspense>
          )}

          {/* Show Notification Settings Modal */}
          {(() => {
            const shouldRender = showNotificationModal && notificationModalItem;
            console.log("üîî Modal render check:", {
              showNotificationModal,
              notificationModalItem: notificationModalItem?.title,
              shouldRender,
            });
            return shouldRender;
          })() && (
            <ShowNotificationSettingsModal
              isOpen={showNotificationModal}
              onClose={() => {
                console.log("üîî Closing notification modal");
                setShowNotificationModal(false);
              }}
              show={{
                id: Number(notificationModalItem.id),
                title: notificationModalItem.title,
                mediaType: notificationModalItem.mediaType,
              }}
            />
          )}

          {/* Bloopers Modal - DEPRECATED: Use GoofsModal instead */}
          {console.log("üé¨ BloopersModal render check:", {
            showBloopersModal,
            hasBloopersModalItem: !!bloopersModalItem,
            bloopersModalItemTitle: bloopersModalItem?.title,
          })}
          {showBloopersModal && bloopersModalItem && (
            <BloopersModal
              isOpen={showBloopersModal}
              onClose={() => setShowBloopersModal(false)}
              showId={(() => {
                const id =
                  typeof bloopersModalItem.id === "string"
                    ? parseInt(bloopersModalItem.id)
                    : bloopersModalItem.id;
                console.log("üé¨ BloopersModal showId conversion:", {
                  originalId: bloopersModalItem.id,
                  convertedId: id,
                  type: typeof id,
                });
                return id;
              })()}
              showTitle={bloopersModalItem.title}
            />
          )}

          {/* Goofs Modal */}
          {showGoofsModal && goofsModalItem && (
            <GoofsModal
              isOpen={showGoofsModal}
              onClose={() => setShowGoofsModal(false)}
              tmdbId={(() => {
                const id =
                  typeof goofsModalItem.id === "string"
                    ? parseInt(goofsModalItem.id)
                    : goofsModalItem.id;
                console.log("üé≠ GoofsModal tmdbId conversion:", {
                  originalId: goofsModalItem.id,
                  convertedId: id,
                  type: typeof id,
                });
                return id;
              })()}
              title={goofsModalItem.title}
            />
          )}

          {/* Extras Modal */}
          {showExtrasModal && extrasModalItem && (
            <ExtrasModal
              isOpen={showExtrasModal}
              onClose={() => setShowExtrasModal(false)}
              showId={(() => {
                const id =
                  typeof extrasModalItem.id === "string"
                    ? parseInt(extrasModalItem.id)
                    : extrasModalItem.id;
                console.log("üé≠ ExtrasModal showId conversion:", {
                  originalId: extrasModalItem.id,
                  convertedId: id,
                  type: typeof id,
                });
                return id;
              })()}
              showTitle={extrasModalItem.title}
              mediaType={extrasModalItem.mediaType === "movie" ? "movie" : "tv"}
            />
          )}

          {/* Help Modal */}
          {showHelpModal && (
            <HelpModal
              isOpen={showHelpModal}
              onClose={() => setShowHelpModal(false)}
            />
          )}
        </main>
        {/* Popup hint banner */}
        {showPopupHint && (
          <div className="fixed bottom-16 left-1/2 -translate-x-1/2 z-[10000] rounded-lg border bg-background/95 backdrop-blur px-3 py-2 text-xs md:text-sm text-foreground shadow-lg">
            <div className="flex items-center gap-2">
              <span>
                Allow popups and third‚Äëparty cookies for Google sign‚Äëin.
              </span>
              <button
                className="rounded border px-2 py-0.5 text-[11px] hover:bg-accent hover:text-accent-foreground"
                onClick={() => {
                  try {
                    localStorage.removeItem("flicklet.auth.popup.hint");
                  } catch (e) {
                    /* ignore */
                  }
                  setShowPopupHint(false);
                  // User gesture: retry
                  void googleLogin();
                }}
              >
                Try again
              </button>
              <button
                className="rounded border px-2 py-0.5 text-[11px] hover:bg-muted"
                onClick={() => {
                  try {
                    localStorage.removeItem("flicklet.auth.popup.hint");
                  } catch (e) {
                    /* ignore */
                  }
                  setShowPopupHint(false);
                }}
                aria-label="Dismiss"
                title="Dismiss"
              >
                Dismiss
              </button>
            </div>
          </div>
        )}

        {/* Toast Notifications */}
        {toasts.map((toast) => (
          <Toast
            key={toast.id}
            message={toast.message}
            type={toast.type}
            personalityLevel={settings.personalityLevel}
            onClose={() => removeToast(toast.id)}
          />
        ))}
      </>
    );
  }

  if (!authInitialized) {
    return (
      <div
        className="min-h-screen flex items-center justify-center"
        style={{ backgroundColor: "var(--bg)", color: "var(--text)" }}
      >
        <div className="text-center">
          <div className="w-8 h-8 border-2 border-current border-t-transparent rounded-full animate-spin mx-auto mb-4"></div>
          <p className="text-sm" style={{ color: "var(--muted)" }}>
            Loading...
          </p>
          {loadingTimeout && (
            <div
              className="mt-4 p-3 rounded border"
              style={{
                backgroundColor: "var(--btn)",
                borderColor: "var(--line)",
              }}
            >
              <p className="text-xs mb-2" style={{ color: "var(--muted)" }}>
                Loading is taking longer than expected.
              </p>
              <button
                onClick={() => window.location.reload()}
                className="px-3 py-1.5 text-xs rounded transition-colors"
                style={{
                  backgroundColor: "var(--accent)",
                  color: "var(--text)",
                }}
              >
                Reload Page
              </button>
            </div>
          )}
        </div>
      </div>
    );
  }

  // Render debug auth page if on /debug/auth route
  if (isDebugAuth) {
    return (
      <PersonalityErrorBoundary>
        <Suspense
          fallback={
            <div
              className="min-h-screen flex items-center justify-center"
              style={{ backgroundColor: "var(--bg)", color: "var(--text)" }}
            >
              <div className="text-center">
                <div className="w-8 h-8 border-2 border-current border-t-transparent rounded-full animate-spin mx-auto mb-4"></div>
                <p className="text-sm" style={{ color: "var(--muted)" }}>
                  Loading...
                </p>
              </div>
            </div>
          }
        >
          <AuthDebugPage />
        </Suspense>
      </PersonalityErrorBoundary>
    );
  }

  // Render unsubscribe page if on /unsubscribe route
  if (isUnsubscribe) {
    return (
      <PersonalityErrorBoundary>
        <Suspense
          fallback={
            <div
              className="min-h-screen flex items-center justify-center"
              style={{ backgroundColor: "var(--bg)", color: "var(--text)" }}
            >
              <div className="text-center">
                <div className="w-8 h-8 border-2 border-current border-t-transparent rounded-full animate-spin mx-auto mb-4"></div>
                <p className="text-sm" style={{ color: "var(--muted)" }}>
                  Loading...
                </p>
              </div>
            </div>
          }
        >
          <UnsubscribePage />
        </Suspense>
      </PersonalityErrorBoundary>
    );
  }

  // Render admin page if on /admin route
  if (isAdmin) {
    return (
      <PersonalityErrorBoundary>
        <Suspense
          fallback={
            <div
              className="min-h-screen flex items-center justify-center"
              style={{ backgroundColor: "var(--bg)", color: "var(--text)" }}
            >
              <div className="text-center">
                <div className="w-8 h-8 border-2 border-current border-t-transparent rounded-full animate-spin mx-auto mb-4"></div>
                <p className="text-sm" style={{ color: "var(--muted)" }}>
                  Loading...
                </p>
              </div>
            </div>
          }
        >
          <AdminPage />
        </Suspense>
      </PersonalityErrorBoundary>
    );
  }

  // Render post detail page if on /posts/:slug route
  if (postSlug) {
    return (
      <PersonalityErrorBoundary>
        <PostDetail slug={postSlug} />
      </PersonalityErrorBoundary>
    );
  }

  return (
    <PersonalityErrorBoundary>
      <main
        className="min-h-screen"
        style={{
          backgroundColor: "var(--bg)",
          color: "var(--text)",
          minHeight: "100lvh",
        }}
      >
        <FlickletHeader
          appName="Flicklet"
          onSearch={(q, g, t, m) =>
            handleSearch(q, g ?? null, (t as SearchType) ?? "all", m)
          }
          onClear={handleClear}
          onHelpOpen={handleHelpOpen}
          onNavigateHome={() => {
            handleClear();
            setView("home");
          }}
        />

        {/* Desktop Tabs - tablet and above */}
        <div className="hidden md:block">
          <Tabs
            current={view}
            onChange={(tab) => {
              // Clear search when switching tabs
              handleClear();
              setView(tab);
            }}
          />
        </div>

        {/* Mobile Tabs - mobile only */}
        <div className="block md:hidden">
          <MobileTabs
            current={view}
            onChange={(tab) => {
              // Clear search when switching tabs (consistent with desktop behavior)
              handleClear();
              setView(tab);
            }}
          />
        </div>

        {searchActive ? (
          <PullToRefreshWrapper onRefresh={handleRefresh}>
            <SearchResults
              query={search.q}
              genre={search.genre}
              searchType={search.type}
              mediaTypeFilter={search.mediaTypeFilter}
              onBackToHome={() => {
                handleClear();
                setView("home");
              }}
            />
          </PullToRefreshWrapper>
        ) : (
          <PullToRefreshWrapper onRefresh={handleRefresh}>
            <>
              {view === "home" && (
                <div
                  className="pb-20 lg:pb-0"
                  style={{
                    paddingBottom:
                      viewportOffset > 0 &&
                      window.visualViewport?.offsetTop === 0
                        ? `${80 + viewportOffset}px`
                        : undefined,
                  }}
                >
                  {/* Home Marquee - between tabs and Your Shows */}
                  <HomeMarquee messages={HOME_MARQUEE_MESSAGES} />

                  {/* Content anchor - scroll target for down-arrow */}
                  {/* This marks where the main content starts (first rail / main feed) */}
                  <div 
                    ref={homeContentAnchorRef}
                    id="home-content-anchor"
                    style={{ scrollMarginTop: '100px' }} // Account for sticky header
                  />

                  {/* Your Shows container with both rails */}
                  <Section title={translations.yourShows}>
                    <div className="space-y-4">
                      <HomeYourShowsRail />
                      <div
                        data-onboarding-id="home-your-shows-between"
                        className="h-4"
                      />
                      <HomeUpNextRail />
                    </div>
                  </Section>

                  {/* Community container, always visible */}
                  <Section title={translations.community}>
                    <CommunityPanel />
                  </Section>

                  {/* For you container with dynamic rails based on settings */}
                  <Section
                    title={translations.forYou}
                    inlineHeaderAction={true}
                    headerAction={
                      <span
                        className="font-normal text-sm"
                        style={{ color: "var(--muted)" }}
                      >
                        (
                        <button
                          onClick={() => {
                            // CTA: Opens Settings directly to the personalization/home-rows section.
                            openSettingsAtSection("display", setShowSettings);
                            // Scroll to row 1 after a delay to ensure Settings is mounted
                            setTimeout(() => {
                              const row1 =
                                document.getElementById("for-you-row-1");
                              if (row1) {
                                row1.scrollIntoView({
                                  behavior: "smooth",
                                  block: "start",
                                });
                              }
                            }, 300);
                          }}
                          className="text-sm text-blue-600 dark:text-blue-400 hover:text-blue-700 dark:hover:text-blue-300 underline font-normal"
                          aria-label="Configure For You section"
                        >
                          Click here to personalize these rows.
                        </button>
                        )
                      </span>
                    }
                  >
                    <div className="space-y-4">
                      {forYouContent.map((contentQuery) => (
                        <Rail
                          key={`for-you-${contentQuery.rowId}`}
                          id={`for-you-${contentQuery.rowId}`}
                          title={contentQuery.title}
                          items={
                            Array.isArray(contentQuery.data)
                              ? contentQuery.data
                              : []
                          }
                          skeletonCount={12}
                        />
                      ))}
                    </div>
                  </Section>

                  {/* In theaters container with address/info header */}
                  <Section title={translations.inTheatersNearYou}>
                    <TheaterInfo />
                    <Rail
                      id="in-theaters"
                      title={translations.nowPlaying}
                      items={
                        Array.isArray(itemsFor("in-theaters"))
                          ? itemsFor("in-theaters")!.map((item) => ({
                              ...item,
                              id: String(item.id),
                              year: item.year
                                ? parseInt(String(item.year))
                                : undefined,
                            }))
                          : []
                      }
                      skeletonCount={12}
                    />
                  </Section>

                  {/* Feedback container */}
                  <Section title={translations.feedback}>
                    <FeedbackPanel />
                  </Section>

                  {/* Home down-arrow - scrolls to content anchor (only on Home page) */}
                  {view === "home" && (
                    <HomeDownArrow contentAnchorRef={homeContentAnchorRef} />
                  )}
                  
                  {/* Scroll to top arrow - appears when scrolled down */}
                  <ScrollToTopArrow threshold={400} />
                </div>
              )}

              {/* These views are handled in the main home view above */}
            </>
          </PullToRefreshWrapper>
        )}

        {/* FAB Components - Available on all tabs */}
        <SettingsFAB onClick={handleSettingsClick} />
        <ThemeToggleFAB
          theme={settings.layout.theme}
          onToggle={() =>
            settingsManager.updateTheme(
              settings.layout.theme === "dark" ? "light" : "dark"
            )
          }
        />

        {/* Settings Modal (Desktop) */}
        {showSettings && (
          <Suspense
            fallback={
              <div className="loading-spinner">Loading settings...</div>
            }
          >
            <SettingsPage onClose={() => setShowSettings(false)} />
          </Suspense>
        )}

        {/* Settings Sheet (Mobile) */}
        <SettingsSheet />

        {/* Notes and Tags Modal */}
        {showNotesModal && notesModalItem && (
          <Suspense
            fallback={<div className="loading-spinner">Loading notes...</div>}
          >
            <NotesAndTagsModal
              item={notesModalItem}
              isOpen={showNotesModal}
              onClose={() => setShowNotesModal(false)}
              onSave={handleSaveNotesAndTags}
            />
          </Suspense>
        )}

        {/* Toast Notifications */}
        {toasts.map((toast) => (
          <Toast
            key={toast.id}
            message={toast.message}
            type={toast.type}
            personalityLevel={settings.personalityLevel}
            onClose={() => removeToast(toast.id)}
          />
        ))}

        {/* Auth Modal */}
        <AuthModal
          isOpen={showAuthModal}
          onClose={() => setShowAuthModal(false)}
        />

        {/* Auth Config Error Surface */}
        <AuthConfigError />

        {/* Onboarding Coachmarks */}
        {(() => {
          console.log("[App] Rendering OnboardingCoachmarks component");
          return <OnboardingCoachmarks />;
        })()}

        {/* Debug HUD */}
        {showDebugHUD && (
          <DebugAuthHUD
            status={status}
            authLoading={authLoading}
            authInitialized={authInitialized}
            isAuthenticated={isAuthenticated}
            showAuthModal={showAuthModal}
          />
        )}

        {/* FlickWord Game Modal */}
        {showFlickWordModal && (
          <Suspense
            fallback={<div className="loading-spinner">Loading game...</div>}
          >
            <FlickWordModal
              isOpen={showFlickWordModal}
              onClose={() => setShowFlickWordModal(false)}
            />
          </Suspense>
        )}

        {/* Help Modal */}
        {showHelpModal && (
          <HelpModal
            isOpen={showHelpModal}
            onClose={() => setShowHelpModal(false)}
          />
        )}
      </main>
    </PersonalityErrorBoundary>
  );
}

```

## apps/web/src/assets/help.json
### Summary
Static help copy referencing rating/discovery and guiding users.
### Content
```json
{
  "version": "1.0",
  "lastUpdated": "2025-01-01",
  "sections": {
    "pwa-install": {
      "title": "How to Install the PWA",
      "content": [
        {
          "type": "heading",
          "text": "Mobile (Android)"
        },
        {
          "type": "list",
          "items": [
            "Open Flicklet in Chrome or Edge browser",
            "Tap the menu (three dots) in the top right",
            "Select 'Install app' or 'Add to Home Screen'",
            "Confirm installation",
            "Open the app from your home screen"
          ]
        },
        {
          "type": "screenshot",
          "description": "Chrome ‚Üí Install prompt in address bar"
        },
        {
          "type": "heading",
          "text": "Desktop (Windows/Mac)"
        },
        {
          "type": "list",
          "items": [
            "Open Flicklet in Chrome or Edge browser",
            "Look for the install icon in the address bar",
            "Click 'Install' when prompted",
            "Or use the 'Install' button in the header",
            "The app will open in its own window"
          ]
        },
        {
          "type": "screenshot",
          "description": "Desktop ‚Üí Install button in header"
        },
        {
          "type": "heading",
          "text": "iOS (iPhone/iPad)"
        },
        {
          "type": "list",
          "items": [
            "Open Flicklet in Safari",
            "Tap the share button (square with arrow)",
            "Select 'Add to Home Screen'",
            "Customize the name if desired",
            "Tap 'Add'"
          ]
        },
        {
          "type": "screenshot",
          "description": "Safari ‚Üí Share sheet ‚Üí Add to Home Screen"
        },
        {
          "type": "note",
          "text": "Once installed, Flicklet opens faster and is easier to find on your device. Some features may work with limited offline support, but new data and notifications still require an internet connection."
        }
      ]
    },
    "search-tags": {
      "title": "How to Use Search & Tag Filters",
      "content": [
        {
          "type": "heading",
          "text": "Text Search"
        },
        {
          "type": "list",
          "items": [
            "Click the search bar at the top of the page",
            "Type a movie or TV show title",
            "Press Enter or click the search button",
            "Results appear with posters and descriptions",
            "You can also search for actor names"
          ]
        },
        {
          "type": "screenshot",
          "description": "Search bar ‚Üí typing 'The Office' ‚Üí highlighted results drop-down"
        },
        {
          "type": "heading",
          "text": "Tag Search"
        },
        {
          "type": "list",
          "items": [
            "Type 'tag:' followed by a tag name",
            "Example: 'tag:comedy' or 'tag:action'",
            "Press Enter to search",
            "Only items with that tag will appear"
          ]
        },
        {
          "type": "screenshot",
          "description": "Search bar ‚Üí typing 'tag:comedy' ‚Üí filtered results"
        },
        {
          "type": "heading",
          "text": "Tag Filtering"
        },
        {
          "type": "list",
          "items": [
            "After performing a search, look for tag chips",
            "Click any tag chip to filter by that tag",
            "Multiple tags can be active at once",
            "Click the 'X' on a tag chip to remove the filter"
          ]
        },
        {
          "type": "screenshot",
          "description": "Tag chip row ‚Üí clicking 'comedy' ‚Üí filtered feed"
        },
        {
          "type": "tip",
          "text": "Use the '/' key to quickly jump to the search bar!"
        }
      ]
    },
    "vote-comment-mention": {
      "title": "How to Vote, Comment & Mention",
      "content": [
        {
          "type": "heading",
          "text": "Voting"
        },
        {
          "type": "list",
          "items": [
            "Find the vote buttons (thumbs up/down) on any post",
            "Click thumbs up to upvote, thumbs down to downvote",
            "Click again to remove your vote",
            "You can only vote once per post",
            "Votes are anonymous but public"
          ]
        },
        {
          "type": "screenshot",
          "description": "Post card ‚Üí thumbs up/down buttons ‚Üí vote count updates live"
        },
        {
          "type": "heading",
          "text": "Commenting"
        },
        {
          "type": "list",
          "items": [
            "Scroll to the comments section at the bottom of a post",
            "Type your comment in the text box",
            "Click 'Post Comment' or press Ctrl+Enter (Cmd+Enter on Mac)",
            "Comments are limited to 5,000 characters",
            "Comments are automatically sanitized for inappropriate content"
          ]
        },
        {
          "type": "screenshot",
          "description": "Comment box ‚Üí typing ‚Üí 'Post Comment' button"
        },
        {
          "type": "heading",
          "text": "Mentioning Users"
        },
        {
          "type": "list",
          "items": [
            "Type '@' followed by a username in a comment",
            "Example: '@johndoe'",
            "The mentioned user will receive an email notification (if subscribed)",
            "Mentions are case-insensitive",
            "Make sure you spell the username correctly"
          ]
        },
        {
          "type": "screenshot",
          "description": "Comment box ‚Üí typing '@jane' ‚Üí mention highlight"
        },
        {
          "type": "heading",
          "text": "Replying to Comments"
        },
        {
          "type": "list",
          "items": [
            "Click 'Reply' on any comment",
            "Type your reply (limited to 500 characters)",
            "Click 'Post Reply' or press Enter",
            "The original commenter will receive a push notification",
            "Replies are nested under the original comment"
          ]
        },
        {
          "type": "screenshot",
          "description": "Comment ‚Üí 'Reply' button ‚Üí reply box ‚Üí nested reply"
        },
        {
          "type": "note",
          "text": "You must be signed in to vote, comment, or mention users."
        }
      ]
    },
    "unsubscribe-email": {
      "title": "How to Unsubscribe from Email",
      "content": [
        {
          "type": "heading",
          "text": "Method 1: Email Link"
        },
        {
          "type": "list",
          "items": [
            "Open your weekly digest email",
            "Scroll to the bottom",
            "Click the 'Unsubscribe' link",
            "You'll be redirected to the unsubscribe page",
            "Your subscription will be cancelled immediately"
          ]
        },
        {
          "type": "screenshot",
          "description": "Weekly digest email ‚Üí bottom ‚Üí 'Unsubscribe' link"
        },
        {
          "type": "heading",
          "text": "Method 2: Settings (Coming Soon)"
        },
        {
          "type": "list",
          "items": [
            "Go to Settings ‚Üí Notifications",
            "Find the 'Email Digest' toggle",
            "Turn it off to unsubscribe",
            "Turn it back on to resubscribe"
          ]
        },
        {
          "type": "heading",
          "text": "What You'll Miss"
        },
        {
          "type": "list",
          "items": [
            "Weekly summary of top posts",
            "Notifications when someone mentions you",
            "New comment highlights",
            "You'll still receive push notifications if enabled"
          ]
        },
        {
          "type": "note",
          "text": "Unsubscribe tokens expire after 30 days. If the link doesn't work, contact support."
        }
      ]
    },
    "keyboard-shortcuts": {
      "title": "Keyboard Shortcuts",
      "content": [
        {
          "type": "heading",
          "text": "Desktop Shortcuts"
        },
        {
          "type": "table",
          "headers": ["Key", "Action"],
          "rows": [
            ["Esc", "Close modals or exit search"],
            ["Tab", "Move between fields or buttons"],
            ["Enter", "Activate selected button or submit form"],
            ["/", "Jump to search bar"],
            ["Ctrl+Enter / Cmd+Enter", "Post comment (when in comment box)"]
          ]
        },
        {
          "type": "heading",
          "text": "Mobile Gestures (Coming Soon)"
        },
        {
          "type": "list",
          "items": [
            "Tap and hold: Reorder items (on supported lists)"
          ]
        }
      ]
    },
    "faq": {
      "title": "Frequently Asked Questions",
      "content": [
        {
          "type": "qa",
          "question": "Why can't I install the app on my iPhone?",
          "answer": "iOS requires you to use Safari's 'Add to Home Screen' feature. The install prompt may not appear automatically on iOS, but you can manually add it from the Safari share menu."
        },
        {
          "type": "qa",
          "question": "How do I become an admin?",
          "answer": "Admin roles are granted manually by the development team. Contact support with your email address to request admin access. You'll need to sign out and sign back in after the role is granted."
        },
        {
          "type": "qa",
          "question": "Why aren't my emails arriving?",
          "answer": "Check your spam folder first. Make sure your email address is verified in Firebase Auth. You also need to have 'emailSubscriber=true' in your user profile. Contact support if issues persist."
        },
        {
          "type": "qa",
          "question": "Can I use the app offline?",
          "answer": "Yes! Once you've visited a post while online, it will be cached and available offline. However, new searches and comments require an internet connection. Comments will be queued and sent when you're back online."
        },
        {
          "type": "qa",
          "question": "Why aren't push notifications working?",
          "answer": "Make sure you've granted notification permission in your browser settings. Push notifications require HTTPS (they work on the production site). Some browsers, especially Safari on iOS, have limited push notification support."
        },
        {
          "type": "qa",
          "question": "How do I report a bug?",
          "answer": "Go to Settings ‚Üí Feedback and fill out the form. Include what you were doing, what you expected, what happened instead, and your browser/device information. Screenshots are helpful!"
        },
        {
          "type": "qa",
          "question": "Can I delete my comments?",
          "answer": "Yes! You can delete your own comments by clicking the delete button (trash icon) on any comment you've written. Post authors and admins can also delete comments on their posts."
        },
        {
          "type": "qa",
          "question": "How do I change my username?",
          "answer": "Your username is based on your Google account display name. To change it, update your Google account profile, then sign out and sign back in to Flicklet."
        },
        {
          "type": "qa",
          "question": "What happens if I vote on a post?",
          "answer": "Your vote (upvote or downvote) is recorded anonymously. The post's score and vote count update in real-time. You can change or remove your vote at any time."
        },
        {
          "type": "qa",
          "question": "Can I use Flicklet without signing in?",
          "answer": "You can browse and read posts without signing in, but you need to sign in to vote, comment, or access your personal lists. Sign-in is required for the full experience."
        }
      ]
    }
  }
}

```

## apps/web/src/components/games/TriviaGame.tsx
### Summary
Trivia UI that could reference watch history, discovery data, and scoring/ratings.
### Content
```tsx
import { useState, useEffect, useCallback, useRef } from "react";
import { useProStatus } from "../../lib/proStatus";
import { getCachedTrivia } from "../../lib/triviaApi";
import { getDailySeedDate } from "../../lib/dailySeed";
import { SAMPLE_TRIVIA_QUESTIONS, type TriviaQuestion } from "../../lib/triviaQuestions";
import { getTriviaGamesCompletedKey, getTriviaStatsKey } from '../../lib/cacheKeys';
import { useOnlineStatus } from '../../hooks/useOnlineStatus';
import { saveCompletedTriviaGame, getCompletedTriviaGames } from '../../lib/gameReview';
import { trackTriviaGameStart, trackTriviaGameComplete, trackTriviaAnswer, trackGameError } from '../../lib/analytics';
import { authManager } from '../../lib/auth';
import { syncGameStats } from '../../lib/gameStatsSync';
import { shareWithFallback } from '../../lib/shareLinks';
import { getToastCallback } from '@/state/actions';

interface TriviaGameProps {
  onClose?: () => void;
  onGameComplete?: (score: number, total: number) => void;
  onShowReview?: () => void;
}

export default function TriviaGame({
  onClose,
  onGameComplete,
  onShowReview,
}: TriviaGameProps) {
  const { isPro } = useProStatus();
  const [questions, setQuestions] = useState<TriviaQuestion[]>([]);
  const [currentQuestionIndex, setCurrentQuestionIndex] = useState(0);
  const [selectedAnswer, setSelectedAnswer] = useState<number | null>(null);
  const [score, setScore] = useState(0);
  const [questionAnswers, setQuestionAnswers] = useState<Array<{ questionIndex: number; selectedAnswer: number; isCorrect: boolean }>>([]);
  const [gameState, setGameState] = useState<
    "loading" | "playing" | "completed" | "error"
  >("loading");
  const [showExplanation, setShowExplanation] = useState(false);
  const [currentGame, setCurrentGame] = useState(1);
  const [gamesCompletedToday, setGamesCompletedToday] = useState(0);
  const [errorMessage, setErrorMessage] = useState<string | null>(null);
  const isOnline = useOnlineStatus();
  const [focusedOptionIndex, setFocusedOptionIndex] = useState<number | null>(
    null
  );
  const optionRefs = useRef<(HTMLButtonElement | null)[]>([]);
  const nextButtonRef = useRef<HTMLButtonElement | null>(null);
  const explanationRef = useRef<HTMLDivElement | null>(null);

  // Note: Hardcoded questions moved to module level (triviaQuestions.ts) to prevent recreation
  // Using imported constant instead
  const sampleQuestions = SAMPLE_TRIVIA_QUESTIONS;

  /**
   * Core question selection logic - shared by getTodaysQuestions() and getRecentTriviaQuestionIds()
   * This ensures both functions use the exact same selection algorithm.
   * 
   * @param date Date string (YYYY-MM-DD)
   * @param gameNumber Game number (1-3 for Pro, 1 for Regular)
   * @param isPro Whether user is Pro
   * @param allQuestions All available questions
   * @param providedRecentIds Optional set of recent question IDs to avoid (prevents infinite recursion)
   * @returns Array of selected questions for that date/game
   */
  const getQuestionsForDate = (
    date: string,
    gameNumber: number,
    isPro: boolean,
    allQuestions: TriviaQuestion[],
    providedRecentIds: Set<string> | null = null
  ): TriviaQuestion[] => {
    // Calculate days since epoch (Jan 1, 2000) for 365-day cycle
    const epochDate = new Date('2000-01-01');
    const currentDate = new Date(date + 'T00:00:00Z');
    const daysSinceEpoch = Math.floor((currentDate.getTime() - epochDate.getTime()) / (1000 * 60 * 60 * 24));
    const cycleDay = daysSinceEpoch % 365;

    const questionsPerGame = 10;
    const totalQuestionsPerDay = 30;

    // Use provided recent IDs if available, otherwise calculate them
    // (This prevents infinite recursion when getRecentTriviaQuestionIds calls this)
    const recentQuestionIds = providedRecentIds !== null
      ? providedRecentIds
      : getRecentTriviaQuestionIds(14, isPro, allQuestions, date);

    const selectedQuestions: TriviaQuestion[] = [];
    const usedQuestionIds = new Set<string>(); // Track used questions to prevent duplicates within this game
    const startIndex = isPro ? (gameNumber - 1) * 10 : 0;

    for (let i = 0; i < questionsPerGame; i++) {
      const globalIndex = startIndex + i;
      const baseIndex = (cycleDay * totalQuestionsPerDay + globalIndex) % allQuestions.length;
      
      // Find next available question that:
      // 1. Hasn't been used in this game
      // 2. Wasn't used in the last 14 days (no-repeat window)
      let questionIndex = baseIndex;
      let attempts = 0;
      const maxAttempts = allQuestions.length * 2;
      
      while (
        (usedQuestionIds.has(allQuestions[questionIndex].id) || 
         recentQuestionIds.has(allQuestions[questionIndex].id)) && 
        attempts < maxAttempts
      ) {
        questionIndex = (questionIndex + 1) % allQuestions.length;
        attempts++;
      }
      
      // Fallback: if we've exhausted all questions, use base index
      if (attempts >= maxAttempts) {
        console.warn(`‚ö†Ô∏è Could not find question avoiding recent window after ${attempts} attempts. Using question at base index ${baseIndex}`);
        questionIndex = baseIndex;
      }
      
      const selectedQuestion = allQuestions[questionIndex];
      selectedQuestions.push(selectedQuestion);
      usedQuestionIds.add(selectedQuestion.id);
    }

    return selectedQuestions;
  };

  // Get today's questions based on UTC date (deterministic rotation)
  // Regular: 10 questions per day (game 1 only)
  // Pro: 30 questions per day (games 1-3, 10 questions each)
  // ALL users get the same questions in the same order (Regular gets first 10, Pro gets all 30)
  // Questions rotate on a 365-day cycle with no-repeat window (last 14 days)
  // Uses UTC date so all users globally share the same daily content
  const getTodaysQuestions = (
    isPro: boolean = false,
    gameNumber: number = 1
  ) => {
    const today = getDailySeedDate();
    const questions = getQuestionsForDate(today, gameNumber, isPro, sampleQuestions);
    
    const totalForUser = isPro ? 30 : 10;
    const startIndex = isPro ? (gameNumber - 1) * 10 : 0;
    console.log(
      `üéØ Game ${gameNumber} questions (${isPro ? "Pro" : "Regular"} user, questions ${startIndex + 1}-${startIndex + 10} of ${totalForUser}):`,
      questions.map((q) => q.id)
    );
    return questions;
  };

  // Get question IDs used in the last N days for a specific user type
  // FIXED: Now uses the same selection logic as getTodaysQuestions() to ensure
  // the recent questions list matches what was actually selected (accounting for
  // repeat prevention logic).
  // Processes days in forward chronological order (oldest to newest) so each
  // day's selection accounts for questions selected on previous days.
  const getRecentTriviaQuestionIds = (
    days: number,
    isPro: boolean,
    allQuestions: TriviaQuestion[],
    currentDate?: string
  ): Set<string> => {
    const recentIds = new Set<string>();
    const today = currentDate || getDailySeedDate();
    const todayDate = new Date(today + 'T00:00:00Z');
    
    // Process days in forward chronological order (oldest first)
    // This ensures when we select questions for day N, we already know
    // what questions were selected on days N-1, N-2, etc.
    const dayQuestions: Array<{ date: string; questionIds: Set<string> }> = [];
    
    for (let i = days; i >= 1; i--) {
      const pastDate = new Date(todayDate);
      pastDate.setUTCDate(pastDate.getUTCDate() - i);
      const pastDateStr = getDailySeedDate(pastDate);
      
      // Get all games for that date
      // Pro users: 3 games (30 questions), Regular: 1 game (10 questions)
      const maxGames = isPro ? 3 : 1;
      const dayQuestionIds = new Set<string>();
      
      for (let gameNum = 1; gameNum <= maxGames; gameNum++) {
        // Build recent IDs from all previous days (chronologically before this date)
        const previousDaysIds = new Set<string>();
        dayQuestions.forEach(prevDay => {
          prevDay.questionIds.forEach(id => previousDaysIds.add(id));
        });
        
        // Use the same selection logic, with questions from previous days as recent IDs
        const gameQuestions = getQuestionsForDate(pastDateStr, gameNum, isPro, allQuestions, previousDaysIds);
        
        // Add all questions from this game to this day's set
        gameQuestions.forEach(q => dayQuestionIds.add(q.id));
      }
      
      // Store this day's questions
      dayQuestions.push({ date: pastDateStr, questionIds: dayQuestionIds });
      
      // Add to overall recent IDs set
      dayQuestionIds.forEach(id => recentIds.add(id));
    }
    
    return recentIds;
  };

  // Get games completed today from localStorage (uses UTC date for consistency)
  const getGamesCompletedToday = (): number => {
    try {
      const today = getDailySeedDate(); // UTC-based date
      const key = getTriviaGamesCompletedKey(today);
      const completed = localStorage.getItem(key);
      const count = completed ? parseInt(completed, 10) : 0;
      // Cap to max games to prevent invalid counts
      const maxGames = isPro ? 3 : 1;
      return Math.min(count, maxGames);
    } catch (_e) {
      return 0;
    }
  };

  // Save games completed today to localStorage (uses UTC date for consistency)
  const saveGamesCompletedToday = (count: number): void => {
    try {
      const today = getDailySeedDate(); // UTC-based date
      const key = getTriviaGamesCompletedKey(today);
      localStorage.setItem(key, String(count));
    } catch (error) {
      if (error instanceof DOMException && error.name === 'QuotaExceededError') {
        console.error("‚ùå localStorage quota exceeded. Cannot save games completed count.");
        setErrorMessage("Storage full. Game progress may not be saved.");
      } else {
        console.warn("Failed to save games completed:", error);
      }
    }
  };

  // Update trivia stats after game completes
  const updateTriviaStats = (
    gameScore: number,
    totalQuestions: number
  ): void => {
    try {
      const existingData = JSON.parse(
        localStorage.getItem("flicklet-data") || "{}"
      );
      const currentStats = existingData.trivia || {
        games: 0,
        wins: 0,
        losses: 0,
        correct: 0,
        total: 0,
        streak: 0,
        maxStreak: 0,
      };

      const percentage =
        totalQuestions > 0 ? Math.round((gameScore / totalQuestions) * 100) : 0;
      const isWin = percentage >= 60; // 60% or higher is a win

      const newStats = {
        games: currentStats.games + 1,
        wins: currentStats.wins + (isWin ? 1 : 0),
        losses: currentStats.losses + (isWin ? 0 : 1),
        correct: currentStats.correct + gameScore,
        total: currentStats.total + totalQuestions,
        streak: isWin ? currentStats.streak + 1 : 0,
        maxStreak: isWin
          ? Math.max(currentStats.maxStreak, currentStats.streak + 1)
          : currentStats.maxStreak,
      };

      const updatedData = {
        ...existingData,
        trivia: newStats,
      };

      localStorage.setItem("flicklet-data", JSON.stringify(updatedData));
      localStorage.setItem(getTriviaStatsKey(), JSON.stringify(newStats));

      // Sync to Firebase if user is authenticated
      const currentUser = authManager.getCurrentUser();
      if (currentUser?.uid) {
        syncGameStats(currentUser.uid).catch((_syncError) => {
          console.warn("Failed to sync game stats to cloud:", _syncError);
        });
      }

      // Notify listeners
      window.dispatchEvent(new CustomEvent("trivia:statsUpdated"));

      console.log("üíæ Trivia stats saved:", newStats);
    } catch (error) {
      if (error instanceof DOMException && error.name === 'QuotaExceededError') {
        console.error("‚ùå localStorage quota exceeded. Cannot save trivia stats.");
        setErrorMessage("Storage full. Stats may not be saved.");
      } else {
        console.error("Failed to save trivia stats:", error);
      }
    }
  };

  // Check for share link params on mount
  useEffect(() => {
    try {
      const shareParamsStr = localStorage.getItem("trivia:shareParams");
      if (shareParamsStr) {
        const shareParams = JSON.parse(shareParamsStr);
        console.log("[Trivia] Share link params detected:", shareParams);
        
        // If mode is 'sharedResult', show review screen for that date/game
        if (shareParams.mode === "sharedResult" && shareParams.date) {
          // Navigate to review screen showing that specific game
          // The review screen will filter by date/gameNumber
          if (onShowReview) {
            onShowReview();
          }
        }
        
        // Clear share params after processing
        localStorage.removeItem("trivia:shareParams");
      }
    } catch (e) {
      console.warn("Failed to process Trivia share params:", e);
    }
  }, [onShowReview]);

  // Initialize games completed - Regular: 1 game (10 questions), Pro: 3 games (30 questions)
  // Combined with question loading to avoid race condition
  useEffect(() => {
    const initializeAndLoad = async () => {
      const completed = getGamesCompletedToday();
      setGamesCompletedToday(completed);
      
      // Set current game to next game to play
      // Regular: 1 game per day (10 questions)
      // Pro: 3 games per day (30 questions)
      // Don't start a new game if limit is reached
      const maxGames = isPro ? 3 : 1;
      let gameNumber: number;
      if (completed >= maxGames) {
        // All games completed - load last completed game's data for display
        gameNumber = maxGames;
        setCurrentGame(gameNumber);
        
        // Load last completed game to show its results
        const completedGames = getCompletedTriviaGames();
        const lastGame = completedGames.find(g => g.gameNumber === maxGames) || completedGames[completedGames.length - 1];
        
        if (lastGame) {
          // Set up state to show completion screen with last game's data
          setScore(lastGame.score);
          // Convert completed game questions back to TriviaQuestion format for display
          // Note: CompletedTriviaGame only stores basic question data, so we provide defaults
          const displayQuestions: TriviaQuestion[] = lastGame.questions.map((q, idx) => ({
            id: `completed_${lastGame.gameNumber}_${idx}`,
            question: q.question,
            options: [], // Not needed for completion screen
            correctAnswer: q.correctAnswer,
            explanation: undefined,
            category: 'General',
            difficulty: 'medium',
          }));
          setQuestions(displayQuestions);
          setGameState("completed");
          console.log(
            "üéØ All games completed:",
            "Games completed today:",
            completed,
            "Max games:",
            maxGames,
            "Showing completion screen with last game data"
          );
        } else {
          // No completed game data found, just show completion message
          setGameState("completed");
          console.log(
            "üéØ All games completed:",
            "Games completed today:",
            completed,
            "Max games:",
            maxGames,
            "No completed game data found"
          );
        }
        return; // Exit early, don't load new questions
      } else if (isPro) {
        gameNumber = Math.min(completed + 1, 3); // Max 3 games for Pro
        setCurrentGame(gameNumber);
        console.log(
          "üéØ Pro user status:",
          "Games completed today:",
          completed,
          "Starting game:",
          gameNumber,
          "(Pro: 3 games per day - 30 questions total)"
        );
      } else {
        gameNumber = 1; // Regular users get 1 game per day
        setCurrentGame(gameNumber);
        console.log(
          "üéØ Regular user status:",
          "Games completed today:",
          completed,
          "Starting game:",
          gameNumber,
          "(Regular: 1 game per day - 10 questions)"
        );
      }

      // Load questions immediately after setting game number
      if (gameState === "loading") {
        try {
          console.log(
            `üß† Loading trivia questions for Game ${gameNumber} (${isPro ? "Pro: 30 questions/day" : "Regular: 10 questions/day"})...`
          );

          // Use cached trivia - Regular gets 10 questions, Pro gets 30 questions
          // All users get the same questions (Regular gets first 10, Pro gets all 30)
          const apiQuestions = await getCachedTrivia(gameNumber, isPro);

          let formattedQuestions: TriviaQuestion[] = [];
          const questionsNeeded = 10; // 10 questions per game

          if (apiQuestions && apiQuestions.length > 0) {
            // Convert API format to our format
            // Regular users (gameNumber = 1): use questions 0-9
            // Pro users: gameNumber 1-3, use questions 0-9, 10-19, 20-29 respectively
            const startIndex = isPro ? (gameNumber - 1) * 10 : 0;
            const endIndex = startIndex + questionsNeeded;
            formattedQuestions = apiQuestions.slice(startIndex, endIndex).map((q, index) => ({
              id: `api_${gameNumber}_${index}`,
              question: q.question,
              options: q.options,
              correctAnswer: q.correctAnswer,
              explanation: q.explanation || undefined,
              category: q.category,
              difficulty: q.difficulty,
            }));

            // If we don't have enough from API, supplement with hardcoded questions
            if (formattedQuestions.length < questionsNeeded) {
              const additionalNeeded =
                questionsNeeded - formattedQuestions.length;
              
              // Track used question text to prevent duplicates
              const usedQuestionTexts = new Set(
                formattedQuestions.map(q => q.question.toLowerCase().trim())
              );
              
              // Get hardcoded questions for this game (same questions for all users)
              const allHardcodedQuestions = getTodaysQuestions(isPro, gameNumber);
              
              // Filter out questions that match API questions by text content
              const availableHardcoded = allHardcodedQuestions.filter(
                q => !usedQuestionTexts.has(q.question.toLowerCase().trim())
              );
              
              // Take only what we need
              const additionalQuestions = availableHardcoded
                .slice(0, additionalNeeded)
                .map((q) => ({
                  ...q,
                  explanation: q.explanation || undefined,
                }));
              
              formattedQuestions.push(...additionalQuestions);
              
              // If still not enough, fill with any remaining hardcoded questions (shouldn't happen)
              if (formattedQuestions.length < questionsNeeded) {
                const stillNeeded = questionsNeeded - formattedQuestions.length;
                const remaining = allHardcodedQuestions
                  .filter(q => !formattedQuestions.some(fq => fq.question.toLowerCase().trim() === q.question.toLowerCase().trim()))
                  .slice(0, stillNeeded);
                formattedQuestions.push(...remaining.map(q => ({
                  ...q,
                  explanation: q.explanation || undefined,
                })));
              }
            }
          } else {
            // No API questions available, use fallback (same questions for all users)
            console.log("üìö Using fallback trivia questions");
            formattedQuestions = getTodaysQuestions(isPro, gameNumber)
              .slice(0, questionsNeeded)
              .map((q) => ({
                ...q,
                explanation: q.explanation || undefined,
              }));
          }
          
          // Final duplicate check - ensure no duplicates in final list
          const finalQuestions: TriviaQuestion[] = [];
          const seenQuestions = new Set<string>();
          for (const q of formattedQuestions) {
            const questionKey = q.question.toLowerCase().trim();
            if (!seenQuestions.has(questionKey)) {
              seenQuestions.add(questionKey);
              finalQuestions.push(q);
            }
          }
          
          // If we lost questions due to duplicates, fill from hardcoded pool
          if (finalQuestions.length < questionsNeeded) {
            const allHardcoded = getTodaysQuestions(isPro, gameNumber);
            const needed = questionsNeeded - finalQuestions.length;
            const additional = allHardcoded
              .filter(q => !seenQuestions.has(q.question.toLowerCase().trim()))
              .slice(0, needed);
            finalQuestions.push(...additional.map(q => ({
              ...q,
              explanation: q.explanation || undefined,
            })));
          }
          
          formattedQuestions = finalQuestions.slice(0, questionsNeeded);

          console.log(
            `‚úÖ Loaded ${formattedQuestions.length} trivia questions for Game ${gameNumber} (${isPro ? "Pro: 30 questions/day" : "Regular: 10 questions/day"})`
          );
          setQuestions(formattedQuestions);
          setGameState("playing");
          setErrorMessage(null);
          
          // Track game start analytics
          trackTriviaGameStart(gameNumber, isPro);
          // Initialize option refs array
          optionRefs.current = new Array(
            formattedQuestions[0]?.options.length || 4
          ).fill(null);
        } catch (error) {
          console.error("‚ùå Failed to load trivia questions:", error);
          trackGameError('trivia', 'load_questions_failed', { error: String(error) });
          setErrorMessage(
            "Failed to load questions from server. Using backup questions."
          );
          // Fallback to hardcoded questions (same questions for all users)
          const fallbackQuestions = getTodaysQuestions(isPro, gameNumber)
            .slice(0, 10); // Always 10 questions per game
          setQuestions(fallbackQuestions);
          setGameState("playing");
          optionRefs.current = new Array(
            fallbackQuestions[0]?.options.length || 4
          ).fill(null);
        }
      }
    };

    initializeAndLoad();
  }, [isPro, gameState]); // Include isPro to react to Pro status changes

  const handleAnswerSelect = useCallback(
    (answerIndex: number) => {
      if (selectedAnswer !== null) return;

      const isCorrect = answerIndex === questions[currentQuestionIndex].correctAnswer;
      
      // Track answer analytics
      trackTriviaAnswer(currentQuestionIndex, isCorrect);
      
      // Save answer for review
      setQuestionAnswers((prev) => [
        ...prev,
        {
          questionIndex: currentQuestionIndex,
          selectedAnswer: answerIndex,
          isCorrect,
        },
      ]);

      setSelectedAnswer(answerIndex);
      setShowExplanation(true);
      setFocusedOptionIndex(null);

      if (isCorrect) {
        setScore((prev) => prev + 1);
      }

      // Focus next button after a short delay for screen readers
      setTimeout(() => {
        nextButtonRef.current?.focus();
        explanationRef.current?.focus();
      }, 100);
    },
    [selectedAnswer, questions, currentQuestionIndex]
  );

  const handleNextQuestion = useCallback(() => {
    if (currentQuestionIndex < questions.length - 1) {
      setCurrentQuestionIndex((prev) => prev + 1);
      setSelectedAnswer(null);
      setShowExplanation(false);
      setFocusedOptionIndex(null);
      // Focus first option on next question
      setTimeout(() => {
        optionRefs.current[0]?.focus();
      }, 100);
    } else {
      // Game completed - set state first, then update stats
      setGameState("completed");
      
      const today = getDailySeedDate();
      const percentage = Math.round((score / questions.length) * 100);
      
      // Save completed game for review
      const completedQuestionAnswers = questions.map((q, idx) => {
        const answerData = questionAnswers.find(a => a.questionIndex === idx);
        return {
          question: q.question,
          selectedAnswer: answerData?.selectedAnswer ?? -1,
          correctAnswer: q.correctAnswer,
          isCorrect: answerData?.isCorrect ?? false,
        };
      });
      
      saveCompletedTriviaGame({
        date: today,
        gameNumber: currentGame,
        score,
        total: questions.length,
        percentage,
        questions: completedQuestionAnswers,
        completedAt: Date.now(),
      });
      
      // Track analytics
      trackTriviaGameComplete(score, questions.length, percentage, currentGame, isPro);
      
      // Update stats after state is set to completed
      updateTriviaStats(score, questions.length);

      // Increment games completed today (cap to max games)
      const maxGames = isPro ? 3 : 1;
      const newGamesCompleted = Math.min(gamesCompletedToday + 1, maxGames);
      setGamesCompletedToday(newGamesCompleted);
      saveGamesCompletedToday(newGamesCompleted);

      onGameComplete?.(score, questions.length);
    }
  }, [
    currentQuestionIndex,
    questions.length,
    score,
    onGameComplete,
    gamesCompletedToday,
    questions,
    currentGame,
    isPro,
    selectedAnswer,
  ]);

  // Keyboard navigation handler
  const handleKeyDown = useCallback(
    (e: React.KeyboardEvent, optionIndex: number) => {
      if (selectedAnswer !== null) {
        if (e.key === "Enter" || e.key === " ") {
          e.preventDefault();
          handleNextQuestion();
        }
        return;
      }

      switch (e.key) {
        case "ArrowDown": {
          e.preventDefault();
          const nextIndex =
            optionIndex < questions[currentQuestionIndex].options.length - 1
              ? optionIndex + 1
              : 0;
          setFocusedOptionIndex(nextIndex);
          optionRefs.current[nextIndex]?.focus();
          break;
        }
        case "ArrowUp": {
          e.preventDefault();
          const prevIndex =
            optionIndex > 0
              ? optionIndex - 1
              : questions[currentQuestionIndex].options.length - 1;
          setFocusedOptionIndex(prevIndex);
          optionRefs.current[prevIndex]?.focus();
          break;
        }
        case "Enter":
        case " ":
          e.preventDefault();
          handleAnswerSelect(optionIndex);
          break;
      }
    },
    [
      selectedAnswer,
      questions,
      currentQuestionIndex,
      handleAnswerSelect,
      handleNextQuestion,
    ]
  );

  const handleRestart = useCallback(() => {
    // Reset current game
    setCurrentQuestionIndex(0);
    setSelectedAnswer(null);
    setScore(0);
    setShowExplanation(false);
    setQuestionAnswers([]);
    setGameState("loading");
  }, []);

  // Start next game (for pro users with games remaining)
  const handleNextGame = useCallback(() => {
    // Pro users get 3 games per day, Regular users get 1 game per day
    const maxGames = isPro ? 3 : 1;
    if (gamesCompletedToday < maxGames) {
      const nextGame = gamesCompletedToday + 1;
      setCurrentGame(nextGame);
      setCurrentQuestionIndex(0);
      setSelectedAnswer(null);
      setScore(0);
      setShowExplanation(false);
      setQuestionAnswers([]);
      setGameState("loading");
    }
  }, [isPro, gamesCompletedToday]);

  const getScoreColor = (percentage: number) => {
    if (percentage >= 80) return "text-green-400";
    if (percentage >= 60) return "text-yellow-400";
    return "text-red-400";
  };

  // Generate share text for Trivia results
  // Share link deep-linking: Includes date, gameNumber, and score so link opens to correct game
  // Config: App.tsx handles ?game=trivia&date=...&gameNumber=...&score=... query params
  // Note: URL is NOT included here - it will be added by shareWithFallback
  const generateShareText = useCallback(() => {
    const today = getDailySeedDate();
    const gameLabel = isPro ? ` Game ${currentGame}` : '';
    const percentage = questions.length > 0 ? Math.round((score / questions.length) * 100) : 0;
    
    return `üß† Trivia ${today}${gameLabel}\n\nScore: ${score}/${questions.length} (${percentage}%)\n\nPlay Trivia at flicklet.netlify.app`;
  }, [score, questions.length, isPro, currentGame]);

  // Primary share handler for Trivia
  // Handle share - single game results
  const handleShare = useCallback(async () => {
    const shareText = generateShareText();
    const today = getDailySeedDate();
    // Always use flicklet.netlify.app for consistency
    const origin = "https://flicklet.netlify.app";
    const shareUrl = `${origin}/?game=trivia&date=${today}&gameNumber=${currentGame}&score=${score}&mode=sharedResult`;
    
    // Detect if native share is available (for toast message)
    const canNativeShare =
      typeof navigator !== "undefined" &&
      "share" in navigator &&
      /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
    
    // Use unified share helper
    await shareWithFallback({
      title: 'Trivia Results',
      text: shareText,
      url: shareUrl,
      onSuccess: () => {
        const toast = getToastCallback();
        if (toast) {
          // Different message for native share vs clipboard
          if (canNativeShare) {
            toast('Share completed!', 'success');
          } else {
            toast('Share link copied to clipboard!', 'success');
          }
        }
      },
      onError: (error) => {
        console.error('Share failed:', error);
        const toast = getToastCallback();
        if (toast) {
          toast('Unable to share ‚Äì link copied instead', 'error');
        }
      },
    });
  }, [generateShareText, currentGame, score]);

  if (gameState === "loading") {
    return (
      <div
        className="trivia-game"
        role="status"
        aria-live="polite"
        aria-label="Loading trivia game"
      >
        <div className="trivia-loading">
          <div className="loading-spinner" aria-hidden="true"></div>
          <p>Loading trivia questions...</p>
        </div>
      </div>
    );
  }

  if (gameState === "error") {
    return (
      <div className="trivia-game" role="alert">
        <div className="trivia-error">
          <h3>Error Loading Game</h3>
          <p>{errorMessage || "Something went wrong. Please try again."}</p>
          <button className="btn-primary" onClick={handleRestart}>
            Try Again
          </button>
          {onClose && (
            <button className="btn-secondary" onClick={onClose}>
              Close
            </button>
          )}
        </div>
      </div>
    );
  }

  if (gameState === "completed") {
    // Handle case where questions might be empty (all games completed on load)
    const percentage = questions.length > 0 ? Math.round((score / questions.length) * 100) : 0;
    const canPlayNextGame = isPro && gamesCompletedToday < 3; // Only Pro users can play multiple games
    const gamesRemaining = isPro ? 3 - gamesCompletedToday : 0;

    return (
      <div className="trivia-game" role="region" aria-label="Game completed">
        <div className="trivia-completed">
          <h3>üéâ Game {currentGame} Complete!</h3>
          {isPro && (
            <p className="game-progress">Game {currentGame} of 3</p>
          )}
          <div className="score-display">
            <div
              className="score-circle"
              role="img"
              aria-label={`Score: ${score} out of ${questions.length || 10} correct, ${percentage} percent`}
            >
              <span
                className={`score-percentage ${getScoreColor(percentage)}`}
                aria-hidden="true"
              >
                {percentage}%
              </span>
              <span className="score-fraction" aria-hidden="true">
                {score}/{questions.length || 10}
              </span>
            </div>
          </div>

          <div className="score-message">
            {percentage >= 80 && (
              <p>üèÜ Excellent! You&apos;re a movie trivia master!</p>
            )}
            {percentage >= 60 && percentage < 80 && (
              <p>üëç Good job! You know your movies!</p>
            )}
            {percentage < 60 && (
              <p>üìö Keep watching! You&apos;ll get better!</p>
            )}
          </div>

          <div className="completion-actions">
            {canPlayNextGame ? (
              <button
                className="btn-primary"
                onClick={handleNextGame}
                aria-label={`Play Game ${gamesCompletedToday + 1}, ${gamesRemaining} games remaining`}
              >
                <span className="btn-text-responsive">
                  Play Game {gamesCompletedToday + 1}
                </span>
                <span className="btn-text-responsive-mobile">
                  Game {gamesCompletedToday + 1}
                </span>
                <span className="btn-text-small">({gamesRemaining} left)</span>
              </button>
            ) : (
              <button
                className="btn-primary"
                onClick={handleRestart}
                aria-label="Play again"
              >
                Play Again
              </button>
            )}
            <button
              className="btn-secondary"
              onClick={handleShare}
              aria-label="Share trivia results"
            >
              Share Results
            </button>
            {onShowReview && (
              <button
                className="btn-secondary"
                onClick={() => {
                  onShowReview();
                }}
                aria-label="Review completed games"
              >
                Review Games
              </button>
            )}
            {onClose && (
              <button
                className="btn-secondary"
                onClick={onClose}
                aria-label="Close trivia game"
              >
                Close
              </button>
            )}
          </div>

          {!isPro && (
            <div className="pro-upsell">
              <p>
                ‚úÖ You&apos;ve completed your game today! Come back tomorrow for the next game!
              </p>
              <p>
                üîí Want more games? Upgrade to Pro for 3 games per day (10 questions each)!
              </p>
            </div>
          )}
          {isPro && gamesCompletedToday >= 3 && (
            <div className="games-limit">
              <p>
                ‚úÖ You&apos;ve completed all 3 games today! Come back tomorrow for the next games!
              </p>
            </div>
          )}
        </div>
      </div>
    );
  }

  const currentQuestion = questions[currentQuestionIndex];
  const progress = ((currentQuestionIndex + 1) / questions.length) * 100;

  // Safety check - don't render if no questions or current question is undefined
  if (!questions.length || !currentQuestion) {
    return (
      <div className="trivia-game">
        <div className="trivia-header">
          <h3>üß† Daily Trivia</h3>
        </div>
        <div className="trivia-content">
          <p>Loading questions...</p>
        </div>
      </div>
    );
  }

  return (
    <div className="trivia-game" role="main" aria-label="Trivia game">
      {/* Offline indicator */}
      {!isOnline && (
        <div className="trivia-error-banner" role="alert" aria-live="polite">
          <span className="error-icon" aria-hidden="true">üì°</span>
          <span>You&apos;re offline. Using cached questions if available.</span>
        </div>
      )}
      {/* Error message banner */}
      {errorMessage && (
        <div className="trivia-error-banner" role="alert" aria-live="polite">
          <span className="error-icon" aria-hidden="true">
            ‚ö†Ô∏è
          </span>
          <span>{errorMessage}</span>
        </div>
      )}

      {/* Game progress indicator (Pro users only) */}
      {isPro && (
        <div
          className="trivia-game-header"
          aria-label={`Game ${currentGame} of 3`}
        >
          <span>Game {currentGame} of 3</span>
          {gamesCompletedToday > 0 && (
            <span
              className="games-completed"
              aria-label={`${gamesCompletedToday} games completed today`}
            >
              ({gamesCompletedToday} completed)
            </span>
          )}
        </div>
      )}

      {/* Progress indicator */}
      <div
        className="trivia-progress"
        role="progressbar"
        aria-valuenow={currentQuestionIndex + 1}
        aria-valuemin={1}
        aria-valuemax={questions.length}
        aria-label={`Question ${currentQuestionIndex + 1} of ${questions.length}`}
      >
        <span aria-hidden="true">
          {currentQuestionIndex + 1}/{questions.length}
        </span>
        <div className="progress-bar" aria-hidden="true">
          <div className="progress-fill" style={{ width: `${progress}%` }} />
        </div>
      </div>

      {/* Question */}
      <div className="trivia-question">
        <div className="question-meta" aria-hidden="true">
          <span className="category">{currentQuestion.category}</span>
          <span
            className="difficulty"
            aria-label={`Difficulty: ${currentQuestion.difficulty}`}
          >
            {currentQuestion.difficulty}
          </span>
        </div>
        <h4 id="trivia-question-text">{currentQuestion.question}</h4>
      </div>

      {/* Options */}
      <div
        className="trivia-options"
        role="radiogroup"
        aria-labelledby="trivia-question-text"
        aria-required="true"
      >
        {currentQuestion.options.map((option, index) => {
          let className = "option-btn";
          const isCorrect = index === currentQuestion.correctAnswer;
          const isSelected = index === selectedAnswer;
          const isDisabled = selectedAnswer !== null;

          if (selectedAnswer !== null) {
            if (isCorrect) {
              className += " correct";
            } else if (isSelected && !isCorrect) {
              className += " incorrect";
            } else {
              className += " disabled";
            }
          }

          let ariaLabel = option;
          if (selectedAnswer !== null) {
            if (isCorrect) {
              ariaLabel = `${option} - Correct answer`;
            } else if (isSelected) {
              ariaLabel = `${option} - Incorrect answer`;
            } else {
              ariaLabel = `${option} - Not selected`;
            }
          }

          return (
            <button
              key={index}
              ref={(el) => {
                optionRefs.current[index] = el;
              }}
              className={className}
              onClick={() => handleAnswerSelect(index)}
              onKeyDown={(e) => handleKeyDown(e, index)}
              disabled={isDisabled}
              role="radio"
              aria-checked={isSelected}
              aria-label={ariaLabel}
              aria-describedby={
                isDisabled && !isSelected ? "disabled-explanation" : undefined
              }
              tabIndex={
                focusedOptionIndex === index ||
                (focusedOptionIndex === null && index === 0)
                  ? 0
                  : -1
              }
            >
              {option}
            </button>
          );
        })}
      </div>

      {/* Disabled explanation tooltip */}
      {selectedAnswer !== null && (
        <div id="disabled-explanation" className="sr-only">
          Other options are disabled because you have already selected an answer
        </div>
      )}

      {/* Explanation */}
      {showExplanation && currentQuestion.explanation && (
        <div
          ref={explanationRef}
          className="trivia-explanation"
          role="region"
          aria-live="polite"
          aria-label="Explanation"
          tabIndex={-1}
        >
          <p>{currentQuestion.explanation}</p>
        </div>
      )}

      {/* Actions */}
      <div className="trivia-actions">
        {selectedAnswer !== null && (
          <button
            ref={nextButtonRef}
            className="btn-primary"
            onClick={handleNextQuestion}
            aria-label={
              currentQuestionIndex < questions.length - 1
                ? "Go to next question"
                : "Finish quiz"
            }
          >
            <span className="btn-text-responsive">
              {currentQuestionIndex < questions.length - 1
                ? "Next Question"
                : "Finish Quiz"}
            </span>
            <span className="btn-text-responsive-mobile">
              {currentQuestionIndex < questions.length - 1 ? "Next" : "Finish"}
            </span>
          </button>
        )}

        {onClose && (
          <button
            className="btn-secondary"
            onClick={onClose}
            aria-label="Close trivia game"
          >
            Close
          </button>
        )}
      </div>
    </div>
  );
}

```

## apps/web/src/components/CommunityPanel.tsx
### Summary
Community feed component that emphasizes `score`/votes and cross-links to discovery content.
### Content
```tsx
import {
  useState,
  lazy,
  Suspense,
  useEffect,
  useRef,
  memo,
  useCallback,
} from "react";
import {
  collection,
  query,
  orderBy,
  limit,
  getDocs,
  startAfter,
  DocumentData,
  QueryDocumentSnapshot,
} from "firebase/firestore";
import { db } from "../lib/firebaseBootstrap";
import { useTranslations } from "@/lib/language";
import { useSettings, settingsManager } from "../lib/settings";
import { useProStatus } from "../lib/proStatus";
import { useAdminRole } from "../hooks/useAdminRole";
import { useAuth } from "../hooks/useAuth";
import FlickWordStats from "./games/FlickWordStats";
import TriviaStats from "./games/TriviaStats";
import CommunityPlayer from "./CommunityPlayer";
import NewPostModal from "./NewPostModal";
import { TOPICS, getTopicBySlug } from "../lib/communityTopics";
import {
  SortMode,
  sortPosts,
  isProSortMode,
  getAvailableSortModes,
  getSortModeLabel,
} from "../lib/communitySorting";
import ProBadge from "./ProBadge";
import { UpgradeToProCTA } from "./UpgradeToProCTA";
import { reportPostOrComment } from "../lib/communityReports";
// ‚ö†Ô∏è REMOVED: flickerDiagnostics import disabled

// Lazy load game modals
const FlickWordModal = lazy(() => import("./games/FlickWordModal"));
const TriviaModal = lazy(() => import("./games/TriviaModal"));

interface Post {
  id: string;
  slug: string;
  title: string;
  excerpt?: string;
  publishedAt: string;
  author: {
    username?: string;
    name?: string;
    profile?: {
      avatarUrl?: string;
    };
  };
  tags?: Array<{ slug: string; name: string }>;
  topics?: string[];
  score?: number;
  voteCount?: number;
  commentCount?: number;
  containsSpoilers?: boolean;
  authorIsPro?: boolean;
}

// ‚ö†Ô∏è FIXED: Memoize component to prevent unnecessary re-renders from parent
const CommunityPanel = memo(function CommunityPanel() {
  // ‚ö†Ô∏è REMOVED: flickerDiagnostics logging disabled

  const translations = useTranslations();
  const { isAdmin } = useAdminRole();
  const { isAuthenticated, user } = useAuth();
  const settings = useSettings();
  // Pro gating: Use centralized Pro status helper
  // Config: proStatus.ts - useProStatus()
  const proStatus = useProStatus();
  const isPro = proStatus.isPro;
  const followedTopics = settings.community.followedTopics || [];
  const [reportingPosts, setReportingPosts] = useState<Record<string, boolean>>(
    {}
  );

  const [flickWordModalOpen, setFlickWordModalOpen] = useState(false);
  const [triviaModalOpen, setTriviaModalOpen] = useState(false);

  // Listen for custom event to open Trivia modal (e.g., from share links)
  useEffect(() => {
    const handleOpenTriviaModal = () => {
      setTriviaModalOpen(true);
    };

    window.addEventListener("open-trivia-modal", handleOpenTriviaModal);
    return () => {
      window.removeEventListener("open-trivia-modal", handleOpenTriviaModal);
    };
  }, []);
  const [newPostModalOpen, setNewPostModalOpen] = useState(false);
  const [posts, setPosts] = useState<Post[]>([]);
  const [postsLoading, setPostsLoading] = useState(true);
  const [postsError, setPostsError] = useState<string | null>(null);
  const [sortMode, setSortMode] = useState<SortMode>("newest");
  // Persist selectedTopics to localStorage
  const [selectedTopics, setSelectedTopics] = useState<string[]>(() => {
    if (typeof window === "undefined") return [];
    const saved = localStorage.getItem("flicklet.community.selectedTopics");
    return saved ? JSON.parse(saved) : [];
  }); // Multi-select for Pro, single for Free
  const [hasMore, setHasMore] = useState(true);
  const [loadingMore, setLoadingMore] = useState(false);
  const [showSortUpgradeCTA, setShowSortUpgradeCTA] = useState(false);

  // Persist selectedTopics to localStorage when it changes
  useEffect(() => {
    if (typeof window !== "undefined") {
      localStorage.setItem(
        "flicklet.community.selectedTopics",
        JSON.stringify(selectedTopics)
      );
    }
  }, [selectedTopics]);

  const fetchingRef = useRef(false);
  const hasFetchedRef = useRef(false);
  const lastDocRef = useRef<QueryDocumentSnapshot<DocumentData> | null>(null);

  // Fetch posts from Firestore with filtering, sorting, and infinite scroll
  const fetchPosts = useCallback(
    async (reset: boolean = false) => {
      // Prevent multiple simultaneous fetches
      if (fetchingRef.current) {
        return;
      }

      // Capture isAdmin from component scope
      const adminStatus = isAdmin;

      try {
        fetchingRef.current = true;
        if (reset) {
          setPostsLoading(true);
          setPosts([]);
          lastDocRef.current = null;
          hasFetchedRef.current = false;
        } else {
          setLoadingMore(true);
        }
        setPostsError(null);

        // Pro gating: Sanitize sort mode - if free user has Pro sort mode, fall back to "newest"
        // Config: communitySorting.ts - isProSortMode()
        let effectiveSortMode = sortMode;
        if (isProSortMode(sortMode) && !isPro) {
          effectiveSortMode = "newest";
          // Optionally reset the sort mode state to prevent UI inconsistency
          setSortMode("newest");
        }

        const postsRef = collection(db, "posts");
        const pageSize = 20; // Increased from 5 for infinite scroll

        // Build query based on sort mode
        // For Firestore, we can only orderBy fields that exist, so we'll fetch and sort in memory for advanced modes
        let postsQuery;

        if (effectiveSortMode === "newest" || effectiveSortMode === "oldest") {
          // Can use Firestore orderBy for these
          postsQuery = query(
            postsRef,
            orderBy(
              "publishedAt",
              effectiveSortMode === "newest" ? "desc" : "asc"
            ),
            ...(lastDocRef.current && !reset
              ? [startAfter(lastDocRef.current)]
              : []),
            limit(pageSize)
          );
        } else {
          // For Top/Hot/Trending, fetch by publishedAt desc and sort in memory
          postsQuery = query(
            postsRef,
            orderBy("publishedAt", "desc"),
            ...(lastDocRef.current && !reset
              ? [startAfter(lastDocRef.current)]
              : []),
            limit(pageSize * 2) // Fetch more for filtering/sorting
          );
        }

        const snapshot = await getDocs(postsQuery);

        // Map to Post objects and filter out hidden posts (unless admin)
        let newPosts: Post[] = snapshot.docs
          .filter((doc) => {
            const data = doc.data();
            // Show hidden posts only to admins
            if (data.hidden === true && !adminStatus) {
              return false;
            }
            return true;
          })
          .map((doc) => {
            const data = doc.data();
            return {
              id: doc.id,
              slug: data.slug || "",
              title: data.title || "Untitled",
              excerpt: data.excerpt,
              publishedAt:
                data.publishedAt?.toDate?.()?.toISOString() ||
                new Date().toISOString(),
              author: {
                username: data.authorName,
                name: data.authorName,
              },
              tags: (data.tagSlugs || []).map((slug: string) => ({
                slug,
                name: slug,
              })),
              topics: data.topics || [],
              score: data.score || 0,
              voteCount: data.voteCount || 0,
              commentCount: data.commentCount || 0,
              containsSpoilers: data.containsSpoilers || false,
              authorIsPro: data.authorIsPro || false,
            };
          });

        // Apply topic filtering
        if (selectedTopics.length > 0) {
          newPosts = newPosts.filter((post) => {
            const postTopics = post.topics || [];
            return selectedTopics.some((topic) => postTopics.includes(topic));
          });
        }

        // Apply sorting (for modes that need in-memory sorting)
        // Apply client-side sorting for Pro modes (top, hot, trending)
        if (effectiveSortMode !== "newest" && effectiveSortMode !== "oldest") {
          newPosts = sortPosts(newPosts, effectiveSortMode);
        }

        // Prioritize followed topics if user has followed topics
        if (followedTopics.length > 0 && !selectedTopics.length) {
          newPosts.sort((a, b) => {
            const aHasFollowed = (a.topics || []).some((t) =>
              followedTopics.includes(t)
            );
            const bHasFollowed = (b.topics || []).some((t) =>
              followedTopics.includes(t)
            );
            if (aHasFollowed && !bHasFollowed) return -1;
            if (!aHasFollowed && bHasFollowed) return 1;
            return 0;
          });
        }

        // Limit to pageSize after filtering/sorting
        newPosts = newPosts.slice(0, pageSize);

        // Update last document for pagination
        if (snapshot.docs.length > 0) {
          lastDocRef.current = snapshot.docs[snapshot.docs.length - 1];
        }

        // Check if there are more posts
        setHasMore(snapshot.docs.length >= pageSize);

        // Append or replace posts
        if (reset) {
          setPosts(newPosts);
        } else {
          setPosts((prev) => {
            // Avoid duplicates
            const existingIds = new Set(prev.map((p) => p.id));
            const uniqueNew = newPosts.filter((p) => !existingIds.has(p.id));
            return [...prev, ...uniqueNew];
          });
        }

        hasFetchedRef.current = true;
      } catch (error) {
        console.error("[CommunityPanel] Error fetching posts:", error);
        const errorMsg =
          error instanceof Error ? error.message : "Failed to load posts";

        setPostsError(errorMsg);
        if (reset) {
          setPosts([]);
        }
        hasFetchedRef.current = true;
      } finally {
        setPostsLoading(false);
        setLoadingMore(false);
        fetchingRef.current = false;
      }
    },
    [sortMode, selectedTopics, followedTopics, isAdmin, isPro]
  );

  // Fetch posts on mount
  useEffect(() => {
    if (!hasFetchedRef.current) {
      fetchPosts(true);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  // Reset and refetch when sort mode or topics change
  useEffect(() => {
    if (hasFetchedRef.current) {
      fetchPosts(true);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [sortMode, selectedTopics]);

  // Listen for force-refresh event from pull-to-refresh
  useEffect(() => {
    const handleForceRefresh = () => {
      console.log(
        "[CommunityPanel] Force refresh triggered, refreshing posts..."
      );
      fetchPosts(true);
    };
    window.addEventListener("force-refresh", handleForceRefresh);
    return () => {
      window.removeEventListener("force-refresh", handleForceRefresh);
    };
  }, [fetchPosts]);

  const handlePostCreated = () => {
    // Refresh posts list immediately after new post is created
    console.log(
      "[CommunityPanel] Post created callback triggered, refreshing posts..."
    );
    // Small delay to ensure Firestore write is complete
    setTimeout(() => {
      console.log("[CommunityPanel] Fetching posts after delay...");
      fetchPosts(true);
    }, 300);
  };

  // Handle topic selection (single for Free, multi for Pro)
  const handleTopicToggle = (topicSlug: string) => {
    if (isPro) {
      // Multi-select for Pro
      setSelectedTopics((prev) =>
        prev.includes(topicSlug)
          ? prev.filter((t) => t !== topicSlug)
          : [...prev, topicSlug]
      );
    } else {
      // Single-select for Free
      setSelectedTopics((prev) =>
        prev.includes(topicSlug) ? [] : [topicSlug]
      );
    }
  };

  // Handle topic follow/unfollow
  const handleFollowTopic = (topicSlug: string) => {
    settingsManager.toggleFollowTopic(topicSlug);
  };

  // Handle sort mode change with Pro gating
  // Pro gating: Advanced sorts (top, top-week, hot, trending) are Pro-only
  // Config: communitySorting.ts - isProSortMode()
  const handleSortChange = (newMode: SortMode) => {
    if (isProSortMode(newMode) && !isPro) {
      // Pro-only sort mode attempted by free user
      // Keep selection on current mode and show upgrade CTA
      setShowSortUpgradeCTA(true);
      return;
    }
    setSortMode(newMode);
    setShowSortUpgradeCTA(false);
  };

  // Load more posts (infinite scroll)
  const loadMore = useCallback(() => {
    if (!loadingMore && hasMore && !fetchingRef.current) {
      fetchPosts(false);
    }
  }, [loadingMore, hasMore, fetchPosts]);

  // Use global game functions if available
  const openFlickWord = () => {
    if (typeof (window as any).openFlickWordModal === "function") {
      (window as any).openFlickWordModal();
    } else {
      setFlickWordModalOpen(true);
    }
  };

  const handlePostClick = (slug: string) => {
    window.history.pushState({}, "", `/posts/${slug}`);
    window.dispatchEvent(new Event("pushstate"));
  };

  const handleReportPost = async (postId: string, e: React.MouseEvent) => {
    e.stopPropagation();
    if (!isAuthenticated || !user || reportingPosts[postId]) return;

    if (!confirm("Report this post? This will notify moderators for review.")) {
      return;
    }

    setReportingPosts((prev) => ({ ...prev, [postId]: true }));
    try {
      await reportPostOrComment(postId, "post", user.uid);
      alert("Post reported. Thank you for helping keep the community safe.");
    } catch (error: any) {
      alert(error.message || "Failed to report post. Please try again.");
    } finally {
      setReportingPosts((prev) => ({ ...prev, [postId]: false }));
    }
  };

  return (
    <div className="relative">
      <div
        data-rail="community"
        className="grid md:grid-cols-3 gap-4 items-start"
      >
        {/* Left: Player (spans 1 column) */}
        <div className="md:col-span-1">
          <CommunityPlayer />
        </div>

        {/* Middle: Stacked Games (spans 1 column) */}
        <div
          className="grid grid-rows-[1fr_1fr] gap-4"
          style={{
            height: "750px", // Match CommunityPlayer height
            maxHeight: "750px",
          }}
        >
          {/* FlickWord Game Card */}
          <div
            className="rounded-2xl p-4 flex flex-col justify-between cursor-pointer transition-colors"
            style={{
              backgroundColor: "var(--card)",
              borderColor: "var(--line)",
              borderWidth: "1px",
              borderStyle: "solid",
            }}
            onMouseEnter={(e) => {
              e.currentTarget.style.backgroundColor = "var(--btn)";
            }}
            onMouseLeave={(e) => {
              e.currentTarget.style.backgroundColor = "var(--card)";
            }}
            onClick={openFlickWord}
            onKeyDown={(e) => {
              if (e.key === "Enter" || e.key === " ") {
                e.preventDefault();
                openFlickWord();
              }
            }}
            role="button"
            tabIndex={0}
            aria-label="Play FlickWord game"
          >
            <div className="w-full">
              <h3
                className="text-sm font-semibold mb-2"
                style={{ color: "var(--text)" }}
              >
                {translations.flickword || "FlickWord"}
              </h3>
              <p className="text-xs mb-3" style={{ color: "var(--muted)" }}>
                {translations.flickword_tagline ||
                  "Wordle-style daily word play"}
              </p>
            </div>

            {/* Stats Display */}
            <div
              className="mt-auto"
              onClick={(e) => e.stopPropagation()}
              onKeyDown={(e) => e.stopPropagation()}
            >
              <FlickWordStats />
            </div>

            <div className="mt-3">
              <button
                className="w-full px-3 py-2 bg-blue-600 hover:bg-blue-700 text-white text-xs font-semibold rounded-lg transition-colors"
                onClick={(e) => {
                  e.stopPropagation();
                  openFlickWord();
                }}
                aria-label="Play FlickWord now"
              >
                {translations.play_now || "Play Now"}
              </button>
            </div>
          </div>

          {/* Trivia Game Card */}
          <div
            className="rounded-2xl p-4 flex flex-col justify-between cursor-pointer transition-colors"
            style={{
              backgroundColor: "var(--card)",
              borderColor: "var(--line)",
              borderWidth: "1px",
              borderStyle: "solid",
            }}
            onMouseEnter={(e) => {
              e.currentTarget.style.backgroundColor = "var(--btn)";
            }}
            onMouseLeave={(e) => {
              e.currentTarget.style.backgroundColor = "var(--card)";
            }}
            role="button"
            tabIndex={0}
            aria-label="Daily Trivia game card. Click to play."
            onClick={() => setTriviaModalOpen(true)}
            onKeyDown={(e) => {
              if (e.key === "Enter" || e.key === " ") {
                e.preventDefault();
                setTriviaModalOpen(true);
              }
            }}
          >
            <div className="w-full">
              <h3
                className="text-sm font-semibold mb-2"
                style={{ color: "var(--text)" }}
              >
                {translations.daily_trivia || "Daily Trivia"}
              </h3>
              <p className="text-xs mb-3" style={{ color: "var(--muted)" }}>
                {translations.daily_trivia_tagline ||
                  "Fresh question, new bragging rights"}
              </p>
            </div>

            {/* Stats Display */}
            <div
              className="mt-auto mb-3"
              onClick={(e) => e.stopPropagation()}
              onKeyDown={(e) => e.stopPropagation()}
            >
              <TriviaStats />
            </div>

            <div className="mt-auto">
              <button
                className="w-full px-3 py-2 bg-purple-600 hover:bg-purple-700 text-white text-xs font-semibold rounded-lg transition-colors"
                onClick={(e) => {
                  e.stopPropagation();
                  setTriviaModalOpen(true);
                }}
                aria-label="Play Daily Trivia now"
              >
                {translations.play_now || "Play Now"}
              </button>
            </div>
          </div>
        </div>

        {/* Right: Recent Posts (spans 1 column) */}
        <div
          className="rounded-2xl p-4 flex flex-col"
          style={{
            backgroundColor: "var(--card)",
            borderColor: "var(--line)",
            borderWidth: "1px",
            borderStyle: "solid",
            height: "calc(100vh - 200px)", // Fixed height for scrollable container
            maxHeight: "calc(100vh - 200px)",
            minHeight: "400px",
          }}
        >
          <div className="flex items-center justify-between mb-3">
            <h3
              className="text-sm font-semibold"
              style={{ color: "var(--text)" }}
            >
              {"Community Feed"}
            </h3>
            <button
              onClick={() => setNewPostModalOpen(true)}
              className="px-3 py-1.5 text-xs font-medium rounded-lg transition-colors"
              style={{
                backgroundColor: "var(--accent-primary)",
                color: "#fff",
              }}
              aria-label="Create new post"
            >
              Post
            </button>
          </div>

          {/* Sort Controls & Topic Filters - Sticky Header */}
          <div
            className="sticky top-0 z-10 mb-3 pb-2"
            style={{
              backgroundColor: "var(--card)",
              paddingTop: "0.5rem",
              marginTop: "-0.5rem",
            }}
          >
            {/* Sort Controls */}
            <div className="mb-3">
              <select
                value={sortMode}
                onChange={(e) => handleSortChange(e.target.value as SortMode)}
                className="w-full px-2 py-1.5 text-xs rounded-lg"
                style={{
                  backgroundColor: "var(--bg)",
                  color: "var(--text)",
                  border: "1px solid var(--line)",
                }}
              >
                {getAvailableSortModes(isPro).map((mode) => (
                  <option key={mode} value={mode}>
                    {getSortModeLabel(mode)}
                    {isProSortMode(mode) && " ‚≠ê"}
                  </option>
                ))}
              </select>
              {showSortUpgradeCTA && (
                <div className="mt-2">
                  <UpgradeToProCTA variant="inline" message="Advanced sorting is a Pro feature" />
                </div>
              )}
            </div>

            {/* Topic Filters */}
            <div className="mb-3">
              <div className="flex flex-wrap gap-1.5">
                {TOPICS.map((topic) => {
                  const isSelected = selectedTopics.includes(topic.slug);
                  const isFollowed = followedTopics.includes(topic.slug);
                  return (
                    <div key={topic.slug} className="flex items-center gap-1">
                      <button
                        onClick={() => handleTopicToggle(topic.slug)}
                        className="px-2 py-1 rounded-full text-[10px] font-medium transition"
                        style={{
                          backgroundColor: isSelected
                            ? "var(--accent-primary)"
                            : "var(--layer)",
                          color: isSelected ? "#fff" : "var(--text)",
                          border: `1px solid ${
                            isSelected ? "var(--accent-primary)" : "var(--line)"
                          }`,
                        }}
                        title={topic.description}
                      >
                        {topic.name}
                      </button>
                      <button
                        onClick={() => handleFollowTopic(topic.slug)}
                        className="text-xs"
                        style={{
                          color: isFollowed ? "#fbbf24" : "var(--muted)",
                        }}
                        title={isFollowed ? "Unfollow topic" : "Follow topic"}
                      >
                        {isFollowed ? "‚òÖ" : "‚òÜ"}
                      </button>
                    </div>
                  );
                })}
                {selectedTopics.length > 0 && (
                  <button
                    onClick={() => setSelectedTopics([])}
                    className="px-2 py-1 rounded-full text-[10px] font-medium"
                    style={{
                      backgroundColor: "var(--layer)",
                      color: "var(--text)",
                      border: "1px solid var(--line)",
                    }}
                  >
                    Clear
                  </button>
                )}
              </div>
              {!isPro && selectedTopics.length > 0 && (
                <p
                  className="text-[10px] mt-1"
                  style={{ color: "var(--muted)" }}
                >
                  Pro users can filter by multiple topics
                </p>
              )}
            </div>
          </div>

          {postsLoading ? (
            <div className="flex-1 flex items-center justify-center">
              <div className="text-xs" style={{ color: "var(--muted)" }}>
                Loading posts...
              </div>
            </div>
          ) : postsError ? (
            <div className="flex-1 flex items-center justify-center">
              <div className="text-xs" style={{ color: "var(--muted)" }}>
                {postsError}
              </div>
            </div>
          ) : posts.length === 0 ? (
            <div className="flex-1 flex items-center justify-center">
              <div className="text-xs" style={{ color: "var(--muted)" }}>
                No posts yet
              </div>
            </div>
          ) : (
            <div
              className="flex-1 overflow-y-auto min-h-0"
              style={{
                maxHeight: "100%",
              }}
              onScroll={(e) => {
                const target = e.currentTarget;
                const scrollBottom =
                  target.scrollHeight - target.scrollTop - target.clientHeight;
                // Load more when within 100px of bottom
                if (scrollBottom < 100) {
                  loadMore();
                }
              }}
            >
              {posts.map((post) => {
                const publishDate = post.publishedAt
                  ? new Date(post.publishedAt).toLocaleDateString("en-US", {
                      month: "short",
                      day: "numeric",
                    })
                  : null;

                // Check if post is new (within last 24 hours)
                const isNew = post.publishedAt
                  ? Date.now() - new Date(post.publishedAt).getTime() <
                    24 * 60 * 60 * 1000
                  : false;

                return (
                  <div
                    key={post.id}
                    onClick={() => handlePostClick(post.slug)}
                    className="cursor-pointer rounded-lg p-3 transition-colors mb-3 last:mb-0 relative group"
                    style={{
                      backgroundColor: "var(--btn2)",
                      borderColor: "var(--line)",
                      borderWidth: "1px",
                      borderStyle: "solid",
                    }}
                    onMouseEnter={(e) => {
                      e.currentTarget.style.backgroundColor = "var(--btn)";
                    }}
                    onMouseLeave={(e) => {
                      e.currentTarget.style.backgroundColor = "var(--btn2)";
                    }}
                  >
                    <div className="flex items-center gap-2 mb-1">
                      <h4
                        className="text-xs font-semibold line-clamp-2 flex-1"
                        style={{ color: "var(--text)" }}
                      >
                        {post.title}
                      </h4>
                      {isNew && (
                        <span
                          className="px-1.5 py-0.5 rounded text-[9px] font-semibold uppercase tracking-wide flex-shrink-0 relative z-0"
                          style={{
                            backgroundColor: "var(--accent-primary)",
                            color: "var(--text)",
                            zIndex: 0,
                          }}
                        >
                          New
                        </span>
                      )}
                    </div>
                    {post.excerpt && (
                      <p
                        className="text-xs mb-2 line-clamp-2"
                        style={{ color: "var(--muted)" }}
                      >
                        {post.excerpt}
                      </p>
                    )}
                    <div className="flex items-center gap-2 mb-2 flex-wrap">
                      {post.topics && post.topics.length > 0 && (
                        <div className="flex gap-1 flex-wrap">
                          {post.topics.slice(0, 3).map((topicSlug) => {
                            const topic = getTopicBySlug(topicSlug);
                            return topic ? (
                              <span
                                key={topicSlug}
                                className="px-1.5 py-0.5 rounded-full text-[9px] font-medium"
                                style={{
                                  backgroundColor: "var(--layer)",
                                  color: "var(--muted)",
                                  border: "1px solid var(--line)",
                                }}
                              >
                                {topic.name}
                              </span>
                            ) : null;
                          })}
                        </div>
                      )}
                    </div>
                    <div
                      className="flex items-center gap-2 text-xs"
                      style={{ color: "var(--muted)" }}
                    >
                      <span>
                        {post.author?.username ||
                          post.author?.name ||
                          "Unknown"}
                      </span>
                      <ProBadge isPro={post.authorIsPro} />
                      {publishDate && (
                        <>
                          <span>¬∑</span>
                          <span>{publishDate}</span>
                        </>
                      )}
                      {post.score !== undefined && (
                        <>
                          <span>¬∑</span>
                          <span>Score: {post.score}</span>
                        </>
                      )}
                      {post.commentCount !== undefined &&
                        post.commentCount > 0 && (
                          <>
                            <span>¬∑</span>
                            <span
                              className="font-semibold"
                              style={{ color: "var(--accent-primary)" }}
                            >
                              {post.commentCount}{" "}
                              {post.commentCount === 1 ? "comment" : "comments"}
                            </span>
                          </>
                        )}
                    </div>

                    {/* Report Button - appears on hover */}
                    {isAuthenticated && user && (
                      <button
                        onClick={(e) => handleReportPost(post.id, e)}
                        disabled={reportingPosts[post.id]}
                        className="opacity-0 group-hover:opacity-100 transition-opacity absolute bottom-2 right-2 px-2 py-1 text-xs rounded hover:bg-red-500/10 z-10"
                        style={{ color: "var(--muted)", zIndex: 10 }}
                        title="Report post"
                      >
                        {reportingPosts[post.id] ? "Reporting..." : "Report"}
                      </button>
                    )}
                  </div>
                );
              })}
              {loadingMore && (
                <div className="flex items-center justify-center py-4">
                  <div className="text-xs" style={{ color: "var(--muted)" }}>
                    Loading more...
                  </div>
                </div>
              )}
              {!hasMore && posts.length > 0 && (
                <div className="flex items-center justify-center py-4">
                  <div className="text-xs" style={{ color: "var(--muted)" }}>
                    No more posts
                  </div>
                </div>
              )}
            </div>
          )}
        </div>
      </div>

      {/* FlickWord Modal - Now rendered via Portal */}
      <Suspense
        fallback={<div className="loading-spinner">Loading FlickWord...</div>}
      >
        <FlickWordModal
          isOpen={flickWordModalOpen}
          onClose={() => setFlickWordModalOpen(false)}
        />
      </Suspense>

      {/* Trivia Modal - Now rendered via Portal */}
      <Suspense
        fallback={<div className="loading-spinner">Loading Trivia...</div>}
      >
        <TriviaModal
          isOpen={triviaModalOpen}
          onClose={() => setTriviaModalOpen(false)}
        />
      </Suspense>

      {/* New Post Modal */}
      <NewPostModal
        isOpen={newPostModalOpen}
        onClose={() => setNewPostModalOpen(false)}
        onPostCreated={handlePostCreated}
      />
    </div>
  );
});

export default CommunityPanel;

```

## apps/web/src/lib/analytics.ts
### Summary
Analytics tracker that logs rating/discovery events for debugging.
### Content
```ts
// Minimal analytics wrapper for consistent event names

type Payload = Record<string, unknown>;

function safeLog(event: string, payload: Payload = {}): void {
  try {
    // eslint-disable-next-line no-console
    console.log(`\uD83D\uDCCA Analytics: ${event}`, payload);
  } catch { /* noop */ }
}

export function track(event: string, payload: Payload = {}): void {
  safeLog(event, payload);
}

export function trackTabOpenedReturning(count: number): void {
  track('tab_opened:returning', { count });
  track('returning_count', { count });
}

export function trackOpenFromReturning(showId: string | number, title?: string): void {
  track('open_from:returning', { showId, title });
}

/**
 * Track sort mode change in tabbed lists
 */
export function trackSortChange(tabKey: string, sortMode: string, previousMode?: string): void {
  track('tab_sort_changed', { tabKey, sortMode, previousMode });
}

/**
 * Track filter change in tabbed lists
 */
export function trackFilterChange(tabKey: string, filterType: string, providerCount: number): void {
  track('tab_filter_changed', { tabKey, filterType, providerCount });
}

/**
 * Track reorder completion in tabbed lists
 */
export function trackReorderCompleted(tabKey: string, fromIndex: number, toIndex: number): void {
  track('tab_reorder_completed', { tabKey, fromIndex, toIndex });
}

/**
 * Track tab state reset to defaults
 */
export function trackTabStateReset(tabKey: string): void {
  track('tab_state_reset', { tabKey });
}

/**
 * Track community post creation
 */
export function trackCommunityPostCreate(hasMedia: boolean, length: number): void {
  track('community.post.create', { hasMedia, length });
}

/**
 * Game Analytics Tracking
 */

/**
 * Track FlickWord game start
 */
export function trackFlickWordGameStart(gameNumber: number, isPro: boolean): void {
  track('flickword.game.start', { gameNumber, isPro });
}

/**
 * Track FlickWord game completion
 */
export function trackFlickWordGameComplete(won: boolean, guesses: number, gameNumber: number, isPro: boolean): void {
  track('flickword.game.complete', { won, guesses, gameNumber, isPro });
}

/**
 * Track FlickWord guess submission
 */
export function trackFlickWordGuess(word: string, attemptNumber: number): void {
  track('flickword.guess', { word, attemptNumber });
}

/**
 * Track FlickWord share
 */
export function trackFlickWordShare(gameNumber: number | null, shareType: 'single' | 'all'): void {
  track('flickword.share', { gameNumber, shareType });
}

/**
 * Track Trivia game start
 */
export function trackTriviaGameStart(gameNumber: number, isPro: boolean): void {
  track('trivia.game.start', { gameNumber, isPro });
}

/**
 * Track Trivia game completion
 */
export function trackTriviaGameComplete(score: number, total: number, percentage: number, gameNumber: number, isPro: boolean): void {
  track('trivia.game.complete', { score, total, percentage, gameNumber, isPro });
}

/**
 * Track Trivia answer selection
 */
export function trackTriviaAnswer(questionIndex: number, isCorrect: boolean): void {
  track('trivia.answer', { questionIndex, isCorrect });
}

/**
 * Track game error
 */
export function trackGameError(gameType: 'flickword' | 'trivia', error: string, context?: Record<string, unknown>): void {
  track('game.error', { gameType, error, ...context });
}

/**
 * Track game review view
 */
export function trackGameReview(gameType: 'flickword' | 'trivia', gameNumber: number | null): void {
  track('game.review', { gameType, gameNumber });
}



```

## apps/web/src/lib/gameReview.ts
### Summary
Helper managing in-game reviews or rating-like feedback for discovery experiences.
### Content
```ts
/**
 * Process: Game Review Storage
 * Purpose: Store and retrieve completed games for review
 * Data Source: Completed game results from FlickWord and Trivia
 * Update Path: Save on game completion, retrieve for review display
 * Dependencies: cacheKeys.ts, dailySeed.ts
 */

import { getDailySeedDate } from './dailySeed';
import { getFlickWordCompletedGamesKey, getTriviaCompletedGamesKey } from './cacheKeys';

export interface CompletedFlickWordGame {
  date: string;
  gameNumber: number;
  target: string;
  guesses: string[];
  won: boolean;
  lastResults: Array<'correct' | 'present' | 'absent'>[];
  completedAt: number; // timestamp
}

export interface CompletedTriviaGame {
  date: string;
  gameNumber: number;
  score: number;
  total: number;
  percentage: number;
  questions: Array<{
    question: string;
    selectedAnswer: number;
    correctAnswer: number;
    isCorrect: boolean;
  }>;
  completedAt: number; // timestamp
}

/**
 * Save completed FlickWord game for review
 */
export function saveCompletedFlickWordGame(game: CompletedFlickWordGame): void {
  try {
    const today = getDailySeedDate();
    const key = getFlickWordCompletedGamesKey(today);
    const existing = JSON.parse(localStorage.getItem(key) || '[]') as CompletedFlickWordGame[];
    
    // Remove any existing game with same gameNumber (replace if replayed)
    const filtered = existing.filter(g => g.gameNumber !== game.gameNumber);
    filtered.push(game);
    
    // Sort by gameNumber
    filtered.sort((a, b) => a.gameNumber - b.gameNumber);
    
    localStorage.setItem(key, JSON.stringify(filtered));
    console.log(`üíæ Saved completed FlickWord game ${game.gameNumber} for review`);
  } catch (error) {
    if (error instanceof DOMException && error.name === 'QuotaExceededError') {
      console.error("‚ùå localStorage quota exceeded. Cannot save completed game.");
    } else {
      console.warn("Failed to save completed FlickWord game:", error);
    }
  }
}

/**
 * Get completed FlickWord games for today
 */
export function getCompletedFlickWordGames(date?: string): CompletedFlickWordGame[] {
  try {
    const targetDate = date || getDailySeedDate();
    const key = getFlickWordCompletedGamesKey(targetDate);
    const games = localStorage.getItem(key);
    return games ? JSON.parse(games) : [];
  } catch (error) {
    console.warn("Failed to get completed FlickWord games:", error);
    return [];
  }
}

/**
 * Save completed Trivia game for review
 */
export function saveCompletedTriviaGame(game: CompletedTriviaGame): void {
  try {
    const today = getDailySeedDate();
    const key = getTriviaCompletedGamesKey(today);
    const existing = JSON.parse(localStorage.getItem(key) || '[]') as CompletedTriviaGame[];
    
    // Remove any existing game with same gameNumber (replace if replayed)
    const filtered = existing.filter(g => g.gameNumber !== game.gameNumber);
    filtered.push(game);
    
    // Sort by gameNumber
    filtered.sort((a, b) => a.gameNumber - b.gameNumber);
    
    localStorage.setItem(key, JSON.stringify(filtered));
    console.log(`üíæ Saved completed Trivia game ${game.gameNumber} for review`);
  } catch (error) {
    if (error instanceof DOMException && error.name === 'QuotaExceededError') {
      console.error("‚ùå localStorage quota exceeded. Cannot save completed game.");
    } else {
      console.warn("Failed to save completed Trivia game:", error);
    }
  }
}

/**
 * Get completed Trivia games for today
 */
export function getCompletedTriviaGames(date?: string): CompletedTriviaGame[] {
  try {
    const targetDate = date || getDailySeedDate();
    const key = getTriviaCompletedGamesKey(targetDate);
    const games = localStorage.getItem(key);
    return games ? JSON.parse(games) : [];
  } catch (error) {
    console.warn("Failed to get completed Trivia games:", error);
    return [];
  }
}

/**
 * Get all completed games for a date range (for history)
 */
export function getCompletedGamesHistory(
  gameType: 'flickword' | 'trivia',
  days: number = 7
): Array<{ date: string; games: CompletedFlickWordGame[] | CompletedTriviaGame[] }> {
  const history: Array<{ date: string; games: CompletedFlickWordGame[] | CompletedTriviaGame[] }> = [];
  const today = new Date(getDailySeedDate() + 'T00:00:00Z');
  
  for (let i = 0; i < days; i++) {
    const date = new Date(today);
    date.setDate(date.getDate() - i);
    const dateStr = date.toISOString().split('T')[0];
    
    const games = gameType === 'flickword' 
      ? getCompletedFlickWordGames(dateStr)
      : getCompletedTriviaGames(dateStr);
    
    if (games.length > 0) {
      history.push({ date: dateStr, games });
    }
  }
  
  return history;
}





```

## apps/web/src/hooks/useVote.ts
### Summary
Hook managing upvote/downvote interactions and preventing duplicate scores in discovery/community contexts.
### Content
```ts
/**
 * Process: Vote Hook
 * Purpose: Optimistic voting with real-time score updates using Firestore onSnapshot
 * Data Source: Firestore posts/{postId}/votes/{userId} sub-collection
 * Update Path: User votes via setDoc/deleteDoc, scores aggregated by Cloud Function
 * Dependencies: firebaseBootstrap (db), authManager (userId)
 */

import { useState, useEffect, useCallback } from 'react';
import { doc, setDoc, deleteDoc, getDoc, onSnapshot } from 'firebase/firestore';
import { db } from '../lib/firebaseBootstrap';
import { authManager } from '../lib/auth';

export interface VoteState {
  userVote: number | null; // -1, 0, or 1 (null = not loaded yet, 0 = no vote)
  score: number; // Aggregated score from parent post doc
  voteCount: number; // Total number of votes
  loading: boolean;
  error: string | null;
}

export function useVote(postId: string) {
  const [state, setState] = useState<VoteState>({
    userVote: null,
    score: 0,
    voteCount: 0,
    loading: true,
    error: null,
  });

  const userId = authManager.getCurrentUser()?.uid;

  // Load user's vote
  useEffect(() => {
    if (!postId) return;

    let unsubscribePost: (() => void) | null = null;
    let unsubscribeVote: (() => void) | null = null;

    // Subscribe to post document for score and voteCount
    const postRef = doc(db, 'posts', postId);
    unsubscribePost = onSnapshot(
      postRef,
      (snapshot) => {
        if (snapshot.exists()) {
          const data = snapshot.data();
          setState((prev) => ({
            ...prev,
            score: data.score || 0,
            voteCount: data.voteCount || 0,
            loading: prev.userVote === null && !!userId,
          }));
        } else {
          setState((prev) => ({
            ...prev,
            score: 0,
            voteCount: 0,
            loading: prev.userVote === null && !!userId,
          }));
        }
      },
      (error) => {
        console.error('Error listening to post:', error);
        setState((prev) => ({
          ...prev,
          error: error.message,
          loading: false,
        }));
      }
    );

    // Subscribe to user's vote if authenticated
    if (userId) {
      const voteRef = doc(db, 'posts', postId, 'votes', userId);
      unsubscribeVote = onSnapshot(
        voteRef,
        (snapshot) => {
          setState((prev) => ({
            ...prev,
            userVote: snapshot.exists() ? (snapshot.data()?.value || 0) : 0,
            loading: false,
            error: null,
          }));
        },
        (error) => {
          // If vote doc doesn't exist, that's OK (user hasn't voted)
          if (error.code !== 'permission-denied') {
            console.error('Error listening to vote:', error);
          }
          setState((prev) => ({
            ...prev,
            userVote: 0,
            loading: false,
            error: error.code === 'permission-denied' ? null : error.message,
          }));
        }
      );
    } else {
      // Not authenticated - no user vote
      setState((prev) => ({
        ...prev,
        userVote: 0,
        loading: false,
      }));
    }

    return () => {
      if (unsubscribePost) unsubscribePost();
      if (unsubscribeVote) unsubscribeVote();
    };
  }, [postId, userId]);

  // Toggle vote (optimistic update)
  const toggleVote = useCallback(
    async (voteValue: 1 | -1) => {
      if (!userId) {
        setState((prev) => ({
          ...prev,
          error: 'You must be signed in to vote',
        }));
        return;
      }

      if (!postId) {
        setState((prev) => ({
          ...prev,
          error: 'Invalid post ID',
        }));
        return;
      }

      const voteRef = doc(db, 'posts', postId, 'votes', userId);

      try {
        // Check current vote
        const voteSnap = await getDoc(voteRef);
        const currentValue = voteSnap.exists() ? voteSnap.data()?.value : 0;

        // Optimistic update
        const newVote = currentValue === voteValue ? 0 : voteValue;
        setState((prev) => ({
          ...prev,
          userVote: newVote,
          error: null,
        }));

        if (newVote === 0) {
          // Remove vote (toggle off)
          await deleteDoc(voteRef);
        } else {
          // Set vote
          await setDoc(voteRef, { value: newVote }, { merge: true });
        }

        // Note: score and voteCount will update automatically via onSnapshot
        // when the Cloud Function updates the parent post document
      } catch (error: any) {
        console.error('Error toggling vote:', error);
        
        // Revert optimistic update
        const voteSnap = await getDoc(voteRef);
        const actualValue = voteSnap.exists() ? voteSnap.data()?.value : 0;
        setState((prev) => ({
          ...prev,
          userVote: actualValue,
          error: error.message || 'Failed to update vote',
        }));
      }
    },
    [postId, userId]
  );

  const upvote = useCallback(() => toggleVote(1), [toggleVote]);
  const downvote = useCallback(() => toggleVote(-1), [toggleVote]);

  return {
    ...state,
    upvote,
    downvote,
    isUpvoted: state.userVote === 1,
    isDownvoted: state.userVote === -1,
    canVote: !!userId,
  };
}





























```

## apps/web/src/components/VoteBar.tsx
### Summary
Vote bar UI that displays vote `score` and connects to community discovery posts.
### Content
```tsx
/**
 * Process: Vote Bar Component
 * Purpose: Display upvote/downvote buttons with live score counter
 * Data Source: useVote hook (Firestore real-time)
 * Update Path: User clicks trigger useVote.upvote/downvote
 * Dependencies: useVote hook, useAuth for authentication check
 */

import { useVote } from '../hooks/useVote';
import { useAuth } from '../hooks/useAuth';

interface VoteBarProps {
  postId: string;
  compact?: boolean;
  orientation?: 'horizontal' | 'vertical';
}

export default function VoteBar({ postId, compact = false, orientation = 'horizontal' }: VoteBarProps) {
  const { isAuthenticated: _isAuthenticated } = useAuth(); // Reserved for future use
  const { score, voteCount, userVote, upvote, downvote, isUpvoted, isDownvoted, canVote, loading } = useVote(postId);

  const isVertical = orientation === 'vertical';
  const containerClass = isVertical 
    ? 'flex flex-col items-center gap-1' 
    : 'flex items-center gap-2';

  const buttonBaseClass = compact
    ? 'p-1.5 rounded transition-colors disabled:opacity-50 disabled:cursor-not-allowed'
    : 'px-3 py-1.5 rounded-lg transition-all disabled:opacity-50 disabled:cursor-not-allowed';

  const upvoteClass = `${buttonBaseClass} ${
    isUpvoted
      ? 'bg-green-600 text-white hover:bg-green-700'
      : 'bg-layer hover:bg-layer-hover border border-line'
  }`;

  const downvoteClass = `${buttonBaseClass} ${
    isDownvoted
      ? 'bg-red-600 text-white hover:bg-red-700'
      : 'bg-layer hover:bg-layer-hover border border-line'
  }`;

  // Format score display
  const formatScore = (num: number): string => {
    if (num === 0) return '0';
    if (Math.abs(num) >= 1000) {
      return (num / 1000).toFixed(1) + 'k';
    }
    return num > 0 ? `+${num}` : `${num}`;
  };

  if (loading && userVote === null) {
    return (
      <div className={containerClass}>
        <div className="w-4 h-4 border-2 border-current border-t-transparent rounded-full animate-spin opacity-50" />
      </div>
    );
  }

  return (
    <div className={containerClass} aria-label="Vote controls">
      {/* Upvote button */}
      <button
        type="button"
        onClick={upvote}
        disabled={!canVote}
        className={upvoteClass}
        aria-label={isUpvoted ? 'Remove upvote' : 'Upvote'}
        title={isUpvoted ? 'Remove upvote' : canVote ? 'Upvote' : 'Sign in to vote'}
        style={!isUpvoted ? { color: 'var(--text)', borderColor: 'var(--line)' } : undefined}
      >
        <svg
          width={compact ? '14' : '16'}
          height={compact ? '14' : '16'}
          viewBox="0 0 16 16"
          fill="currentColor"
          className={isUpvoted ? '' : 'opacity-70'}
        >
          <path d="M8 0L3 5h3v6h4V5h3L8 0z" />
        </svg>
      </button>

      {/* Score display */}
      <div
        className={`font-medium ${compact ? 'text-xs' : 'text-sm'}`}
        style={{ color: 'var(--text)', minWidth: compact ? '32px' : '48px', textAlign: 'center' }}
        aria-label={`Score: ${score}, Votes: ${voteCount}`}
      >
        {formatScore(score)}
      </div>

      {/* Downvote button */}
      <button
        type="button"
        onClick={downvote}
        disabled={!canVote}
        className={downvoteClass}
        aria-label={isDownvoted ? 'Remove downvote' : 'Downvote'}
        title={isDownvoted ? 'Remove downvote' : canVote ? 'Downvote' : 'Sign in to vote'}
        style={!isDownvoted ? { color: 'var(--text)', borderColor: 'var(--line)' } : undefined}
      >
        <svg
          width={compact ? '14' : '16'}
          height={compact ? '14' : '16'}
          viewBox="0 0 16 16"
          fill="currentColor"
          className={isDownvoted ? '' : 'opacity-70'}
        >
          <path d="M8 16L3 11h3V5h4v6h3L8 16z" />
        </svg>
      </button>
    </div>
  );
}



```

## apps/web/src/styles/global.css
### Summary
Global CSS that defines typography and color tokens used by rating/discovery UI.
### Content
```css
/*
  Note: Do not change base token values during the Mobile Compact V1 migration (Step 2).
  Compact overrides are defined in apps/web/src/styles/tokens-compact-mobile.css and gated.
  See reports/v2-tokens-alias-map.csv for mapping.
*/

@tailwind base;
@tailwind components;
@tailwind utilities;

html {
  scrollbar-gutter: stable;
}

:root {
  /* ensures sticky offset respects notches / iOS safe areas */
  --safe-top: env(safe-area-inset-top, 0px);
}

/* Dark theme (default) */
:root {
  color-scheme: dark;

  /* Dark theme design tokens */
  --bg: #0f1115;
  --card: #171a21;
  --muted: #a9b3c1;
  --text: #e6eaf0;
  --line: #242a33;
  --accent: #4da3ff;
  --btn: #232a34;
  --btn2: #1c222b;
  --shadow: 0 6px 24px rgba(0, 0, 0, 0.35);

  /* Menu tokens - WCAG AA compliant (‚â•4.5:1 contrast) */
  --menu-bg: #171a21;
  --menu-border: #242a33;
  --menu-text: #e6eaf0;
  --menu-text-muted: #a9b3c1;
  --menu-text-disabled: #5a6470;
  --menu-hover: #232a34;
  --menu-focus: #4da3ff;
  --accent-primary: #4da3ff;
}

/* Light theme */
[data-theme="light"] {
  color-scheme: light;

  /* Light theme design tokens */
  --bg: #ffffff;
  --card: #f8fafc;
  --muted: #64748b;
  --text: #1e293b;
  --line: #e2e8f0;
  --accent: #3b82f6;
  --btn: #f1f5f9;
  --btn2: #e2e8f0;
  --shadow: 0 6px 24px rgba(0, 0, 0, 0.1);

  /* Menu tokens - WCAG AA compliant (‚â•4.5:1 contrast) */
  --menu-bg: #ffffff;
  --menu-border: #e2e8f0;
  --menu-text: #1e293b;
  --menu-text-muted: #64748b;
  --menu-text-disabled: #94a3b8;
  --menu-hover: #f1f5f9;
  --menu-focus: #3b82f6;
  --accent-primary: #3b82f6;
}

html,
body,
#root {
  height: 100%;
  background: var(--bg);
  color: var(--text);
  transition:
    background-color 0.3s ease,
    color 0.3s ease;
}

/* Mobile navigation height - single source of truth */
:root {
  --mobile-nav-height: 80px;
}

/* Mobile nav fix - proper CSS specificity */
@media (max-width: 1024px) {
  /* Force viewport to be actual visible area using large viewport units */
  html {
    height: 100lvh;
    overflow: hidden;
  }

  body {
    height: 100lvh;
    margin: 0;
    padding: 0;
    overflow-y: auto;
    overflow-x: hidden;
  }

  /* Ensure the main content area accounts for mobile nav */
  main {
    min-height: calc(100lvh - var(--mobile-nav-height));
    padding-bottom: var(--mobile-nav-height);
  }

  /* Mobile nav positioning with GPU layering for stability */
  .mobile-nav {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    z-index: var(--z-nav);
    /* Force it to stay within viewport */
    max-height: 100lvh;
    /* Force visibility */
    display: flex;
    visibility: visible;
    opacity: 1;
    /* GPU layering hack for iOS Safari stability */
    transform: translate3d(0, 0, 0);
    -webkit-backface-visibility: hidden;
  }
}

.poster-2x3 {
  aspect-ratio: 2 / 3;
}
[data-cards]::-webkit-scrollbar {
  height: 8px;
}
[data-cards]::-webkit-scrollbar-thumb {
  background: rgba(255, 255, 255, 0.2);
  border-radius: 9999px;
}

/* Focus styles for menu elements - WCAG AA compliant */
select:focus-visible,
button:focus-visible,
input:focus-visible {
  outline: 2px solid var(--menu-focus) !important;
  outline-offset: 2px;
}

/* Rounded, consistent action buttons */
.btn {
  @apply px-3 py-1.5 rounded-xl bg-neutral-800 hover:bg-neutral-700 text-xs text-neutral-100 transition-all duration-150 ease-out hover:scale-105 active:scale-95 active:shadow-inner hover:shadow-md;
}

/* Game Modal Styles */
.game-modal {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  z-index: var(--z-modal);
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 20px;
}

.gm-dialog {
  position: fixed;
  background: var(--card, #171a21);
  border-radius: 16px;
  box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
  width: min(90vw, 500px);
  max-width: 500px;
  max-height: 100vh;
  overflow: hidden;
  animation: modalFadeIn 0.3s ease-out;
  user-select: none;
  display: flex;
  flex-direction: column;
}

.gm-draggable {
  transition: transform 0.1s ease-out;
}

.gm-draggable:not(.gm-dragging) {
  transition: transform 0.2s ease-out;
}

.gm-drag-handle {
  cursor: grab;
  user-select: none;
}

.gm-drag-handle:active {
  cursor: grabbing;
}

@keyframes modalFadeIn {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}

.gm-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 20px 28px; /* extra inset so left icon and close button aren't flush */
  border-bottom: 1px solid var(--line, #242a33);
  background: var(--bg, #0f1115);
}

.gm-header h3 {
  margin: 0;
  font-size: 1.25rem;
  font-weight: 700;
  color: var(--text, #e6eaf0);
}

.gm-close {
  background: none;
  border: none;
  font-size: 1.5rem;
  cursor: pointer;
  color: var(--muted, #a9b3c1);
  padding: 6px; /* slightly larger hit area */
  margin-right: 2px; /* keep away from rounded edge to prevent visual clipping */
  border-radius: 4px;
  transition: all 0.2s ease;
}

.gm-close:hover {
  background: var(--line, #242a33);
  color: var(--text, #e6eaf0);
}

.gm-body {
  padding: 0;
  overflow: hidden; /* prevent inner scrolling */
  display: flex;
  flex-direction: column;
  align-items: center; /* center all modal content horizontally */
  flex: 1;
  min-height: 0;
  width: 100%;
  box-sizing: border-box;
  -webkit-overflow-scrolling: touch;
}

/* FlickWord modal body - no padding, handled by component */
.gm-body.flickword,
.gm-body[data-fw-root] {
  padding: 0;
  overflow: hidden;
}

/* Scroll to top arrow animation */
@keyframes fadeInUp {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.stats-grid {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 12px;
  margin-bottom: 16px;
}

.stat-item {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 8px;
  background: var(--bg, #0f1115);
  border-radius: 8px;
  border: 1px solid var(--line, #242a33);
}

.stat-label {
  font-size: 0.75rem;
  font-weight: 600;
  color: var(--muted, #a9b3c1);
  text-transform: uppercase;
  letter-spacing: 0.05em;
  margin-bottom: 4px;
}

.stat-value {
  font-size: 1.25rem;
  font-weight: 700;
  color: var(--text, #e6eaf0);
}

.game-stats-view {
  text-align: center;
}

.stats-actions {
  display: flex;
  gap: 12px;
  justify-content: center;
  margin-top: 24px;
}

.btn-primary {
  padding: 12px 24px;
  background: linear-gradient(135deg, var(--accent, #4da3ff), #3b82f6);
  color: white;
  border: none;
  border-radius: 8px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.15s ease-out;
}

.btn-primary:hover {
  transform: scale(1.05);
  box-shadow: 0 4px 12px rgba(77, 163, 255, 0.3);
}

.btn-primary:active {
  transform: scale(0.95);
  box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2);
}

.btn-secondary {
  padding: 12px 24px;
  background: var(--card, #171a21);
  color: var(--text, #e6eaf0);
  border: 1px solid var(--line, #242a33);
  border-radius: 8px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.15s ease-out;
}

.btn-secondary:hover {
  background: var(--line, #242a33);
  transform: scale(1.05);
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
}

.btn-secondary:active {
  transform: scale(0.95);
  box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2);
}

/* YouTube Community Player Styles */
.youtube-player-container {
  width: 100%;
  display: flex;
  flex-direction: column;
  background: var(--card, #171a21);
  border-radius: 12px;
  overflow: hidden;
}

.control-btn {
  background: transparent;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  transition: all 0.2s ease;
  color: var(--text, #e6eaf0);
  font-size: 0.875rem;
  display: flex;
  align-items: center;
  justify-content: center;
}

.rotation-active {
  color: var(--accent, #4da3ff) !important;
  font-weight: 600;
}

.rotation-inactive {
  color: var(--muted, #a9b3c1);
}

.player-loading {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  background: var(--card, #171a21);
  color: var(--text, #e6eaf0);
}

.loading-spinner {
  width: 40px;
  height: 40px;
  border: 3px solid var(--line, #242a33);
  border-top: 3px solid var(--accent, #4da3ff);
  border-radius: 50%;
  animation: spin 1s linear infinite;
  margin-bottom: 16px;
}

@keyframes spin {
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
}

.youtube-player {
  width: 100%;
  height: 100%;
}

.youtube-player-error {
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  background: var(--card, #171a21);
  border-radius: 12px;
}

.error-content {
  text-align: center;
  color: var(--text, #e6eaf0);
}

.error-content h3 {
  margin: 0 0 12px 0;
  font-size: 1.125rem;
  font-weight: 700;
}

.error-content p {
  margin: 0 0 16px 0;
  color: var(--muted, #a9b3c1);
}

.retry-btn {
  background: var(--accent, #4da3ff);
  color: white;
  border: none;
  border-radius: 8px;
  padding: 10px 20px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s ease;
}

.retry-btn:hover {
  background: #3b82f6;
  transform: translateY(-1px);
}

/* Trivia Game Styles */
.trivia-game {
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
  padding: 16px;
  background: transparent;
}

.trivia-loading {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100%;
  color: var(--text, #e6eaf0);
  gap: 16px;
}

/* Loading spinner animation */
.loading-spinner {
  width: 40px;
  height: 40px;
  border: 4px solid var(--line, #242a33);
  border-top-color: var(--accent, #4da3ff);
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  to {
    transform: rotate(360deg);
  }
}

/* Screen reader only class */
.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border-width: 0;
}

/* Error banner */
.trivia-error-banner {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 12px 16px;
  background: rgba(239, 68, 68, 0.1);
  border: 1px solid #ef4444;
  border-radius: 8px;
  margin-bottom: 16px;
  color: #ef4444;
  font-size: 0.875rem;
}

.trivia-error {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100%;
  text-align: center;
  gap: 16px;
  padding: 24px;
}

.trivia-error h3 {
  margin: 0;
  color: var(--text, #e6eaf0);
  font-size: 1.25rem;
}

.trivia-error p {
  margin: 0;
  color: var(--muted, #a9b3c1);
}

/* Pro game header styles */
.trivia-game-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 8px 12px;
  background: var(--bg, #0f1115);
  border-radius: 8px;
  margin-bottom: 16px;
  font-size: 0.875rem;
  color: var(--text, #e6eaf0);
  border: 1px solid var(--line, #242a33);
}

.games-completed {
  color: var(--muted, #a9b3c1);
  font-size: 0.75rem;
}

.trivia-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;
  flex-shrink: 0;
}

.trivia-header h3 {
  margin: 0;
  font-size: 1.125rem;
  font-weight: 700;
  color: var(--text, #e6eaf0);
}

.trivia-progress {
  display: flex;
  align-items: center;
  gap: 12px;
  font-size: 0.875rem;
  color: var(--muted, #a9b3c1);
}

.progress-bar {
  flex: 1;
  min-width: 150px;
  height: 8px;
  background: var(--line, #242a33);
  border-radius: 4px;
  overflow: hidden;
}

.progress-fill {
  height: 100%;
  background: var(--accent, #4da3ff);
  transition: width 0.3s ease;
}

.trivia-question {
  margin-bottom: 24px;
  flex-shrink: 0;
}

.question-meta {
  display: flex;
  gap: 12px;
  margin-bottom: 12px;
}

.category,
.difficulty {
  padding: 4px 8px;
  border-radius: 4px;
  font-size: 0.75rem;
  font-weight: 600;
  text-transform: uppercase;
}

.category {
  background: var(--accent, #4da3ff);
  color: white;
}

.difficulty {
  background: #404040;
  color: #e0e0e0;
}

.trivia-question h4 {
  margin: 0;
  font-size: 1.125rem;
  font-weight: 600;
  color: var(--text, #e6eaf0);
  line-height: 1.4;
}

.trivia-options {
  display: flex;
  flex-direction: column;
  gap: 12px;
  margin-bottom: 20px;
  flex: 1;
}

.option-btn {
  padding: 16px 20px;
  border: 2px solid var(--line, #242a33);
  border-radius: 8px;
  background: var(--card, #171a21);
  color: var(--text, #e6eaf0);
  font-size: 0.875rem;
  font-weight: 500;
  text-align: left;
  cursor: pointer;
  transition: all 0.2s ease;
  position: relative;
  outline: none;
}

.option-btn:hover:not(:disabled) {
  border-color: var(--accent, #4da3ff);
  background: var(--bg, #0f1115);
  transform: translateY(-1px);
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
}

.option-btn:active:not(:disabled) {
  transform: translateY(0);
  box-shadow: 0 1px 4px rgba(0, 0, 0, 0.1);
}

.option-btn:focus-visible {
  outline: 3px solid var(--accent, #4da3ff);
  outline-offset: 2px;
  border-color: var(--accent, #4da3ff);
}

.option-btn.correct {
  border-color: #20b265;
  background: rgba(32, 178, 101, 0.15);
  color: #20b265;
  animation: correctPulse 0.4s ease-out;
}

.option-btn.incorrect {
  border-color: #ef4444;
  background: rgba(239, 68, 68, 0.15);
  color: #ef4444;
  animation: incorrectShake 0.4s ease-out;
}

.option-btn.disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.option-btn.disabled:hover {
  transform: none;
  box-shadow: none;
  border-color: var(--line, #242a33);
  background: var(--card, #171a21);
}

@keyframes correctPulse {
  0% {
    transform: scale(1);
  }
  50% {
    transform: scale(1.02);
  }
  100% {
    transform: scale(1);
  }
}

@keyframes incorrectShake {
  0%,
  100% {
    transform: translateX(0);
  }
  25% {
    transform: translateX(-4px);
  }
  75% {
    transform: translateX(4px);
  }
}

.trivia-explanation {
  padding: 16px;
  background: var(--bg, #0f1115);
  border-radius: 8px;
  border-left: 4px solid var(--accent, #4da3ff);
  margin-bottom: 20px;
  flex-shrink: 0;
  animation: explanationFadeIn 0.3s ease-out;
}

@keyframes explanationFadeIn {
  from {
    opacity: 0;
    transform: translateY(-8px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.trivia-explanation p {
  margin: 0;
  font-size: 0.875rem;
  color: var(--muted, #a9b3c1);
  line-height: 1.4;
}

.trivia-actions {
  display: flex;
  gap: 12px;
  justify-content: center;
  flex-shrink: 0;
}

.trivia-completed {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100%;
  text-align: center;
  color: var(--text, #e6eaf0);
}

.trivia-completed h3 {
  margin: 0 0 24px 0;
  font-size: 1.5rem;
  font-weight: 700;
}

.score-display {
  margin-bottom: 24px;
}

.score-circle {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  width: 120px;
  height: 120px;
  border: 4px solid var(--line, #242a33);
  border-radius: 50%;
  background: var(--card, #171a21);
}

.score-percentage {
  font-size: 2rem;
  font-weight: 700;
  margin-bottom: 4px;
}

.score-fraction {
  font-size: 0.875rem;
  color: var(--muted, #a9b3c1);
}

.score-message {
  margin-bottom: 24px;
}

.score-message p {
  margin: 0;
  font-size: 1rem;
  color: var(--text, #e6eaf0);
}

.completion-actions {
  display: flex;
  gap: 12px;
  margin-bottom: 20px;
  flex-wrap: wrap;
  justify-content: center;
}

.completion-actions button {
  min-width: 120px;
  flex: 0 1 auto;
}

/* Responsive button text */
.btn-text-responsive {
  display: inline;
}

.btn-text-responsive-mobile {
  display: none;
}

.btn-text-small {
  display: inline;
  font-size: 0.875em;
}

@media (max-width: 480px) {
  .btn-text-responsive {
    display: none;
  }

  .btn-text-responsive-mobile {
    display: inline;
  }

  .completion-actions {
    flex-direction: column;
    width: 100%;
  }

  .completion-actions button {
    width: 100%;
    min-width: unset;
  }
}

.pro-upsell {
  padding: 12px 16px;
  background: rgba(77, 163, 255, 0.1);
  border: 1px solid var(--accent, #4da3ff);
  border-radius: 8px;
  max-width: 300px;
}

.pro-upsell p {
  margin: 0;
  font-size: 0.875rem;
  color: var(--accent, #4da3ff);
  text-align: center;
}

/* Trivia Stats Styles */
.trivia-stats {
  margin-top: 8px;
}

.trivia-stats .stats-grid {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 8px;
  margin-bottom: 0;
}

.trivia-stats .stat-item {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 6px 4px;
  background: var(--bg, #0f1115);
  border-radius: 6px;
  border: 1px solid var(--line, #242a33);
}

.trivia-stats .stat-label {
  font-size: 0.625rem;
  font-weight: 600;
  color: var(--muted, #a9b3c1);
  text-transform: uppercase;
  letter-spacing: 0.05em;
  margin-bottom: 2px;
}

.trivia-stats .stat-value {
  font-size: 1rem;
  font-weight: 700;
  color: var(--text, #e6eaf0);
}

/* Hide tabpanels when hidden attribute is set (in case of resets) */
[role="tabpanel"][hidden] {
  display: none !important;
}

/* Z-index semantic utilities */
.z-base {
  z-index: var(--z-base);
}
.z-nav {
  z-index: var(--z-nav);
}
.z-dropdown {
  z-index: var(--z-dropdown);
}
.z-overlay {
  z-index: var(--z-overlay);
}
.z-modal {
  z-index: var(--z-modal);
}
.z-toast {
  z-index: var(--z-toast);
}

/* Touch action utilities for swipe handling */
.touch-pan-y {
  touch-action: pan-y;
}
.touch-none {
  touch-action: none;
}

/* D2.3: swipe surface allows vertical scrolling, JS handles horizontal without preventDefault */
.swipe-surface {
  touch-action: pan-y;
}
/* In case we ever need to fully own the gesture (rare): */
.swipe-surface--own {
  touch-action: none;
}

/* Swipeable rows must allow vertical page scroll by default */
.swipeable {
  touch-action: pan-y;
  -webkit-user-select: none;
  user-select: none;
}

/* Mobile responsiveness for trivia game */
@media (max-width: 768px) {
  .trivia-game {
    padding: 12px;
  }

  .trivia-progress {
    font-size: 0.75rem;
  }

  .trivia-question h4 {
    font-size: 1rem;
  }

  .option-btn {
    padding: 14px 16px;
    font-size: 0.8125rem;
  }

  .trivia-completed h3 {
    font-size: 1.25rem;
  }

  .score-circle {
    width: 100px;
    height: 100px;
  }

  .score-percentage {
    font-size: 1.75rem;
  }

  .gm-dialog {
    width: 95vw;
    height: 95vh;
    max-height: 95vh;
  }

  .gm-body {
    overflow-y: auto;
    -webkit-overflow-scrolling: touch;
  }
}

/* Reduced motion support */
@media (prefers-reduced-motion: reduce) {
  .loading-spinner {
    animation: none;
    border-top-color: var(--accent, #4da3ff);
  }

  .option-btn,
  .progress-fill,
  .trivia-explanation {
    transition: none;
    animation: none;
  }

  .option-btn.correct,
  .option-btn.incorrect {
    animation: none;
  }

  .option-btn:hover:not(:disabled) {
    transform: none;
  }
}

/* Games limit message */
.games-limit {
  padding: 12px 16px;
  background: rgba(34, 197, 94, 0.1);
  border: 1px solid #22c55e;
  border-radius: 8px;
  max-width: 300px;
  margin-top: 16px;
}

.games-limit p {
  margin: 0;
  font-size: 0.875rem;
  color: #22c55e;
  text-align: center;
}

/* Home Marquee Scrolling Ticker Styles */
.flicklet-marquee-outer {
  margin-top: 8px;
  margin-bottom: 8px;
  /* No background, no border, no shadow - just spacing */
}

.flicklet-marquee-container {
  position: relative;
  overflow: hidden;
  width: 100%;
  /* No background, no border, no radius - visually transparent */
}

.flicklet-marquee-track {
  display: inline-block;
  white-space: nowrap;
  will-change: transform;
  /* NO animation keyframes here - JS drives transform via requestAnimationFrame */
  /* No extra padding/background - text sits directly on page bg */
}

/* Reduced motion: no movement, just show text left-aligned */
@media (prefers-reduced-motion: reduce) {
  .flicklet-marquee-track {
    transform: translateX(0) !important;
  }
}

```

## apps/web/src/components/games/TriviaReview.tsx
### Summary
Review overlay for trivia that showcases score summaries and discovery links.
### Content
```tsx
/**
 * Process: Trivia Game Review
 * Purpose: Display completed Trivia games for review
 * Data Source: Completed games from gameReview.ts
 * Update Path: Loads from localStorage on mount
 * Dependencies: gameReview.ts, analytics.ts
 */

import { useState, useEffect } from 'react';
import { getCompletedTriviaGames, type CompletedTriviaGame } from '../../lib/gameReview';
import { trackGameReview } from '../../lib/analytics';

interface TriviaReviewProps {
  onClose?: () => void;
}

export default function TriviaReview({ onClose }: TriviaReviewProps) {
  const [completedGames, setCompletedGames] = useState<CompletedTriviaGame[]>([]);
  const [selectedGame, setSelectedGame] = useState<number | null>(null);

  useEffect(() => {
    const games = getCompletedTriviaGames();
    setCompletedGames(games);
    
    // Track review view
    trackGameReview('trivia', null);
  }, []);

  if (completedGames.length === 0) {
    return (
      <div className="trivia-review">
        <div className="trivia-review-empty">
          <h3>No Completed Games</h3>
          <p>Complete a game to review your results here!</p>
          {onClose && (
            <button className="btn-secondary" onClick={onClose}>
              Close
            </button>
          )}
        </div>
      </div>
    );
  }

  const selectedGameData = selectedGame !== null 
    ? completedGames.find(g => g.gameNumber === selectedGame)
    : null;

  return (
    <div className="trivia-review">
      <div className="trivia-review-header">
        <h3>üìä Today&apos;s Games</h3>
        {onClose && (
          <button className="btn-secondary" onClick={onClose}>
            √ó
          </button>
        )}
      </div>
      
      <div className="trivia-review-games">
        {completedGames.map((game) => (
          <div key={game.gameNumber} className="trivia-review-game">
            <div className="trivia-review-game-header">
              <h4>Game {game.gameNumber}</h4>
              <span className={`trivia-review-score ${game.percentage >= 60 ? 'passed' : 'failed'}`}>
                {game.score}/{game.total} ({game.percentage}%)
              </span>
            </div>
            
            <div className="trivia-review-summary">
              <p>
                <strong>Score:</strong> {game.score} out of {game.total} correct
              </p>
              <p>
                <strong>Result:</strong> {game.percentage >= 60 ? '‚úÖ Passed' : '‚ùå Failed'} 
                {game.percentage >= 60 && ' (60%+ required)'}
              </p>
            </div>
            
            <button
              className="btn-secondary"
              onClick={() => setSelectedGame(selectedGame === game.gameNumber ? null : game.gameNumber)}
            >
              {selectedGame === game.gameNumber ? 'Hide Details' : 'Show Details'}
            </button>
            
            {selectedGame === game.gameNumber && selectedGameData && (
              <div className="trivia-review-details">
                {selectedGameData.questions.map((q, idx) => (
                  <div key={idx} className={`trivia-review-question ${q.isCorrect ? 'correct' : 'incorrect'}`}>
                    <p className="question-text">
                      <strong>Q{idx + 1}:</strong> {q.question}
                    </p>
                    <p className="answer-text">
                      Your answer: <strong>{q.selectedAnswer >= 0 ? 'Option ' + (q.selectedAnswer + 1) : 'Not answered'}</strong>
                      {q.isCorrect ? ' ‚úÖ' : ' ‚ùå'}
                    </p>
                    {!q.isCorrect && (
                      <p className="correct-answer-text">
                        Correct answer: <strong>Option {q.correctAnswer + 1}</strong>
                      </p>
                    )}
                  </div>
                ))}
              </div>
            )}
          </div>
        ))}
      </div>
    </div>
  );
}


```

## apps/web/src/lib/communitySorting.ts
### Summary
Sorting helpers that prioritize posts by score, vote count, or recency.
### Content
```ts
/**
 * Process: Community Sorting Utilities
 * Purpose: Implement sorting algorithms for community posts (Top, Hot, Trending)
 * Data Source: Post data with score, voteCount, commentCount, publishedAt
 * Update Path: N/A - utility functions
 * Dependencies: Used by CommunityPanel for sorting posts
 */

export type SortMode = 'newest' | 'oldest' | 'top' | 'top-week' | 'hot' | 'trending';

export interface PostForSorting {
  id: string;
  score?: number;
  voteCount?: number;
  commentCount?: number;
  publishedAt: string | Date;
}

/**
 * Calculate "Hot" score using Reddit-like algorithm
 * Formula: score / (age_in_hours + 2)^gravity
 * Higher score = more recent activity + higher votes
 */
function calculateHotScore(post: PostForSorting, gravity: number = 1.5): number {
  const now = new Date();
  const publishedAt = typeof post.publishedAt === 'string' 
    ? new Date(post.publishedAt) 
    : post.publishedAt;
  const ageInHours = (now.getTime() - publishedAt.getTime()) / (1000 * 60 * 60);
  
  // Prevent division by zero and handle very new posts
  const denominator = Math.pow(ageInHours + 2, gravity);
  return (post.score || 0) / denominator;
}

/**
 * Calculate "Trending" score based on recent activity
 * Prioritizes posts with recent votes/comments
 */
function calculateTrendingScore(post: PostForSorting): number {
  const now = new Date();
  const publishedAt = typeof post.publishedAt === 'string' 
    ? new Date(post.publishedAt) 
    : post.publishedAt;
  const ageInHours = (now.getTime() - publishedAt.getTime()) / (1000 * 60 * 60);
  
  // Recent posts (last 24 hours) get boost
  const recencyBoost = ageInHours < 24 ? 1.5 : 1.0;
  
  // Combine score, vote count, and comment count with recency
  return ((post.score || 0) + (post.voteCount || 0) * 0.5 + (post.commentCount || 0) * 0.3) * recencyBoost;
}

/**
 * Sort posts by the specified mode
 */
export function sortPosts<T extends PostForSorting>(
  posts: T[],
  mode: SortMode
): T[] {
  const sorted = [...posts]; // Create copy to avoid mutating original

  switch (mode) {
    case 'newest':
      return sorted.sort((a, b) => {
        const dateA = typeof a.publishedAt === 'string' ? new Date(a.publishedAt) : a.publishedAt;
        const dateB = typeof b.publishedAt === 'string' ? new Date(b.publishedAt) : b.publishedAt;
        return dateB.getTime() - dateA.getTime(); // Newest first
      });

    case 'oldest':
      return sorted.sort((a, b) => {
        const dateA = typeof a.publishedAt === 'string' ? new Date(a.publishedAt) : a.publishedAt;
        const dateB = typeof b.publishedAt === 'string' ? new Date(b.publishedAt) : b.publishedAt;
        return dateA.getTime() - dateB.getTime(); // Oldest first
      });

    case 'top':
      return sorted.sort((a, b) => (b.score || 0) - (a.score || 0)); // Highest score first

    case 'top-week': {
      // Filter to last 7 days, then sort by score
      const weekAgo = new Date();
      weekAgo.setDate(weekAgo.getDate() - 7);
      
      return sorted
        .filter(post => {
          const publishedAt = typeof post.publishedAt === 'string' 
            ? new Date(post.publishedAt) 
            : post.publishedAt;
          return publishedAt >= weekAgo;
        })
        .sort((a, b) => (b.score || 0) - (a.score || 0));
    }

    case 'hot':
      return sorted.sort((a, b) => {
        const hotA = calculateHotScore(a);
        const hotB = calculateHotScore(b);
        return hotB - hotA; // Highest hot score first
      });

    case 'trending':
      return sorted.sort((a, b) => {
        const trendingA = calculateTrendingScore(a);
        const trendingB = calculateTrendingScore(b);
        return trendingB - trendingA; // Highest trending score first
      });

    default:
      return sorted; // Return unsorted if unknown mode
  }
}

/**
 * Check if a sort mode requires Pro
 */
export function isProSortMode(mode: SortMode): boolean {
  return ['top', 'top-week', 'hot', 'trending'].includes(mode);
}

/**
 * Get available sort modes for a user
 */
export function getAvailableSortModes(isPro: boolean): SortMode[] {
  const freeModes: SortMode[] = ['newest', 'oldest'];
  const proModes: SortMode[] = ['top', 'top-week', 'hot', 'trending'];
  
  return isPro ? [...freeModes, ...proModes] : freeModes;
}

/**
 * Get display name for sort mode
 */
export function getSortModeLabel(mode: SortMode): string {
  const labels: Record<SortMode, string> = {
    newest: 'Newest',
    oldest: 'Oldest',
    top: 'Top (All-time)',
    'top-week': 'Top (Past Week)',
    hot: 'Hot',
    trending: 'Trending',
  };
  return labels[mode] || mode;
}


```

## apps/web/src/components/NewPostModal.tsx
### Summary
Modal used to craft community posts, often referencing rated/discovered shows.
### Content
```tsx
/**
 * Process: New Post Modal
 * Purpose: Allow authenticated users to create posts with optimistic submit
 * Data Source: Firestore posts collection
 * Update Path: User submits post ‚Üí writes to Firestore ‚Üí Cloud Function sanitizes
 * Dependencies: firebaseBootstrap, authManager, serverTimestamp
 */

import { useState, FormEvent, KeyboardEvent, useRef, useEffect } from "react";
import {
  collection,
  addDoc,
  serverTimestamp,
  query,
  getDocs,
  limit,
} from "firebase/firestore";
import { db } from "../lib/firebaseBootstrap";
import { useAuth } from "../hooks/useAuth";
import { trackCommunityPostCreate } from "../lib/analytics";
import { useSettings } from "../lib/settings";
import { TOPICS, extractTopicsFromTags } from "../lib/communityTopics";
import { checkCanCreatePost } from "../lib/communityLimitsCheck";

interface NewPostModalProps {
  isOpen: boolean;
  onClose: () => void;
  onPostCreated?: () => void;
}

const MAX_LENGTH = 5000;
const MIN_LENGTH = 1;

export default function NewPostModal({
  isOpen,
  onClose,
  onPostCreated,
}: NewPostModalProps) {
  const { isAuthenticated, user } = useAuth();
  const settings = useSettings();
  const [content, setContent] = useState("");
  const [submitting, setSubmitting] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [availableTags, setAvailableTags] = useState<
    Array<{ slug: string; name: string }>
  >([]);
  const [selectedTags, setSelectedTags] = useState<string[]>([]);
  const [selectedTopics, setSelectedTopics] = useState<string[]>([]);
  const [containsSpoilers, setContainsSpoilers] = useState(false);
  const [newTagInput, setNewTagInput] = useState("");
  const [loadingTags, setLoadingTags] = useState(false);
  const [limitCheck, setLimitCheck] = useState<{ canCreate: boolean; remaining: number; message?: string } | null>(null);
  const textareaRef = useRef<HTMLTextAreaElement>(null);
  const announcementRef = useRef<HTMLDivElement>(null);

  const remainingChars = MAX_LENGTH - content.length;
  const canSubmit =
    content.trim().length >= MIN_LENGTH &&
    content.trim().length <= MAX_LENGTH &&
    !submitting &&
    (limitCheck?.canCreate ?? true); // Block if limit reached

  // Fetch available tags and check limits when modal opens
  useEffect(() => {
    if (isOpen && isAuthenticated && user) {
      fetchTags();
      checkLimits();
    }
  }, [isOpen, isAuthenticated, user]);

  const checkLimits = async () => {
    if (!isAuthenticated || !user) return;
    const result = await checkCanCreatePost(user.uid, settings.pro.isPro);
    setLimitCheck(result);
  };

  // Focus textarea when modal opens
  useEffect(() => {
    if (isOpen && textareaRef.current) {
      setTimeout(() => textareaRef.current?.focus(), 100);
    }
  }, [isOpen]);

  const fetchTags = async () => {
    try {
      setLoadingTags(true);
      // Fetch recent posts to extract unique tags
      const postsRef = collection(db, "posts");
      const postsQuery = query(postsRef, limit(100)); // Get up to 100 posts to find tags

      const snapshot = await getDocs(postsQuery);
      const tagSet = new Set<string>();

      // Extract all unique tag slugs from posts
      snapshot.forEach((doc) => {
        const data = doc.data();
        const tagSlugs = data.tagSlugs || [];
        tagSlugs.forEach((slug: string) => {
          if (slug && typeof slug === "string") {
            tagSet.add(slug);
          }
        });
      });

      // Convert to array of tag objects (slug and name are the same for now)
      const tags = Array.from(tagSet)
        .sort()
        .map((slug) => ({
          slug,
          name: slug, // In Firestore, tags are stored as slugs, so name = slug
        }));

      setAvailableTags(tags);
    } catch (err) {
      console.error("Failed to fetch tags:", err);
      // Don't show error - tags are optional
    } finally {
      setLoadingTags(false);
    }
  };

  // Reset form when modal closes
  useEffect(() => {
    if (!isOpen) {
      setContent("");
      setError(null);
      setSubmitting(false);
      setSelectedTags([]);
      setSelectedTopics([]);
      setContainsSpoilers(false);
      setNewTagInput("");
    }
  }, [isOpen]);

  const handleSubmit = async (e: FormEvent) => {
    e.preventDefault();

    if (!isAuthenticated || !user) {
      setError("You must be signed in to create a post");
      return;
    }

    if (!canSubmit) {
      if (limitCheck && !limitCheck.canCreate) {
        setError(limitCheck.message || "Daily post limit reached");
      }
      return;
    }

    const trimmedContent = content.trim();

    // Validation
    if (trimmedContent.length < MIN_LENGTH) {
      setError("Post must be at least 1 character long");
      return;
    }

    if (trimmedContent.length > MAX_LENGTH) {
      setError(`Post must be no more than ${MAX_LENGTH} characters`);
      return;
    }

    setSubmitting(true);
    setError(null);

    try {
      // Process tags: convert tag names to slugs
      // Tags are stored as slugs (lowercase, hyphenated) in the tagSlugs array
      let tagSlugs: string[] = [...selectedTags, ...selectedTopics];

      // If user entered new tags, convert them to slugs
      if (newTagInput.trim()) {
        const newTagNames = newTagInput
          .split(",")
          .map((t) => t.trim())
          .filter((t) => t.length > 0);

        // Convert tag names to slugs (lowercase, hyphenated)
        const newSlugs = newTagNames.map((name) =>
          name
            .toLowerCase()
            .replace(/[^\da-z]+/g, "-")
            .replace(/^-|-$/g, "")
        );

        tagSlugs = [...new Set([...tagSlugs, ...newSlugs])]; // Remove duplicates
      }

      // Extract topics from tagSlugs (topics are a subset of tags)
      const topics = extractTopicsFromTags(tagSlugs);
      
      // Get user's Pro status
      const authorIsPro = settings.pro.isPro || false;

      // Generate slug from content
      const title = trimmedContent.slice(0, 100).trim() || "Untitled Post";
      const slug =
        title
          .toLowerCase()
          .replace(/[^\da-z]+/g, "-")
          .replace(/^-|-$/g, "") + `-${Date.now()}`;

      const postsRef = collection(db, "posts");

      // Create post in Firestore (matches Firestore rules structure)
      const postData: any = {
        title,
        excerpt: trimmedContent.slice(0, 200).trim(),
        body: trimmedContent,
        slug,
        authorId: user.uid,
        authorName:
          user.displayName || user.email?.split("@")[0] || "Anonymous",
        authorEmail: user.email || null,
        tagSlugs,
        publishedAt: serverTimestamp(),
        updatedAt: serverTimestamp(),
        score: 0,
        voteCount: 0,
        commentCount: 0,
        containsSpoilers: containsSpoilers,
        authorIsPro: authorIsPro,
      };
      
      // Add topics field if there are any topics
      if (topics.length > 0) {
        postData.topics = topics;
      }

      console.log("[NewPostModal] Creating post in Firestore:", {
        slug,
        title,
        tagSlugs,
        authorId: user.uid,
        authorName: postData.authorName,
      });

      const docRef = await addDoc(postsRef, postData);
      console.log("[NewPostModal] Post created in Firestore:", {
        id: docRef.id,
        slug,
        path: docRef.path,
      });

      // Track analytics
      trackCommunityPostCreate(false, trimmedContent.length);

      // Clear form and announce success
      setContent("");
      if (announcementRef.current) {
        announcementRef.current.textContent = "Post published.";
      }

      // Call callback to refresh posts list
      // This happens before closing modal to ensure immediate refresh
      if (onPostCreated) {
        onPostCreated();
      }

      // Close modal after a brief delay to show success message
      setTimeout(() => {
        onClose();
      }, 100);
    } catch (err: any) {
      console.error("Failed to create post:", err);

      // Check if error is from Cloud Function rejection
      if (err.message?.includes("disallowed words")) {
        setError("Post contains disallowed words");
      } else {
        setError(err.message || "Failed to post. Please try again.");
      }
    } finally {
      setSubmitting(false);
    }
  };

  const handleKeyDown = (e: KeyboardEvent<HTMLTextAreaElement>) => {
    // Cmd/Ctrl + Enter submits
    if ((e.metaKey || e.ctrlKey) && e.key === "Enter") {
      e.preventDefault();
      handleSubmit(e as any);
    }
    // Plain Enter just inserts newline (default behavior)
    // Escape closes modal
    if (e.key === "Escape" && !submitting) {
      onClose();
    }
  };

  if (!isOpen) return null;

  return (
    <div
      className="fixed inset-0 z-50 flex items-center justify-center p-4"
      style={{
        backgroundColor: "rgba(0, 0, 0, 0.85)",
        backdropFilter: "blur(4px)",
        paddingBottom: "calc(1rem + env(safe-area-inset-bottom, 0px))",
      }}
      onClick={(e) => {
        if (e.target === e.currentTarget) {
          onClose();
        }
      }}
    >
      <div
        className="rounded-lg p-6 w-full max-w-2xl max-h-[90vh] overflow-y-auto border shadow-2xl"
        style={{
          backgroundColor: "var(--card)",
          borderColor: "var(--line)",
          borderWidth: "1px",
          maxHeight:
            "calc(90vh - env(safe-area-inset-top, 0px) - env(safe-area-inset-bottom, 0px))",
          boxShadow:
            "0 20px 25px -5px rgba(0, 0, 0, 0.5), 0 10px 10px -5px rgba(0, 0, 0, 0.2)",
        }}
        onClick={(e) => e.stopPropagation()}
      >
        <div className="flex items-center justify-between mb-4">
          <h2 className="text-xl font-semibold text-primary">Create Post</h2>
          <button
            type="button"
            onClick={onClose}
            className="text-muted hover:text-primary transition"
            aria-label="Close modal"
            disabled={submitting}
          >
            <span className="text-2xl">&times;</span>
          </button>
        </div>

        {!isAuthenticated ? (
          <div className="p-4 rounded-lg bg-layer border border-line">
            <p className="text-sm mb-3" style={{ color: "var(--muted)" }}>
              Sign in to create a post
            </p>
          </div>
        ) : (
          <form onSubmit={handleSubmit} role="form" aria-label="Create post">
            <div className="mb-4">
              <label htmlFor="post-content" className="sr-only">
                Post content
              </label>
              <textarea
                id="post-content"
                ref={textareaRef}
                value={content}
                onChange={(e) => {
                  setContent(e.target.value);
                  setError(null);
                }}
                onKeyDown={handleKeyDown}
                placeholder="What's on your mind?"
                disabled={submitting}
                rows={6}
                maxLength={MAX_LENGTH}
                className="w-full px-3 py-2 rounded-lg text-sm resize-y min-h-[150px]"
                style={{
                  backgroundColor: "var(--bg)",
                  color: "var(--text)",
                  border: `1px solid ${error ? "#ef4444" : "var(--line)"}`,
                }}
                aria-label="Post content"
                aria-describedby="post-help post-error"
                aria-invalid={!!error}
              />

              {error && (
                <div
                  id="post-error"
                  className="mt-2 text-sm"
                  style={{ color: "#ef4444" }}
                  role="alert"
                >
                  {error}
                </div>
              )}

              <div className="flex items-center justify-between mt-2">
                <span
                  id="post-help"
                  className="text-xs"
                  style={{
                    color: remainingChars < 100 ? "#ef4444" : "var(--muted)",
                  }}
                >
                  {remainingChars} characters remaining
                  {limitCheck && (
                    <span className="ml-2">
                      ¬∑ {limitCheck.remaining} posts remaining today
                    </span>
                  )}
                </span>
                <span className="text-xs" style={{ color: "var(--muted)" }}>
                  Press Cmd/Ctrl+Enter to submit, Esc to close
                </span>
              </div>
              {limitCheck && !limitCheck.canCreate && (
                <div className="mt-2 text-xs" style={{ color: "#ef4444" }}>
                  {limitCheck.message}
                </div>
              )}
            </div>

            {/* Topic Selection */}
            <div className="mb-4">
              <label
                className="block text-sm font-medium mb-2"
                style={{ color: "var(--text)" }}
              >
                Topic(s) (optional)
              </label>
              <div className="flex flex-wrap gap-2 mb-2">
                {TOPICS.map((topic) => {
                  const isSelected = selectedTopics.includes(topic.slug);
                  return (
                    <button
                      key={topic.slug}
                      type="button"
                      onClick={() => {
                        if (isSelected) {
                          setSelectedTopics((prev) =>
                            prev.filter((t) => t !== topic.slug)
                          );
                        } else {
                          setSelectedTopics((prev) => [...prev, topic.slug]);
                        }
                      }}
                      className="px-3 py-1.5 rounded-full text-xs font-medium transition"
                      style={{
                        backgroundColor: isSelected
                          ? "var(--accent-primary)"
                          : "var(--layer)",
                        color: isSelected ? "#fff" : "var(--text)",
                        border: `1px solid ${
                          isSelected ? "var(--accent-primary)" : "var(--line)"
                        }`,
                      }}
                    >
                      {topic.name}
                    </button>
                  );
                })}
              </div>
            </div>

            {/* Spoiler Toggle */}
            <div className="mb-4">
              <label className="flex items-center gap-2 cursor-pointer">
                <input
                  type="checkbox"
                  checked={containsSpoilers}
                  onChange={(e) => setContainsSpoilers(e.target.checked)}
                  disabled={submitting}
                  className="w-4 h-4 rounded"
                  style={{ accentColor: "var(--accent-primary)" }}
                />
                <span className="text-sm" style={{ color: "var(--text)" }}>
                  Contains spoilers
                </span>
              </label>
            </div>

            {/* Tag Selection */}
            <div className="mb-4">
              <label
                htmlFor="post-tags"
                className="block text-sm font-medium mb-2"
                style={{ color: "var(--text)" }}
              >
                Additional Tags (optional)
              </label>

              {/* Selected Tags */}
              {selectedTags.length > 0 && (
                <div className="flex flex-wrap gap-2 mb-2">
                  {selectedTags.map((tagSlug) => {
                    const tag = availableTags.find((t) => t.slug === tagSlug);
                    return (
                      <span
                        key={tagSlug}
                        className="inline-flex items-center gap-1 px-2 py-1 rounded-full text-xs font-medium"
                        style={{
                          backgroundColor: "var(--accent-primary)",
                          color: "#fff",
                        }}
                      >
                        {tag?.name || tagSlug}
                        <button
                          type="button"
                          onClick={() =>
                            setSelectedTags((prev) =>
                              prev.filter((t) => t !== tagSlug)
                            )
                          }
                          className="hover:opacity-70"
                          aria-label={`Remove tag ${tag?.name || tagSlug}`}
                        >
                          √ó
                        </button>
                      </span>
                    );
                  })}
                </div>
              )}

              {/* Available Tags */}
              {!loadingTags && availableTags.length > 0 && (
                <div className="mb-2">
                  <p className="text-xs mb-1" style={{ color: "var(--muted)" }}>
                    Select existing tags:
                  </p>
                  <div className="flex flex-wrap gap-2">
                    {availableTags
                      .filter((tag) => !selectedTags.includes(tag.slug))
                      .slice(0, 10)
                      .map((tag) => (
                        <button
                          key={tag.slug}
                          type="button"
                          onClick={() =>
                            setSelectedTags((prev) => [...prev, tag.slug])
                          }
                          className="px-2 py-1 rounded-full text-xs font-medium transition hover:opacity-80"
                          style={{
                            backgroundColor: "var(--layer)",
                            color: "var(--text)",
                            border: "1px solid var(--line)",
                          }}
                        >
                          {tag.name || tag.slug}
                        </button>
                      ))}
                  </div>
                </div>
              )}

              {/* New Tag Input */}
              <div>
                <input
                  id="post-tags"
                  type="text"
                  value={newTagInput}
                  onChange={(e) => setNewTagInput(e.target.value)}
                  placeholder="Add new tags (comma-separated)"
                  disabled={submitting}
                  className="w-full px-3 py-2 rounded-lg text-sm"
                  style={{
                    backgroundColor: "var(--bg)",
                    color: "var(--text)",
                    border: "1px solid var(--line)",
                  }}
                />
                <p className="text-xs mt-1" style={{ color: "var(--muted)" }}>
                  Enter new tags separated by commas (e.g., "discussion,
                  review")
                </p>
              </div>
            </div>

            <div className="flex items-center justify-end gap-2">
              <button
                type="button"
                onClick={onClose}
                disabled={submitting}
                className="px-4 py-2 rounded-lg text-sm font-medium transition disabled:opacity-50 disabled:cursor-not-allowed"
                style={{
                  backgroundColor: "var(--btn)",
                  color: "var(--text)",
                }}
              >
                Cancel
              </button>
              <button
                type="submit"
                disabled={!canSubmit}
                className="px-4 py-2 rounded-lg text-sm font-medium transition disabled:opacity-50 disabled:cursor-not-allowed"
                style={{
                  backgroundColor: canSubmit
                    ? "var(--accent-primary)"
                    : "var(--btn)",
                  color: canSubmit ? "#fff" : "var(--muted)",
                }}
                aria-label={submitting ? "Posting..." : "Submit post"}
              >
                {submitting ? "Posting..." : "Post"}
              </button>
            </div>
          </form>
        )}

        {/* Screen reader announcement */}
        <div
          ref={announcementRef}
          role="status"
          aria-live="polite"
          aria-atomic="true"
          className="sr-only"
        />
      </div>
    </div>
  );
}

```

## apps/web/src/lib/searchRelevance.ts
### Summary
Additional relevance heuristics wired into search/discovery ranking.
### Content
```ts
/**
 * Process: Search Relevance Enhancement
 * Purpose: Predictive search relevance scoring for autocomplete suggestions
 * Data Source: MediaItem candidates from TMDB API
 * Update Path: Adjust weights in scoreCandidate function
 * Dependencies: Library, providerCatalog
 */

import type { MediaItem } from '../components/cards/card.types';
import { Library } from './storage';

// Stopwords to ignore for token scoring
const STOPWORDS = new Set(['the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by']);

// LRU cache for normalizeTitle (max 500 entries)
class LRUCache<K, V> {
  private cache = new Map<K, V>();
  private maxSize: number;

  constructor(maxSize: number) {
    this.maxSize = maxSize;
  }

  get(key: K): V | undefined {
    if (!this.cache.has(key)) return undefined;
    const value = this.cache.get(key)!;
    // Move to end (most recently used)
    this.cache.delete(key);
    this.cache.set(key, value);
    return value;
  }

  set(key: K, value: V): void {
    if (this.cache.has(key)) {
      this.cache.delete(key);
    } else if (this.cache.size >= this.maxSize) {
      // Remove least recently used (first item)
      const firstKey = this.cache.keys().next().value;
      if (firstKey !== undefined) {
        this.cache.delete(firstKey);
      }
    }
    this.cache.set(key, value);
  }
}

const normalizeCache = new LRUCache<string, string>(500);
const collator = new Intl.Collator('en', { sensitivity: 'base', numeric: true });

/**
 * Normalize title: lowercase, trim, strip diacritics & punctuation, collapse whitespace
 */
export function normalizeTitle(str: string): string {
  const cached = normalizeCache.get(str);
  if (cached) return cached;

  const normalized = str
    .normalize('NFKD')
    .replace(/[\u0300-\u036f]/g, '') // Remove diacritics
    .toLowerCase()
    .trim()
    .replace(/[''"]/g, "'") // Normalize quotes
    .replace(/["""]/g, '"')
    .replace(/[^\w\s'-]/g, '') // Remove punctuation except hyphens/apostrophes
    .replace(/\s+/g, ' ') // Collapse whitespace
    .trim();

  normalizeCache.set(str, normalized);
  return normalized;
}

/**
 * Tokenize query, filtering out stopwords
 */
export function tokenize(query: string): string[] {
  const normalized = normalizeTitle(query);
  return normalized
    .split(/\s+/)
    .filter(token => token.length > 0 && !STOPWORDS.has(token));
}

/**
 * Check if item is in user's library lists
 */
function getListPenalty(item: MediaItem): number {
  const allItems = Library.getAll();
  const key = `${item.mediaType}:${item.id}`;
  const entry = allItems.find(e => `${e.mediaType}:${e.id}` === key);
  
  if (!entry) return 0;
  
  if (entry.list === 'watched') return -2.0;
  if (entry.list === 'watching') return -0.5;
  return 0;
}

/**
 * Check if item is available on user-enabled providers
 */
function getProviderBoost(item: MediaItem, enabledProvidersLower: Set<string>): number {
  if (enabledProvidersLower.size === 0) return 0;
  if (!item.networks || item.networks.length === 0) return 0;
  
  // Check if any of the item's networks match enabled providers
  const hasMatch = item.networks.some(network => {
    const networkLower = network.toLowerCase();
    return Array.from(enabledProvidersLower).some(provider => 
      networkLower.includes(provider)
    );
  });
  
  return hasMatch ? 1.0 : 0;
}

/**
 * Calculate Jaccard similarity between query tokens and title tokens
 */
function jaccardSimilarity(queryTokens: string[], titleTokens: string[]): number {
  if (queryTokens.length === 0 || titleTokens.length === 0) return 0;
  
  const querySet = new Set(queryTokens);
  const titleSet = new Set(titleTokens);
  
  let intersection = 0;
  for (const token of querySet) {
    if (titleSet.has(token)) intersection++;
  }
  
  const union = querySet.size + titleSet.size - intersection;
  return union === 0 ? 0 : intersection / union;
}

/**
 * Score a candidate item for autocomplete relevance
 */
export function scoreCandidate(
  query: string,
  candidate: MediaItem,
  enabledProviders: string[] = []
): number {
  const normalizedQuery = normalizeTitle(query);
  const normalizedTitle = normalizeTitle(candidate.title || '');
  const queryTokens = tokenize(query);
  // Cache tokenize result for performance
  const titleTokens = tokenize(candidate.title || '');
  // Pre-compute enabled providers set for performance
  const enabledProvidersLower = new Set(enabledProviders.map(p => p.toLowerCase()));
  
  let score = 0;
  
  // Check if query is a single word (like "bat") vs multi-word (like "bat man")
  const isSingleWordQuery = queryTokens.length === 1 && normalizedQuery.length <= 10;
  
  // w_exact: exact normalized title match
  // Ensure exact match >= 6.0, never let substring > exact
  if (normalizedTitle === normalizedQuery) {
    score += 6.0; // Always at least 6.0 for exact matches
  }
  
  // w_prefix: title startsWith first token (+3.0)
  if (queryTokens.length > 0) {
    const firstToken = queryTokens[0];
    if (normalizedTitle.startsWith(firstToken) || titleTokens.some(t => t.startsWith(firstToken))) {
      score += 3.0;
    }
  }
  
  // w_substring: title contains query as substring
  // This handles cases like "bat" matching "batman" or "super" matching "superman"
  // Ensure substring <= 5.9 so exact matches always win
  if (normalizedTitle.includes(normalizedQuery) && normalizedTitle !== normalizedQuery) {
    // Extra boost if the substring match is at the start of a word (e.g., "bat" in "batman")
    const startsWord = normalizedTitle.startsWith(normalizedQuery) || 
                       normalizedTitle.includes(` ${normalizedQuery}`) ||
                       titleTokens.some(t => t.startsWith(normalizedQuery));
    
    // For single-word queries, boost word-starting substring matches but keep below exact (6.0)
    if (isSingleWordQuery && startsWord) {
      score += 5.9; // High but still below exact match (6.0)
    } else if (startsWord) {
      score += 4.0;
    } else {
      score += 2.5;
    }
  }
  
  // w_token_intersection: Jaccard of query tokens vs title tokens (+2.0 * J)
  const jaccard = jaccardSimilarity(queryTokens, titleTokens);
  score += 2.0 * jaccard;
  
  // w_partial_token: any title token contains query token as substring (+1.5)
  // Handles cases where query token is embedded in a longer title token
  if (queryTokens.length > 0) {
    const firstToken = queryTokens[0];
    if (titleTokens.some(t => t.includes(firstToken) && t !== firstToken)) {
      score += 1.5;
    }
  }
  
  // w_popularity: min-max of vote_count or popularity (+0..+1.5)
  const voteCount = (candidate as any).vote_count || 0;
  const popularity = (candidate as any).popularity || 0;
  // Normalize to 0-1 range (assuming max vote_count ~50000, max popularity ~2000)
  const voteNorm = Math.min(voteCount / 50000, 1);
  const popNorm = Math.min(popularity / 2000, 1);
  const popularityScore = Math.max(voteNorm, popNorm) * 1.5;
  score += popularityScore;
  
  // w_recency: year decay exp(-(nowYear - year)/12) * 1.0
  if (candidate.year) {
    const nowYear = new Date().getFullYear();
    const year = parseInt(candidate.year);
    if (!isNaN(year)) {
      const age = nowYear - year;
      const recencyScore = Math.exp(-age / 12) * 1.0;
      score += recencyScore;
    }
  }
  
  // w_providerBoost: +1.0 if available on any user-enabled provider
  score += getProviderBoost(candidate, enabledProvidersLower);
  
  // w_listPenalty: -2.0 if in "Watched", -0.5 if in "Watching"
  score += getListPenalty(candidate);
  
  return score;
}

/**
 * Rank candidates by score with tie-breaking
 */
export function rankCandidates(
  query: string,
  candidates: MediaItem[],
  enabledProviders: string[] = [],
  maxResults: number = 10
): MediaItem[] {
  // Score all candidates
  const scored = candidates.map(candidate => ({
    item: candidate,
    score: scoreCandidate(query, candidate, enabledProviders)
  }));
  
  // Sort by score (descending), then tie-break
  scored.sort((a, b) => {
    const scoreDiff = b.score - a.score;
    if (Math.abs(scoreDiff) > 0.001) return scoreDiff;
    
    // Tie-breakers: (a) higher popularity, (b) newer year, (c) lexicographic title asc
    const aPop = (a.item as any).popularity || (a.item as any).vote_count || 0;
    const bPop = (b.item as any).popularity || (b.item as any).vote_count || 0;
    if (Math.abs(aPop - bPop) > 0.001) return bPop - aPop;
    
    const aYear = a.item.year ? parseInt(a.item.year) : 0;
    const bYear = b.item.year ? parseInt(b.item.year) : 0;
    if (aYear !== bYear) return bYear - aYear;
    
    return collator.compare(a.item.title || '', b.item.title || '');
  });
  
  // Deduplicate by (id, mediaType) - keep highest score
  const seen = new Map<string, typeof scored[0]>();
  for (const entry of scored) {
    const key = `${entry.item.mediaType}:${entry.item.id}`;
    const existing = seen.get(key);
    if (!existing || entry.score > existing.score) {
      seen.set(key, entry);
    }
  }
  
  const deduped = Array.from(seen.values());
  
  // Ensure at least one exact/prefix/substring match in top-3 if present
  const exactOrPrefix = deduped.filter((entry, idx) => {
    if (idx >= 3) return false;
    const normalizedQuery = normalizeTitle(query);
    const normalizedTitle = normalizeTitle(entry.item.title || '');
    const queryTokens = tokenize(query);
    const firstToken = queryTokens.length > 0 ? queryTokens[0] : '';
    
    // Check for exact match, prefix match, or word-starting substring match
    return normalizedTitle === normalizedQuery || 
           (firstToken && normalizedTitle.startsWith(firstToken)) ||
           (normalizedTitle.includes(normalizedQuery) && 
            (normalizedTitle.startsWith(normalizedQuery) || 
             normalizedTitle.includes(` ${normalizedQuery}`) ||
             tokenize(entry.item.title || '').some(t => t.startsWith(normalizedQuery))));
  });
  
  // If exact/prefix/substring exists but not in top-3, promote highest one
  if (exactOrPrefix.length > 0 && deduped.indexOf(exactOrPrefix[0]) >= 3) {
    const toPromote = exactOrPrefix[0];
    const index = deduped.indexOf(toPromote);
    deduped.splice(index, 1);
    deduped.splice(2, 0, toPromote); // Insert at position 2 (0-indexed, so 3rd position)
  }
  
  return deduped.slice(0, maxResults).map(entry => entry.item);
}



```

## apps/web/src/lib/words/commonWords.ts
### Summary
Stopword list that supports better scoring in the ranking pipeline.
### Content
```ts
/**
 * Common 5-letter words that most English speakers will know
 * Curated list focusing on familiar, everyday vocabulary
 * Used for both daily word selection and guess validation
 */

// Common words list - lowercase for consistency
export const COMMON_WORDS = new Set([
  // High frequency everyday words
  "about", "above", "abuse", "actor", "acute", "admit", "adopt", "adult", "after", "again",
  "agent", "agree", "ahead", "alarm", "album", "alert", "alien", "align", "alike", "alive",
  "allow", "alone", "along", "alter", "among", "anger", "angle", "angry", "apart", "apple",
  "apply", "arena", "argue", "arise", "array", "aside", "asset", "avoid", "awake", "aware",
  "award", "badly", "basic", "beach", "began", "begin", "being", "below", "bench", "birth",
  "black", "blame", "blank", "blind", "block", "blood", "board", "boost", "booth", "bound",
  "brain", "brand", "brave", "bread", "break", "breed", "brief", "bring", "broad", "broke",
  "brown", "build", "built", "buyer", "cable", "calif", "carry", "catch", "cause", "chain",
  "chair", "chaos", "charm", "chart", "chase", "cheap", "check", "chest", "chief", "child",
  "china", "chose", "civil", "claim", "class", "clean", "clear", "click", "climb", "clock",
  "close", "cloud", "coach", "coast", "could", "count", "court", "cover", "craft", "crash",
  "crazy", "cream", "crime", "cross", "crowd", "crown", "crude", "curve", "cycle", "daily",
  "dance", "dated", "dealt", "death", "debut", "delay", "depth", "doing", "doubt", "dozen",
  "draft", "drama", "drank", "dream", "dress", "drill", "drink", "drive", "drove", "dying",
  "eager", "early", "earth", "eight", "elite", "empty", "enemy", "enjoy", "enter", "entry",
  "equal", "error", "event", "every", "exact", "exist", "extra", "faith", "false", "fault",
  "fiber", "field", "fifth", "fifty", "fight", "final", "first", "fixed", "flash", "fleet",
  "floor", "fluid", "focus", "force", "forth", "forty", "forum", "found", "frame", "frank",
  "fraud", "fresh", "front", "fruit", "fully", "funny", "giant", "given", "glass", "globe",
  "going", "grace", "grade", "grand", "grant", "grass", "grave", "great", "green", "gross",
  "group", "grown", "guard", "guess", "guest", "guide", "happy", "harry", "heart", "heavy",
  "hello", "hence", "holly", "hopes", "horse", "hotel", "house", "human", "ideal", "image", "index", "inner", "input",
  "issue", "japan", "jimmy", "joint", "jones", "judge", "known", "label", "large", "laser",
  "later", "laugh", "layer", "learn", "lease", "least", "leave", "legal", "level", "lewis",
  "light", "limit", "links", "lives", "local", "logic", "loose", "lower", "lucky", "lunch",
  "lying", "magic", "major", "maker", "march", "maria", "match", "maybe", "mayor", "meant",
  "media", "metal", "might", "minor", "minus", "mixed", "model", "money", "month", "moral",
  "motor", "mount", "mouse", "mouth", "moved", "movie", "music", "needs", "never", "newly",
  "night", "noise", "north", "noted", "novel", "nurse", "occur", "ocean", "offer", "often",
  "order", "other", "ought", "paint", "panel", "paper", "party", "peace", "penny", "peter",
  "phase", "phone", "photo", "piece", "pilot", "pitch", "place", "plain", "plane", "plant",
  "plate", "point", "pound", "power", "press", "price", "pride", "prime", "print", "prior",
  "prize", "proof", "proud", "prove", "queen", "quick", "quiet", "quite", "radio", "raise",
  "range", "rapid", "ratio", "reach", "ready", "realm", "rebel", "refer", "relax", "reply",
  "right", "rigid", "rival", "river", "robin", "roger", "roman", "rough", "round", "route",
  "royal", "rural", "scale", "scene", "scope", "score", "sense", "serve", "seven", "shall",
  "shape", "share", "sharp", "sheet", "shelf", "shell", "shift", "shine", "shirt", "shock",
  "shoot", "short", "shown", "sides", "sight", "silly", "since", "sixth", "sixty", "sized",
  "skill", "sleep", "slide", "small", "smart", "smile", "smith", "smoke", "snake", "solid",
  "solve", "sorry", "sound", "south", "space", "spare", "speak", "speed", "spend", "spent",
  "split", "spoke", "sport", "staff", "stage", "stake", "stand", "start", "state", "steam",
  "steel", "stick", "still", "stock", "stone", "stood", "store", "storm", "story", "strip",
  "stuck", "study", "stuff", "style", "sugar", "suite", "super", "sweet", "table", "taken",
  "taste", "taxes", "teach", "teeth", "thank", "theft", "their", "theme", "there", "these",
  "thick", "thing", "think", "third", "those", "three", "threw", "throw", "thumb", "tight",
  "times", "tired", "title", "today", "topic", "total", "touch", "tough", "tower", "track",
  "trade", "train", "treat", "trend", "trial", "tribe", "trick", "tried", "tries", "truck",
  "truly", "trust", "truth", "twice", "uncle", "under", "union", "unity", "until", "upper",
  "upset", "urban", "usage", "usual", "valid", "value", "video", "virus", "visit", "vital",
  "voice", "waste", "watch", "water", "wheel", "where", "which", "while", "white", "whole",
  "whose", "woman", "women", "world", "worry", "worse", "worst", "worth", "would", "wound",
  "write", "wrong", "wrote", "young", "youth"
]);

/**
 * Check if a word is in the common words list
 */
export function isCommonWord(word: string): boolean {
  return COMMON_WORDS.has(word.toLowerCase());
}

/**
 * Get array of common words (for indexing)
 */
export function getCommonWordsArray(): string[] {
  return Array.from(COMMON_WORDS);
}


```

## apps/web/src/components/admin/ExportCSV.tsx
### Summary
Admin export UI that dumps discovery/rating data for diagnostics.
### Content
```tsx
/**
 * Process: CSV Export
 * Purpose: Client-side CSV export for posts and comments
 * Data Source: Firestore posts and comments collections
 * Update Path: N/A - read-only export
 * Dependencies: firebaseBootstrap (db)
 */

import { useState } from 'react';
import { collection, query, limit, getDocs } from 'firebase/firestore';
import { db } from '../../lib/firebaseBootstrap';

export default function ExportCSV() {
  const [exporting, setExporting] = useState<'posts' | 'comments' | null>(null);

  const convertToCSV = (data: any[], columns: string[]): string => {
    const headers = columns.join(',');
    const rows = data.map((item) => {
      return columns.map((col) => {
        const value = item[col];
        if (value === null || value === undefined) return '';
        if (Array.isArray(value)) return JSON.stringify(value);
        if (typeof value === 'object') return JSON.stringify(value);
        return String(value).replace(/"/g, '""'); // Escape quotes
      }).map((val) => `"${val}"`).join(',');
    });
    return [headers, ...rows].join('\n');
  };

  const downloadCSV = (csv: string, filename: string) => {
    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    const url = URL.createObjectURL(blob);
    link.setAttribute('href', url);
    link.setAttribute('download', filename);
    link.style.visibility = 'hidden';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  };

  const handleExportPosts = async () => {
    setExporting('posts');
    try {
      const postsRef = collection(db, 'posts');
      const postsQuery = query(postsRef, limit(100));
      const snapshot = await getDocs(postsQuery);

      const posts = snapshot.docs.map((doc) => {
        const data = doc.data();
        return {
          id: doc.id,
          title: data.title || '',
          authorId: data.authorId || '',
          tagSlugs: JSON.stringify(data.tagSlugs || []),
          createdAt: data.publishedAt?.toDate ? data.publishedAt.toDate().toISOString() : data.publishedAt || '',
          voteScore: data.score || 0,
        };
      });

      const csv = convertToCSV(posts, ['id', 'title', 'authorId', 'tagSlugs', 'createdAt', 'voteScore']);
      downloadCSV(csv, `posts_export_${new Date().toISOString().split('T')[0]}.csv`);
    } catch (error) {
      console.error('Error exporting posts:', error);
      alert('Failed to export posts. Please try again.');
    } finally {
      setExporting(null);
    }
  };

  const handleExportComments = async () => {
    setExporting('comments');
    try {
      // Get all posts first to iterate through comments
      const postsRef = collection(db, 'posts');
      const postsQuery = query(postsRef, limit(100));
      const postsSnapshot = await getDocs(postsQuery);

      const allComments: any[] = [];

      for (const postDoc of postsSnapshot.docs) {
        const postId = postDoc.id;
        const commentsRef = collection(db, 'posts', postId, 'comments');
        const commentsQuery = query(commentsRef, limit(100));
        const commentsSnapshot = await getDocs(commentsQuery);

        commentsSnapshot.docs.forEach((commentDoc) => {
          const data = commentDoc.data();
          allComments.push({
            id: commentDoc.id,
            postId: postId,
            authorId: data.authorId || '',
            content: data.body || '',
            createdAt: data.createdAt?.toDate ? data.createdAt.toDate().toISOString() : data.createdAt || '',
          });
        });
      }

      const csv = convertToCSV(allComments, ['id', 'postId', 'authorId', 'content', 'createdAt']);
      downloadCSV(csv, `comments_export_${new Date().toISOString().split('T')[0]}.csv`);
    } catch (error) {
      console.error('Error exporting comments:', error);
      alert('Failed to export comments. Please try again.');
    } finally {
      setExporting(null);
    }
  };

  return (
    <div className="border rounded-lg p-6" style={{ borderColor: 'var(--line)', backgroundColor: 'var(--card)' }}>
      <h2 className="text-xl font-semibold mb-4">Export Data</h2>
      <div className="flex space-x-4">
        <button
          onClick={handleExportPosts}
          disabled={exporting !== null}
          className="px-4 py-2 rounded border disabled:opacity-50 disabled:cursor-not-allowed hover:opacity-80"
          style={{ borderColor: 'var(--line)', backgroundColor: 'var(--btn)' }}
        >
          {exporting === 'posts' ? 'Exporting...' : 'Export Posts as CSV'}
        </button>
        <button
          onClick={handleExportComments}
          disabled={exporting !== null}
          className="px-4 py-2 rounded border disabled:opacity-50 disabled:cursor-not-allowed hover:opacity-80"
          style={{ borderColor: 'var(--line)', backgroundColor: 'var(--btn)' }}
        >
          {exporting === 'comments' ? 'Exporting...' : 'Export Comments as CSV'}
        </button>
      </div>
    </div>
  );
}


```

---
Processed 56 files, missing 0
