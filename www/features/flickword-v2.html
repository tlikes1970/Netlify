<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>FlickWord</title>

  <style>
    :root {
      --fw-bg: #f6f8ff;
      --fw-card: #ffffff;
      --fw-accent: #5a88ff;
      --fw-accent-2: #3b6cff;
      --fw-text: #1f2937;
      --fw-muted: #6b7280;
      --fw-border: #d7e3ff;
      --fw-good: #20b265;
      --fw-mid: #f7c23c;
      
      /* Responsive sizing tokens */
      --tile: clamp(36px, 6vw, 56px);
      --gap: clamp(4px, 0.8vw, 8px);
      --key: clamp(28px, 6vw, 44px);
    }

    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      color: var(--fw-text);
      background:
        radial-gradient(60% 50% at 70% 0%, rgba(90,136,255,0.10), rgba(90,136,255,0)) no-repeat,
        var(--fw-bg);
    }

    /* Centered card with reasonable cap so it never overwhelms the modal */
    #gameWrapper {
      width: 100%;
      max-width: 100%;
      margin: 0 auto;
      padding: 16px;
      background: var(--fw-card);
      border: 1px solid var(--fw-border);
      border-radius: 12px;
      box-shadow: 0 4px 16px rgba(0,0,0,.08);
      box-sizing: border-box;
      min-height: 100vh;
    }

    /* 5x6 grid */
    #grid {
      display: grid;
      grid-template-columns: repeat(5, var(--tile));
      gap: var(--gap);
      justify-items: center;
      width: 100%;
      max-width: calc(5 * var(--tile) + 4 * var(--gap));
      margin: 0 auto 24px;
    }
    .tile {
      width: var(--tile);
      height: var(--tile);
      aspect-ratio: 1 / 1;
      border-radius: 10px;
      border: 2px solid #a7b7e9;
      background: linear-gradient(180deg, #fff, #f7f9ff);
      box-shadow: inset 0 -1px 0 rgba(0,0,0,.05);
      display: grid;
      place-items: center;
      font-weight: 800;
      font-size: clamp(12px, 2.5vw, 24px);
    }

    .tile.correct { background: linear-gradient(180deg,#3ddc84,#20b265); color:#052b18; border-color:#20b265; }
    .tile.present { background: linear-gradient(180deg,#ffda6b,#f7c23c); color:#3c2a00; border-color:#f7c23c; }
    .tile.absent  { background: linear-gradient(180deg,#e9edf7,#d7ddea); color:#6b7280; }

    /* Keyboard: matches wrapper; ensures side keys never clip */
    #keyboard {
      width: 100%;
      max-width: calc(10 * var(--key) + 9 * var(--gap));
      margin: 16px auto 0;
    }
    .kb-row {
      display:flex;
      gap: var(--gap);
      justify-content:center;
      margin: 8px 0;
      flex-wrap: wrap; /* extra safety in narrow cases */
    }
    .key {
      padding: 8px 12px;
      border-radius: 8px;
      border: 2px solid var(--fw-border);
      background: #fff;
      box-shadow: 0 2px 4px rgba(0,0,0,.1);
      font-weight: 700;
      font-size: clamp(12px, 2.5vw, 16px);
      cursor: pointer;
      transition: all .15s ease;
      min-width: var(--key);
      height: calc(var(--key) + 8px);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      user-select: none;
      touch-action: manipulation;
    }
    .key:hover { 
      background: #f8f9fa; 
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(0,0,0,.15);
    }
    .key:active { 
      transform: translateY(1px); 
      box-shadow: 0 1px 2px rgba(0,0,0,.1);
    }
    .key.enter, .key.back, .key.special {
      background: linear-gradient(135deg, var(--fw-accent), var(--fw-accent-2));
      border-color: transparent;
      color: #fff;
    }
    
    /* Keyboard key colors */
    .key.correct {
      background-color: var(--fw-good, #20b265) !important;
      color: white !important;
    }
    .key.present {
      background-color: var(--fw-mid, #f7c23c) !important;
      color: white !important;
    }
    .key.absent {
      background-color: var(--fw-muted, #6b7280) !important;
      color: white !important;
    }

    .btn-exit {
      margin-top: 20px;
      padding: 10px 16px;
      border-radius: 10px;
      border: 1px solid var(--fw-border);
      background: #fff;
      font-weight: 700;
      cursor: pointer;
    }
    .btn-exit:hover { filter: brightness(1.03); }

    /* Custom notification styles */
    .custom-notification {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      padding: 12px 24px;
      border-radius: 8px;
      font-weight: 600;
      font-size: 14px;
      z-index: 1000;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      animation: slideDown 0.3s ease-out;
    }
    .custom-notification.success {
      background: linear-gradient(135deg, #20b265, #16a34a);
      color: white;
    }
    .custom-notification.error {
      background: linear-gradient(135deg, #ef4444, #dc2626);
      color: white;
    }
    .custom-notification.info {
      background: linear-gradient(135deg, #3b82f6, #2563eb);
      color: white;
    }
    @keyframes slideDown {
      from { opacity: 0; transform: translateX(-50%) translateY(-20px); }
      to { opacity: 1; transform: translateX(-50%) translateY(0); }
    }

    /* Small screens inside the iframe */
    @media (max-width: 560px){
      :root {
        --tile: clamp(32px, 8vw, 44px);
        --gap: clamp(3px, 1vw, 6px);
        --key: clamp(24px, 8vw, 36px);
      }
      #gameWrapper { padding: 12px; border-radius: 12px; }
      #grid { gap: var(--gap); width: min(360px, 100%); }
      .tile { font-size: clamp(10px, 2.5vw, 16px); }
      #keyboard { width: 100%; }
      .kb-row { gap: var(--gap); }
      .key { min-width: var(--key); height: calc(var(--key) + 6px); padding: 6px 10px; font-size: clamp(10px, 2.5vw, 14px); }
    }
  </style>
</head>
<body>
  <div id="gameWrapper">
    <div id="grid" aria-label="FlickWord board" role="group"></div>
    <div id="keyboard" aria-label="Keyboard" role="group"></div>
    <div style="text-align:center;margin-top:20px;">
      <button class="btn-exit" type="button" onclick="closeGame()">Exit</button>
    </div>
  </div>

  <script>
    /* ===== Config ===== */
    const WORDS = ["bliss","crane","flick","gravy","masks","toast","crown","spine","tiger","pride"];
    const ROWS  = ["QWERTYUIOP","ASDFGHJKL","ZXCVBNM"];

    /* ===== State ===== */
    let game = { target:null, guesses:[], current:"", max:6, done:false, status:{}, lastResults:[] };

    function getDateFromURL(){ return new URLSearchParams(location.search).get('date'); }

    async function getTodayWord(){
      const dateParam = getDateFromURL();
      const targetDate = dateParam ? new Date(dateParam + 'T00:00:00') : new Date();
      const dateStr = targetDate.toISOString().slice(0,10);

      const cached = localStorage.getItem(`flickword:word:${dateStr}`);
      if (cached) return cached.toUpperCase();

      try{
        const r = await fetch('https://api.datamuse.com/words?sp=?????&max=1');
        const d = await r.json();
        if (Array.isArray(d) && d[0]?.word && /^[a-z]{5}$/.test(d[0].word)) {
          localStorage.setItem(`flickword:word:${dateStr}`, d[0].word);
          return d[0].word.toUpperCase();
        }
      } catch {}

      const start = new Date("2023-01-01T00:00:00");
      const days = Math.floor((targetDate - start) / 86400000);
      const fallback = WORDS[days % WORDS.length];
      localStorage.setItem(`flickword:word:${dateStr}`, fallback);
      return fallback.toUpperCase();
    }

    function reportResult(won, guesses){
      console.log('ðŸŽ¯ reportResult called:', { won, guesses, target: game.target });
      try{
        const now = new Date();
        const today = now.getFullYear()+'-'+String(now.getMonth()+1).padStart(2,'0')+'-'+String(now.getDate()).padStart(2,'0');
        const message = { type:'flickword:result', date:today, won, guesses, target: game.target };
        console.log('ðŸŽ¯ Sending result message to parent:', message);
        if (window.parent && window.parent !== window) window.parent.postMessage(message, '*');
        const results = JSON.parse(localStorage.getItem('flickword:results') || '{}');
        results[today] = message;
        localStorage.setItem('flickword:results', JSON.stringify(results));
      }catch(e){
        console.error('ðŸŽ¯ Error in reportResult:', e);
      }
    }

    async function showGame(){
      console.log('ðŸŽ¯ Initializing FlickWord game...');
      game.target = await getTodayWord();
      console.log('ðŸŽ¯ Target word:', game.target);
      game.guesses = [];
      game.current = "";
      game.done = false;
      game.status = {};
      game.lastResults = [];
      renderGrid(); 
      renderKeyboard();
      console.log('ðŸŽ¯ Game initialized successfully');
      
      // Debug: Check if elements exist
      const grid = document.getElementById('grid');
      const keyboard = document.getElementById('keyboard');
      console.log('ðŸŽ¯ Grid element:', grid);
      console.log('ðŸŽ¯ Keyboard element:', keyboard);
      console.log('ðŸŽ¯ Grid children:', grid?.children.length);
      console.log('ðŸŽ¯ Keyboard children:', keyboard?.children.length);
    }

    function closeGame(){
      console.log('ðŸŽ¯ closeGame() called');
      if (window.parent && window.parent !== window) {
        console.log('ðŸŽ¯ Sending close message to parent');
        window.parent.postMessage({ type:'flickword:close' }, '*');
      } else {
        console.log('ðŸŽ¯ No parent window, trying to close');
        try {
          window.close();
        } catch (e) {
          console.warn('Cannot close popup due to Cross-Origin-Opener-Policy:', e.message);
        }
      }
    }

    function renderGrid(){
      console.log('ðŸŽ¯ Rendering grid...');
      const grid = document.getElementById('grid'); 
      if (!grid) {
        console.error('ðŸŽ¯ Grid element not found!');
        return;
      }
      grid.innerHTML='';
      for (let i=0;i<game.max;i++){
        const guess = game.guesses[i] || (i===game.guesses.length ? game.current : "");
        for (let j=0;j<5;j++){
          const tile = document.createElement('div');
          tile.className = 'tile';
          const letter = guess[j]||'';
          tile.textContent = letter;
          if (i < game.guesses.length){
            const res = game.lastResults[i][j];
            tile.classList.add(res);
          }
          grid.appendChild(tile);
        }
      }
      console.log('ðŸŽ¯ Grid rendered with', grid.children.length, 'tiles');
    }

    function renderKeyboard(){
      console.log('ðŸŽ¯ Rendering keyboard...');
      const kb = document.getElementById('keyboard'); 
      if (!kb) {
        console.error('ðŸŽ¯ Keyboard element not found!');
        return;
      }
      kb.innerHTML = '';

      const r1 = document.createElement('div'); r1.className='kb-row';
      for (const L of ROWS[0]) r1.appendChild(makeKey(L));
      kb.appendChild(r1);

      const r2 = document.createElement('div'); r2.className='kb-row';
      for (const L of ROWS[1]) r2.appendChild(makeKey(L));
      kb.appendChild(r2);

      const r3 = document.createElement('div'); r3.className='kb-row';
      r3.appendChild(makeKey('âŒ«','backspace special', backspace));
      for (const L of ROWS[2]) r3.appendChild(makeKey(L));
      r3.appendChild(makeKey('Enter','enter special', submit));
      kb.appendChild(r3);
      
      console.log('ðŸŽ¯ Keyboard rendered with', kb.querySelectorAll('.key').length, 'buttons');
      console.log('ðŸŽ¯ Keyboard HTML:', kb.innerHTML.substring(0, 200) + '...');
    }

    function makeKey(label, extra='', handler){
      const btn = document.createElement('button');
      btn.type='button';
      btn.textContent = label;
      btn.className = ('key '+extra).trim();

      // Add debugging and event handling
      btn.addEventListener('click', (e) => {
        console.log('ðŸŽ¯ Button clicked:', label, 'Event:', e);
        e.preventDefault();
        e.stopPropagation();
        
        if (label === 'âŒ«') {
          backspace();
        } else if (label === 'Enter') {
          submit();
        } else if (label.length === 1) {
          onKey(label);
        } else if (handler) {
          handler();
        }
      });

      // Set up data attribute for letter keys
      if (label.length === 1) {
        btn.setAttribute('data-letter', label);
      }

      return btn;
    }

    function updateKeyboardColors(){
      console.log('ðŸŽ¯ Updating keyboard colors...');
      const keys = document.querySelectorAll('.key[data-letter]');
      keys.forEach(key => {
        const letter = key.getAttribute('data-letter');
        const status = game.status[letter];
        
        // Remove all status classes from keyboard keys only
        key.classList.remove('correct', 'present', 'absent');
        
        // Add the appropriate status class to keyboard keys
        if (status === 'correct') {
          key.classList.add('correct');
          console.log(`ðŸŽ¯ Keyboard key ${letter} set to correct (green)`);
        } else if (status === 'present') {
          key.classList.add('present');
          console.log(`ðŸŽ¯ Keyboard key ${letter} set to present (yellow)`);
        } else if (status === 'absent') {
          key.classList.add('absent');
          console.log(`ðŸŽ¯ Keyboard key ${letter} set to absent (grey)`);
        }
      });
    }

    function onKey(l){
      console.log('ðŸŽ¯ Key pressed:', l);
      if (l === 'âŒ«' || l === 'Backspace') return;
      if (game.done || game.current.length>=5) return;
      game.current += l;
      renderGrid();
    }

    function backspace(){
      console.log('ðŸŽ¯ Backspace pressed');
      if (game.done || !game.current) return;
      game.current = game.current.slice(0, -1);
      renderGrid();
    }

    async function submit(){
      console.log('ðŸŽ¯ Submit pressed, current word:', game.current);
      if (game.done || game.current.length!==5) return;

      const valid = await isValidWord(game.current);
      if (!valid){
        showCustomNotification("Not a valid word. Try again!", "error");
        game.current = '';
        renderGrid();
        return;
      }

      const res = scoreGuess(game.current, game.target);
      game.lastResults.push(res);

      for (let i=0;i<5;i++){
        const L = game.current[i];
        if (res[i]==='correct') game.status[L]='correct';
        else if (res[i]==='present' && game.status[L]!=='correct') game.status[L]='present';
        else if (res[i]==='absent' && !game.status[L]) game.status[L]='absent';
      }

      game.guesses.push(game.current);
      
      // Update keyboard colors after each guess
      updateKeyboardColors();

      if (game.current === game.target){
        showCustomNotification("ðŸŽ‰ Nice! You got it!", "success");
        game.done = true;
        reportResult(true, game.guesses.length);
        setTimeout(closeGame, 2000);
      } else if (game.guesses.length === game.max){
        showCustomNotification(`Out of tries. The word was: ${game.target}`, "error");
        game.done = true;
        reportResult(false, game.guesses.length);
        setTimeout(closeGame, 2500);
      }

      game.current = '';
      renderGrid();
    }

    async function isValidWord(w){
      try{
        const r = await fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${w.toLowerCase()}`);
        return r.ok;
      } catch { return false; }
    }

    function scoreGuess(guess, target){
      const res = Array(5).fill('absent');
      const pool = target.split('');
      for (let i=0;i<5;i++){ if (guess[i]===pool[i]){ res[i]='correct'; pool[i]=null; } }
      for (let i=0;i<5;i++){
        if (res[i]==='correct') continue;
        const idx = pool.indexOf(guess[i]);
        if (idx!==-1){ res[i]='present'; pool[idx]=null; }
      }
      return res;
    }

    function showCustomNotification(message, type='info'){
      const existing = document.querySelector('.custom-notification');
      if (existing) existing.remove();
      const n = document.createElement('div');
      n.className = `custom-notification ${type}`;
      n.textContent = message;
      document.body.appendChild(n);
      setTimeout(()=> n.remove(), 2500);
    }

    document.addEventListener('keydown', (e)=>{
      if (game.done) return;
      if (e.key === 'Backspace'){ e.preventDefault(); backspace(); return; }
      if (e.key === 'Enter'){ e.preventDefault(); submit(); return; }
      if (e.key.length===1 && /[a-z]/i.test(e.key)) onKey(e.key.toUpperCase());
    });

    showGame();
  </script>
</body>
</html>
