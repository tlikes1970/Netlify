<div id="watchedList" class="list-container">
          <div class="empty-state sassy-empty">Nothing completed yet? Commitment issues much? üòè</div>
        </div>
      </div>
    </div>
  </div>

  <div class="easter-egg" id="easterEgg">üé≠</div>
  <div class="feedback-button" id="feedbackBtn">üí¨</div>

  <script>
    // Core Application Logic
    const TMDB_IMG_BASE = 'https://image.tmdb.org/t/p/w200';
    const API_BASE = '/.netlify/functions/tmdb';
    
    let currentPage = 1, searchCache = [], currentActiveTab = 'home';
    
    const appData = {
      tv: { watching: [], wishlist: [], watched: [] },
      movies: { watching: [], wishlist: [], watched: [] },
      settings: { theme: 'light', displayName: '' }
    };

    // Content filtering
    let showMoviesOnly = false;
    let showTVOnly = false;

    // Push Notifications Implementation
    function initPushNotifications() {
      if ('Capacitor' in window && window.Capacitor.Plugins) {
        const { PushNotifications } = window.Capacitor.Plugins;

        PushNotifications.requestPermissions().then(result => {
          if (result.receive === 'granted') {
            console.log('Push notification permission granted');
            PushNotifications.register();
          } else {
            console.log('Push notification permission denied');
          }
        });

        PushNotifications.addListener('registration', (token) => {
          console.log('Push registration success, token: ' + token.value);
        });

        PushNotifications.addListener('registrationError', (error) => {
          console.log('Error on registration: ' + JSON.stringify(error));
        });

        PushNotifications.addListener('pushNotificationReceived', (notification) => {
          console.log('Push received: ' + JSON.stringify(notification));
          showNotification('New notification: ' + notification.body, 'info');
        });

        PushNotifications.addListener('pushNotificationActionPerformed', (notification) => {
          console.log('Push action performed: ' + JSON.stringify(notification));
        });
      } else {
        console.log('Push notifications not available - running in browser');
      }
    }

    // Test notification function
    function testNotification() {
      if ('Notification' in window) {
        if (Notification.permission === 'granted') {
          new Notification('Showly', {
            body: 'Your favorite show has a new episode! üì∫‚ú®',
            icon: 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><rect width="100" height="100" fill="%23ff6b6b"/><text x="50" y="55" font-size="40" text-anchor="middle" fill="white">üì∫</text></svg>'
          });
        } else if (Notification.permission !== 'denied') {
          Notification.requestPermission().then(permission => {
            if (permission === 'granted') {
              testNotification();
            }
          });
        } else {
          showNotification('Notifications are blocked. Please enable them in your browser settings.', 'warning');
        }
      } else {
        showNotification('This browser does not support notifications.', 'warning');
      }
    }

    // Simple modal functions - NO closeModal references
    function showAboutModal() {
      const backdrop = document.createElement('div');
      backdrop.style.position = 'fixed';
      backdrop.style.top = '0';
      backdrop.style.left = '0';
      backdrop.style.width = '100%';
      backdrop.style.height = '100%';
      backdrop.style.backgroundColor = 'rgba(0,0,0,0.8)';
      backdrop.style.zIndex = '2000';
      backdrop.style.display = 'flex';
      backdrop.style.alignItems = 'center';
      backdrop.style.justifyContent = 'center';
      backdrop.style.padding = '20px';
      
      const modal = document.createElement('div');
      modal.style.backgroundColor = 'var(--bg)';
      modal.style.padding = '30px';
      modal.style.borderRadius = '20px';
      modal.style.maxWidth = '500px';
      modal.style.width = '100%';
      modal.style.color = 'var(--text)';
      modal.style.boxShadow = '0 20px 60px rgba(0,0,0,0.3)';
      modal.style.border = '2px solid var(--primary)';
      
      modal.innerHTML = '<h2 style="color: var(--primary); margin: 0 0 20px 0; font-size: 24px; text-align: center;">About Showly üì∫</h2><div style="line-height: 1.6; font-size: 14px;"><div style="margin-bottom: 20px;"><strong style="color: var(--primary);">Why Showly exists:</strong><br>Because tracking your TV shows and movies shouldn\'t be harder than actually watching them! Created for people who start 20 shows and finish... maybe 3.</div><div style="margin-bottom: 20px;"><strong style="color: var(--primary);">üíæ Your Data:</strong><br>Showly is browser-based, so your data stays on your device. If you use it on your phone, that data won\'t magically appear on your computer (and vice versa). Use the Export/Import feature to transfer your collection between devices!</div><div style="margin-bottom: 20px;"><strong style="color: var(--primary);">üöÄ Coming Soon:</strong><br>Native mobile app with cloud sync, so your questionable taste follows you everywhere!</div><div style="margin-bottom: 25px;"><strong style="color: var(--primary);">üêõ Found a bug or have feedback?</strong><br>We\'re constantly improving Showly based on user feedback. Your input helps make this the best TV/movie tracker out there!</div></div><div style="text-align: center;"><button style="background: linear-gradient(45deg, var(--primary), var(--purple)); color: white; border: none; padding: 12px 25px; border-radius: 25px; cursor: pointer; font-weight: bold; font-size: 14px;" onclick="this.closest(\'.backdrop\').remove()">Got it! üëç</button></div>';
      
      backdrop.className = 'backdrop';
      backdrop.appendChild(modal);
      document.body.appendChild(backdrop);
      
      backdrop.onclick = function(e) {
        if (e.target === backdrop) {
          backdrop.remove();
        }
      };
    }

    function showStatsModal() {
      const stats = getUsageStats();
      const totalShows = (appData.tv.watching.length + appData.tv.wishlist.length + appData.tv.watched.length + appData.movies.watching.length + appData.movies.wishlist.length + appData.movies.watched.length);
      
      const backdrop = document.createElement('div');
      backdrop.style.position = 'fixed';
      backdrop.style.top = '0';
      backdrop.style.left = '0';
      backdrop.style.width = '100%';
      backdrop.style.height = '100%';
      backdrop.style.backgroundColor = 'rgba(0,0,0,0.8)';
      backdrop.style.zIndex = '2000';
      backdrop.style.display = 'flex';
      backdrop.style.alignItems = 'center';
      backdrop.style.justifyContent = 'center';
      backdrop.style.padding = '20px';
      
      const modal = document.createElement('div');
      modal.style.backgroundColor = 'var(--bg)';
      modal.style.padding = '30px';
      modal.style.borderRadius = '20px';
      modal.style.maxWidth = '500px';
      modal.style.width = '100%';
      modal.style.color = 'var(--text)';
      modal.style.boxShadow = '0 20px 60px rgba(0,0,0,0.3)';
      modal.style.border = '2px solid var(--primary)';
      
      modal.innerHTML = '<h2 style="color: var(--primary); margin: 0 0 20px 0; font-size: 24px; text-align: center;">üìä Your Showly Stats</h2><div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 15px; margin: 20px 0;"><div style="text-align: center; padding: 15px; background: var(--card); border-radius: 10px; border: 1px solid var(--border);"><div style="font-size: 24px; font-weight: bold; color: var(--primary);">' + totalShows + '</div><div style="font-size: 12px; color: #666;">Total Shows</div></div><div style="text-align: center; padding: 15px; background: var(--card); border-radius: 10px; border: 1px solid var(--border);"><div style="font-size: 24px; font-weight: bold; color: var(--primary);">' + (stats.rating || 0) + '</div><div style="font-size: 12px; color: #666;">Ratings Given</div></div><div style="text-align: center; padding: 15px; background: var(--card); border-radius: 10px; border: 1px solid var(--border);"><div style="font-size: 24px; font-weight: bold; color: var(--primary);">' + (stats.share || 0) + '</div><div style="font-size: 12px; color: #666;">Shows Shared</div></div></div><h3 style="color: var(--primary); font-size: 16px; margin: 20px 0 10px 0;">Feature Usage:</h3><div style="background: var(--card); padding: 15px; border-radius: 10px; font-size: 14px; border: 1px solid var(--border);">No usage data yet. Start using features to see stats!</div><div style="text-align: center; margin-top: 25px;"><button style="background: linear-gradient(45deg, var(--primary), var(--purple)); color: white; border: none; padding: 12px 25px; border-radius: 25px; cursor: pointer; font-weight: bold; font-size: 14px;" onclick="this.closest(\'.backdrop\').remove()">Close</button></div>';
      
      backdrop.className = 'backdrop';
      backdrop.appendChild(modal);
      document.body.appendChild(backdrop);
      
      backdrop.onclick = function(e) {
        if (e.target === backdrop) {
          backdrop.remove();
        }
      };
    }

    // Sassy messages for different actions
    const homeMessages = [
      "Back to the beginning.",
      "Here we go again.", 
      "Didn't we just leave here?",
      "Home sweet home (but with more streaming debt).",
      "Welcome back to your digital shame spiral.",
      "Ready for more questionable life choices?",
      "The mothership awaits your return."
    ];

    const loadingMessages = [
      "Finding shows you'll probably abandon after 2 episodes...",
      "Searching the depths of entertainment mediocrity...",
      "Loading... (This is taking longer than your last relationship)",
      "Fetching content that'll judge your life choices...",
      "Retrieving shows you'll add but never watch...",
      "Consulting the algorithm gods...",
      "Preparing your next binge-watching obsession..."
    ];

    const sassyTitles = [
      "Chaos", "Digital Hoarding", "Commitment Issues", "Questionable Taste", 
      "Binge Empire", "Streaming Madness", "Watch List Anarchy", "Media Obsession",
      "Entertainment Addiction", "Viewing Disorder", "Screen Time Shame"
    ];

    function showNotification(message, type = 'success') {
      const notification = document.createElement('div');
      notification.className = `notification ${type}`;
      notification.textContent = message;
      document.body.appendChild(notification);
      
      setTimeout(() => {
        if (notification.parentNode) {
          notification.parentNode.removeChild(notification);
        }
      }, 3000);
    }

    function getRandomMessage(array) {
      return array[Math.floor(Math.random() * array.length)];
    }

    function createLoadingElement() {
      return `<div class="loading-container"><div class="loading-spinner"></div><div class="loading-text">${getRandomMessage(loadingMessages)}</div></div>`;
    }

    function loadAppData() {
      const saved = localStorage.getItem('tvMovieTrackerData');
      if (saved) {
        try {
          const parsedData = JSON.parse(saved);
          if (!parsedData.tv) parsedData.tv = { watching: [], wishlist: [], watched: [] };
          if (!parsedData.movies) parsedData.movies = { watching: [], wishlist: [], watched: [] };
          if (!parsedData.tv.watched) parsedData.tv.watched = [];
          if (!parsedData.movies.watched) parsedData.movies.watched = [];
          if (!parsedData.settings) parsedData.settings = { theme: 'light', displayName: '' };
          
          Object.assign(appData, parsedData);
        } catch (e) {
          console.error('Error loading data:', e);
          showNotification("Failed to load your data. Starting fresh! üî•", 'warning');
        }
      }
      
      if (appData.settings.theme === 'dark') {
        document.body.classList.add('dark-mode');
      }
      
      if (appData.settings.displayName) {
        document.getElementById('displayNameInput').value = appData.settings.displayName;
        updateWelcomeText();
        hideNameContainer();
      }
    }

    function updateWelcomeText() {
      const name = appData.settings.displayName;
      if (name) {
        const randomSass = getRandomMessage(sassyTitles);
        document.getElementById('welcomeText').textContent = `${name}'s ${randomSass}`;
      } else {
        document.getElementById('welcomeText').textContent = 'Showly';
      }
    }

    function hideNameContainer() {
      const container = document.getElementById('nameContainer');
      if (appData.settings.displayName && container) {
        container.classList.add('hidden');
      }
    }

    function updateDarkModeButton() {
      const isDark = document.body.classList.contains('dark-mode');
      document.getElementById('darkModeToggle').textContent = isDark ? '‚òÄÔ∏è Go Light' : 'üåô Go Dark';
    }

    function saveAppData() {
      localStorage.setItem('tvMovieTrackerData', JSON.stringify(appData));
    }

    function setupEventListeners() {
      document.getElementById('darkModeToggle').onclick = () => {
        document.body.classList.toggle('dark-mode');
        appData.settings.theme = document.body.classList.contains('dark-mode') ? 'dark' : 'light';
        updateDarkModeButton();
        saveAppData();
        
        const isDark = document.body.classList.contains('dark-mode');
        showNotification(isDark ? "Welcome to the dark side üòà" : "Returning to the light! ‚òÄÔ∏è", 'success');
      };
      
      document.getElementById('displayNameInput').oninput = (e) => {
        appData.settings.displayName = e.target.value;
        updateWelcomeText();
        saveAppData();
        
        if (e.target.value.trim()) {
          setTimeout(() => hideNameContainer(), 1000);
        }
      };
      
      document.getElementById('homeTab').onclick = () => switchToTab('home');
      document.getElementById('watchingTab').onclick = () => switchToTab('watching');
      document.getElementById('wishlistTab').onclick = () => switchToTab('wishlist');
      document.getElementById('watchedTab').onclick = () => switchToTab('watched');
      
      document.getElementById('searchBtn').onclick = performSearch;
      document.getElementById('searchInput').onkeydown = (e) => {
        if (e.key === 'Enter') performSearch();
      };
      
      document.getElementById('testNotification').onclick = testNotification;
      
      document.getElementById('clearSearchBtn').onclick = clearSearch;
      document.getElementById('searchInput').oninput = updateClearButton;
      document.getElementById('genreFilter').onchange = updateClearButton;
      
      document.getElementById('prevPageBtn').onclick = () => {
        if (currentPage > 1) {
          currentPage--;
          performSearch();
        }
      };
      
      document.getElementById('nextPageBtn').onclick = () => {
        currentPage++;
        performSearch();
      };
      
      document.getElementById('exportBtn').onclick = exportData;
      document.getElementById('importFile').onchange = importData;
      document.getElementById('clearAllBtn').onclick = () => {
        if (confirm('Are you SURE you want to delete everything? This nuclear option cannot be undone! üí•')) {
          appData.tv = { watching: [], wishlist: [], watched: [] };
          appData.movies = { watching: [], wishlist: [], watched: [] };
          saveAppData();
          updateUI();
          showNotification("Boom! Everything deleted. Hope you're happy! üíÄ", 'error');
        }
      };
      
      document.getElementById('aboutBtn').onclick = showAboutModal;
      document.getElementById('usageStatsBtn').onclick = showStatsModal;
      
      setupEasterEgg();
    }

    function updateClearButton() {
      const hasContent = document.getElementById('searchInput').value.trim() || 
                        document.getElementById('genreFilter').value;
      document.getElementById('clearSearchBtn').style.display = hasContent ? 'inline-block' : 'none';
    }

    function switchToTab(tab) {
      currentActiveTab = tab;
      
      document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
      document.getElementById(tab + 'Tab').classList.add('active');
      
      document.querySelectorAll('.tab-section').forEach(s => s.style.display = 'none');
      document.getElementById(tab + 'Section').style.display = 'block';
      
      if (tab !== 'home') {
        document.getElementById('searchResults').style.display = 'none';
      }
      
      const messages = {
        home: getRandomMessage(homeMessages),
        watching: 'Time to face your current commitments! üì∫',
        wishlist: 'Welcome to your digital hoarding paradise! üìö',
        watched: 'Behold your completed conquests! üèÜ'
      };
      
      showNotification(messages[tab], 'success');
    }

    async function performSearch() {
      const query = document.getElementById('searchInput').value.trim();
      const genre = document.getElementById('genreFilter').value;
      
      if (!query && !genre) {
        showNotification('Please enter a search term or select a genre, genius! ü§î', 'warning');
        return;
      }
      
      const container = document.getElementById('searchResultsList');
      container.innerHTML = createLoadingElement();
      document.getElementById('searchResults').style.display = 'block';
      
      try {
        let processedQuery = query;
        let isWildcardSearch = false;
        let wildcardType = 'none';
        
        if (query.includes('*')) {
          isWildcardSearch = true;
          
          if (query.startsWith('*') && query.endsWith('*')) {
            wildcardType = 'contains';
            processedQuery = query.slice(1, -1);
          } else if (query.startsWith('*')) {
            wildcardType = 'endsWith';
            processedQuery = query.slice(1);
          } else if (query.endsWith('*')) {
            wildcardType = 'startsWith';
            processedQuery = query.slice(0, -1);
          }
          
          if (processedQuery.length === 0) {
            showNotification('Wildcard search needs some text! Try "star*" or "*wars" ü§î', 'warning');
            return;
          }
          
          showNotification(`üîç Wildcard search: ${wildcardType} "${processedQuery}"`, 'info');
        }
        
        const searchTerm = isWildcardSearch ? processedQuery : query;
        const results = await fetchShowData(searchTerm, currentPage, genre);
        
        let filteredResults = results;
        if (isWildcardSearch && results.length > 0) {
          const searchPattern = processedQuery.toLowerCase();
          filteredResults = results.filter(item => {
            const title = (item.name || item.title || '').toLowerCase();
            
            switch(wildcardType) {
              case 'contains':
                return title.includes(searchPattern);
              case 'endsWith':
                return title.endsWith(searchPattern);
              case 'startsWith':
                return title.startsWith(searchPattern);
              default:
                return title.includes(searchPattern);
            }
          });
          
          if (filteredResults.length !== results.length) {
            showNotification(`Filtered to ${filteredResults.length} shows matching "${query}" üéØ`, 'success');
          }
        }
        
        searchCache = filteredResults;
        displaySearchResults(filteredResults);
        updatePagination();
        
        if (filteredResults.length === 0) {
          if (isWildcardSearch) {
            showNotification(`No shows found matching "${query}". Try a different pattern! üîç`, 'warning');
          } else {
            showNotification('No results found. Try lowering your standards! üìâ', 'warning');
          }
        } else if (!isWildcardSearch) {
          showNotification(`Found ${filteredResults.length} options for your viewing pleasure! üéØ`, 'success');
        }
      } catch (error) {
        container.innerHTML = `<div style="color: red; text-align: center; padding: 40px; font-weight: bold;">Search failed: ${error.message}<br><br>Maybe try turning it off and on again? ü§∑‚Äç‚ôÇÔ∏è</div>`;
        showNotification('Search failed. The internet is judging you! üåê', 'error');
      }
    }

    async function fetchShowData(query, page = 1, genreFilter = '') {
      const type = 'multi';
      let endpoint = `search/${type}`;
      let params = `endpoint=${endpoint}&page=${page}`;
      
      if (query) params += `&query=${encodeURIComponent(query)}`;
      if (genreFilter && !query) {
        endpoint = `discover/tv`;
        params = `endpoint=${endpoint}&page=${page}&genre=${genreFilter}`;
      }
      
      try {
        const response = await fetch(`${API_BASE}?${params}`);
        
        if (!response.ok) {
          throw new Error(`Search service unavailable (${response.status}). Please try again later.`);
        }
        
        const data = await response.json();
        
        const enhancedResults = await Promise.all(
          (data.results || []).map(async (item) => {
            try {
              if (item.media_type === 'tv' || item.first_air_date) {
                const detailResponse = await fetch(`${API_BASE}?endpoint=tv/${item.id}`);
                if (detailResponse.ok) {
                  const details = await detailResponse.json();
                  return {
                    ...item,
                    status: details.status,
                    number_of_seasons: details.number_of_seasons,
                    number_of_episodes: details.number_of_episodes,
                    last_air_date: details.last_air_date,
                    first_air_date: details.first_air_date,
                    next_episode_to_air: details.next_episode_to_air,
                    last_episode_to_air: details.last_episode_to_air,
                    in_production: details.in_production,
                    genres: details.genres,
                    networks: details.networks
                  };
                }
              } else if (item.media_type === 'movie' || item.release_date) {
                const detailResponse = await fetch(`${API_BASE}?endpoint=movie/${item.id}`);
                if (detailResponse.ok) {
                  const details = await detailResponse.json();
                  return {
                    ...item,
                    status: details.status,
                    release_date: details.release_date,
                    genres: details.genres
                  };
                }
              }
            } catch (e) {
              console.log('Failed to fetch details for:', item.name || item.title);
            }
            return item;
          })
        );
        
        return enhancedResults;
      } catch (error) {
        console.error('Fetch error:', error);
        throw new Error('Search temporarily unavailable. Our servers are probably binge-watching something! üì∫');
      }
    }

    async function loadGenres() {
      try {
        const response = await fetch(`${API_BASE}?endpoint=genre/tv/list`);
        
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const data = await response.json();
        const select = document.getElementById('genreFilter');
        select.innerHTML = '<option value="">All Genres</option>';
        
        if (data.genres && data.genres.length > 0) {
          data.genres.forEach(genre => {
            select.innerHTML += `<option value="${genre.id}">${genre.name}</option>`;
          });
        }
      } catch (error) {
        console.error('Error loading genres:', error);
        const select = document.getElementById('genreFilter');
        const fallbackGenres = [
          {id: 10759, name: 'Action & Adventure'}, {id: 16, name: 'Animation'}, 
          {id: 35, name: 'Comedy'}, {id: 80, name: 'Crime'}, 
          {id: 99, name: 'Documentary'}, {id: 18, name: 'Drama'}, 
          {id: 10765, name: 'Sci-Fi & Fantasy'}
        ];
        
        select.innerHTML = '<option value="">All Genres</option>';
        fallbackGenres.forEach(genre => {
          select.innerHTML += `<option value="${genre.id}">${genre.name}</option>`;
        });
      }
    }

    function displaySearchResults(results) {
      const container = document.getElementById('searchResultsList');
      document.getElementById('resultsCount').textContent = results.length;
      
      if (results.length === 0) {
        container.innerHTML = '<div class="empty-state sassy-empty">No results found. Maybe try something that actually exists? ü§®</div>';
        return;
      }
      
      container.innerHTML = '';
      results.forEach(item => {
        const card = createShowCard(item, true);
        container.appendChild(card);
      });
    }

    function createShowCard(item, isSearchResult = false) {
      const card = document.createElement('div');
      card.className = 'show-card';
      
      const title = item.name || item.title || 'Unknown Title';
      const date = item.first_air_date || item.release_date || '';
      const rating = item.vote_average ? item.vote_average.toFixed(1) : 'N/A';
      const overview = item.overview || 'No description available.';
      const mediaType = item.media_type || (item.first_air_date ? 'tv' : 'movie');
      
      const category = mediaType === 'tv' ? 'tv' : 'movies';
      const isInWatching = appData[category] && appData[category].watching && appData[category].watching.some(show => show.id === item.id);
      const isInWishlist = appData[category] && appData[category].wishlist && appData[category].wishlist.some(show => show.id === item.id);
      const isInWatched = appData[category] && appData[category].watched && appData[category].watched.some(show => show.id === item.id);
      
      const posterHtml = item.poster_path ? 
        `<img src="${TMDB_IMG_BASE}${item.poster_path}" alt="${title}" class="show-poster" onclick="openTMDBLink(${item.id}, '${mediaType}')">` : 
        `<div class="poster-placeholder" onclick="openTMDBLink(${item.id}, '${mediaType}')">No Image<br>Available üì∑</div>`;
      
      let actionsHtml = '';
      
      if (isSearchResult) {
        actionsHtml = `
          <div class="show-actions">
            <button onclick="addToList(${JSON.stringify(item).replace(/"/g, '&quot;')}, 'watching')" ${isInWatching ? 'disabled' : ''}>
              ${isInWatching ? '‚úì Currently Watching' : '‚ñ∂Ô∏è Currently Watching'}
            </button>
            <button onclick="addToList(${JSON.stringify(item).replace(/"/g, '&quot;')}, 'wishlist')" ${isInWishlist ? 'disabled' : ''}>
              ${isInWishlist ? '‚úì In Want to Watch' : 'üìñ Want to Watch'}
            </button>
            <button onclick="addToList(${JSON.stringify(item).replace(/"/g, '&quot;')}, 'watched')" ${isInWatched ? 'disabled' : ''}>
              ${isInWatched ? '‚úì Already Watched' : '‚úÖ Mark as Watched'}
            </button>
            <button onclick="shareShow(null, ${JSON.stringify(item).replace(/"/g, '&quot;')})" class="secondary">üì§ Share</button>
            <button onclick="openTMDBLink(${item.id}, '${mediaType}')" class="secondary">üîó TMDB Info</button>
          </div>
        `;
      } else {
        const userRating = item.userRating || 0;
        const notes = item.notes || '';
        const tags = item.tags || [];
        const likeStatus = item.likeStatus || 'none';
        const currentSeason = item.currentSeason || '';
        const currentEpisode = item.currentEpisode || '';
        
        actionsHtml = `
          <div class="rating-container">
            <span>Your Rating:</span>
            <div class="star-rating">
              ${[1,2,3,4,5].map(star => 
                `<span class="star ${star <= userRating ? 'active' : ''}" onclick="setRating(${item.id}, ${star})" data-rating="${star}">‚≠ê</span>`
              ).join('')}
            </div>
            <div class="like-dislike">
              <button class="like-btn ${likeStatus === 'like' ? 'active' : ''}" onclick="setLikeStatus(${item.id}, 'like')">üëç</button>
              <button class="dislike-btn ${likeStatus === 'dislike' ? 'active' : ''}" onclick="setLikeStatus(${item.id}, 'dislike')">üëé</button>
            </div>
          </div>
          
          ${mediaType === 'tv' ? `
            <div class="episode-tracker">
              <strong>Episode Progress:</strong>
              <div class="episode-inputs">
                <input type="number" placeholder="Season" min="1" value="${currentSeason}" onchange="updateEpisodeProgress(${item.id}, 'season', this.value)">
                <input type="number" placeholder="Episode" min="1" value="${currentEpisode}" onchange="updateEpisodeProgress(${item.id}, 'episode', this.value)">
              </div>
              ${getSeriesStatusInfo(item)}
            </div>
          ` : ''}
          
          <div class="tags-container">
            <div style="display: flex; gap: 8px; margin-bottom: 8px;">
              <input type="text" class="tag-input" placeholder="Add tags (horror, comedy, etc.)" id="tagInput-${item.id}" style="flex: 1;">
              <button onclick="addTagFromInput(${item.id})" style="padding: 6px 12px; font-size: 12px; margin: 0;">Add Tag</button>
            </div>
            <div class="tags-display" id="tags-${item.id}">
              ${tags.map(tag => `<span class="tag">${tag} <span class="tag-remove" onclick="removeTag(${item.id}, '${tag}')">√ó</span></span>`).join('')}
            </div>
          </div>
          
          <div class="notes-container">
            <textarea class="notes-field" placeholder="Your thoughts on this (250 chars)..." maxlength="250" onchange="updateNotes(${item.id}, this.value)" spellcheck="true">${notes}</textarea>
            <div class="char-count ${notes.length > 200 ? 'warning' : ''} ${notes.length > 240 ? 'danger' : ''}">${notes.length}/250</div>
          </div>
          
          <div class="show-actions">
            <button onclick="moveItem(${item.id}, 'watching')" ${isInWatching ? 'disabled' : ''}>‚Üí Currently Watching</button>
            <button onclick="moveItem(${item.id}, 'wishlist')" ${isInWishlist ? 'disabled' : ''}>‚Üí Want to Watch</button>
            <button onclick="moveItem(${item.id}, 'watched')" ${isInWatched ? 'disabled' : ''}>‚Üí Already Watched</button>
            <button class="danger" onclick="removeItemFromCurrentList(${item.id})" title="Remove from current list only">üóëÔ∏è Remove</button>
            <button onclick="shareShow(${item.id})" class="secondary" title="Share this show">üì§ Share</button>
          </div>
        `;
      }
      
      card.innerHTML = `
        ${posterHtml}
        <div class="show-details">
          <h4 class="show-title" onclick="openTMDBLink(${item.id}, '${mediaType}')">
            ${title}
            <span class="external-link">üîó</span>
          </h4>
          <div class="show-meta">‚≠ê ${rating} ${date ? `‚Ä¢ ${date.split('-')[0]}` : ''} ‚Ä¢ ${mediaType.toUpperCase()}</div>
          <div class="show-overview" onclick="this.classList.toggle('expanded')">${overview}</div>
          ${actionsHtml}
        </div>
      `;
      
      return card;
    }

    function openTMDBLink(id, mediaType) {
      const url = `https://www.themoviedb.org/${mediaType}/${id}`;
      window.open(url, '_blank');
      showNotification('Opening TMDB details! üîó', 'info');
    }

    function setRating(itemId, rating) {
      let item = findItem(itemId);
      if (item) {
        item.userRating = rating;
        saveAppData();
        
        const stars = document.querySelectorAll(`[onclick*="setRating(${itemId}"]`);
        stars.forEach((star, index) => {
          const starRating = parseInt(star.getAttribute('data-rating'));
          if (starRating <= rating) {
            star.classList.add('active');
          } else {
            star.classList.remove('active');
          }
        });
        
        showNotification(`Rated "${item.title}" ${rating} stars! ‚≠ê`, 'success');
        trackFeatureUsage('rating');
      }
    }

    function addTagFromInput(itemId) {
      const input = document.getElementById(`tagInput-${itemId}`);
      if (input) {
        const tagValue = input.value.trim();
        if (tagValue) {
          addTag(itemId, tagValue);
          input.value = '';
        }
      }
    }

    function handleTagInput(event, itemId) {
      if (event.key === 'Enter') {
        event.preventDefault();
        const tagValue = event.target.value.trim();
        if (tagValue) {
          addTag(itemId, tagValue);
          event.target.value = '';
        }
      }
    }

    function removeItemFromCurrentList(itemId) {
      let item = findItem(itemId);
      if (!item) return;
      
      if (confirm(`Remove "${item.title}" from your current list? üóëÔ∏è`)) {
        let removed = false;
        
        const currentTab = currentActiveTab;
        if (currentTab === 'watching') {
          ['tv', 'movies'].forEach(category => {
            const index = appData[category].watching.findIndex(s => s.id === itemId);
            if (index !== -1) {
              appData[category].watching.splice(index, 1);
              removed = true;
            }
          });
        } else if (currentTab === 'wishlist') {
          ['tv', 'movies'].forEach(category => {
            const index = appData[category].wishlist.findIndex(s => s.id === itemId);
            if (index !== -1) {
              appData[category].wishlist.splice(index, 1);
              removed = true;
            }
          });
        } else if (currentTab === 'watched') {
          ['tv', 'movies'].forEach(category => {
            const index = appData[category].watched.findIndex(s => s.id === itemId);
            if (index !== -1) {
              appData[category].watched.splice(index, 1);
              removed = true;
            }
          });
        }
        
        if (removed) {
          saveAppData();
          updateUI();
          showNotification(`"${item.title}" removed from current list! üöÄ`, 'success');
          trackFeatureUsage('remove');
        }
      }
    }

    function removeItem(itemId) {
      if (confirm('Remove this item from ALL lists? It\'s probably for the best... üóëÔ∏è')) {
        let item = null;
        
        ['tv', 'movies'].forEach(category => {
          ['watching', 'wishlist', 'watched'].forEach(list => {
            const found = appData[category][list].find(s => s.id === itemId);
            if (found) item = found;
            appData[category][list] = appData[category][list].filter(s => s.id !== itemId);
          });
        });
        
        saveAppData();
        updateUI();
        
        showNotification(`"${item?.title || 'Item'}" has been yeeted into the void! üöÄ`, 'success');
        trackFeatureUsage('removeAll');
      }
    }

    function shareShow(itemId, itemData = null) {
      let item = itemId ? findItem(itemId) : itemData;
      if (!item) return;
      
      const title = item.title || item.name;
      const shareText = `Check out "${title}" on Showly! üé¨\n\nI'm tracking this ${item.media_type === 'tv' ? 'TV show' : 'movie'} and thought you might like it too!`;
      
      if (navigator.share) {
        navigator.share({
          title: `${title} - Showly`,
          text: shareText,
          url: window.location.href
        }).then(() => {
          showNotification('Shared successfully! üì§', 'success');
          trackFeatureUsage('share');
        }).catch(() => {
          fallbackShare(shareText);
        });
      } else {
        fallbackShare(shareText);
      }
    }

    function fallbackShare(text) {
      if (navigator.clipboard) {
        navigator.clipboard.writeText(text).then(() => {
          showNotification('Share text copied to clipboard! üìã', 'success');
          trackFeatureUsage('share');
        });
      } else {
        const textArea = document.createElement('textarea');
        textArea.value = text;
        document.body.appendChild(textArea);
        textArea.select();
        document.execCommand('copy');
        document.body.removeChild(textArea);
        showNotification('Share text copied to clipboard! üìã', 'success');
        trackFeatureUsage('share');
      }
    }

    function trackFeatureUsage(feature) {
      const usage = JSON.parse(localStorage.getItem('showlyUsageStats') || '{}');
      usage[feature] = (usage[feature] || 0) + 1;
      usage.lastUsed = new Date().toISOString();
      localStorage.setItem('showlyUsageStats', JSON.stringify(usage));
    }

    function getUsageStats() {
      return JSON.parse(localStorage.getItem('showlyUsageStats') || '{}');
    }

    function setLikeStatus(itemId, status) {
      let item = findItem(itemId);
      if (item) {
        item.likeStatus = item.likeStatus === status ? 'none' : status;
        saveAppData();
        updateUI();
        
        const messages = {
          like: 'You liked this! üëç',
          dislike: 'You disliked this! üëé',
          none: 'Rating cleared! ü§∑‚Äç‚ôÇÔ∏è'
        };
        showNotification(`${item.title}: ${messages[item.likeStatus]}`, 'success');
      }
    }

    function updateNotes(itemId, notes) {
      let item = findItem(itemId);
      if (item) {
        item.notes = notes;
        saveAppData();
      }
    }

    function updateEpisodeProgress(itemId, type, value) {
      let item = findItem(itemId);
      if (item) {
        if (type === 'season') {
          item.currentSeason = value;
        } else if (type === 'episode') {
          item.currentEpisode = value;
        }
        saveAppData();
        showNotification(`Updated ${type} progress! üì∫`, 'success');
      }
    }

    function addTag(itemId, tagValue) {
      let item = findItem(itemId);
      if (item && !item.tags.includes(tagValue)) {
        item.tags.push(tagValue);
        saveAppData();
        updateUI();
        showNotification(`Added tag "${tagValue}" to ${item.title}! üè∑Ô∏è`, 'success');
      }
    }

    function removeTag(itemId, tagValue) {
      let item = findItem(itemId);
      if (item) {
        item.tags = item.tags.filter(tag => tag !== tagValue);
        saveAppData();
        updateUI();
        showNotification(`Removed tag "${tagValue}" from ${item.title}! üóëÔ∏è`, 'success');
      }
    }

    function findItem(itemId) {
      let found = null;
      ['tv', 'movies'].forEach(category => {
        ['watching', 'wishlist', 'watched'].forEach(list => {
          const item = appData[category][list].find(s => s.id === itemId);
          if (item) found = item;
        });
      });
      return found;
    }

    function getSeriesStatusInfo(item) {
      if (!item || item.media_type !== 'tv') return '';
      
      const status = item.status;
      const lastAirDate = item.last_air_date;
      const nextEpisode = item.next_episode_to_air;
      const lastEpisode = item.last_episode_to_air;
      const seasons = item.number_of_seasons;
      const inProduction = item.in_production;
      
      let statusClass = 'status-ongoing';
      let statusText = '';
      
      if (status === 'Ended' || status === 'Canceled') {
        statusClass = 'status-ended';
        if (lastEpisode) {
          const lastEp = lastEpisode;
          statusText = `<div class="episode-info">Series Complete</div>
                       <div class="air-date">Final: S${lastEp.season_number}E${lastEp.episode_number} - ${formatDate(lastEp.air_date)}</div>`;
        } else if (lastAirDate) {
          statusText = `<div class="episode-info">Series Complete</div>
                       <div class="air-date">Last aired: ${formatDate(lastAirDate)}</div>`;
        } else {
          statusText = `<div class="episode-info">Series Complete</div>
                       <div class="air-date">${seasons ? `${seasons} seasons total` : 'Status: Ended'}</div>`;
        }
      } else if (status === 'Returning Series' || inProduction) {
        statusClass = 'status-ongoing';
        if (nextEpisode) {
          const nextEp = nextEpisode;
          statusText = `<div class="episode-info">Currently Airing</div>
                       <div class="air-date">Next: S${nextEp.season_number}E${nextEp.episode_number} - ${formatDate(nextEp.air_date)}</div>`;
        } else if (lastEpisode) {
          const lastEp = lastEpisode;
          statusText = `<div class="episode-info">Season ${lastEp.season_number} Ongoing</div>
                       <div class="air-date">Latest: S${lastEp.season_number}E${lastEp.episode_number} - ${formatDate(lastEp.air_date)}</div>`;
        } else if (lastAirDate) {
          statusText = `<div class="episode-info">Currently Airing</div>
                       <div class="air-date">Last episode: ${formatDate(lastAirDate)}</div>`;
        } else {
          statusText = `<div class="episode-info">Returning Series</div>
                       <div class="air-date">${seasons ? `${seasons} seasons so far` : 'Status: Ongoing'}</div>`;
        }
      } else if (status === 'In Production') {
        statusClass = 'status-upcoming';
        const firstAir = item.first_air_date;
        if (firstAir && new Date(firstAir) > new Date()) {
          statusText = `<div class="episode-info">Coming Soon</div>
                       <div class="air-date">Premieres: ${formatDate(firstAir)}</div>`;
        } else {
          statusText = `<div class="episode-info">In Production</div>
                       <div class="air-date">Release date TBA</div>`;
        }
      } else {
        if (lastAirDate) {
          statusText = `<div class="episode-info">${status || 'Status Unknown'}</div>
                       <div class="air-date">Last aired: ${formatDate(lastAirDate)}</div>`;
        } else {
          statusText = `<div class="episode-info">${status || 'Status Unknown'}</div>
                       <div class="air-date">${seasons ? `${seasons} seasons` : 'Air dates unknown'}</div>`;
        }
      }
      
      return `<div class="series-status ${statusClass}">${statusText}</div>`;
    }

    function formatDate(dateString) {
      if (!dateString) return 'Date unknown';
      try {
        const date = new Date(dateString);
        return date.toLocaleDateString('en-US', { 
          year: 'numeric', 
          month: 'short', 
          day: 'numeric' 
        });
      } catch (e) {
        return dateString;
      }
    }

    function addToList(item, listType) {
      const mediaType = item.media_type || (item.first_air_date ? 'tv' : 'movie');
      const category = mediaType === 'tv' ? 'tv' : 'movies';
      
      const newItem = {
        id: item.id,
        title: item.name || item.title,
        overview: item.overview,
        poster_path: item.poster_path,
        date: item.first_air_date || item.release_date,
        rating: item.vote_average,
        media_type: mediaType,
        date_added: new Date().toISOString(),
        userRating: 0,
        likeStatus: 'none',
        notes: '',
        tags: [],
        currentSeason: '',
        currentEpisode: '',
        status: item.status,
        number_of_seasons: item.number_of_seasons,
        number_of_episodes: item.number_of_episodes,
        last_air_date: item.last_air_date,
        first_air_date: item.first_air_date,
        next_episode_to_air: item.next_episode_to_air,
        last_episode_to_air: item.last_episode_to_air,
        in_production: item.in_production
      };
      
      if (!appData[category][listType].some(show => show.id === item.id)) {
        appData[category][listType].push(newItem);
        saveAppData();
        updateUI();
        performSearch();
        
        const listNames = { 
          watching: 'Currently Watching', 
          wishlist: 'Want to Watch',
          watched: 'Already Watched'
        };
        showNotification(`Added "${newItem.title}" to ${listNames[listType]}! üéâ`, 'success');
        
        if ('Notification' in window && Notification.permission === 'granted') {
          setTimeout(() => {
            new Notification('Showly', {
              body: `"${newItem.title}" added to your ${listNames[listType]} list! üé¨`,
              icon: 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><rect width="100" height="100" fill="%23ff6b6b"/><text x="50" y="55" font-size="40" text-anchor="middle" fill="white">üì∫</text></svg>'
            });
          }, 1000);
        }
      } else {
        showNotification('Already on your list, genius! üôÑ', 'warning');
      }
    }

    function moveItem(itemId, newListType) {
      let item = null;
      let fromList = null;
      let category = null;
      
      ['tv', 'movies'].forEach(cat => {
        ['watching', 'wishlist', 'watched'].forEach(list => {
          const found = appData[cat][list].find(s => s.id === itemId);
          if (found) {
            item = found;
            fromList = list;
            category = cat;
          }
        });
      });
      
      if (item && fromList !== newListType) {
        appData[category][fromList] = appData[category][fromList].filter(s => s.id !== itemId);
        
        if (!appData[category][newListType].some(s => s.id === itemId)) {
          appData[category][newListType].push(item);
        }
        
        saveAppData();
        updateUI();
        
        const listNames = { 
          watching: 'Currently Watching', 
          wishlist: 'Want to Watch',
          watched: 'Already Watched'
        };
        showNotification(`Moved "${item.title}" from ${listNames[fromList]} to ${listNames[newListType]}! üì¶`, 'success');
      } else if (fromList === newListType) {
        showNotification(`"${item?.title}" is already in that list! ü§∑‚Äç‚ôÇÔ∏è`, 'warning');
      }
    }

    function updateUI() {
      try {
        const totalWatching = appData.tv.watching.length + appData.movies.watching.length;
        const totalWishlist = appData.tv.wishlist.length + appData.movies.wishlist.length;
        const totalWatched = appData.tv.watched.length + appData.movies.watched.length;
        
        const watchingBadge = document.getElementById('watchingBadge');
        const wishlistBadge = document.getElementById('wishlistBadge');
        const watchedBadge = document.getElementById('watchedBadge');
        
        if (watchingBadge) watchingBadge.textContent = totalWatching;
        if (wishlistBadge) wishlistBadge.textContent = totalWishlist;
        if (watchedBadge) watchedBadge.textContent = totalWatched;
        
        const totalWatchingCount = document.getElementById('totalWatchingCount');
        const totalWishlistCount = document.getElementById('totalWishlistCount');
        const totalWatchedCount = document.getElementById('totalWatchedCount');
        const totalCount = document.getElementById('totalCount');
        
        if (totalWatchingCount) totalWatchingCount.textContent = totalWatching;
        if (totalWishlistCount) totalWishlistCount.textContent = totalWishlist;
        if (totalWatchedCount) totalWatchedCount.textContent = totalWatched;
        if (totalCount) totalCount.textContent = totalWatching + totalWishlist + totalWatched;
        
        const watchingCount = document.getElementById('watchingCount');
        const wishlistCount = document.getElementById('wishlistCount');
        const watchedCount = document.getElementById('watchedCount');
        
        if (watchingCount) watchingCount.textContent = totalWatching;
        if (wishlistCount) wishlistCount.textContent = totalWishlist;
        if (watchedCount) watchedCount.textContent = totalWatched;
        
        updateList('watchingList', [...appData.tv.watching, ...appData.movies.watching]);
        updateList('wishlistList', [...appData.tv.wishlist, ...appData.movies.wishlist]);
        updateList('watchedList', [...appData.tv.watched, ...appData.movies.watched]);
      } catch (error) {
        console.error('Error updating UI:', error);
      }
    }

    function updateList(containerId, items) {
      const container = document.getElementById(containerId);
      
      if (!container) {
        console.error('Container not found:', containerId);
        return;
      }
      
      let filteredItems = items;
      if (showTVOnly) {
        filteredItems = items.filter(item => item.media_type === 'tv');
      } else if (showMoviesOnly) {
        filteredItems = items.filter(item => item.media_type === 'movie');
      }
      
      if (filteredItems.length === 0) {
        const emptyMessages = {
          watchingList: 'No shows yet? What are you, productive or something? üôÑ',
          wishlistList: 'Your wishlist is emptier than a Netflix comedy special üíÄ',
          watchedList: 'Nothing completed yet? Commitment issues much? üòè'
        };
        
        let message = emptyMessages[containerId];
        if (items.length > 0 && filteredItems.length === 0) {
          message = showTVOnly ? 'No TV shows in this category! üì∫' : 'No movies in this category! üé¨';
        }
        
        container.innerHTML = `<div class="empty-state sassy-empty">${message}</div>`;
      } else {
        container.innerHTML = '';
        filteredItems.forEach(item => {
          try {
            const card = createShowCard(item, false);
            container.appendChild(card);
          } catch (error) {
            console.error('Error creating card for item:', item, error);
          }
        });
      }
    }

    function clearSearch() {
      document.getElementById('searchInput').value = '';
      document.getElementById('genreFilter').value = '';
      document.getElementById('clearSearchBtn').style.display = 'none';
      document.getElementById('searchResults').style.display = 'none';
      currentPage = 1;
      document.getElementById('pageInfo').textContent = 'Page 1';
      document.getElementById('prevPageBtn').disabled = true;
      document.getElementById('nextPageBtn').disabled = true;
      searchCache = [];
      showNotification('Search cleared! Back to square one! üîÑ', 'success');
    }

    function updatePagination() {
      document.getElementById('pageInfo').textContent = `Page ${currentPage}`;
      document.getElementById('prevPageBtn').disabled = currentPage === 1;
      document.getElementById('nextPageBtn').disabled = searchCache.length < 20;
    }

    function exportData() {
      const blob = new Blob([JSON.stringify(appData, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `showly-backup-${new Date().toISOString().split('T')[0]}.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      showNotification('Your questionable taste has been exported! üì§', 'success');
    }

    function importData(e) {
      const file = e.target.files[0];
      if (!file) return;
      
      const reader = new FileReader();
      reader.onload = function(event) {
        try {
          const imported = JSON.parse(event.target.result);
          if (confirm('Import data? This will overwrite your current collection of digital hoarding! üíæ')) {
            if (!imported.tv.watched) imported.tv.watched = [];
            if (!imported.movies.watched) imported.movies.watched = [];
            
            Object.assign(appData, imported);
            saveAppData();
            updateUI();
            showNotification('Data imported! Your taste is still questionable! üéâ', 'success');
          }
        } catch (error) {
          showNotification('Invalid file format. Even your backups are broken! üí•', 'error');
        }
      };
      reader.readAsText(file);
    }

    function setupEasterEgg() {
      const tips = [
        "Pro tip: Having 500 items in your wishlist doesn't count as productivity! üéØ",
        "Fun fact: 'I'll watch it later' is the most common lie in streaming! ü§•",
        "Reality check: You have more shows bookmarked than days in the year! üìÖ",
        "Hot take: Your 'Currently Watching' list is more fiction than fantasy movies! üìö",
        "Reminder: Netflix doesn't pay you to collect shows like Pok√©mon cards! üÉè",
        "News flash: Starting 20 shows doesn't make you a 'multimedia enthusiast'! üì∫"
      ];

      let clickCount = 0;
      
      setTimeout(() => {
        const easterEgg = document.getElementById('easterEgg');
        const feedbackBtn = document.getElementById('feedbackBtn');
        
        if (easterEgg) {
          easterEgg.onclick = () => {
            clickCount++;
            if (clickCount % 3 === 0) {
              showRandomTip(tips);
            }
          };
        }
        
        if (feedbackBtn) {
          feedbackBtn.onclick = () => {
            showNotification('Feedback feature coming soon! For now, enjoy the sassy tips! üí¨', 'info');
          };
        }
      }, 500);
    }

    function showRandomTip(tips) {
      const tip = tips[Math.floor(Math.random() * tips.length)];
      const bubble = document.createElement('div');
      bubble.style.position = 'fixed';
      bubble.style.bottom = '80px';
      bubble.style.right = '20px';
      bubble.style.zIndex = '1500';
      bubble.style.background = 'var(--purple)';
      bubble.style.color = 'white';
      bubble.style.padding = '15px 20px';
      bubble.style.borderRadius = '20px';
      bubble.style.maxWidth = '300px';
      bubble.style.fontSize = '13px';
      bubble.style.boxShadow = '0 5px 20px rgba(0,0,0,0.3)';
      bubble.style.animation = 'bubble-bounce 0.5s ease';
      
      bubble.textContent = tip;
      document.body.appendChild(bubble);
      
      setTimeout(() => {
        if (bubble.parentNode) bubble.parentNode.removeChild(bubble);
      }, 7000);
    }

    function toggleContentFilter() {
      const btn = document.getElementById('filterBtn');
      
      if (!showMoviesOnly && !showTVOnly) {
        showTVOnly = true;
        btn.textContent = 'üì∫ TV Shows Only';
        showNotification('Filtering to TV shows only! üì∫', 'info');
      } else if (showTVOnly) {
        showTVOnly = false;
        showMoviesOnly = true;
        btn.textContent = 'üé¨ Movies Only';
        showNotification('Filtering to movies only! üé¨', 'info');
      } else {
        showMoviesOnly = false;
        btn.textContent = 'üé≠ Show All Content';
        showNotification('Showing all content! üé≠', 'info');
      }
      
      updateUI();
      trackFeatureUsage('filter');
    }

    // Initialize app
    document.addEventListener('DOMContentLoaded', () => {
      loadAppData();
      setupEventListeners();
      loadGenres();
      updateUI();
      updateDarkModeButton();
      initPushNotifications();
      
      if ('Notification' in window && Notification.permission === 'default') {
        Notification.requestPermission();
      }
    });
  </script>
</body>
</html><!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <!-- Primary Meta Tags -->
  <title>Showly - TV & Movie Tracker</title>
  <meta name="title" content="Showly - TV & Movie Tracker">
  <meta name="description" content="Search, track, and rate shows & films fast. Never lose track of your binge-watching again!">
  <meta name="keywords" content="tv tracker, movie tracker, streaming, watchlist, tv shows, movies, entertainment, episode tracker">
  <meta name="author" content="Showly">
  
  <!-- Open Graph / Facebook -->
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://tv-movie-tracker.netlify.app/">
  <meta property="og:title" content="Showly - TV & Movie Tracker">
  <meta property="og:description" content="Search, track, and rate shows & films fast. Never lose track of your binge-watching again!">
  <meta property="og:image" content="https://tv-movie-tracker.netlify.app/icons/og-image.png">
  
  <!-- PWA Meta Tags -->
  <meta name="application-name" content="Showly">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Showly">
  <meta name="theme-color" content="#ff6b6b">
  
  <!-- PWA Manifest -->
  <link rel="manifest" href="/manifest.json">
  
  <style>
    :root {
      --bg: #fff; --text: #000; --primary: #ff6b6b; --card: #f9f9f9; --border: #ddd;
      --success: #51cf66; --warning: #ffd43b; --danger: #ff6b6b; --purple: #845ec2;
      --blue: #4dabf7; --orange: #ff8c42; --green: #51cf66;
    }
    
    * { box-sizing: border-box; }
    
    body { 
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; 
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: var(--text); margin: 0; padding: 20px; min-height: 100vh;
      transition: all 0.3s ease;
    }
    
    .dark-mode { 
      --bg: #1a1a1a; --text: #f5f5f5; --card: #2d2d2d; --border: #444;
      background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%) !important;
    }
    
    .main-container {
      max-width: 1200px; margin: 0 auto; background: var(--bg); 
      border-radius: 20px; padding: 30px; box-shadow: 0 20px 60px rgba(0,0,0,0.3);
      transition: all 0.3s ease;
    }
    
    .header { 
      display: flex; justify-content: space-between; align-items: center; 
      padding: 20px 0; border-bottom: 3px dashed var(--primary); margin-bottom: 30px;
      position: relative; flex-wrap: wrap; gap: 15px;
    }
    
    .header::after {
      content: "üõãÔ∏è"; position: absolute; right: 20px; top: 15px; 
      font-size: 28px; animation: couch-bounce 3s ease-in-out infinite;
    }
    
    @keyframes couch-bounce {
      0%, 100% { transform: translateY(0) rotate(0deg); }
      50% { transform: translateY(-5px) rotate(-5deg); }
    }
    
    .title { 
      font-size: 2.5em; font-weight: bold; color: var(--primary); 
      margin: 0; cursor: pointer; flex-shrink: 0;
    }

    .subtitle {
      font-size: 1.1em; font-style: italic; color: #666; 
      margin-top: 5px; font-weight: normal;
    }
    
    .user-section {
      display: flex; align-items: center; gap: 15px; flex-wrap: wrap;
    }
    
    .name-container {
      display: flex; flex-direction: column; align-items: flex-end;
      transition: all 0.3s ease;
    }
    
    .name-instruction {
      font-size: 12px; color: var(--primary); font-weight: bold;
      margin-bottom: 5px;
    }
    
    .name-input {
      padding: 12px; border: 2px solid var(--primary); border-radius: 25px;
      background: var(--card); color: var(--text); font-weight: bold;
    }
    
    .name-container.hidden {
      opacity: 0; transform: scale(0.8); pointer-events: none;
    }
    
    .tab-container { 
      display: flex; background: var(--card); border-radius: 15px; 
      padding: 8px; margin: 30px 0; gap: 5px;
    }
    
    .tab { 
      flex: 1; padding: 18px 30px; border: none; background: transparent; 
      color: var(--text); cursor: pointer; border-radius: 10px; font-weight: bold;
      transition: all 0.3s ease; font-size: 16px; text-align: center;
      display: flex; align-items: center; justify-content: center; gap: 8px;
    }
    
    .tab.active { 
      background: linear-gradient(45deg, var(--primary), var(--purple)); 
      color: white; transform: scale(1.05);
    }
    
    .tab-badge {
      background: rgba(255,255,255,0.9); color: var(--primary);
      padding: 4px 10px; border-radius: 12px; font-size: 12px;
      font-weight: bold; min-width: 20px;
    }
    
    .tab.active .tab-badge {
      background: rgba(255,255,255,1); color: var(--primary);
    }
    
    button { 
      margin: 8px; padding: 12px 20px; border: none; border-radius: 25px; 
      background: linear-gradient(45deg, var(--primary), var(--purple)); 
      color: white; cursor: pointer; font-weight: bold; font-size: 14px;
      transition: all 0.3s ease;
    }
    
    button:hover { 
      transform: translateY(-3px) scale(1.05); 
    }
    
    button:disabled { 
      background: #666; cursor: not-allowed; transform: none; opacity: 0.6;
    }
    
    button.danger { background: linear-gradient(45deg, #ff4757, #ff3742); }
    button.success { background: linear-gradient(45deg, #2ed573, #1dd1a1); }
    button.secondary { background: linear-gradient(45deg, #747d8c, #57606f); }
    
    .search-container { 
      background: var(--card); padding: 25px; border-radius: 20px; 
      margin: 30px 0; border: 2px solid var(--primary);
    }
    
    .search-row {
      display: flex; gap: 15px; margin-bottom: 15px; flex-wrap: wrap;
    }
    
    .search-input {
      flex: 1; min-width: 250px; padding: 12px 15px;
      border: 2px solid var(--border); border-radius: 15px;
      background: var(--bg); color: var(--text); font-size: 16px;
    }
    
    .search-help {
      font-size: 12px; color: #666; margin-top: 5px; font-style: italic;
    }
    
    .tooltip {
      position: relative; display: inline-block; cursor: help;
      color: var(--primary); font-weight: bold; text-decoration: underline;
    }
    
    .tooltip .tooltiptext {
      visibility: hidden; width: 300px; background-color: var(--purple);
      color: white; text-align: left; border-radius: 10px;
      padding: 15px; position: absolute; z-index: 1000;
      bottom: 125%; left: 50%; margin-left: -150px;
      opacity: 0; transition: opacity 0.3s; font-style: normal;
      box-shadow: 0 5px 20px rgba(0,0,0,0.3);
    }
    
    .tooltip .tooltiptext::after {
      content: ""; position: absolute; top: 100%; left: 50%;
      margin-left: -5px; border-width: 5px;
      border-style: solid; border-color: var(--purple) transparent transparent transparent;
    }
    
    .tooltip:hover .tooltiptext {
      visibility: visible; opacity: 1;
    }

    .notification-test {
      background: #fef5e7; border: 2px solid #f6ad55; color: #c05621;
      margin-bottom: 20px; text-align: center; border-radius: 15px;
      padding: 12px 20px; font-weight: bold;
    }
    
    input, select { 
      padding: 12px 15px; margin: 5px; border: 2px solid var(--border); 
      border-radius: 15px; background: var(--bg); color: var(--text);
    }
    
    .section { margin: 40px 0; }
    
    .section-header {
      display: flex; justify-content: space-between; align-items: center;
      margin-bottom: 20px; cursor: pointer; padding: 10px 0;
    }
    
    .section h3 { 
      color: var(--primary); margin: 0; font-size: 1.8em;
    }
    
    .section-subtitle {
      font-size: 14px; color: #666; font-style: italic;
      margin-top: 5px; font-weight: normal;
    }
    
    .count { 
      background: linear-gradient(45deg, var(--primary), var(--purple)); 
      color: white; padding: 8px 15px; border-radius: 20px; 
      font-size: 16px; font-weight: bold; cursor: pointer;
    }
    
    .list-container { 
      background: var(--card); border-radius: 15px; padding: 20px; 
      min-height: 80px; border: 3px dashed var(--border);
    }
    
    .show-card { 
      display: flex; border: 2px solid var(--border); 
      border-radius: 15px; padding: 20px; margin: 15px 0; 
      background: var(--bg);
    }
    
    .show-poster { 
      width: 90px; height: 135px; border-radius: 10px; 
      object-fit: cover; margin-right: 20px; flex-shrink: 0;
      cursor: pointer;
    }
    
    .poster-placeholder { 
      width: 90px; height: 135px; background: #f0f0f0; 
      border-radius: 10px; display: flex; align-items: center; justify-content: center; 
      margin-right: 20px; color: #999; font-size: 12px; font-weight: bold; flex-shrink: 0;
      cursor: pointer;
    }
    
    .show-details { flex: 1; display: flex; flex-direction: column; }
    
    .show-title { 
      font-size: 20px; font-weight: bold; margin: 0 0 10px 0; 
      cursor: pointer; color: var(--primary);
      display: flex; align-items: center; gap: 10px;
    }
    
    .external-link {
      font-size: 14px; opacity: 0.7; transition: opacity 0.3s ease;
    }
    
    .external-link:hover { opacity: 1; }
    
    .show-meta { 
      color: #666; font-size: 14px; margin-bottom: 12px;
    }
    
    .show-overview { 
      font-size: 14px; line-height: 1.6; margin-bottom: 15px; 
      max-height: 60px; overflow: hidden; cursor: pointer;
    }
    
    .show-overview.expanded { max-height: none; }
    
    .rating-container {
      display: flex; align-items: center; gap: 10px; margin: 10px 0;
      flex-wrap: wrap;
    }
    
    .star-rating {
      display: flex; gap: 2px;
    }
    
    .star {
      font-size: 18px; cursor: pointer; transition: all 0.2s ease;
      color: #ddd;
    }
    
    .star:hover, .star.active { 
      color: #ffd700; transform: scale(1.1);
    }
    
    .like-dislike {
      display: flex; gap: 8px; align-items: center;
    }
    
    .like-btn, .dislike-btn {
      padding: 6px 12px; font-size: 12px; border-radius: 15px;
      border: none; cursor: pointer; transition: all 0.3s ease;
    }
    
    .like-btn {
      background: #ddd; color: #666;
    }
    
    .like-btn.active {
      background: linear-gradient(45deg, #2ed573, #1dd1a1);
      color: white;
    }
    
    .dislike-btn {
      background: #ddd; color: #666;
    }
    
    .dislike-btn.active {
      background: linear-gradient(45deg, #ff4757, #ff3742);
      color: white;
    }
    
    .notes-container {
      margin: 10px 0;
    }
    
    .notes-field {
      width: 100%; min-height: 50px; padding: 10px;
      border: 2px dashed var(--border); border-radius: 10px;
      background: var(--card); color: var(--text); resize: vertical;
      font-family: inherit; font-size: 13px;
    }
    
    .char-count {
      font-size: 11px; color: #999; text-align: right; margin-top: 5px;
    }
    
    .char-count.warning { color: var(--warning); }
    .char-count.danger { color: var(--danger); }
    
    .tags-container {
      margin: 10px 0;
    }
    
    .tag-input {
      width: 100%; padding: 8px; font-size: 12px;
      margin-bottom: 8px; border: 2px solid var(--border);
      border-radius: 10px; background: var(--bg); color: var(--text);
    }
    
    .tags-display {
      display: flex; flex-wrap: wrap; gap: 6px;
    }
    
    .tag {
      background: var(--purple); color: white; padding: 4px 8px;
      border-radius: 15px; font-size: 11px; font-weight: bold;
      display: flex; align-items: center; gap: 5px;
    }
    
    .tag-remove {
      cursor: pointer; font-weight: bold;
    }
    
    .episode-tracker {
      background: var(--card); padding: 12px; border-radius: 10px;
      border: 2px dashed var(--border); margin: 10px 0;
    }
    
    .episode-inputs {
      display: grid; grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
      gap: 8px; margin-top: 8px;
    }
    
    .episode-inputs input {
      padding: 8px; font-size: 12px; text-align: center;
      border: 2px solid var(--border); border-radius: 8px;
      background: var(--bg); color: var(--text);
    }
    
    .series-status {
      background: var(--card); padding: 10px; border-radius: 8px;
      margin: 8px 0; font-size: 12px; border-left: 4px solid var(--primary);
    }
    
    .status-ongoing { border-left-color: var(--success); }
    .status-ended { border-left-color: var(--danger); }
    .status-upcoming { border-left-color: var(--warning); }
    
    .episode-info {
      font-weight: bold; color: var(--primary);
    }
    
    .air-date {
      color: #666; font-style: italic;
    }
    
    .show-actions { 
      display: flex; gap: 12px; flex-wrap: wrap; align-items: center; 
      margin-top: 15px;
    }
    
    .show-actions button { padding: 8px 15px; font-size: 12px; margin: 2px; }
    
    .empty-state { 
      text-align: center; color: #666; padding: 40px 20px; 
      font-style: italic; font-size: 18px;
    }
    
    .sassy-empty { 
      font-weight: bold; color: var(--primary);
    }
    
    .stats { 
      display: flex; gap: 20px; margin: 30px 0; flex-wrap: wrap;
    }
    
    .stat { 
      background: var(--card); padding: 25px; border-radius: 15px; 
      text-align: center; flex: 1; min-width: 140px; 
      border: 2px solid var(--primary); cursor: pointer;
    }
    
    .stat:hover { 
      transform: translateY(-5px); 
    }
    
    .stat-num { 
      font-size: 2.5em; font-weight: bold; color: var(--primary); 
    }
    
    .stat-label { 
      font-size: 12px; color: #666; font-weight: bold; 
      text-transform: uppercase;
    }
    
    .notification {
      position: fixed; top: 20px; right: 20px; z-index: 1000;
      padding: 15px 25px; border-radius: 10px; color: white;
      font-weight: bold; animation: slide-in 0.5s ease, slide-out 0.5s ease 2.5s forwards;
    }
    
    @keyframes slide-in {
      from { transform: translateX(100%); opacity: 0; }
      to { transform: translateX(0); opacity: 1; }
    }
    
    @keyframes slide-out {
      from { transform: translateX(0); opacity: 1; }
      to { transform: translateX(100%); opacity: 0; }
    }
    
    .notification.success { background: var(--success); }
    .notification.error { background: var(--danger); }
    .notification.warning { background: var(--warning); color: #000; }
    .notification.info { background: var(--purple); }
    
    .loading-container {
      text-align: center; padding: 40px;
    }
    
    .loading-spinner {
      width: 50px; height: 50px; border: 5px solid var(--border);
      border-top: 5px solid var(--primary); border-radius: 50%;
      animation: spin 1s linear infinite; margin: 0 auto 20px;
    }
    
    @keyframes spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }
    
    .loading-text {
      font-weight: bold; color: var(--primary); font-size: 16px;
    }
    
    .easter-egg {
      position: fixed; bottom: 20px; right: 20px; 
      background: var(--purple); color: white; padding: 12px; 
      border-radius: 50%; cursor: pointer; z-index: 1000;
      font-size: 18px; width: 50px; height: 50px;
      display: flex; align-items: center; justify-content: center;
    }
    
    .feedback-button {
      position: fixed; bottom: 90px; right: 20px; 
      background: var(--primary); color: white; padding: 15px; 
      border-radius: 50%; cursor: pointer; z-index: 1001;
      font-size: 20px; width: 60px; height: 60px;
      display: flex; align-items: center; justify-content: center;
    }
    
    /* Responsive Design */
    @media (max-width: 768px) {
      .main-container { 
        padding: 15px; margin: 10px; border-radius: 15px;
      }
      
      .header { 
        flex-direction: column; text-align: center; gap: 10px;
      }
      
      .header::after { display: none; }
      
      .title { font-size: 2em; }
      
      .tab-container {
        flex-direction: column;
      }
      
      .tab {
        padding: 15px 20px;
      }
      
      .search-row {
        flex-direction: column;
      }
      
      .search-input {
        min-width: auto;
      }
      
      .show-card { 
        flex-direction: column; padding: 15px; text-align: center;
      }
      
      .show-poster, .poster-placeholder { 
        width: 70px; height: 105px; margin: 0 auto 15px auto; 
      }
      
      .stats { 
        flex-direction: column; gap: 10px;
      }
      
      .stat { 
        min-width: auto; padding: 15px;
      }
    }

    @keyframes bubble-bounce {
      0% { transform: scale(0) translateY(20px); opacity: 0; }
      100% { transform: scale(1) translateY(0); opacity: 1; }
    }
  </style>
</head>
<body>
  <div class="main-container">
    <div class="header">
      <div>
        <h1 class="title" id="welcomeText">Showly</h1>
        <div class="subtitle">TV & Movie Tracker</div>
      </div>
      <div class="user-section">
        <div class="name-container" id="nameContainer">
          <div class="name-instruction">üëÜ Add your name for a personal touch!</div>
          <input type="text" id="displayNameInput" class="name-input" placeholder="Your name here...">
        </div>
        <button id="darkModeToggle">üåô Go Dark</button>
      </div>
    </div>

    <div class="tab-container">
      <button id="homeTab" class="tab active">
        üè† Home
        <span class="tab-badge">Overview</span>
      </button>
      <button id="watchingTab" class="tab">
        ‚ñ∂Ô∏è Currently Watching
        <span class="tab-badge" id="watchingBadge">0</span>
      </button>
      <button id="wishlistTab" class="tab">
        üìñ Want to Watch
        <span class="tab-badge" id="wishlistBadge">0</span>
      </button>
      <button id="watchedTab" class="tab">
        ‚úÖ Already Watched
        <span class="tab-badge" id="watchedBadge">0</span>
      </button>
    </div>

    <!-- HOME TAB -->
    <div id="homeSection" class="tab-section">
      <div class="search-container">
        <button id="testNotification" class="notification-test">üîî Test Push Notifications</button>
        
        <div class="search-row">
          <input type="text" id="searchInput" class="search-input" placeholder="Search for shows or movies...">
          <select id="genreFilter"><option value="">All Genres</option></select>
          <button id="searchBtn">üîç Search</button>
          <button id="clearSearchBtn" class="secondary" style="display: none;">‚úñÔ∏è Clear</button>
        </div>
        
        <div class="search-help">
          üí° <strong><span class="tooltip">Wildcards:<span class="tooltiptext">
            <strong>Wildcard = when your brain is mush and you only remember part of the title.</strong><br><br>
            <strong>Examples:</strong><br>
            ‚Ä¢ Type "star*" = shows starting with "star"<br>
            ‚Ä¢ Type "*wars" = shows ending with "wars"<br>
            ‚Ä¢ Type "*trek*" = shows containing "trek"<br><br>
            Basically, it's search for dummies when you can't remember the full title! üß†
          </span></span></strong> "star*" = starts with "star" | "*wars" = ends with "wars" | "*trek*" = contains "trek"
        </div>
        
        <div style="display: flex; gap: 10px; align-items: center; margin-top: 10px;">
          <button id="prevPageBtn" disabled>‚Üê Previous</button>
          <span id="pageInfo" style="font-weight: bold; color: var(--primary);">Page 1</span>
          <button id="nextPageBtn" disabled>Next ‚Üí</button>
        </div>
      </div>

      <div id="searchResults" class="section" style="display: none;">
        <h3>üéØ Search Results <span class="count" id="resultsCount">0</span></h3>
        <div id="searchResultsList" class="list-container"></div>
      </div>

      <div class="stats">
        <div class="stat" onclick="switchToTab('watching')">
          <div class="stat-num" id="totalWatchingCount">0</div>
          <div class="stat-label">Currently Watching</div>
        </div>
        <div class="stat" onclick="switchToTab('wishlist')">
          <div class="stat-num" id="totalWishlistCount">0</div>
          <div class="stat-label">Want to Watch</div>
        </div>
        <div class="stat" onclick="switchToTab('watched')">
          <div class="stat-num" id="totalWatchedCount">0</div>
          <div class="stat-label">Already Watched</div>
        </div>
        <div class="stat">
          <div class="stat-num" id="totalCount">0</div>
          <div class="stat-label">Total Collection</div>
        </div>
      </div>

      <div style="background: var(--card); padding: 25px; border-radius: 20px; margin: 30px 0; border: 2px solid var(--primary);">
        <h3 style="color: var(--primary); margin-top: 0;">üíæ Backup Your Questionable Taste</h3>
        <div style="display: flex; gap: 10px; flex-wrap: wrap; align-items: center; margin-bottom: 15px;">
          <input type="file" id="importFile" accept=".json" style="max-width: 200px;">
          <button id="exportBtn" class="success">üì§ Export My Shame</button>
          <button id="clearAllBtn" class="danger">üóëÔ∏è Nuclear Option</button>
        </div>
        <div style="display: flex; gap: 10px; flex-wrap: wrap; align-items: center;">
          <button id="aboutBtn" class="secondary">‚ÑπÔ∏è About Showly</button>
          <button id="usageStatsBtn" class="secondary">üìä Usage Stats</button>
          <button onclick="toggleContentFilter()" class="secondary" id="filterBtn">üé≠ Show All Content</button>
        </div>
      </div>
    </div>

    <!-- CURRENTLY WATCHING TAB -->
    <div id="watchingSection" class="tab-section" style="display: none;">
      <div class="section">
        <div class="section-header">
          <div>
            <h3>‚ñ∂Ô∏è Currently Watching <span class="count" id="watchingCount">0</span></h3>
            <div class="section-subtitle">Shows and movies you're actually committed to... for now</div>
          </div>
        </div>
        <div id="watchingList" class="list-container">
          <div class="empty-state sassy-empty">No shows yet? What are you, productive or something? üôÑ</div>
        </div>
      </div>
    </div>

    <!-- WANT TO WATCH TAB -->
    <div id="wishlistSection" class="tab-section" style="display: none;">
      <div class="section">
        <div class="section-header">
          <div>
            <h3>üìñ Want to Watch <span class="count" id="wishlistCount">0</span></h3>
            <div class="section-subtitle">Your digital hoarding collection of "I'll definitely watch this someday"</div>
          </div>
        </div>
        <div id="wishlistList" class="list-container">
          <div class="empty-state sassy-empty">Your wishlist is emptier than a Netflix comedy special üíÄ</div>
        </div>
      </div>
    </div>

    <!-- ALREADY WATCHED TAB -->
    <div id="watchedSection" class="tab-section" style="display: none;">
      <div class="section">
        <div class="section-header">
          <div>
            <h3>‚úÖ Already Watched <span class="count" id="watchedCount">0</span></h3>
            <div class="section-subtitle">Your bragging rights collection and relationship argument ammunition</div>
          </div>
        </div>
        <div id="watchedList" class="list-container">
          <div class="empty-